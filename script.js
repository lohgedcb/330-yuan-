const ACTIVATION_PIN_URL = 'https://gist.githubusercontent.com/cx3300-1/f04ec50b5e8f2d88365d17ff35efffcf/raw/cd28d8825c5c34ea10bda8a4518a1a6a1f5a7d13/pin.txt';

function escapeHTML(str) {
  if (!str) return '';
  return str.replace(/[&<>"']/g, function(match) {
    return {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    } [match];
  });
}
function generateRandomPacketAmounts(totalAmount, count) {
    let remainingAmount = totalAmount;
    let remainingCount = count;
    const amounts = [];
    const min = 0.01; 

    for (let i = 0; i < count - 1; i++) {
      
        const avg = remainingAmount / remainingCount;
        const absoluteMax = remainingAmount - (remainingCount - 1) * min;
        
        let max = Math.min(avg * 2, absoluteMax);
        if (max < min) {
            max = min;
        }

        let amount = Math.random() * (max - min) + min;
        amount = parseFloat(amount.toFixed(2));
        
        amounts.push(amount);
        remainingAmount -= amount;
        remainingCount--;
    }
    
  
    amounts.push(parseFloat(remainingAmount.toFixed(2)));
  
    for (let i = amounts.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [amounts[i], amounts[j]] = [amounts[j], amounts[i]];
    }
    
    console.log(`[红包生成]: 总金额 ${totalAmount}, 数量 ${count}. 分配结果:`, amounts);
    return amounts;
}

function getDeviceId() {
  let deviceId = localStorage.getItem('ephoneDeviceId');
  if (!deviceId) {
 
    deviceId = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
    localStorage.setItem('ephoneDeviceId', deviceId);
  }
  return deviceId;
}


const EPHONE_DEVICE_ID = getDeviceId();
console.log(`EPhone 设备ID: ${EPHONE_DEVICE_ID}`);

// 全局 API 调用控制器
let currentApiController = null;

let isPinActivated = localStorage.getItem('ephonePinActivated') === 'true';



const translations = {
  'zh-CN': {

    save: '保存',
    cancel: '取消',
    confirm: '确定',
    edit: '编辑',
    done: '完成',
    add: '添加',
    back: '返回',
    next: '下一步',
    close: '关闭',
    reset: '重置',
    upload: '上传',
    send: '发送',
    manage: '管理',
    share: '分享',
    delete: '删除',
    publish: '发布',
    refresh: '刷新',
    search: '搜索',
    remove: '移除',
    finish: '结束',
    details: '详情',
    settings: '设置',
    title: '标题',
    content: '内容',
    category: '分类',
    name: '名称',
    description: '描述',
    status: '状态',
    ok: '好的',
    error: '错误',
    success: '成功',
    warning: '警告',
    loading: '加载中...',
    processing: '处理中...',
    pleaseWait: '请稍候...',
    languageChangedAlert: '语言已切换，页面即将刷新以应用更改。',


    // --- 主屏幕 & Dock ---
    homeAppQQ: 'QQ',
    homeAppWorldBook: '世界书',
    homeAppAppearance: '外观设置',
    homeAppRenderer: '渲染器',
    homeAppApiSettings: '设置',
    homeAppFont: '字体',
    homeAppCPhone: 'CPhone',
    homeAppDouban: '豆瓣',
    homeAppPreset: '预设',
    homeAppTutorial: '教程',
    homeAppWerewolf: '狼人杀',
    homeAppX: 'X',

    // --- 聊天列表页 ---
    chatListTitle: '消息',
    navMessages: '消息',
    navQzone: '动态',
    navMemories: '回忆',
    navFavorites: '收藏',
    navNpcList: 'NPC',

    // --- QZone & 动态 ---
    qzoneTitle: '好友动态',
    qzoneActionShuoshuo: '说说',
    qzoneActionPost: '动态',
    qzoneActionAlbum: '相册',

    // --- CPhone (角色手机) ---
    cphoneTitleSelect: '选择一部手机',
    cphoneAppQQ: 'QQ',
    cphoneAppAlbum: '相册',
    cphoneAppBrowser: '浏览器',
    cphoneAppTaobao: '淘宝',
    cphoneAppMemo: '备忘录',
    cphoneAppDiary: '日记',
    cphoneAppAmap: '高德地图',
    cphoneAppUsage: 'App记录',
    cphoneAppMusic: '网易云',
    cphoneAppEphone: 'Ephone',
    cphoneAppFootprints: '足迹',
    cphoneAlbumTitle: 'TA的相册',
    cphoneBrowserTitle: 'TA的浏览器历史',
    cphoneTaobaoTitle: 'TA的淘宝订单',
    cphoneWalletTitle: '钱包',
    cphoneMemoTitle: '备忘录',
    cphoneDiaryTitle: '日记',
    cphoneUsageTitle: 'App使用记录',
    cphoneMusicTitle: 'TA的歌单',
    cphoneArticleTitle: '文章',
    cphoneSimulatedChatPlaceholder: '这是模拟对话，无法发送消息',

    // --- 世界书 ---
    worldBookTitle: '世界书',
    worldBookEditorTitle: '编辑世界书',
    worldBookEntryEditorTitle: '编辑条目',
    worldBookNameLabel: '书名',
    worldBookCategoryLabel: '分类',
    worldBookEntriesLabel: '内容条目',
    worldBookAddEntryBtn: '[+] 添加新条目',
    worldBookNamePlaceholder: '请输入世界书的名称...',
    worldBookImportTitle: '导入世界书',

    // --- 预设 ---
    presetTitle: '预设',
    presetEditorTitle: '编辑预设',
    presetNameLabel: '预设名称',
    presetCategoryLabel: '分类',
    presetEntriesLabel: '内容条目',
    presetAddEntryBtn: '[+] 添加新条目',

    // --- 教程 ---
    tutorialTitle: '教程',

    // --- API 设置 ---
    apiSettingsTitle: 'API 设置',
    languageLabel: '语言',
    apiPresetManagement: 'API 预设管理',
    apiPresetSelectLabel: '选择或切换预设',
    apiPrimarySettings: '主API设置 (用于聊天)',
    apiProxyUrlLabel: '反代地址 (不需要添加/v1噢~)',
    apiKeyLabel: '密钥 (API Key)',
    apiModelLabel: '模型',
    apiFetchModelsBtn: '拉取主模型',
    apiSecondarySettings: '副API设置 (用于总结长期记忆)',
    apiSecondaryProxyUrlLabel: '副反代地址',
    apiSecondaryKeyLabel: '副密钥',
    apiSecondaryModelLabel: '副模型',
    apiFetchSecondaryModelsBtn: '拉取副模型',
    apiBgActivitySettings: '后台活动设置',
    apiEnableBgActivityLabel: '启用后台角色活动',
    apiBgIntervalLabel: '后台活动检测间隔 (秒)',
    apiBlockCooldownLabel: 'AI被拉黑后冷静期 (小时)',
    apiTtsSettings: '语音消息设置 (Minimax TTS)',
    apiTtsModelLabel: '语音模型 (Model)',
    apiPerformanceSettings: '性能与显示设置',
    apiChatListRenderWindowLabel: '聊天列表每次加载条数',
    apiChatRenderWindowLabel: '聊天界面初始加载条数',
    apiImageGenSettings: '生图功能设置',
    apiEnableImageGenLabel: '启用AI生图功能',
    apiEnableNovelAILabel: '启用 NovelAI 图像生成',
    apiNovelAIModelLabel: 'NovelAI 模型',
    apiNovelAIKeyLabel: 'NovelAI API Key',
    apiNovelAIGenSettingsBtn: '生成设置',
    apiNovelAITestBtn: '测试生成',
    apiStorageOptimization: '存储空间优化',
    apiCompressImagesBtn: '一键压缩本地图片',
    apiSaveAllBtn: '保存所有设置',
    apiExportDataBtn: '导出数据',
    apiImportDataBtn: '导入备份文件',
    apiCleanupDataBtn: '清理冗余数据',
    apiDeleteWorldBooksBtn: '删除世界书',
    apiAdvancedCleanupBtn: '高级数据清理',
    apiCheckAndFixDataBtn: '数据检查与修复',

    // --- 聊天界面 ---
    chatHeaderOnline: '在线',
    chatHeaderLongTermMemory: '长期记忆',
    chatHeaderListenTogether: '一起听',
    chatHeaderChatSettings: '聊天设置',
    chatSelectionCancel: '取消',
    chatSelectionScreenshot: '长截图',
    chatSelectionFavorite: '收藏',
    chatSelectionForward: '转发',
    chatSelectionShare: '分享',
    chatSelectionSoftDelete: '删除(通知AI)',
    chatSelectionHardDelete: '彻底删除',
    chatReplyTo: '回复',
    chatInputPlaceholder: '输入消息...',
    chatWaitForReply: '等待回复',

    // --- 外观设置 ---
    appearanceTitle: '外观设置',
    appearanceSaveAll: '保存所有外观设置',

    // --- 字体设置 ---
    fontSettingsTitle: '字体设置',
    fontPresetManagement: '字体预设管理',
    fontFileUrlLabel: '字体文件URL (.ttf, .otf, .woff等)',
    fontPreviewLabel: '实时预览',
    fontPreviewText1: '你好世界 Hello World',
    fontPreviewText2: '这是字体预览效果，12345。',
    fontSaveAndApply: '保存并应用',
    fontResetDefault: '恢复默认字体',

    // --- 渲染规则 ---
    rendererTitle: '渲染规则',
    rendererEditorTitle: '编辑规则',
    rendererCreateTitle: '创建新规则',
    rendererRuleName: '规则名称',
    rendererBindScope: '绑定范围',
    rendererScopeGlobal: '公用 (所有角色)',
    rendererRegex: '正则表达式 (使用g作为标志)',
    rendererHtmlTemplate: 'HTML 模板 (用 $1, $2 引用)',
    rendererEnableRule: '启用规则',

    // --- 其他 ---
    myAlbumTitle: '我的相册',
    albumPhotosTitle: '相册名称',
    npcEditorTitleAdd: '添加 NPC',
    npcEditorTitleEdit: '编辑 NPC',
    npcAvatarLabel: 'NPC 头像',
    npcUploadAvatar: '上传头像',
    npcNicknameLabel: 'NPC 昵称',
    npcPersonaLabel: 'NPC 人设',
    npcEnableBgActivity: '启用独立后台活动',
    npcActionCooldown: '独立行动冷却 (分钟)',
    npcAssociatedChars: '关联的角色 (NPC会去评论这些角色的动态)',
  

  },
  'en': {

    save: 'Save',
    cancel: 'Cancel',
    confirm: 'Confirm',
    edit: 'Edit',
    done: 'Done',
    add: 'Add',
    back: 'Back',
    next: 'Next',
    close: 'Close',
    reset: 'Reset',
    upload: 'Upload',
    send: 'Send',
    manage: 'Manage',
    share: 'Share',
    delete: 'Delete',
    publish: 'Publish',
    refresh: 'Refresh',
    search: 'Search',
    remove: 'Remove',
    finish: 'Finish',
    details: 'Details',
    settings: 'Settings',
    title: 'Title',
    content: 'Content',
    category: 'Category',
    name: 'Name',
    description: 'Description',
    status: 'Status',
    ok: 'OK',
    error: 'Error',
    success: 'Success',
    warning: 'Warning',
    loading: 'Loading...',
    processing: 'Processing...',
    pleaseWait: 'Please wait...',
    languageChangedAlert: 'Language switched. The page will reload to apply changes.',


    // --- Home Screen & Dock ---
    homeAppQQ: 'QQ',
    homeAppWorldBook: 'World Book',
    homeAppAppearance: 'Appearance',
    homeAppRenderer: 'Renderer',
    homeAppApiSettings: 'Settings',
    homeAppFont: 'Fonts',
    homeAppCPhone: 'CPhone',
    homeAppDouban: 'Douban',
    homeAppPreset: 'Presets',
    homeAppTutorial: 'Tutorial',
    homeAppWerewolf: 'Werewolf',
    homeAppX: 'X',

    // --- Chat List Screen ---
    chatListTitle: 'Messages',
    navMessages: 'Messages',
    navQzone: 'Moments',
    navMemories: 'Memories',
    navFavorites: 'Favorites',
    navNpcList: 'NPCs',

    // --- QZone & Moments ---
    qzoneTitle: 'Moments',
    qzoneActionShuoshuo: 'Status',
    qzoneActionPost: 'Post',
    qzoneActionAlbum: 'Album',

    // --- CPhone (Character's Phone) ---
    cphoneTitleSelect: 'Select a Phone',
    cphoneAppQQ: 'QQ',
    cphoneAppAlbum: 'Album',
    cphoneAppBrowser: 'Browser',
    cphoneAppTaobao: 'Taobao',
    cphoneAppMemo: 'Memo',
    cphoneAppDiary: 'Diary',
    cphoneAppAmap: 'Amap',
    cphoneAppUsage: 'App Usage',
    cphoneAppMusic: 'Music',
    cphoneAppEphone: 'Ephone',
    cphoneAppFootprints: 'Footprints',
    cphoneAlbumTitle: 'Their Album',
    cphoneBrowserTitle: 'Their Browser History',
    cphoneTaobaoTitle: 'Their Taobao Orders',
    cphoneWalletTitle: 'Wallet',
    cphoneMemoTitle: 'Memo',
    cphoneDiaryTitle: 'Diary',
    cphoneUsageTitle: 'App Usage Log',
    cphoneMusicTitle: 'Their Playlist',
    cphoneArticleTitle: 'Article',
    cphoneSimulatedChatPlaceholder: 'This is a simulated chat, messages cannot be sent',

    // --- World Book ---
    worldBookTitle: 'World Book',
    worldBookEditorTitle: 'Edit World Book',
    worldBookEntryEditorTitle: 'Edit Entry',
    worldBookNameLabel: 'Book Name',
    worldBookCategoryLabel: 'Category',
    worldBookEntriesLabel: 'Content Entries',
    worldBookAddEntryBtn: '[+] Add New Entry',
    worldBookNamePlaceholder: 'Enter the name of the world book...',
    worldBookImportTitle: 'Import World Book',

    // --- Presets ---
    presetTitle: 'Presets',
    presetEditorTitle: 'Edit Preset',
    presetNameLabel: 'Preset Name',
    presetCategoryLabel: 'Category',
    presetEntriesLabel: 'Content Entries',
    presetAddEntryBtn: '[+] Add New Entry',

    // --- Tutorial ---
    tutorialTitle: 'Tutorial',

    // --- API Settings ---
    apiSettingsTitle: 'API Settings',
    languageLabel: 'Language',
    apiPresetManagement: 'API Preset Management',
    apiPresetSelectLabel: 'Select or Switch Preset',
    apiPrimarySettings: 'Primary API Settings (for Chat)',
    apiProxyUrlLabel: 'Proxy URL (No /v1 needed~)',
    apiKeyLabel: 'API Key',
    apiModelLabel: 'Model',
    apiFetchModelsBtn: 'Fetch Primary Models',
    apiSecondarySettings: 'Secondary API Settings (for Summarization)',
    apiSecondaryProxyUrlLabel: 'Secondary Proxy URL',
    apiSecondaryKeyLabel: 'Secondary API Key',
    apiSecondaryModelLabel: 'Secondary Model',
    apiFetchSecondaryModelsBtn: 'Fetch Secondary Models',
    apiTemperatureLabel: 'API Temperature',
    apiBgActivitySettings: 'Background Activity Settings',
    apiEnableBgActivityLabel: 'Enable Background Character Activity',
    apiBgIntervalLabel: 'Background Activity Interval (sec)',
    apiBlockCooldownLabel: 'AI Block Cooldown (hours)',
    apiTtsSettings: 'Voice Message Settings (Minimax TTS)',
    apiTtsModelLabel: 'Voice Model',
    apiPerformanceSettings: 'Performance & Display Settings',
    apiChatListRenderWindowLabel: 'Chat List Batch Load Count',
    apiChatRenderWindowLabel: 'Chat View Initial Load Count',
    apiImageGenSettings: 'Image Generation Settings',
    apiEnableImageGenLabel: 'Enable AI Image Generation',
    apiEnableNovelAILabel: 'Enable NovelAI Image Generation',
    apiNovelAIModelLabel: 'NovelAI Model',
    apiNovelAIKeyLabel: 'NovelAI API Key',
    apiNovelAIGenSettingsBtn: 'Generation Settings',
    apiNovelAITestBtn: 'Test Generation',
    apiStorageOptimization: 'Storage Optimization',
    apiCompressImagesBtn: 'Compress Local Images',
    apiSaveAllBtn: 'Save All Settings',
    apiExportDataBtn: 'Export Data',
    apiImportDataBtn: 'Import Backup File',
    apiCleanupDataBtn: 'Cleanup Redundant Data',
    apiDeleteWorldBooksBtn: 'Delete World Books',
    apiAdvancedCleanupBtn: 'Advanced Data Cleanup',
    apiCheckAndFixDataBtn: 'Data Check & Repair',

    // --- Chat Screen ---
    chatHeaderOnline: 'Online',
    chatHeaderLongTermMemory: 'Long-term Memory',
    chatHeaderListenTogether: 'Listen Together',
    chatHeaderChatSettings: 'Chat Settings',
    chatSelectionCancel: 'Cancel',
    chatSelectionScreenshot: 'Long Screenshot',
    chatSelectionFavorite: 'Favorite',
    chatSelectionForward: 'Forward',
    chatSelectionShare: 'Share',
    chatSelectionSoftDelete: 'Delete (Notify AI)',
    chatSelectionHardDelete: 'Erase',
    chatReplyTo: 'Reply to',
    chatInputPlaceholder: 'Type a message...',
    chatWaitForReply: 'Wait for Reply',

    // --- Appearance Settings ---
    appearanceTitle: 'Appearance Settings',
    appearanceSaveAll: 'Save All Appearance Settings',

    // --- Font Settings ---
    fontSettingsTitle: 'Font Settings',
    fontPresetManagement: 'Font Preset Management',
    fontFileUrlLabel: 'Font File URL (.ttf, .otf, .woff, etc.)',
    fontPreviewLabel: 'Live Preview',
    fontPreviewText1: 'Hello World 你好世界',
    fontPreviewText2: 'This is a font preview effect, 12345.',
    fontSaveAndApply: 'Save and Apply',
    fontResetDefault: 'Reset to Default Font',

    // --- Renderer ---
    rendererTitle: 'Rendering Rules',
    rendererEditorTitle: 'Edit Rule',
    rendererCreateTitle: 'Create New Rule',
    rendererRuleName: 'Rule Name',
    rendererBindScope: 'Binding Scope',
    rendererScopeGlobal: 'Global (All Characters)',
    rendererRegex: 'Regular Expression (use g flag)',
    rendererHtmlTemplate: 'HTML Template (use $1, $2)',
    rendererEnableRule: 'Enable Rule',

    // --- Others ---
    myAlbumTitle: 'My Albums',
    albumPhotosTitle: 'Album Name',
    npcEditorTitleAdd: 'Add NPC',
    npcEditorTitleEdit: 'Edit NPC',
    npcAvatarLabel: 'NPC Avatar',
    npcUploadAvatar: 'Upload Avatar',
    npcNicknameLabel: 'NPC Nickname',
    npcPersonaLabel: 'NPC Persona',
    npcEnableBgActivity: 'Enable Independent Background Activity',
    npcActionCooldown: 'Independent Action Cooldown (min)',
    npcAssociatedChars: 'Associated Characters (NPC will comment on their moments)',
  
  }
};

let currentLanguage = 'zh-CN';

function setLanguage(lang) {
  if (!translations[lang]) {
    console.warn(`Language "${lang}" not found. Defaulting to 'zh-CN'.`);
    lang = 'zh-CN';
  }
  currentLanguage = lang;
  localStorage.setItem('ephone-language', lang);
  document.documentElement.lang = lang;

  document.querySelectorAll('[data-lang-key]').forEach(el => {
    const key = el.getAttribute('data-lang-key');
    if (translations[lang][key]) {
      el.textContent = translations[lang][key];
    }
  });

  document.querySelectorAll('[data-lang-key-placeholder]').forEach(el => {
    const key = el.getAttribute('data-lang-key-placeholder');
    if (translations[lang][key]) {
      el.placeholder = translations[lang][key];
    }
  });

  document.querySelectorAll('[data-lang-key-title]').forEach(el => {
    const key = el.getAttribute('data-lang-key-title');
    if (translations[lang][key]) {
      el.title = translations[lang][key];
    }
  });
}

function initLanguage() {
  const savedLang = localStorage.getItem('ephone-language') || 'zh-CN';
  const langSelector = document.getElementById('language-select');

  if (langSelector) {
    langSelector.value = savedLang;
    langSelector.addEventListener('change', (e) => {
      const newLang = e.target.value;
      alert(translations[newLang].languageChangedAlert);
      localStorage.setItem('ephone-language', newLang);
      setTimeout(() => window.location.reload(), 100);
    });
  }
  setLanguage(savedLang);
}

(function() {
  'use strict';


  function downloadImage(imageSrc, filename) {
    try {
     
      const link = document.createElement('a');
      link.href = imageSrc;
      link.download = filename;
      link.style.display = 'none';

      document.body.appendChild(link);
      link.click(); 

    
      setTimeout(() => {
        document.body.removeChild(link);
      }, 100);

      console.log('✅ [NAI下载] 开始下载图片:', filename);

      // 显示下载提示
      showDownloadToast();
    } catch (error) {
      console.error('❌ [NAI下载] 下载失败:', error);
      showDownloadToast('下载失败，请重试', 'error');
    }
  }

 
  function showDownloadToast(message = '📥 图片下载中...', type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4CAF50' : '#f44336'};
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                pointer-events: none;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.3s ease;
            `;

    document.body.appendChild(toast);

   
    setTimeout(() => {
      toast.style.opacity = '1';
      toast.style.transform = 'translateY(0)';
    }, 10);

 
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(-20px)';
      setTimeout(() => {
        toast.remove();
      }, 300);
    }, 2000);
  }

 
  function generateFilename(imgElement) {
   
    const title = imgElement.getAttribute('title') || imgElement.getAttribute('alt') || '';

    
    let cleanTitle = title
      .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_') 
      .replace(/\s+/g, '_')
      .substring(0, 30);

    if (!cleanTitle) {
      cleanTitle = 'NAI_Image';
    }

   
    const timestamp = new Date().toISOString()
      .replace(/[-:]/g, '')
      .replace('T', '_')
      .split('.')[0];

 
    return `${cleanTitle}_${timestamp}.png`;
  }

 
  function addVisualFeedback(imgElement) {
    const originalTransform = imgElement.style.transform || '';
    const originalTransition = imgElement.style.transition || '';

  
    imgElement.style.transition = 'transform 0.15s ease';
    imgElement.style.transform = 'scale(0.95)';

    setTimeout(() => {
      imgElement.style.transform = originalTransform;
      setTimeout(() => {
        imgElement.style.transition = originalTransition;
      }, 150);
    }, 150);
  }
 window.downloadImage = downloadImage;     // 把下载函数暴露给全局
  window.generateFilename = generateFilename; // 把文件名生成暴露给全局
  window.addVisualFeedback = addVisualFeedback;

  let clickCount = 0;
  let clickTimer = null;
  let lastClickedElement = null;

 
  document.addEventListener('click', function(e) {
    const target = e.target;

    
    if (target.tagName === 'IMG' &&
      (target.classList.contains('realimag-image') ||
        target.classList.contains('naiimag-image'))) {

   
      if (target === lastClickedElement) {
        clickCount++;
      } else {
      
        clickCount = 1;
        lastClickedElement = target;
      }

      // 清除之前的定时器
      if (clickTimer) {
        clearTimeout(clickTimer);
      }

     
      if (clickCount === 3) {
        
        clickCount = 0;
        lastClickedElement = null;

      
        e.preventDefault();
        e.stopPropagation();

        console.log('🖼️ [NAI下载] 检测到三击NAI图片');

      
        addVisualFeedback(target);

     
        const imageSrc = target.src;

        if (!imageSrc || imageSrc === 'about:blank') {
          console.warn('⚠️ [NAI下载] 图片源为空，无法下载');
          showDownloadToast('图片加载中，请稍后重试', 'error');
          return;
        }

      
        const filename = generateFilename(target);

     
        downloadImage(imageSrc, filename);
      } else {
      
        clickTimer = setTimeout(() => {
          clickCount = 0;
          lastClickedElement = null;
        }, 500);
      }
    }
  }, true); 

  console.log('✅ [NAI下载] 三击下载功能已初始化');
  console.log('💡 [NAI下载] 提示：三击任意NAI图片即可下载');
})();


if ('serviceWorker' in navigator) {

  window.addEventListener('load', () => {

    navigator.serviceWorker.register('./sw.js')
      .then(registration => {

        console.log('ServiceWorker 注册成功，作用域为: ', registration.scope);
      })
      .catch(error => {

        console.log('ServiceWorker 注册失败: ', error);
      });
  });
}

if (!Array.prototype.findLastIndex) {
  Object.defineProperty(Array.prototype, 'findLastIndex', {
    value: function(predicate) {
      if (this == null) {
        throw new TypeError('Cannot read property \'findLastIndex\' of null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      let o = Object(this);
      let len = o.length >>> 0;
      let thisArg = arguments[1];
      let k = len - 1;
      while (k >= 0) {
        let kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return k;
        }
        k--;
      }
      return -1;
    },
    configurable: true,
    writable: true
  });
}

const dynamicIslandContent = document.getElementById('dynamic-island-content');
const islandAlbumArt = document.getElementById('island-album-art');
const islandLyricContainer = document.getElementById('island-lyric-container');
const islandLyricText = document.getElementById('island-lyric-text');
const phoneScreenForIsland = document.getElementById('phone-screen');

let activeMessageTimestamp = null;
let activeTransferTimestamp = null;

let lastRawAiResponse = '';
let lastResponseTimestamps = [];
let lastPrivateMessagesSent = [];
let lastGroupMessagesSent = [];
let currentQzoneReplyContext = null;
let editingNpcId = null;
let pendingBackupData = null;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
function findBestStickerMatch(meaning, availableStickers) {
  if (!meaning || !availableStickers || availableStickers.length === 0) {
    return null;
  }

  const SIMILARITY_THRESHOLD = 0.7; 
  const candidates = []; 
  let highestScore = 0;

  const getTokens = (str) => [...new Set(str.replace(/\s+/g, ''))];
  const meaningTokens = getTokens(meaning);

  availableStickers.forEach(sticker => {
    if (!sticker.name) return;

    const stickerNameTokens = getTokens(sticker.name);
    const intersection = stickerNameTokens.filter(token => meaningTokens.includes(token));
    // Jaccard Similarity Score
    const score = intersection.length / (stickerNameTokens.length + meaningTokens.length - intersection.length);

    
    if (score > highestScore) {
      highestScore = score;
    }

    
    if (score >= SIMILARITY_THRESHOLD) {
      candidates.push({ sticker, score });
    }
  });

  if (candidates.length > 0) {
  
    const bestCandidates = candidates.filter(c => c.score === highestScore);
    
    
    const randomIndex = Math.floor(Math.random() * bestCandidates.length);
    const chosenSticker = bestCandidates[randomIndex].sticker;
    
    console.log(`[模糊随机匹配成功] AI含义: "${meaning}", 匹配到 ${bestCandidates.length} 个最佳选项, 随机选中: "${chosenSticker.name}", 相似度: ${highestScore.toFixed(2)}`);
    return chosenSticker;
  }

  console.log(`[模糊随机匹配失败] AI含义: "${meaning}", 最高相似度为 ${highestScore.toFixed(2)}，未达到阈值 ${SIMILARITY_THRESHOLD}。`);
  return null;
}
function getRandomValue(str) {

  if (str.includes(',')) {

    const arr = str.split(',').map(item => item.trim());

    const randomIndex = Math.floor(Math.random() * arr.length);

    return arr[randomIndex];
  }

  return str;
}

function isImage(content) {
  if (content.image_url && content.image_url.url) {
    let currentImageData = content.image_url.url

    const base64Data = currentImageData.split(',')[1];

    const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
    return [{
        text: '用户向你发送了一张图片'
      },
      {
        inline_data: {
          mime_type: mimeType,
          data: base64Data
        }
      }
    ]
  }
  return []
}



function getGeminiResponseText(data) {

 
  if (data.choices && Array.isArray(data.choices) && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
    return data.choices[0].message.content;
  }


  if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts) {
    return data.candidates[0].content.parts[0].text;
  }

 
  console.error("API返回了非预期的格式:", data);
  let errorReason = "AI返回了空内容或未知格式。";

 
  if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0 && data.candidates[0].finishReason === 'SAFETY') {
    const safetyRatings = data.candidates[0].safetyRatings;
    const blockedCategories = safetyRatings
      .filter(r => r.probability !== 'NEGLIGIBLE' && r.probability !== 'LOW')
      .map(r => `${r.category} (概率: ${r.probability})`)
      .join(', ');
    errorReason = `内容因安全策略被屏蔽。触发类别: ${blockedCategories || '未知'}`;
  } 
  
  else if (data.promptFeedback?.blockReason) {
    const reason = data.promptFeedback.blockReason;
    const details = data.promptFeedback.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ');
    errorReason = `内容因安全策略被屏蔽 (原因: ${reason})。详情: ${details || '无'}`;
  } 
  
  else if (data.error?.message) { 
    errorReason = `API错误: ${data.error.message}`;
  } 
 
  else if (data.message) { 
    errorReason = `API错误: ${data.message}`;
  }

  else if (data.detail) {
    errorReason = `API错误: ${data.detail}`;
  }
 
  else if (data.error && typeof data.error === 'string') {
      errorReason = `API错误: ${data.error}`;
  }

  throw new Error(errorReason);
}


document.addEventListener('DOMContentLoaded', () => {

 document.getElementById('user-city-search-btn').addEventListener('click', async () => {
    const query = document.getElementById('user-real-city-search').value.trim();
    if(!query) return alert("请输入真实城市拼音或英文名称");
    
    const result = await searchCityGeo(query);
    if (result) {
        document.getElementById('user-city-lat').value = result.latitude;
        document.getElementById('user-city-lon').value = result.longitude;
        document.getElementById('user-city-result').textContent = `已选中: ${result.name}, ${result.country} (${result.latitude}, ${result.longitude})`;
        document.getElementById('user-city-result').style.color = 'green';
        // 可以在 dataset 暂存真实城市名
        document.getElementById('user-real-city-search').dataset.realName = result.name;
    } else {
        alert("未找到该城市，请尝试使用拼音或英文 (如 Shanghai)。");
    }
});

document.getElementById('char-city-search-btn').addEventListener('click', async () => {
    const query = document.getElementById('char-real-city-search').value.trim();
    if(!query) return alert("请输入真实城市拼音或英文名称");
    
    const result = await searchCityGeo(query);
    if (result) {
        document.getElementById('char-city-lat').value = result.latitude;
        document.getElementById('char-city-lon').value = result.longitude;
        document.getElementById('char-city-result').textContent = `已选中: ${result.name}, ${result.country} (${result.latitude}, ${result.longitude})`;
        document.getElementById('char-city-result').style.color = 'green';
        document.getElementById('char-real-city-search').dataset.realName = result.name;
    } else {
        alert("未找到该城市，请尝试使用拼音或英文 (如 New York)。");
    }
});

  // 手动总结弹窗事件监听器
  document.getElementById('manual-summary-btn').addEventListener('click', openManualSummaryModal);
  document.getElementById('manual-summary-close-btn').addEventListener('click', closeManualSummaryModal);
  document.getElementById('manual-summary-cancel-btn').addEventListener('click', closeManualSummaryModal);
  document.getElementById('manual-summary-confirm-btn').addEventListener('click', executeManualSummary);
  
  // 暂停调用按钮事件监听器
  const stopApiCallBtn = document.getElementById('stop-api-call-btn');
  if (stopApiCallBtn) {
    stopApiCallBtn.addEventListener('click', () => {
      if (currentApiController) {
        console.log('用户点击暂停调用按钮，正在取消API请求...');
        currentApiController.abort();
        
        // 立即隐藏按钮并移除动画
        stopApiCallBtn.style.display = 'none';
        stopApiCallBtn.classList.remove('active');
        
        // 显示取消提示
        showCustomAlert('已暂停', 'API调用已被取消');
      }
    });
  }
  
  const PREFILLED_SALT = "bu_wan_jiu_guan_bu_yao_huo_qu";


  async function generatePin(deviceId, salt) {
    if (!deviceId || !salt) {
      throw new Error("设备ID和密钥盐不能为空。");
    }
    const dataToHash = deviceId + salt;
    const dataBuffer = new TextEncoder().encode(dataToHash);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex.substring(0, 6).toUpperCase();
  }

 
  function requirePinActivation() {
  
    return new Promise(async (resolve, reject) => {
      
      if (isPinActivated) {
        resolve(true);
        return;
      }

     
      const modal = document.getElementById('pin-modal-overlay');
      const deviceIdDisplay = document.getElementById('pin-device-id-display');
      const pinInput = document.getElementById('pin-input');
      const confirmBtn = document.getElementById('pin-modal-confirm-btn');
      const cancelBtn = document.getElementById('pin-modal-cancel-btn');

      
      deviceIdDisplay.value = EPHONE_DEVICE_ID;
      pinInput.value = ''; 

     

      const onConfirmClick = async () => {
        const userPin = pinInput.value;

       
        modal.classList.remove('visible');

       
        confirmBtn.removeEventListener('click', onConfirmClick);
        cancelBtn.removeEventListener('click', onCancelClick);

        if (!userPin || !userPin.trim()) {
          await showCustomAlert('操作取消', '您没有输入激活码。'); 
          reject(new Error('用户取消了输入。'));
          return;
        }

       
        await showCustomAlert("请稍候...", "正在验证激活码...");


        try {
        
          const correctPin = await generatePin(EPHONE_DEVICE_ID, PREFILLED_SALT);

         
          if (userPin.trim().toUpperCase() === correctPin) {
            
            localStorage.setItem('ephonePinActivated', 'true');
            isPinActivated = true;
            await showCustomAlert('激活成功！', '此功能已为您的设备永久解锁。');

        
            updateLockedFeatureUI();

           
            resolve(true);
          } else {
            
            await showCustomAlert('激活失败', '您输入的激活码不正确。');
            reject(new Error('激活码不正确。'));
          }
        } catch (error) {
         
          console.error("本地PIN码验证过程出错:", error);
          await showCustomAlert('激活失败', `验证过程中发生错误：${error.message}`);
          reject(error);
        }
     
      };


      const onCancelClick = async () => { // <--- 添加 async
        modal.classList.remove('visible');
       
        confirmBtn.removeEventListener('click', onConfirmClick);
        cancelBtn.removeEventListener('click', onCancelClick);

    
        await showCustomAlert('操作取消', '激活流程已取消。'); 
        reject(new Error('用户取消了激活。'));
      };

    
      confirmBtn.addEventListener('click', onConfirmClick);
      cancelBtn.addEventListener('click', onCancelClick);

   
      modal.classList.add('visible');
      pinInput.focus();
    });
  }

  
  function updateLockedFeatureUI() {
    const isActivated = localStorage.getItem('ephonePinActivated') === 'true';
    const presetImportBtn = document.getElementById('import-preset-btn');

    
    const worldBookImportBtn = document.getElementById('import-world-book-btn');
  

    
    if (presetImportBtn) {
      presetImportBtn.classList.toggle('locked-feature', !isActivated);
    }

 
    if (worldBookImportBtn) {
      worldBookImportBtn.classList.toggle('locked-feature', !isActivated);
    }
  
  }
  document.addEventListener('visibilitychange', () => {
   
    if (document.visibilityState === 'visible') {
      console.log('应用已返回前台，正在检查更新...');
     
      navigator.serviceWorker.ready.then(registration => {
       
        registration.update();
      });
    }
  });

  function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision) {
    const apiTemperature = state.globalSettings.apiTemperature || 0.8;
    const roleType = {
      user: 'user',
      assistant: 'model',
      system: 'user'
    };


    const contents = [{
        role: 'user',
        parts: [{
          text: systemInstruction
        }]
      },
      {
        role: 'model',
        parts: [{
          text: '好的，我明白了。我会严格遵守以上所有规则和设定。'
        }]
      },

      ...messagesForDecision.map((item) => {
        const parts = [];

        if (Array.isArray(item.content)) {
          item.content.forEach(part => {
            if (part.type === 'text') {
              parts.push({
                text: part.text
              });
            } else if (part.type === 'image_url' && part.image_url && part.image_url.url) {

              const currentImageData = part.image_url.url;
              const base64Data = currentImageData.split(',')[1];
              const mimeTypeMatch = currentImageData.match(/^data:(.*);base64/);
              if (mimeTypeMatch && base64Data) {
                parts.push({
                  inline_data: {
                    mime_type: mimeTypeMatch[1],
                    data: base64Data
                  }
                });
              }
            }
          });
        } else {

          parts.push({
            text: String(item.content)
          });
        }
        return {
          role: roleType[item.role],
          parts: parts
        };
      })
    ];


    return {
      url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
      data: {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: contents,
          generationConfig: {
            temperature: apiTemperature,
          },
        })
      }
    };
  }





  const db = new Dexie('GeminiChatDB');
  const avatarFrames = [{
      id: 'none',
      url: '',
      name: '无'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif',
      name: '14'
    }, {
      id: 'frame_cat_ear',
      url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif',
      name: '1'
    }, {
      id: 'frame_ribbon',
      url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif',
      name: '2'
    }, {
      id: 'frame_flower',
      url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif',
      name: '3'
    }, {
      id: 'frame_tech',
      url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif',
      name: '4'
    }, {
      id: 'frame_5',
      url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif',
      name: '5'
    }, {
      id: 'frame_6',
      url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif',
      name: '6'
    }, {
      id: 'frame_7',
      url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif',
      name: '7'
    }, {
      id: 'frame_8',
      url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif',
      name: '8'
    }, {
      id: 'frame_9',
      url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif',
      name: '9'
    }, {
      id: 'frame_10',
      url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif',
      name: '10'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif',
      name: '14'
    }, {
      id: 'frame_11',
      url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif',
      name: '11'
    }, {
      id: 'frame_12',
      url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif',
      name: '12'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif',
      name: '14'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif',
      name: '14'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif',
      name: '14'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif',
      name: '14'
    }, {
      id: 'frame_13',
      url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif',
      name: '13'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif',
      name: '14'
    }, {
      id: 'frame_14',
      url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif',
      name: '14'
    },
    {
      id: 'frame_12',
      url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif',
      name: '12'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif',
      name: '14'
    },

    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif',
      name: '14'
    },


    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif',
      name: '14'
    },
    {
      id: 'frame_13',
      url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif',
      name: '13'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif',
      name: '14'
    },
    {
      id: 'frame_14',
      url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif',
      name: '14'
    },

  ];
  let billState = {
    page: 0,
    pageSize: 30,      
    isLoading: false,   
    hasMore: true,      
    filterDate: '',     
    filterType: 'all'   
};
  let state = {
    chats: {},
    activeChatId: null,
    globalSettings: {},
    apiConfig: {},
    userStickers: [],
    worldBooks: [],
    personaPresets: [],
    qzoneSettings: {},
    activeAlbumId: null,
    cache: {
      songs: new Map(),
      lyrics: new Map()
    },
    ttsCache: new Map(),
    quickReplies: []
  };

// ==================== 角色监测功能 ====================

// 初始化监测配置
if (!state.globalSettings) {
  state.globalSettings = {};
}
if (!state.globalSettings.characterMonitor) {
  state.globalSettings.characterMonitor = {
    timeSegments: 12,
    hoursPerSegment: 2,
    historyDays: 7,
    autoGenerate: false
  };
}

// 当前监测数据
let currentMonitorData = null;
let currentMonitorDate = null;

// 打开角色监测界面
async function openCharacterMonitor() {
  // 强制弹窗提示功能已锁定
  await showCustomAlert('功能暂时锁定', '角色监测功能存在较多bug，正在修复中。\n\n为了保证您的使用体验，该功能暂时锁定，修复完成后将重新开放。\n\n感谢您的理解与支持！');
  return;
  
  // 以下代码暂时禁用
  /*
  if (!state.activeChatId) {
    await showCustomAlert('提示', '请先选择一个聊天对象');
    return;
  }
  
  const chat = state.chats[state.activeChatId];
  if (!chat) return;
  
  document.getElementById('monitor-character-name').textContent = `${chat.name} - 角色监测`;
  
  const today = new Date();
  currentMonitorDate = today;
  updateMonitorDateDisplay(today);
  
  const todayStr = formatMonitorDate(today);
  const existingData = await loadMonitorData(state.activeChatId, todayStr);
  
  // 先显示界面
  showScreen('character-monitor-screen');
  
  if (existingData) {
    currentMonitorData = existingData;
    renderMonitorTimeline(existingData);
  } else {
    // 先渲染空白时间轴
    renderEmptyTimeline();
    
    // 然后再询问是否生成
    const hour = today.getHours();
    let shouldGenerate = false;
    let generateMode = 'full';
    let targetDate = todayStr;
    let displayDate = today;
    
    if (hour >= 22) {
      shouldGenerate = await showCustomConfirm('生成监测', '是否立即生成今日完整监测？');
      generateMode = 'full';
    } else if (hour >= 6) {
      shouldGenerate = await showCustomConfirm('生成监测', '是否立即生成今日已过去的时段？');
      generateMode = 'past';
    } else {
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = formatMonitorDate(yesterday);
      shouldGenerate = await showCustomConfirm('生成监测', '是否立即生成昨日完整监测？');
      if (shouldGenerate) {
        targetDate = yesterdayStr;
        displayDate = yesterday;
        currentMonitorDate = yesterday;
        updateMonitorDateDisplay(yesterday);
        generateMode = 'full';
      }
    }
    
    if (shouldGenerate) {
      try {
        await generateMonitorData(state.activeChatId, targetDate, generateMode);
        // generateMonitorData 内部已经有成功提示
      } catch (error) {
        console.error('生成监测数据失败:', error);
        await showCustomAlert('错误', '生成失败，请重试');
        renderEmptyTimeline();
      }
    }
  }
  */
}

// 生成监测数据
async function generateMonitorData(characterId, date, mode = 'full') {
  const chat = state.chats[characterId];
  if (!chat) return;
  
  // 确保配置已初始化
  if (!state.globalSettings) {
    state.globalSettings = {};
  }
  if (!state.globalSettings.characterMonitor) {
    state.globalSettings.characterMonitor = {
      timeSegments: 12,
      hoursPerSegment: 2,
      historyDays: 7,
      autoGenerate: false
    };
  }
  
  const config = state.globalSettings.characterMonitor;
  const segments = config.timeSegments;
  const hoursPerSegment = config.hoursPerSegment;
  
  let segmentsToGenerate = [];
  const now = new Date();
  const targetDate = new Date(date);
  const isToday = formatMonitorDate(now) === date;
  
  for (let i = 0; i < segments; i++) {
    const startHour = i * hoursPerSegment;
    const endHour = (i + 1) * hoursPerSegment;
    const timeRange = `${String(startHour).padStart(2, '0')}:00-${String(endHour).padStart(2, '0')}:00`;
    
    if (mode === 'full') {
      segmentsToGenerate.push({ index: i, timeRange, startHour, endHour });
    } else if (mode === 'past' && isToday) {
      if (endHour <= now.getHours()) {
        segmentsToGenerate.push({ index: i, timeRange, startHour, endHour });
      }
    }
  }
  
  if (segmentsToGenerate.length === 0) {
    await showCustomAlert('提示', '没有需要生成的时段');
    return;
  }
  
  const timeline = [];
  
  for (const segment of segmentsToGenerate) {
    try {
      const content = await generateSegmentContent(chat, date, segment);
      timeline.push({
        timeRange: segment.timeRange,
        action: content.action,
        mood: content.mood,
        innerThought: content.innerThought,
        isEdited: false,
        editTime: null,
        isHighlighted: false
      });
    } catch (error) {
      console.error(`生成时段 ${segment.timeRange} 失败:`, error);
      timeline.push({
        timeRange: segment.timeRange,
        action: '生成失败，请重试',
        mood: '未知',
        innerThought: '...',
        isEdited: false,
        editTime: null,
        isHighlighted: false
      });
    }
  }
  
  const monitorData = {
    characterId: characterId,
    characterName: chat.name,
    date: date,
    timeline: timeline,
    generatedAt: new Date().toISOString()
  };
  
  await saveMonitorData(monitorData);
  currentMonitorData = monitorData;
  renderMonitorTimeline(monitorData);
  
  await showCustomAlert('完成', '监测数据生成完成！');
}

// 生成单个时段的内容
async function generateSegmentContent(chat, date, segment) {
  const prompt = `根据以下信息，生成 ${chat.name} 在 ${date} ${segment.timeRange} 这个时段的行动监测。

【角色人设】
${chat.settings?.persona || '无'}

【近期对话】
${await getRecentMessagesForMonitor(chat.id, 10)}

【要求】
1. 用第三人称描述 ${chat.name} 的具体行动
2. 不要使用任何表情符号
3. 描述要具体生动
4. 格式：
   行动：[具体描述，50-100字]
   心情：[2-4字的词汇]
   内心想法：[口语化表达，10-20字]

请直接输出，不要有任何额外说明。`;

  const apiConfig = state.apiConfig;
  const response = await fetch(`${apiConfig.proxyUrl}/chat/completions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiConfig.apiKey}`
    },
    body: JSON.stringify({
      model: apiConfig.model,
      messages: [
        { role: 'system', content: '你是一个专业的角色行为分析师，擅长根据角色设定推测其日常行为。' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.8
    })
  });
  
  const data = await response.json();
  const text = getGeminiResponseText(data);
  
  return parseSegmentResponse(text);
}

// 解析API返回的内容
function parseSegmentResponse(text) {
  const lines = text.split('\n').filter(l => l.trim());
  
  let action = '';
  let mood = '';
  let innerThought = '';
  
  for (const line of lines) {
    if (line.includes('行动：') || line.includes('行动:')) {
      action = line.split(/[：:]/)[1]?.trim() || '';
    } else if (line.includes('心情：') || line.includes('心情:')) {
      mood = line.split(/[：:]/)[1]?.trim() || '';
    } else if (line.includes('内心想法：') || line.includes('内心想法:')) {
      innerThought = line.split(/[：:]/)[1]?.trim() || '';
    }
  }
  
  if (!action && !mood && !innerThought) {
    const parts = text.split(/心情[：:]|内心想法[：:]/);
    action = parts[0]?.replace(/行动[：:]/, '').trim() || text;
    mood = parts[1]?.trim() || '平静';
    innerThought = parts[2]?.trim() || '...';
  }
  
  return { action, mood, innerThought };
}

// 渲染时间轴
function renderMonitorTimeline(monitorData) {
  const container = document.getElementById('monitor-timeline-container');
  container.innerHTML = '';
  
  // 确保配置已初始化
  if (!state.globalSettings) {
    state.globalSettings = {};
  }
  if (!state.globalSettings.characterMonitor) {
    state.globalSettings.characterMonitor = {
      timeSegments: 12,
      hoursPerSegment: 2,
      historyDays: 7,
      autoGenerate: false
    };
  }
  
  const config = state.globalSettings.characterMonitor;
  const totalSegments = config.timeSegments;
  
  const allSegments = [];
  for (let i = 0; i < totalSegments; i++) {
    const startHour = i * config.hoursPerSegment;
    const endHour = (i + 1) * config.hoursPerSegment;
    const timeRange = `${String(startHour).padStart(2, '0')}:00-${String(endHour).padStart(2, '0')}:00`;
    
    const existingSegment = monitorData.timeline.find(s => s.timeRange === timeRange);
    allSegments.push(existingSegment || { timeRange, isEmpty: true });
  }
  
  allSegments.forEach((segment, index) => {
    const card = document.createElement('div');
    
    if (segment.isEmpty) {
      card.className = 'monitor-empty-slot';
      card.innerHTML = `
        <div style="font-size: 14px; font-weight: 600; margin-bottom: 5px;">${segment.timeRange}</div>
        <div>暂无数据</div>
      `;
    } else {
      card.className = 'monitor-time-card';
      if (segment.isHighlighted) card.classList.add('highlighted');
      if (segment.isEdited) card.classList.add('edited');
      
      card.innerHTML = `
        <div class="monitor-time-range">${segment.timeRange}</div>
        <div class="monitor-action">${escapeHTML(segment.action)}</div>
        <div class="monitor-mood"><strong>心情：</strong>${escapeHTML(segment.mood)}</div>
        <div class="monitor-inner-thought"><strong>内心想法：</strong>${escapeHTML(segment.innerThought)}</div>
        <div class="monitor-time-card-actions">
          <span onclick="editMonitorSegment('${segment.timeRange}')">编辑</span>
          <span onclick="toggleMonitorHighlight('${segment.timeRange}')">${segment.isHighlighted ? '取消高亮' : '高亮'}</span>
          <span onclick="regenerateMonitorSegment('${segment.timeRange}')">重新生成</span>
        </div>
      `;
    }
    
    container.appendChild(card);
  });
}

// 渲染空时间轴
function renderEmptyTimeline() {
  const container = document.getElementById('monitor-timeline-container');
  container.innerHTML = '';
  
  const config = state.globalSettings.characterMonitor;
  const totalSegments = config.timeSegments;
  
  for (let i = 0; i < totalSegments; i++) {
    const startHour = i * config.hoursPerSegment;
    const endHour = (i + 1) * config.hoursPerSegment;
    const timeRange = `${String(startHour).padStart(2, '0')}:00-${String(endHour).padStart(2, '0')}:00`;
    
    const card = document.createElement('div');
    card.className = 'monitor-empty-slot';
    card.innerHTML = `
      <div style="font-size: 14px; font-weight: 600; margin-bottom: 5px;">${timeRange}</div>
      <div>暂无数据</div>
    `;
    container.appendChild(card);
  }
}

// 编辑时段 - 暴露到全局作用域
window.editMonitorSegment = async function(timeRange) {
  if (!currentMonitorData) return;
  
  const segment = currentMonitorData.timeline.find(s => s.timeRange === timeRange);
  if (!segment) return;
  
  const newAction = prompt('编辑行动描述：', segment.action);
  if (newAction === null) return;
  
  const newMood = prompt('编辑心情：', segment.mood);
  if (newMood === null) return;
  
  const newThought = prompt('编辑内心想法：', segment.innerThought);
  if (newThought === null) return;
  
  segment.action = newAction;
  segment.mood = newMood;
  segment.innerThought = newThought;
  segment.isEdited = true;
  segment.editTime = new Date().toISOString();
  
  await saveMonitorData(currentMonitorData);
  renderMonitorTimeline(currentMonitorData);
};

// 切换高亮 - 暴露到全局作用域
window.toggleMonitorHighlight = async function(timeRange) {
  if (!currentMonitorData) return;
  
  const segment = currentMonitorData.timeline.find(s => s.timeRange === timeRange);
  if (!segment) return;
  
  segment.isHighlighted = !segment.isHighlighted;
  
  await saveMonitorData(currentMonitorData);
  renderMonitorTimeline(currentMonitorData);
};

// 重新生成单个时段 - 暴露到全局作用域
window.regenerateMonitorSegment = async function(timeRange) {
  if (!currentMonitorData || !state.activeChatId) return;
  
  const confirmed = await showCustomConfirm('确认', '是否重新生成此时段？');
  if (!confirmed) return;
  
  const chat = state.chats[state.activeChatId];
  const segmentIndex = currentMonitorData.timeline.findIndex(s => s.timeRange === timeRange);
  if (segmentIndex === -1) return;
  
  const [startTime] = timeRange.split('-');
  const startHour = parseInt(startTime.split(':')[0]);
  const config = state.globalSettings.characterMonitor;
  const endHour = startHour + config.hoursPerSegment;
  
  const segment = {
    timeRange,
    startHour,
    endHour
  };
  
  try {
    const content = await generateSegmentContent(chat, currentMonitorData.date, segment);
    currentMonitorData.timeline[segmentIndex] = {
      timeRange,
      action: content.action,
      mood: content.mood,
      innerThought: content.innerThought,
      isEdited: false,
      editTime: null,
      isHighlighted: currentMonitorData.timeline[segmentIndex].isHighlighted
    };
    
    await saveMonitorData(currentMonitorData);
    renderMonitorTimeline(currentMonitorData);
    await showCustomAlert('完成', '重新生成成功！');
  } catch (error) {
    console.error('重新生成失败:', error);
    await showCustomAlert('错误', '重新生成失败，请重试');
  }
};

// 保存监测数据
async function saveMonitorData(monitorData) {
  const key = `characterMonitor_${monitorData.characterId}_${monitorData.date}`;
  localStorage.setItem(key, JSON.stringify(monitorData));
  await cleanupOldMonitorData(monitorData.characterId);
}

// 加载监测数据
async function loadMonitorData(characterId, date) {
  const key = `characterMonitor_${characterId}_${date}`;
  const data = localStorage.getItem(key);
  return data ? JSON.parse(data) : null;
}

// 清理过期数据
async function cleanupOldMonitorData(characterId) {
  const config = state.globalSettings.characterMonitor;
  const maxDays = config.historyDays;
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - maxDays);
  
  const prefix = `characterMonitor_${characterId}_`;
  const keysToRemove = [];
  
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith(prefix)) {
      const dateStr = key.replace(prefix, '');
      const date = new Date(dateStr);
      if (date < cutoffDate) {
        keysToRemove.push(key);
      }
    }
  }
  
  keysToRemove.forEach(key => localStorage.removeItem(key));
}

// 辅助函数
function formatMonitorDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function updateMonitorDateDisplay(date) {
  const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const weekday = weekdays[date.getDay()];
  
  document.getElementById('monitor-date-display').textContent = 
    `${year}年${month}月${day}日 ${weekday}`;
}

async function getRecentMessagesForMonitor(chatId, count = 10) {
  const chat = state.chats[chatId];
  if (!chat || !chat.messages) return '无';
  
  const recentMsgs = chat.messages.slice(-count);
  return recentMsgs.map(m => {
    const role = m.role === 'user' ? '用户' : chat.name;
    return `${role}: ${m.content}`;
  }).join('\n');
}

// ==================== 角色监测功能结束 ====================

let memoryCache = []; // 缓存所有需要显示的记忆
let memoryRenderCount = 0; // 当前已渲染数量
let isLoadingMoreMemories = false; // 防抖锁

// 待办事项分页状态
let todoCache = [];
let todoRenderCount = 0;
let isLoadingMoreTodos = false;
async function uploadImageToImgBB(base64String) {
    // 1. 检查功能是否开启
    if (!state.apiConfig.imgbbEnable || !state.apiConfig.imgbbApiKey) {
        // console.log("ImgBB 未开启，返回原始 Base64。");
        return base64String; // 功能未开启，直接返回
    }

    // 2. 检查是否已经是 URL
    if (!base64String || !base64String.startsWith('data:image')) {
        // console.log("输入已是 URL 或为空，无需上传。");
        return base64String; // 已经是 URL 或为空，无需上传
    }

    // 3. 提取 Base64 数据
    // 格式为 data:image/png;base64,iVBORw0KGgo...
    const base64Data = base64String.split(',')[1];
    if (!base64Data) {
        console.warn("无法从字符串中提取 Base64 数据:", base64String.substring(0, 50) + "...");
        return base64String; // 格式错误，返回原文
    }
    
    console.log(`[ImgBB] 开始上传图片... (大小: ${(base64String.length / 1024).toFixed(1)} KB)`);

    try {
        const formData = new FormData();
        formData.append('image', base64Data);

        const response = await fetch(`https://api.imgbb.com/1/upload?key=${state.apiConfig.imgbbApiKey}`, {
            method: 'POST',
            body: formData
        });

        const result = await response.json();

        if (result.success && result.data && result.data.url) {
            console.log("[ImgBB] 上传成功! URL:", result.data.url);
            return result.data.url; // 成功！返回 URL
        } else {
            // ImgBB API 返回了错误
            throw new Error(result.error?.message || 'ImgBB API 返回了未知错误。');
        }
    } catch (error) {
        console.error("[ImgBB] 上传失败:", error);
        // 抛出错误，让调用此函数的上层逻辑知道上传失败了
        throw new Error(`ImgBB 上传失败: ${error.message}`);
    }
}
        async function uploadFileToCatbox(fileObject) {
    // 1. 检查功能是否开启
    if (!state.apiConfig.catboxEnable || !state.apiConfig.catboxUserHash) {
        console.log("[Catbox] 功能未开启或未配置 User Hash，跳过上传。");
        return null; // 功能未开启，返回 null 以便回退
    }

    const userHash = state.apiConfig.catboxUserHash;
    console.log(`[Catbox] 开始上传文件: ${fileObject.name || 'blob.mp3'}... (大小: ${(fileObject.size / 1024 / 1024).toFixed(2)} MB)`);

    try {
        const formData = new FormData();
        formData.append('reqtype', 'fileupload');
        formData.append('userhash', userHash);
        formData.append('fileToUpload', fileObject, fileObject.name || 'track.mp3'); // 提供文件名

        // ▼▼▼ 【核心修复】 ▼▼▼
        // 1. 定义 Catbox API URL
        let apiUrl = 'https://catbox.moe/user/api.php';

        // 2. 获取 CORS 代理设置 (复用 NovelAI 的设置)
        const proxySettings = getNovelAISettings(); // This function is around line 4504
        let corsProxy = proxySettings.cors_proxy;
        if (corsProxy === 'custom') {
            corsProxy = proxySettings.custom_proxy_url || '';
        }

        // 3. 如果代理存在, 则使用代理
        if (corsProxy && corsProxy !== '') {
            // 【重要】Catbox API URL 不需要编码，而 NovelAI 需要，这里我们直接拼接
            apiUrl = corsProxy + apiUrl; 
            console.log(`[Catbox] 检测到CORS代理，使用代理上传: ${apiUrl}`);
        } else {
            console.log("[Catbox] 未配置CORS代理，尝试直连... (这很可能会失败)");
        }
        // ▲▲▲ 【修复结束】 ▲▲▲

        const response = await fetch(apiUrl, { // <-- 替换为 apiUrl
            method: 'POST',
            body: formData
        });

        const responseText = await response.text();

        if (response.ok && responseText.startsWith('http')) {
            console.log("[Catbox] 上传成功! URL:", responseText);
            return responseText; // 成功！返回 URL
        } else {
            // Catbox API 返回了错误文本
            throw new Error(responseText || 'Catbox API 返回了未知错误。');
        }
    } catch (error) {
        console.error("[Catbox] 上传失败:", error);
        // 抛出错误，让调用此函数的上层逻辑知道上传失败了
        // 【重要】我们在这里只抛出原始错误，以便上层函数可以捕获并显示它
        throw error;
    }
}
async function silentlyUpdateDbUrl(table, recordId, pathString, base64ToFind, nameToMatch = null) {
    if (!state.apiConfig.imgbbEnable || !state.apiConfig.imgbbApiKey) {
        console.log(`[ImgBB Silent Update] ImgBB is disabled, skipping silent upload for ${table.name}.${recordId}.${pathString}.`);
        return; // ImgBB not enabled, do nothing.
    }
    
    let imageUrl;
    try {
        imageUrl = await uploadImageToImgBB(base64ToFind);
        if (imageUrl === base64ToFind) {
             console.log("[ImgBB Silent Update] Upload returned Base64 (or failed), no update needed.");
             return; // Upload failed or was skipped
        }
    } catch (uploadError) {
        console.error(`[ImgBB Silent Update] Background upload failed for ${table.name}.${recordId}.${pathString}:`, uploadError.message);
        return; // Upload failed
    }

    console.log(`[ImgBB Silent Update] Success. New URL: ${imageUrl}. Finding record to update...`);

    try {
        const record = await table.get(recordId);
        if (!record) {
            console.warn(`[ImgBB Silent Update] Could not find record ${recordId} in table ${table.name}.`);
            return;
        }

        let updated = false;

        // 辅助函数：通过路径字符串深入对象，返回父级和最后的键
        function getNestedParent(obj, path) {
            const keys = path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                if (current[keys[i]] === undefined || current[keys[i]] === null) {
                    console.warn(`[ImgBB Silent Update] Invalid path: ${path} in record at key ${keys[i]}.`);
                    return null; // Path does not exist
                }
                current = current[keys[i]];
            }
            return { parent: current, finalKey: keys[keys.length - 1] };
        }

        if (nameToMatch) {
            // --- 逻辑 A: 搜索数组 ---
            const result = getNestedParent(record, pathString);
            if (result && Array.isArray(result.parent[result.finalKey])) {
                const arrayToSearch = result.parent[result.finalKey];
                const itemToUpdate = arrayToSearch.find(item => item.url === base64ToFind && item.name === nameToMatch);
                
                if (itemToUpdate) {
                    itemToUpdate.url = imageUrl;
                    updated = true;
                    console.log(`[ImgBB Silent Update] Found and updated item "${nameToMatch}" in array ${pathString}.`);
                } else {
                    console.warn(`[ImgBB Silent Update] Could not find item "${nameToMatch}" with matching Base64 in array ${pathString} to update.`);
                }
            } else {
                 console.warn(`[ImgBB Silent Update] Path ${pathString} did not resolve to a valid array.`);
            }
        } else {
            // --- 逻辑 B: 更新简单属性 (如 'url' 或 'widgetData.polaroid-img-1') ---
            const result = getNestedParent(record, pathString);
            if (result && result.parent[result.finalKey] === base64ToFind) {
                result.parent[result.finalKey] = imageUrl;
                updated = true;
                console.log(`[ImgBB Silent Update] Found and updated simple path ${pathString}.`);
            } else if (result) {
                console.warn(`[ImgBB Silent Update] Value changed since upload for ${pathString}. Expected Base64, found: ${String(result.parent[result.finalKey]).substring(0,30)}...`);
            } else {
                console.warn(`[ImgBB Silent Update] Path ${pathString} did not resolve to a matching string.`);
            }
        }


        if (updated) {
            await table.put(record);
            console.log(`[ImgBB Silent Update] Successfully updated DB for ${table.name}.${recordId}.${pathString}.`);
            
            // 更新内存 (state.globalSettings)
            if (table.name === 'globalSettings' && recordId === 'main') {
                // (重新获取更新后的内存状态)
                const stateResult = getNestedParent(state, `globalSettings.${pathString}`);
                if (nameToMatch && stateResult && Array.isArray(stateResult.parent[stateResult.finalKey])) {
                    const stateArray = stateResult.parent[stateResult.finalKey];
                    const stateItem = stateArray.find(item => item.url === base64ToFind && item.name === nameToMatch);
                    if (stateItem) stateItem.url = imageUrl;
                } else if (!nameToMatch && stateResult && stateResult.parent[stateResult.finalKey] === base64ToFind) {
                    stateResult.parent[stateResult.finalKey] = imageUrl;
                }
                console.log(`[ImgBB Silent Update] In-memory state.globalSettings updated.`);
            }
        }
    } catch (dbError) {
        console.error(`[ImgBB Silent Update] Failed to save updated URL to DB for ${table.name}.${recordId}.${pathString}:`, dbError);
    }
}
  let werewolfGameState = {
    isActive: false,
    gameMode: null,
    chatId: null,
    players: [],
    currentDay: 1,
    currentPhase: 'setup',
    nightActions: {},
    gameLog: [],
    discussionLog: [],
    voteResults: {},
    electionInfo: {
      candidates: [],
      votes: {}
    },
    sheriffId: null,
    lastFailedAction: null,
  };

  let thoughtsHistoryRenderCount = 0;
  const THOUGHTS_RENDER_WINDOW = 15;


  let qzonePostsRenderCount = 0;
  const QZONE_RENDER_WINDOW = 10;

  let qzonePostsCache = [];

  let musicState = {
    isActive: false,
    activeChatId: null,
    isPlaying: false,
    playlist: [],
    currentIndex: -1,
    playMode: 'order',
    totalElapsedTime: 0,
    timerId: null,

    parsedLyrics: [],
    currentLyricIndex: -1
  };
  let qzoneStickerPanelState = {
    isOpen: false,
    activePostId: null,
    panelEl: null,
    gridEl: null
  };
  const audioPlayer = document.getElementById('audio-player');
 // 变量声明区域
let isQuickReplyManagementMode = false;
let selectedQuickReplies = new Set();
  let newWallpaperBase64 = null;
  let isRuleManagementMode = false;
  let selectedRules = new Set();
  let isSelectionMode = false;
  let cphoneRenderedCount = 0;
  let cphoneActiveConversationType = null;
  let isLoadingMoreCphoneMessages = false;
  let activeStickerCategoryId = 'all';
  let selectedMessages = new Set();
  let editingMemberId = null;
  let isAddingNpcToGroup = false;
  let editingWorldBookId = null;
  let editingRuleId = null;
  let isLoadingMoreChats = false;
  let isLoadingMoreMessages = false;
  let isLoadingMoreThoughts = false;
  let isLoadingMorePosts = false;
  let sortedChatListItems = [];
  let editingPersonaPresetId = null;
  let isManageMode = false;
  let selectedPresetIds = new Set();
  let pendingTavernPersonas = [];
  let currentReplyContext = null;
  let waimaiTimers = {};
  let currentSpectatorMode = 'group';
  let activeMessageTimestamp = null;
  let activeCharacterId = null;
  let editingMemoId = null;
  let editingDiaryId = null;
  let activeDiaryForViewing = null;
  let activeArticleForViewing = null;
  let activeMemoForViewing = null;
  let currentNaiPresetId = null;
  let shoppingCart = [];
  let editingProductId = null;
  let activeProductId = null;
  let selectedProducts = new Set();
  let activeQuickReplyCategoryId = 'all';

  let currentQzoneReplyContext = null;

  let activePostId = null;
  let activeDoubanPostId = null;
  let photoViewerState = {
    isOpen: false,
    photos: [],
    currentIndex: -1,
  };

  let unreadPostsCount = 0;

  let isFavoritesSelectionMode = false;
  let selectedFavorites = new Set()

  let simulationIntervalId = null;
  let currentTodoDate = new Date(); // 当前查看的日期
  let editingTodoId = null;
  const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
  const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
  const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
  const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
  let notificationTimeout;
  let ruleCache = {};

  const DEFAULT_NOTIFICATION_SOUND = 'https://www.myinstants.com/media/sounds/notification-sound-2.mp3';

  let gomokuState = {};
  let readingState = {};
  let originalChatMessagesPaddingTop = null;



  const DEFAULT_APP_ICONS = {
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'renderer': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756312261242_qdqqd_g0eriz.jpeg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',

    'char-phone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg',
    'douban': 'https://i.postimg.cc/Pq2xJN1g/IMG-7301.jpg',

    'preset': 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',

    'tutorial': 'https://i.postimg.cc/d10GjC4g/IMG-7302.jpg',
    'werewolf': 'https://i.postimg.cc/k401K5g7/IMG-7304.jpg',
     
    'x': 'https://i.postimg.cc/Y9d3BztC/1.png',
    'alipay': 'https://i.postimg.cc/Hs7BLh76/alipay.png',
    'auction': 'https://i.postimg.cc/Hs7BLh76/alipay.png',
     'green-river': 'https://i.postimg.cc/0j55Pj1L/green-river-icon.png',
    'mail': 'https://i.postimg.cc/PfR7f37x/mail.png'
  };


  const DEFAULT_CPHONE_ICONS = {
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'album': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'browser': 'https://i.postimg.cc/KzC2gTq6/IMG-7276.jpg',
    'taobao': 'https://i.postimg.cc/L6R7x16R/IMG-7278.jpg',
    'memo': 'https://i.postimg.cc/J0b6Nym4/IMG-7279.jpg',
    'diary': 'https://i.postimg.cc/DZ541sbt/IMG-7280.jpg',
    'amap': 'https://i.postimg.cc/Jz2Tz0dw/IMG-7281.jpg',
    'usage': 'https://i.postimg.cc/WbF8kzz9/IMG-7282.jpg',
    'music': 'https://is1-ssl.mzstatic.com/image/thumb/Purple112/v4/64/9d/21/649d21e8-a151-6136-3914-256e54f15d9a/AppIcon-0-0-1x_U007emarketing-0-0-0-7-0-0-sRGB-0-0-0-GLES2_U002c0-512MB-85-220-0-0.png/1200x630wa.png',
    'bilibili': 'https://i.postimg.cc/Wz5gV0jB/bilibili-icon.png',
     'reddit': 'https://www.redditinc.com/assets/images/site/reddit-logo.png',
    'ephone': 'https://i.postimg.cc/pXj9h20L/IMG-7275.jpg'
  };

  let repostTargetId = null;
  const STICKER_REGEX = /(^https:\/\/i\.postimg\.cc\/.+|^https:\/\/files\.catbox\.moe\/.+|^https?:\/\/sharkpan\.xyz\/.+|^data:image|\.(png|jpg|jpeg|gif|webp)\?.*$|\.(png|jpg|jpeg|gif|webp)$)/i;

  let currentRenderedCount = 0;
  let lastKnownBatteryLevel = 1;
  let alertFlags = {
    hasShown40: false,
    hasShown20: false,
    hasShown10: false
  };
  let batteryAlertTimeout;
  const dynamicFontStyle = document.createElement('style');
  dynamicFontStyle.id = 'dynamic-font-style';
  document.head.appendChild(dynamicFontStyle);

  const modalOverlay = document.getElementById('custom-modal-overlay');
  const modalTitle = document.getElementById('custom-modal-title');
  const modalBody = document.getElementById('custom-modal-body');
  const modalConfirmBtn = document.getElementById('custom-modal-confirm');
  const modalCancelBtn = document.getElementById('custom-modal-cancel');
  let modalResolve;

  function showCustomModal() {
    modalOverlay.classList.add('visible');
  }

  function hideCustomModal() {
    modalOverlay.classList.remove('visible');
    modalConfirmBtn.classList.remove('btn-danger');
    if (modalResolve) modalResolve(null);
  }

  function applyLyricsBarPosition(chat) {
    const lyricsBar = document.getElementById('global-lyrics-bar');

    const settings = chat.settings.lyricsPosition || {
      vertical: 'top',
      horizontal: 'center',
      offset: 10
    };


    lyricsBar.style.top = 'auto';
    lyricsBar.style.bottom = 'auto';
    lyricsBar.style.left = 'auto';
    lyricsBar.style.right = 'auto';
    lyricsBar.style.transform = 'none';


    if (settings.vertical === 'top') {
      lyricsBar.style.top = `${settings.offset}px`;
    } else {
      lyricsBar.style.bottom = `${settings.offset}px`;
    }


    switch (settings.horizontal) {
      case 'left':
        lyricsBar.style.left = '15px';
        break;
      case 'right':
        lyricsBar.style.right = '15px';
        break;
      case 'center':
      default:
        lyricsBar.style.left = '50%';
        lyricsBar.style.transform = 'translateX(-50%)';
        break;
    }
  }




  async function handleLocalGroupAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    let base64Url = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });

    // [已删除] AI命名提示
    // await showCustomAlert("请稍候...", "正在请求AI为新群头像命名...");

    try {
      // [修改] 将AI命名改为手动输入
      // const description = await getAvatarDescriptionFromApi(base64Url);
      const description = await showCustomPrompt("命名群头像", "请为这个新群头像命名");

      // [修改] 检查是否输入了名称
      // if (!description) {
      //   throw new Error("AI未能成功描述图片。");
      // }
      if (!description || !description.trim()) {
        await showCustomAlert("操作取消", "你没有输入名称，已取消上传。");
        event.target.value = null; // 清空 input
        return;
      }

      const chat = state.chats[state.activeChatId];
      if (!chat.settings.groupAvatarLibrary) {
        chat.settings.groupAvatarLibrary = [];
      }
      
      const newItem = {
        name: description, // 使用用户输入的名称
        url: base64Url
      };
      chat.settings.groupAvatarLibrary.push(newItem);
      await db.chats.put(chat);
      
      renderGroupAvatarLibrary();
      
      // [修改] 更改成功提示
      // await showCustomAlert("上传成功！", `AI已将新群头像命名为：“${description}”\n\n图片将在后台静默上传到图床...`);
      await showCustomAlert("上传成功！", `群头像已命名为：“${description}”\n\n图片将在后台静默上传到图床...`);

      // 【【【已修复的调用】】】
      (async () => {
        await silentlyUpdateDbUrl(
            db.chats, // table
            chat.id,  // recordId
            'settings.groupAvatarLibrary', // pathString (指向数组)
            base64Url, // base64ToFind
            description // [修改] 使用用户输入的名称
        );
      })();

    } catch (error) {
      // [修改] 更改失败提示
      console.error("本地群头像上传及识别失败:", error);
      // await showCustomAlert("操作失败", `无法为头像命名，请检查（主/副）API配置是否正确并支持Vision。\n错误: ${error.message}`);
      await showCustomAlert("操作失败", `上传时发生错误。\n错误: ${error.message}`);
    } finally {
      event.target.value = null;
    }
  }



  async function handleLocalAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    let base64Url = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });

    // [已删除] AI命名提示
    // await showCustomAlert("请稍候...", "正在请求AI为新头像命名...");

    try {
      // [修改] 将AI命名改为手动输入
      // const description = await getAvatarDescriptionFromApi(base64Url);
      const description = await showCustomPrompt("命名头像", "请为这个新头像命名");
      
      // [修改] 检查是否输入了名称
      // if (!description) {
      //   throw new Error("AI未能成功描述图片。");
      // }
      if (!description || !description.trim()) {
        await showCustomAlert("操作取消", "你没有输入名称，已取消上传。");
        event.target.value = null; // 清空 input
        return;
      }
      
      const chat = state.chats[state.activeChatId];
      if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
      }
      
      const newItem = {
        name: description, // 使用用户输入的名称
        url: base64Url
      };
      chat.settings.aiAvatarLibrary.push(newItem);
      await db.chats.put(chat);
      
      renderAiAvatarLibrary();
      
      // [修改] 更改成功提示
      // await showCustomAlert("上传成功！", `AI已将新头像命名为：“${description}”\n\n图片将在后台静默上传到图床...`);
      await showCustomAlert("上传成功！", `头像已命名为：“${description}”\n\n图片将在后台静默上传到图床...`);
      
      // 【【【已修复的调用】】】
      (async () => {
          await silentlyUpdateDbUrl(
              db.chats, // table
              chat.id,  // recordId
              'settings.aiAvatarLibrary', // pathString (指向数组)
              base64Url, // base64ToFind
              description // [修改] 使用用户输入的名称
          );
      })();

    } catch (error) {
      // [修改] 更改失败提示
      console.error("本地头像上传及识别失败:", error);
      // await showCustomAlert("操作失败", `无法为头像命名，请检查（主/副）API配置是否正确并支持Vision。\n错误: ${error.message}`);
      await showCustomAlert("操作失败", `上传时发生错误。\n错误: ${error.message}`);
    } finally {
      event.target.value = null;
    }
  }


  async function getAvatarDescriptionFromApi(base64Url) {

    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
    const {
      proxyUrl,
      apiKey,
      model
    } = useSecondaryApi
      ?
      {
        proxyUrl: state.apiConfig.secondaryProxyUrl,
        apiKey: state.apiConfig.secondaryApiKey,
        model: state.apiConfig.secondaryModel
      } :
      state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
      throw new Error("主API和副API均未配置或配置不完整。");
    }

    const prompt = "请为这张图片起一个简洁的、适合作为头像库标签的名字。例如：“微笑自拍”、“阳光下的猫咪”、“蓝发动漫少女”。请直接回答名字，不要加任何多余的解释。";

    let isGemini = proxyUrl.includes('generativelanguage');
    let response;

    if (isGemini) {
      const mimeType = base64Url.match(/^data:(.*);base64/)[1];
      const base64Data = base64Url.split(',')[1];
      const payload = {
        contents: [{
          parts: [{
              text: prompt
            },
            {
              inline_data: {
                mime_type: mimeType,
                data: base64Data
              }
            }
          ]
        }]
      };
      response = await fetch(`${proxyUrl}/${model}:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

    } else {
      const payload = {
        model: model,
        messages: [{
          role: 'user',
          content: [{
              type: 'text',
              text: prompt
            },
            {
              type: 'image_url',
              image_url: {
                url: base64Url
              }
            }
          ]
        }],
        max_tokens: 50
      };
      response = await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify(payload)
      });
    }

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`API 错误: ${errorData.error.message}`);
    }

    const data = await response.json();
    let description = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;


    return description.trim().replace(/["'“”‘’]/g, '');
  }


  async function syncCharacterNameInGroups(characterChat) {

    if (!characterChat || characterChat.isGroup) {
      console.warn("syncCharacterNameInGroups: 传入的不是有效的单聊对象，已跳过同步。");
      return;
    }

    const characterId = characterChat.id;
    const newRemarkName = characterChat.name;
    const newOriginalName = characterChat.originalName;

    console.log(`正在为角色 ${characterId} 同步所有群聊内的名称信息...`);


    for (const chatId in state.chats) {
      const groupChat = state.chats[chatId];


      if (groupChat.isGroup && groupChat.members) {

        const memberToUpdate = groupChat.members.find(m => m.id === characterId);


        if (memberToUpdate) {
          let needsDbUpdate = false;


          if (memberToUpdate.groupNickname !== newRemarkName) {
            memberToUpdate.groupNickname = newRemarkName;
            needsDbUpdate = true;
          }


          if (memberToUpdate.originalName !== newOriginalName) {
            memberToUpdate.originalName = newOriginalName;
            needsDbUpdate = true;
          }


          if (needsDbUpdate) {
            await db.chats.put(groupChat);
            console.log(`成功将群聊 "${groupChat.name}" 中的成员信息更新`);
          }
        }
      }
    }
  }





 
  async function syncCharacterAvatarInGroups(characterChat) {

    if (!characterChat || characterChat.isGroup) {
      console.warn("syncCharacterAvatarInGroups: 传入的不是有效的单聊对象，已跳过同步。");
      return;
    }

    const characterId = characterChat.id;
    const newAvatar = characterChat.settings.aiAvatar;

    console.log(`正在为角色 ${characterId} 同步所有群聊内的头像...`);


    for (const groupChat of Object.values(state.chats)) {
      if (groupChat.isGroup && groupChat.members) {

        const memberToUpdate = groupChat.members.find(m => m.id === characterId);


        if (memberToUpdate && memberToUpdate.avatar !== newAvatar) {
          memberToUpdate.avatar = newAvatar;


          await db.chats.put(groupChat);
          console.log(`成功将角色 ${characterId} 的新头像同步到群聊 "${groupChat.name}"`);
        }
      }
    }
  }



  function getDisplayNameInGroup(groupChat, originalName) {

    if (!groupChat || !groupChat.isGroup || !originalName) {
      return originalName;
    }





    const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
    if (originalName === userOriginalName) {

      return groupChat.settings.myNickname || '我';
    }


    const member = groupChat.members.find(m => m.originalName === originalName);


    return member ? member.groupNickname : originalName;
  }




  function switchRuleCategory(categoryId) {

    document.querySelectorAll('.rules-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });

    document.querySelectorAll('.rules-category-pane').forEach(pane => {
      pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
  }


 



  function getDisplayNameByOriginalName(nameIdentifier) {

    if (!nameIdentifier) return '';


    if (state.qzoneSettings && nameIdentifier === state.qzoneSettings.nickname) {
      return state.qzoneSettings.nickname;
    }



    let characterChat = Object.values(state.chats).find(chat => !chat.isGroup && chat.originalName === nameIdentifier);
    if (characterChat) {
      return characterChat.name;
    }


    characterChat = Object.values(state.chats).find(chat =>
      !chat.isGroup &&
      (chat.nameHistory && chat.nameHistory.includes(nameIdentifier))
    );
    if (characterChat) {
      return characterChat.name;
    }



    return nameIdentifier;
  }




 
  function processMentions(text, chat = null) {

    if (!text || typeof text !== 'string' || !text.includes('@[[')) {
      return text;
    }


    return text.replace(/@\[\[([^\]]+)\]\]/g, (match, originalName) => {
      const trimmedOriginalName = originalName.trim();
      let displayName;


      if (chat && chat.isGroup) {


        displayName = getDisplayNameInGroup(chat, trimmedOriginalName);
      } else {

        displayName = getDisplayNameByOriginalName(trimmedOriginalName);
      }


      return `@${displayName}`;
    });
  }




  function showCustomConfirm(title, message, options = {}) {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        modalBody.innerHTML = `<p>${message}</p>`;

        // --- 【修复开始】：强制重置 Footer 结构 ---
        // 因为 showChoiceModal可能会破坏Footer结构导致ID丢失，这里必须重建
        const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
        if (modalFooter) {
            modalFooter.style.flexDirection = 'row'; // 恢复横向布局
            modalFooter.style.justifyContent = 'flex-end'; // 按钮靠右
            modalFooter.innerHTML = `
              <button id="custom-modal-cancel">取消</button>
              <button id="custom-modal-confirm" class="confirm-btn">确定</button>
          `;
        }
        // --- 【修复结束】 ---

        const confirmBtn = document.getElementById('custom-modal-confirm');
        const cancelBtn = document.getElementById('custom-modal-cancel');

        // 此时 cancelBtn 必定存在
        cancelBtn.style.display = 'block';

        confirmBtn.textContent = options.confirmText || '确定';
        cancelBtn.textContent = options.cancelText || '取消';

        if (options.confirmButtonClass) {
            confirmBtn.className = `confirm-btn ${options.confirmButtonClass}`; // 重置class并添加自定义class
        } else {
            confirmBtn.className = 'confirm-btn'; // 恢复默认
        }

        confirmBtn.onclick = () => {
            resolve(true);
            hideCustomModal();
        };
        cancelBtn.onclick = () => {
            resolve(false);
            hideCustomModal();
        };
        showCustomModal();
    });
}

 
  function showDownloadToast(message = '📥 图片下载中...', type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4CAF50' : '#f44336'};
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.3s ease;
    `;

    document.body.appendChild(toast);

    setTimeout(() => {
      toast.style.opacity = '1';
      toast.style.transform = 'translateY(0)';
    }, 10);

    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateY(-20px)';
      setTimeout(() => {
        toast.remove();
      }, 300);
    }, 2000);
  }

  function generateFilenameForNai(prompt) {
    let cleanTitle = (prompt || 'NAI_Image')
      .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_')
      .replace(/\s+/g, '_')
      .substring(0, 30);

    const timestamp = new Date().toISOString()
      .replace(/[-:]/g, '')
      .replace('T', '_')
      .split('.')[0];

    return `${cleanTitle}_${timestamp}.png`;
  }


  function downloadNaiImage(imageSrc, prompt) {
    try {
      const filename = generateFilenameForNai(prompt);
      const link = document.createElement('a');
      link.href = imageSrc;
      link.download = filename;
      link.style.display = 'none';

      document.body.appendChild(link);
      link.click();

      setTimeout(() => {
        document.body.removeChild(link);
      }, 100);

      showDownloadToast('📥 图片下载中...');
    } catch (error) {
      console.error('❌ [NAI下载] 下载失败:', error);
      showDownloadToast('下载失败，请重试', 'error');
    }
  }
// --- 新增：高端非侵入式通知 ---
function showToast(message, type = 'info', duration = 3000) {
    let container = document.querySelector('.toast-container');
    if (!container) {
        container = document.createElement('div');
        container.className = 'toast-container';
        document.body.appendChild(container);
    }

    // 定义图标 (SVG)
    const icons = {
        success: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`,
        loading: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"></path></svg>`,
        error: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>`,
        info: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`
    };

    const iconSvg = icons[type] || icons.info;
    const spinClass = type === 'loading' ? 'spinning' : '';
    
    // 智能截断过长的消息
    const displayMsg = message.length > 25 ? message.substring(0, 24) + '...' : message;

    const toast = document.createElement('div');
    toast.className = 'toast-item';
    toast.innerHTML = `
        <div class="toast-icon ${spinClass}">${iconSvg}</div>
        <span>${displayMsg}</span>
    `;

    container.appendChild(toast);

    // 动画入场
    requestAnimationFrame(() => {
        toast.classList.add('visible');
    });

    // 自动消失 (如果是 loading 类型，则不自动消失，需要外部移除逻辑，或者简单点设个长时限)
    if (type !== 'loading') {
        setTimeout(() => {
            toast.classList.remove('visible');
            setTimeout(() => toast.remove(), 400); // 等待过渡结束
        }, duration);
    }
    
    return toast; // 返回元素以便手动移除
}
  function showCustomAlert(title, message) {
    return new Promise(resolve => {
      modalResolve = resolve;
      modalTitle.textContent = title;
      modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;

      // --- 【核心修复开始】 ---
      // 获取 Footer 容器
      const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
      
      // 强制重置 Footer 结构，防止被 showChoiceModal 修改后导致 ID 丢失
      if (modalFooter) {
          modalFooter.style.flexDirection = 'row'; // 恢复默认横向布局
          modalFooter.innerHTML = `
              <button id="custom-modal-cancel">取消</button>
              <button id="custom-modal-confirm" class="confirm-btn">确定</button>
          `;
      }
      // --- 【核心修复结束】 ---

      const confirmBtn = document.getElementById('custom-modal-confirm');
      const cancelBtn = document.getElementById('custom-modal-cancel');

      // 此时 confirmBtn 和 cancelBtn 必定存在
      if (cancelBtn) cancelBtn.style.display = 'none';
      if (confirmBtn) confirmBtn.textContent = '好的';

      if (confirmBtn) {
          confirmBtn.onclick = () => {
            if (cancelBtn) cancelBtn.style.display = 'block'; // 恢复显示，以免影响其他功能
            confirmBtn.textContent = '确定';
            resolve(true);
            hideCustomModal();
          };
      }
      
      if (cancelBtn) {
          cancelBtn.onclick = hideCustomModal;
      }

      showCustomModal();
    });
  }


  async function copyTextToClipboard(textToCopy, successMessage = '内容已复制到剪贴板！') {
    if (!textToCopy) {
      await showCustomAlert('复制失败', '没有可复制的内容。');
      return;
    }
    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('复制成功', successMessage);
    } catch (err) {
      console.error('复制失败:', err);
      await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
  }

  // 查找 function showCustomPrompt 并完全替换为以下内容：

function showCustomPrompt(title, message, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
      modalResolve = resolve;
      modalTitle.textContent = title;
      const inputId = 'custom-prompt-input';

      // 添加消息显示区域
      const messageHtml = message ? `<div style="margin-bottom: 15px; color: #333; line-height: 1.6;">${message}</div>` : '';

      const inputHtml = type === 'textarea' ?
        `<textarea id="${inputId}" placeholder="" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 16px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>` :
        `<input type="${type}" id="${inputId}" placeholder="" value="${initialValue}">`;

      modalBody.innerHTML = messageHtml + extraHtml + inputHtml;
      const input = document.getElementById(inputId);

      // 绑定额外的格式化按钮事件（如果有）
      modalBody.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const templateStr = btn.dataset.template;
          if (templateStr) {
            try {
              const templateObj = JSON.parse(templateStr);
              input.value = JSON.stringify(templateObj, null, 2);
              input.focus();
            } catch (e) {
              console.error("解析格式模板失败:", e);
            }
          }
        });
      });

      // --- 【核心修复开始】：强制重建 Footer 结构 ---
      // 防止因为之前调用过 showChoiceModal 导致按钮丢失
      const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
      if (modalFooter) {
          modalFooter.style.flexDirection = 'row'; 
          modalFooter.style.justifyContent = 'flex-end'; 
          modalFooter.style.maxHeight = ''; 
          modalFooter.style.overflowY = '';
          
          // 暴力重置：把按钮塞回去
          modalFooter.innerHTML = `
            <button id="custom-modal-cancel">取消</button>
            <button id="custom-modal-confirm" class="confirm-btn">确定</button>
          `;
      }
      // --- 【核心修复结束】 ---

      const confirmBtn = document.getElementById('custom-modal-confirm');
      const cancelBtn = document.getElementById('custom-modal-cancel');

      // 确保按钮存在后再操作
      if (confirmBtn) {
          confirmBtn.textContent = '确定'; // 重置可能被修改的文字
          confirmBtn.className = 'confirm-btn'; // 重置可能被修改的样式
          confirmBtn.style.display = 'block';
          
          confirmBtn.onclick = () => {
            resolve(input.value);
            hideCustomModal();
          };
      }

      if (cancelBtn) {
          cancelBtn.textContent = '取消';
          cancelBtn.style.display = 'block';
          
          cancelBtn.onclick = () => {
            resolve(null);
            hideCustomModal();
          };
      }

      showCustomModal();
      
      // 加个安全判断防止 input 为空
      setTimeout(() => {
          if(input) input.focus();
      }, 100);
    });
}




 
  // 增强版 showChoiceModal：优化滑动体验
function showChoiceModal(title, options) {
    return new Promise(resolve => {
      const modal = document.getElementById('custom-modal-overlay');
      const modalTitle = document.getElementById('custom-modal-title');
      const modalBody = document.getElementById('custom-modal-body');
      const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

      modalTitle.textContent = title;
      modalBody.innerHTML = ''; // 清空主体，选项主要在 Footer

      // 清空 Footer 并设置为列布局
      modalFooter.innerHTML = '';
      modalFooter.style.flexDirection = 'column';
      
      // --- 【核心优化：滑动设置】 ---
      modalFooter.style.maxHeight = '50vh'; // 限制高度，留出空间
      modalFooter.style.overflowY = 'auto'; // 允许垂直滚动
      modalFooter.style.webkitOverflowScrolling = 'touch'; // iOS 流畅滚动
      modalFooter.style.overscrollBehavior = 'contain'; // 防止滚动穿透到底层
      modalFooter.style.padding = '10px'; // 增加内边距
      modalFooter.style.gap = '8px'; // 按钮间距
      // ---------------------------

      // --- 分页逻辑开始 ---
      let renderedCount = 0;
      const PAGE_SIZE = 10; // 每次加载10个
      
      // 创建“加载更多”按钮
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.textContent = '加载更多...';
      loadMoreBtn.style.cssText = 'background-color: #f0f0f0; color: #666; margin-top: 8px; width: 100%; border-radius: 8px; padding: 10px; border: none;';
      loadMoreBtn.style.display = 'none'; // 初始隐藏

      // 渲染函数
      const renderBatch = () => {
        const nextBatch = options.slice(renderedCount, renderedCount + PAGE_SIZE);
        
        nextBatch.forEach(option => {
          const button = document.createElement('button');
          
          // 允许渲染 HTML 内容
          button.innerHTML = option.text; 
          
          // 添加美化类名和样式
          button.className = 'payment-option-item'; 
          button.style.width = '100%';
          button.style.textAlign = 'left';
          button.style.padding = '12px 15px';
          button.style.marginBottom = '0'; // 由父容器 gap 控制
          
          button.onclick = () => {
            modal.classList.remove('visible');
            resolve(option.value);
          };
          // 插入到“加载更多”按钮之前
          modalFooter.insertBefore(button, loadMoreBtn);
        });

        renderedCount += nextBatch.length;

        // 如果还有剩余选项，显示加载更多按钮，否则隐藏
        if (renderedCount < options.length) {
            loadMoreBtn.style.display = 'block';
            loadMoreBtn.textContent = `加载更多 (${options.length - renderedCount} 个剩余)`;
        } else {
            loadMoreBtn.style.display = 'none';
        }
      };

      // 绑定加载更多事件
      loadMoreBtn.onclick = (e) => {
          e.stopPropagation(); 
          renderBatch();
      };

      // 先把加载更多按钮放进去
      modalFooter.appendChild(loadMoreBtn);

      // 初始渲染第一页
      renderBatch();
      // --- 分页逻辑结束 ---

      const cancelButton = document.createElement('button');
      cancelButton.textContent = '取消';
      cancelButton.style.marginTop = '15px'; 
      cancelButton.style.borderRadius = '8px';
      cancelButton.style.backgroundColor = '#fff';
      cancelButton.style.border = '1px solid #ddd';
      cancelButton.style.color = '#666';
      cancelButton.style.padding = '12px';
      cancelButton.style.width = '100%';
      
      cancelButton.onclick = () => {
        modal.classList.remove('visible');
        resolve(null);
      };
      modalFooter.appendChild(cancelButton);

      modal.classList.add('visible');

    }).finally(() => {
      // Promise 结束后的清理工作（如果有）
    });
}



  
  async function getLrcContent() {

    const choice = await showChoiceModal('选择歌词导入方式', [{
        text: '📁 从本地文件 (.lrc)',
        value: 'file'
      },
      {
        text: '📋 直接粘贴歌词文本',
        value: 'paste'
      }
    ]);


    if (choice === 'file') {

      return new Promise(resolve => {
        const lrcInput = document.getElementById('lrc-upload-input');
        const lrcChangeHandler = (e) => {
          const lrcFile = e.target.files[0];
          if (lrcFile) {
            const reader = new FileReader();
            reader.onload = (readEvent) => resolve(readEvent.target.result);
            reader.onerror = () => resolve("");
            reader.readAsText(lrcFile);
          } else {
            resolve(null);
          }
          lrcInput.removeEventListener('change', lrcChangeHandler);
          lrcInput.value = '';
        };
        lrcInput.addEventListener('change', lrcChangeHandler, {
          once: true
        });
        lrcInput.click();
      });
    } else if (choice === 'paste') {

      const pastedText = await showCustomPrompt(
        '粘贴歌词',
        '请在此处粘贴完整的LRC格式歌词...',
        '',
        'textarea'
      );


      if (pastedText) {


        const formattedText = pastedText.replace(/\[/g, '\n[').trim();
        return formattedText;
      }
      return pastedText;


    } else {

      return null;
    }
  }






  db.version(50).stores({
    doubanPosts: '++id, timestamp',
    chats: '&id, isGroup, groupId, isPinned, memos, diary, appUsageLog, lastIntelligentSummaryTimestamp',
    apiConfig: '&id, minimaxGroupId, minimaxApiKey',
    globalSettings: '&id',
    userStickers: '&id, url, name, categoryId',
    stickerVisionCache: '&url, description, timestamp',
    worldBooks: '&id, name, categoryId',
    worldBookCategories: '++id, name',
    musicLibrary: '&id',
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp, authorId',
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate',
    callRecords: '++id, chatId, timestamp, customName',
    shoppingProducts: '++id, name, description',
    shoppingCategories: '++id, name',
    apiPresets: '++id, name',
    renderingRules: '++id, name, chatId',
    appearancePresets: '++id, name, type',
    stickerCategories: '++id, name',
    customAvatarFrames: '++id, name',
    presets: '&id, name, categoryId',
    presetCategories: '++id, name',
    readingLibrary: '++id, title, lastOpened, linkedStoryId',
    quickReplies: '++id, text, categoryId', // 修改：增加 categoryId 索引
    quickReplyCategories: '++id, name',
    npcs: '++id, name, npcGroupId, enableBackgroundActivity, actionCooldownMinutes, lastActionTimestamp',
    npcGroups: '++id, name',
    naiPresets: '++id, name',
    grAuthors: '++id, name',
    grStories: '++id, title, authorId, lastUpdated',
    userWallet: '&id',
    userTransactions: '++id, timestamp, type, amount, description',
    funds: '&id, code, name, riskLevel, currentNav, lastDayNav, history',
    auctions: '++id, status, itemName, endTime', // 拍卖记录
    inventory: '++id, name, type, acquiredTime',
    emails: '++id, sender, senderType, recipient, subject, content, timestamp, isRead'
  }).upgrade(tx => {

    return tx.table('worldBooks').toCollection().modify(book => {

      if (typeof book.content === 'string' && book.content.trim() !== '') {
        book.content = [{
          keys: [],
          comment: '从旧版本迁移的条目',
          content: book.content
        }];
      } else if (!Array.isArray(book.content)) {
        book.content = [];
      }


      book.content.forEach(entry => {
        if (typeof entry.enabled === 'undefined') {
          entry.enabled = true;
        }
      });
    });
  });

  window.db = db;




  function showScreen(screenId) {
    if (screenId === 'chat-list-screen') {
      window.renderChatListProxy();
      switchToChatListView('messages-view');
    }
    if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
    if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
    if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
    if (screenId === 'x-social-screen') window.renderXSocialScreenProxy();
    if (screenId === 'douban-screen') renderDoubanScreen();
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screenToShow = document.getElementById(screenId);
    if (screenToShow) screenToShow.classList.add('active');
    if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
    if (screenId === 'font-settings-screen') {
      loadFontPresetsDropdown();
      document.getElementById('font-url-input').value = state.globalSettings.fontUrl || '';
      applyCustomFont(state.globalSettings.fontUrl || '', true);
    }
  }
  window.updateListenTogetherIconProxy = () => {};

  function switchToChatListView(viewId) {
    const chatListScreen = document.getElementById('chat-list-screen');
    const views = {
      'messages-view': document.getElementById('messages-view'),
      'qzone-screen': document.getElementById('qzone-screen'),
      'favorites-view': document.getElementById('favorites-view'),
      'memories-view': document.getElementById('memories-view'),
      'npc-list-view': document.getElementById('npc-list-view')
    };
    const mainHeader = document.getElementById('main-chat-list-header');
    const mainBottomNav = document.getElementById('chat-list-bottom-nav');

    if (isFavoritesSelectionMode) {
      document.getElementById('favorites-edit-btn').click();
    }


    Object.values(views).forEach(v => v.classList.remove('active'));

    if (views[viewId]) {
      views[viewId].classList.add('active');
    }


    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
      item.classList.toggle('active', item.dataset.view === viewId);
    });


    if (viewId === 'messages-view') {
      mainHeader.style.display = 'flex';
      mainBottomNav.style.display = 'flex';
    } else {
      mainHeader.style.display = 'none';
      mainBottomNav.style.display = 'none';
    }


    if (viewId !== 'memories-view') {
      activeCountdownTimers.forEach(timerId => clearInterval(timerId));
      activeCountdownTimers = [];
    }


    switch (viewId) {
      case 'qzone-screen':
        views['qzone-screen'].style.backgroundColor = '#f0f2f5';
        updateUnreadIndicator(0);
        renderQzoneScreen();
        renderQzonePosts();
        break;
      case 'favorites-view':
        views['favorites-view'].style.backgroundColor = '#f9f9f9';
        renderFavoritesScreen();
        break;
      case 'messages-view':

        break;
      case 'npc-list-view':
        renderNpcListScreen();
        break;
    }
  }

  function renderXSocialScreen() {

    console.log("渲染X社交页面");
  }
  window.renderXSocialScreenProxy = renderXSocialScreen;

  function renderQzoneScreen() {
    if (state && state.qzoneSettings) {
      const settings = state.qzoneSettings;
      document.getElementById('qzone-nickname').textContent = settings.nickname;
      document.getElementById('qzone-avatar-img').src = settings.avatar;
      document.getElementById('qzone-banner-img').src = settings.banner;
    }
  }
  window.renderQzoneScreenProxy = renderQzoneScreen;

  async function saveQzoneSettings() {
    if (db && state.qzoneSettings) {
      await db.qzoneSettings.put(state.qzoneSettings);
    }
  }

  function formatPostTimestamp(timestamp) {
    if (!timestamp) return '';
    const now = new Date();
    const date = new Date(timestamp);
    const diffSeconds = Math.floor((now - date) / 1000);
    const diffMinutes = Math.floor(diffSeconds / 60);
    const diffHours = Math.floor(diffMinutes / 60);
    if (diffMinutes < 1) return '刚刚';
    if (diffMinutes < 60) return `${diffMinutes}分钟前`;
    if (diffHours < 24) return `${diffHours}小时前`;
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    if (now.getFullYear() === year) {
      return `${month}-${day} ${hours}:${minutes}`;
    } else {
      return `${year}-${month}-${day} ${hours}:${minutes}`;
    }
  }



  
  


  



  






  async function createOrUpdatePostElement(post) {
    const existingPostContainer = document.querySelector(`.qzone-post-container[data-post-id="${post.id}"]`);
    const isUpdating = !!existingPostContainer;

    const postContainer = isUpdating ? existingPostContainer : document.createElement('div');
    if (!isUpdating) {
      postContainer.className = 'qzone-post-container';
      postContainer.dataset.postId = post.id;
    }

    const postEl = isUpdating ? postContainer.querySelector('.qzone-post-item') : document.createElement('div');
    if (!isUpdating) {
      postEl.className = 'qzone-post-item';
    }

    let authorAvatar = '',
      authorNickname = '',
      commentAvatar = state.qzoneSettings.avatar;


    if (post.authorId === 'user') {
      authorAvatar = state.qzoneSettings.avatar;
      authorNickname = state.qzoneSettings.nickname;
    } else if (state.chats[post.authorId]) {
      const authorChat = state.chats[post.authorId];
      authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
      authorNickname = authorChat.name;
    } else if (String(post.authorId).startsWith('npc_')) {

      const npcId = parseInt(String(post.authorId).replace('npc_', ''));
      if (!isNaN(npcId)) {
        const npc = await db.npcs.get(npcId);
        if (npc) {
          authorAvatar = npc.avatar || defaultGroupMemberAvatar;
          authorNickname = npc.name;
        } else {
          authorNickname = post.authorOriginalName || '未知NPC';
          authorAvatar = defaultGroupMemberAvatar;
        }
      }
    } else {

      authorNickname = getDisplayNameByOriginalName(post.authorOriginalName);
      authorAvatar = defaultAvatar;
    }


    function renderOriginalPostContent(targetPost) {
      let innerContentHtml = '';
      const publicTextHtml = targetPost.publicText ? `<div class="post-content">${parseMarkdown(targetPost.publicText).replace(/\n/g, '<br>')}</div>` : '';

      if (targetPost.type === 'shuoshuo') {
        innerContentHtml = `<div class="post-content" style="margin-bottom: 10px;">${parseMarkdown(targetPost.content).replace(/\n/g, '<br>')}</div>`;
      } else if (targetPost.type === 'image_post' && targetPost.imageUrl) {

        innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${targetPost.imageUrl}" class="chat-image"></div>` : `<img src="${targetPost.imageUrl}" class="chat-image">`;
      } else if (targetPost.type === 'text_image') {

        const postImageUrl = state.globalSettings.enableAiDrawing && targetPost.image_prompt ? `https://image.pollinations.ai/prompt/${targetPost.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
        innerContentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${targetPost.hiddenContent}">`;
      } else if (targetPost.type === 'naiimag') {
       
        const imageUrls = targetPost.imageUrls || (targetPost.imageUrl ? [targetPost.imageUrl] : []);

        if (imageUrls.length > 0) {
          const imageCount = imageUrls.length;
          let imagesHtml = '';

          // 使用统一的多图布局（包括单张图片）
          imagesHtml = `<div class="post-images-grid grid-${imageCount}">`;
          imageUrls.forEach((url, index) => {
            imagesHtml += `<img src="${url}" class="naiimag-image" alt="图片${index + 1}" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';">`;
          });
          imagesHtml += '</div>';

          innerContentHtml = publicTextHtml ? `${publicTextHtml}${imagesHtml}` : imagesHtml;
        }
      }
      return innerContentHtml;
    }

    let mainContentHtml;

    if (post.type === 'repost') {
      const repostCommentHtml = post.repostComment ? `<div class="post-content">${post.repostComment.replace(/\n/g, '<br>')}</div>` : '';
      let originalAuthorAvatar = defaultAvatar;
      let originalAuthorNickname = '原作者';
      if (post.originalPost.authorId === 'user') {
        originalAuthorAvatar = state.qzoneSettings.avatar;
        originalAuthorNickname = state.qzoneSettings.nickname;
      } else {
        const originalAuthorChat = state.chats[post.originalPost.authorId];
        if (originalAuthorChat) {
          originalAuthorAvatar = originalAuthorChat.settings.aiAvatar || defaultAvatar;
        }
        originalAuthorNickname = getDisplayNameByOriginalName(post.originalPost.authorOriginalName);
      }
      mainContentHtml = `
                    ${repostCommentHtml}
                    <div class="reposted-content-wrapper">
                        <div class="post-header">
                            <img src="${originalAuthorAvatar}" class="post-avatar">
                            <div class="post-info">
                                <span class="post-nickname">@${originalAuthorNickname}</span>
                                <span class="post-timestamp">${formatPostTimestamp(post.originalPost.timestamp)}</span>
                            </div>
                        </div>
                        <div class="post-main-content">${renderOriginalPostContent(post.originalPost)}</div>
                    </div>
                `;
    } else {
      mainContentHtml = `<div class="post-main-content">${renderOriginalPostContent(post)}</div>`;
    }

    let likesHtml = '';
    if (post.likes && post.likes.length > 0) {
      const displayLikes = post.likes.map(name => getDisplayNameByOriginalName(name)).join('、');
      likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${displayLikes} 觉得很赞</span></div>`;
    }


    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
      commentsHtml = '<div class="post-comments-container">';
      post.comments.forEach((comment, index) => {

        if (typeof comment === 'object' && comment !== null && comment.commenterName) {
          const commenterOriginalName = comment.commenterName;

          const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);

          let innerCommentContent;
          if (STICKER_REGEX.test(comment.text)) {
            innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
          } else {
            innerCommentContent = parseMarkdown(comment.text);
          }

          let commentLineHtml = '';

          if (comment.replyTo) {
            const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回复 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
          } else {
            commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
          }

          commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                            <div class="comment-text">${commentLineHtml}</div>
                                            <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                         </div>`;

        } else {

          commentsHtml += `<div class="legacy-comment-item">
                                            <span class="comment-text">${String(comment)}</span>
                                         </div>`;
        }
      });
      commentsHtml += '</div>';
    }


    const userOriginalName = state.qzoneSettings.nickname;
    const isLikedByUser = post.likes && post.likes.includes(userOriginalName);
    const isFavoritedByUser = state.favoritedPostIds && state.favoritedPostIds.has(post.id);

    let repostIconHtml = '';
    if (post.type !== 'repost') {
      repostIconHtml = `
                    <span class="action-icon repost">
                        <svg viewBox="0 0 24 24"><path d="M17 2.1l4 4-4 4 M3 11.5v-3a4 4 0 0 1 4-4h13 M7 21.9l-4-4 4-4 M21 12.5v3a4 4 0 0 1-4 4H4"></path></svg>
                    </span>`;
    }

    postEl.innerHTML = `
                <div class="post-header">
                    <img src="${authorAvatar}" class="post-avatar" data-author-id="${post.authorId}">
                    <div class="post-info">
                        <span class="post-nickname">${authorNickname}</span>
                        <span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
                    </div>
                    <div class="post-actions-btn">…</div>
                </div>
                ${mainContentHtml}
                <div class="post-feedback-icons">
                    ${repostIconHtml}
                    <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                    <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                </div>
                ${likesHtml}
                ${commentsHtml}
                <div class="post-footer">
                    <div class="comment-section">
                        <img src="${commentAvatar}" class="comment-avatar">
                        <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                        <button class="comment-sticker-btn">
        <svg viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14 Q 12 16 16 14"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        </button>
                        <div class="at-mention-popup"></div>
                    </div>
                    <button class="comment-send-btn">发送</button>
                </div>
            `;

    if (!isUpdating) {
      const deleteAction = document.createElement('div');
      deleteAction.className = 'qzone-post-delete-action';
      deleteAction.innerHTML = '<span>删除</span>';
      postContainer.appendChild(postEl);
      postContainer.appendChild(deleteAction);
    }

    return postContainer;
  }

 
  async function updateSinglePostInDOM(postId) {
    const postData = await db.qzonePosts.get(postId);
    if (!postData) {

      const postContainer = document.querySelector(`.qzone-post-container[data-post-id="${postId}"]`);
      if (postContainer) {
        postContainer.remove();
      }
      return;
    }


    const cacheIndex = qzonePostsCache.findIndex(p => p.id === postId);
    if (cacheIndex > -1) {
      qzonePostsCache[cacheIndex] = postData;
    }


    const favorites = await db.favorites.where('type').equals('qzone_post').toArray();
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));


    await createOrUpdatePostElement(postData);
  }




  async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [postsFromDb, favorites] = await Promise.all([
      db.qzonePosts.orderBy('timestamp').reverse().filter(post => !post.isDeleted).toArray(),
      db.favorites.where('type').equals('qzone_post').toArray()
    ]);
    qzonePostsCache = postsFromDb;
    state.favoritedPostIds = new Set(favorites.map(fav => fav.content.id));

    postsListEl.innerHTML = '';
    qzonePostsRenderCount = 0;

    if (qzonePostsCache.length === 0) {
      postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
      return;
    }


    loadMoreQzonePosts();
  }




  async function loadMoreQzonePosts() {
    if (isLoadingMorePosts) return;
    isLoadingMorePosts = true;

    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) {
      isLoadingMorePosts = false;
      return;
    }

    showLoader(postsListEl, 'bottom');


    setTimeout(async () => {
      hideLoader(postsListEl);

      const nextSliceStart = qzonePostsRenderCount;
      const nextSliceEnd = qzonePostsRenderCount + QZONE_RENDER_WINDOW;
      const postsToAppend = qzonePostsCache.slice(nextSliceStart, nextSliceEnd);

      const fragment = document.createDocumentFragment();
      for (const post of postsToAppend) {
        const postElement = await createOrUpdatePostElement(post);
        fragment.appendChild(postElement);
      }
      postsListEl.appendChild(fragment);

      qzonePostsRenderCount += postsToAppend.length;

      isLoadingMorePosts = false;
    }, 500);
  }



  function openQzoneStickerPanel(postId, buttonElement) {
    const panel = qzoneStickerPanelState.panelEl;
    const grid = qzoneStickerPanelState.gridEl;


    grid.innerHTML = '';
    if (state.userStickers.length === 0) {
      grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">请先在聊天界面的<br>表情面板中添加表情包</p>';
    } else {
      state.userStickers.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.style.backgroundImage = `url(${sticker.url})`;
        item.title = sticker.name;
        grid.appendChild(item);
      });
    }




    const btnRect = buttonElement.getBoundingClientRect();
    const phoneScreenRect = document.getElementById('phone-screen').getBoundingClientRect();

    panel.style.display = 'flex';
    const panelRect = panel.getBoundingClientRect();
    const panelHeight = panelRect.height;
    const panelWidth = panelRect.width;


    panel.style.top = `${btnRect.top - panelHeight - 5 - phoneScreenRect.top}px`;


    const desiredLeftPosition = btnRect.left - phoneScreenRect.left;


    if (desiredLeftPosition + panelWidth > phoneScreenRect.width) {

      panel.style.left = 'auto';
      panel.style.right = '5px';
    } else {

      panel.style.left = `${desiredLeftPosition}px`;
      panel.style.right = 'auto';
    }




    qzoneStickerPanelState.isOpen = true;
    qzoneStickerPanelState.activePostId = postId;
  }



  function closeQzoneStickerPanel() {

    if (qzoneStickerPanelState.isOpen) {

      qzoneStickerPanelState.panelEl.style.display = 'none';


      qzoneStickerPanelState.isOpen = false;
      qzoneStickerPanelState.activePostId = null;
    }
  }





 
  async function sendQzoneStickerComment(postId, sticker) {
    if (!sticker || !sticker.url) return;

    const post = await db.qzonePosts.get(postId);
    if (!post) {
      console.error("sendQzoneStickerComment: 找不到帖子:", postId);
      return;
    }

    if (!post.comments) {
      post.comments = [];
    }

    const newComment = {
      commenterName: state.qzoneSettings.nickname,
      text: sticker.url,
      meaning: sticker.name,
      timestamp: Date.now()
    };

    post.comments.push(newComment);

    await db.qzonePosts.update(postId, {
      comments: post.comments
    });

    closeQzoneStickerPanel();
    await renderQzonePosts();

    const postSummary = (post.publicText || post.content || `[图片动态]`).substring(0, 30);


    for (const chatId in state.chats) {
      const chat = state.chats[chatId];
      if (!chat.isGroup) {
        const intelligentPrompt = `[系统提示：'${state.qzoneSettings.nickname}' 在你的动态(ID: ${postId}, 内容摘要: “${postSummary}”)下发送了一个表情评论，意思是：“${sticker.name}”。请你对此作出回应。]`;

        const historyMessage = {
          role: 'system',
          content: intelligentPrompt,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(historyMessage);
        await db.chats.put(chat);
      }
    }

  }






  
  function openRepostModal(postId) {
    repostTargetId = postId;
    document.getElementById('repost-comment-input').value = '';
    document.getElementById('repost-modal').classList.add('visible');
  }


  function hideRepostModal() {
    document.getElementById('repost-modal').classList.remove('visible');
    repostTargetId = null;
  }

 
  async function handleConfirmRepost() {
    if (!repostTargetId) return;

    const comment = document.getElementById('repost-comment-input').value.trim();
    const originalPost = await db.qzonePosts.get(repostTargetId);

    if (!originalPost) {
      alert("错误：找不到要转发的原始动态。");
      hideRepostModal();
      return;
    }

    const newPost = {
      type: 'repost',
      timestamp: Date.now(),
      authorId: 'user',
      repostComment: comment,
      originalPost: originalPost,
      visibleGroupIds: null
    };

    await db.qzonePosts.add(newPost);
    hideRepostModal();
    await renderQzonePosts();
    alert('转发成功！');
  }




  function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
      const searchTerm = document.getElementById('favorites-search-input').value;
      const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
      listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
      return;
    }

    for (const item of items) {
      const card = document.createElement('div');
      card.className = 'favorite-item-card';
      card.dataset.favid = item.id;

      let headerHtml = '',
        contentHtml = '',
        sourceText = '',
        footerHtml = '';

      if (item.type === 'qzone_post') {
        const post = item.content;
        sourceText = '来自动态';
        let authorAvatar = defaultAvatar,
          authorNickname = '未知用户';

        if (post.authorId === 'user') {
          authorAvatar = state.qzoneSettings.avatar;
          authorNickname = state.qzoneSettings.nickname;
        } else if (state.chats[post.authorId]) {
          authorAvatar = state.chats[post.authorId].settings.aiAvatar;
          authorNickname = state.chats[post.authorId].name;
        }

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

        const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
        if (post.type === 'shuoshuo') {
          contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
        } else if (post.type === 'image_post' && post.imageUrl) {
          const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
          contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image"></div>` : `<img src="${postImageUrl}" class="chat-image">`;
        } else if (post.type === 'text_image') {
          const postImageUrl = state.globalSettings.enableAiDrawing && post.image_prompt ? `https://image.pollinations.ai/prompt/${post.image_prompt}` : 'https://i.postimg.cc/KYr2qRCK/1.jpg';
          contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="${postImageUrl}" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
        }




        let likesHtml = '';

        if (post.likes && post.likes.length > 0) {

          likesHtml = `
                            <div class="post-likes-section">
                                <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                                <span>${post.likes.join('、')} 觉得很赞</span>
                            </div>`;
        }



        let commentsHtml = '';
        if (post.comments && post.comments.length > 0) {
          commentsHtml = '<div class="post-comments-container">';
          post.comments.forEach((comment, index) => {

            if (typeof comment === 'object' && comment !== null && comment.commenterName) {

              const commenterOriginalName = comment.commenterName;
              const commenterDisplayName = getDisplayNameByOriginalName(commenterOriginalName);

              let innerCommentContent;
              if (STICKER_REGEX.test(comment.text)) {
                innerCommentContent = `<img src="${comment.text}" class="comment-sticker" alt="sticker">`;
              } else {
                innerCommentContent = comment.text;
              }

              let commentLineHtml = '';
              if (comment.replyTo) {
                const repliedToDisplayName = getDisplayNameByOriginalName(comment.replyTo);
                commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span> 回复 <span class="commenter-name">${repliedToDisplayName}</span>: ${innerCommentContent}`;
              } else {
                commentLineHtml = `<span class="commenter-name">${commenterDisplayName}</span>: ${innerCommentContent}`;
              }

              commentsHtml += `<div class="comment-item" data-post-id="${post.id}" data-commenter-original-name="${commenterOriginalName}" data-commenter-display-name="${commenterDisplayName}">
                                        <div class="comment-text">${commentLineHtml}</div>
                                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                                     </div>`;

            } else {


              commentsHtml += `<div class="legacy-comment-item">
                                        <span class="comment-text">${String(comment)}</span>
                                     </div>`;
            }
          });
          commentsHtml += '</div>';
        }



        footerHtml = `${likesHtml}${commentsHtml}`;



      } else if (item.type === 'chat_message') {
        const msg = item.content;
        const chat = state.chats[item.chatId];
        if (!chat) continue;

        sourceText = `来自与 ${chat.name} 的聊天`;
        const isUser = msg.role === 'user';
        let senderName, senderAvatar;

        if (isUser) {

          senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
          senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
        } else {
          if (chat.isGroup) {


            const member = chat.members.find(m => m.originalName === msg.senderName);


            senderName = msg.senderName;

            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
          } else {

            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
          }
        }


        headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
          contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
        } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
          contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
        } else {
          contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
        }
      } else if (item.type === 'char_diary') {
        const diary = item.content;
        sourceText = `来自 ${diary.characterName} 的日记`;

        const charChat = state.chats[diary.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${diary.characterName}</div></div>`;


        const fullDiaryContent = diary.content || '';

        const formattedContent = parseMarkdown(fullDiaryContent).replace(/\n/g, '<br>');


        contentHtml = `
                <span class="diary-title">${diary.title}</span>
                <div class="fav-card-content-full">${formattedContent}</div>
            `;
      } else if (item.type === 'char_browser_article') {
        const article = item.content;
        sourceText = `来自 ${article.characterName} 的浏览记录`;

        const charChat = state.chats[article.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${article.characterName}</div></div>`;


        contentHtml = `
            <span class="diary-title">${article.title}</span>
            <div class="memo-content-preview">${(article.content || '').replace(/\n/g, '<br>')}</div>
        `;
      } else if (item.type === 'char_memo') {
        const memo = item.content;
        sourceText = `来自 ${memo.characterName} 的备忘录`;

        const charChat = state.chats[memo.characterId];
        const authorAvatar = charChat ? charChat.settings.aiAvatar : defaultAvatar;

        headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${memo.characterName}</div></div>`;


        contentHtml = `
        <span class="memo-title">${memo.title}</span>
        <div class="memo-content-preview">${memo.content.replace(/\n/g, '<br>')}</div>
    `;
      }


      card.innerHTML = `
                    <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                    <div class="fav-card-content">${contentHtml}</div>
                    ${footerHtml}`;

      listEl.appendChild(card);
    }
  }




  async function renderFavoritesScreen() {

    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();


    const searchInput = document.getElementById('favorites-search-input');
    const clearBtn = document.getElementById('favorites-search-clear-btn');
    searchInput.value = '';
    clearBtn.style.display = 'none';


    displayFilteredFavorites(allFavoriteItems);
  }



  function resetCreatePostModal() {
    document.getElementById('post-public-text').value = '';
    document.getElementById('post-image-preview').src = '';
    document.getElementById('post-image-description').value = '';
    document.getElementById('post-image-preview-container').classList.remove('visible');
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-local-image-input').value = '';
    document.getElementById('post-hidden-text').value = '';
    document.getElementById('switch-to-image-mode').click();
  }
 
  async function cleanupRedundantData() {
    const confirmed = await showCustomConfirm(
      '确认清理冗余数据？',
      '此操作将扫描数据库，移除所有与已删除角色相关的孤立数据（如动态、评论、记忆等）。<br><br><strong>此操作不可撤销，但通常是安全的。NPC数据不会被删除。</strong><br><br>建议在操作前先导出数据备份。', {
        confirmButtonClass: 'btn-danger',
        confirmText: '确认清理'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在开始清理冗余数据，请不要关闭页面...");
    console.log("冗余数据清理流程已启动...");

    let cleanupCounts = {
      posts: 0,
      likes: 0,
      comments: 0,
      memories: 0,
      callRecords: 0,
      renderingRules: 0,
      groupMembers: 0,
      chatLinks: 0,
    };

    try {
      await db.transaction('rw', db.tables, async () => {

        const allChats = await db.chats.toArray();
        const allNpcs = await db.npcs.toArray();

        const existingChatIds = new Set(allChats.map(c => c.id));
        const existingNpcIds = new Set(allNpcs.map(n => `npc_${n.id}`));

        const existingOriginalNames = new Set(allChats.filter(c => !c.isGroup).map(c => c.originalName));
        existingOriginalNames.add(state.qzoneSettings.nickname || '{{user}}');

        allNpcs.forEach(npc => existingOriginalNames.add(npc.name));


        for (const chat of allChats) {
          let chatModified = false;
          if (chat.isGroup && chat.members) {
            const originalMemberCount = chat.members.length;



            chat.members = chat.members.filter(member =>
              existingChatIds.has(member.id) || existingNpcIds.has(member.id)
            );

            if (chat.members.length < originalMemberCount) {
              cleanupCounts.groupMembers += (originalMemberCount - chat.members.length);
              chatModified = true;
            }
          }

          if (chat.settings?.linkedMemoryChatIds?.length > 0) {
            const originalLinkCount = chat.settings.linkedMemoryChatIds.length;
            chat.settings.linkedMemoryChatIds = chat.settings.linkedMemoryChatIds.filter(id => existingChatIds.has(id));
            if (chat.settings.linkedMemoryChatIds.length < originalLinkCount) {
              cleanupCounts.chatLinks += (originalLinkCount - chat.settings.linkedMemoryChatIds.length);
              chatModified = true;
            }
          }
          if (chatModified) {
            await db.chats.put(chat);
          }
        }


        const allPosts = await db.qzonePosts.toArray();
        for (const post of allPosts) {
          let postModified = false;



          const isAuthorValid = post.authorId === 'user' || existingChatIds.has(post.authorId) || existingNpcIds.has(post.authorId);

          if (!isAuthorValid) {
            await db.qzonePosts.delete(post.id);
            cleanupCounts.posts++;
            continue;
          }

          if (post.likes && post.likes.length > 0) {
            const originalLikeCount = post.likes.length;
            post.likes = post.likes.filter(name => existingOriginalNames.has(name));
            if (post.likes.length < originalLikeCount) {
              cleanupCounts.likes += (originalLikeCount - post.likes.length);
              postModified = true;
            }
          }
          if (post.comments && post.comments.length > 0) {
            const originalCommentCount = post.comments.length;
            post.comments = post.comments.filter(comment => {
              if (typeof comment === 'object' && comment.commenterName) {
                return existingOriginalNames.has(comment.commenterName);
              }
              return true;
            });
            if (post.comments.length < originalCommentCount) {
              cleanupCounts.comments += (originalCommentCount - post.comments.length);
              postModified = true;
            }
          }
          if (postModified) {
            await db.qzonePosts.put(post);
          }
        }


        await db.memories.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.memories += c);
        await db.callRecords.where('chatId').noneOf([...existingChatIds]).delete().then(c => cleanupCounts.callRecords += c);
        const allRules = await db.renderingRules.toArray();
        for (const rule of allRules) {
          if (rule.chatId !== 'global' && !existingChatIds.has(rule.chatId)) {
            await db.renderingRules.delete(rule.id);
            cleanupCounts.renderingRules++;
          }
        }
      });

      let summary = "✅ 清理完成！\n\n";
      let cleanedSomething = false;
      Object.entries(cleanupCounts).forEach(([key, value]) => {
        if (value > 0) {
          const keyMap = {
            posts: '动态',
            likes: '点赞',
            comments: '评论',
            memories: '记忆',
            callRecords: '通话记录',
            renderingRules: '渲染规则',
            groupMembers: '群成员',
            chatLinks: '记忆链接'
          };
          summary += `- 清理了 ${value} 条无效的${keyMap[key] || key}。\n`;
          cleanedSomething = true;
        }
      });
      if (!cleanedSomething) {
        summary = "✅ 检查完成，未发现任何冗余数据。";
      }
      summary += "\n建议刷新页面以确保所有更改生效。";

      await showCustomAlert("操作成功", summary);

      const confirmedReload = await showCustomConfirm("刷新页面？", "为了确保所有数据同步，建议立即刷新页面。");
      if (confirmedReload) {
        location.reload();
      }

    } catch (error) {
      console.error("清理冗余数据时出错:", error);
      await showCustomAlert('清理失败', `发生了一个错误: ${error.message}`);
    }
  }

  async function exportBackup() {
    try {
      const backupData = {
        version: 1,
        timestamp: Date.now()
      };

      const [
        chats, worldBooks, userStickers, apiConfig, globalSettings,
        personaPresets, musicLibrary, qzoneSettings, qzonePosts,
        qzoneAlbums, qzonePhotos, favorites, qzoneGroups,
        memories, worldBookCategories,
        apiPresets, shoppingProducts, callRecords,
        renderingRules,

        doubanPosts,
        stickerCategories,

        appearancePresets,

        presets,
        presetCategories,

        npcs
      ] = await Promise.all([
        db.chats.toArray(),
        db.worldBooks.toArray(),
        db.userStickers.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.personaPresets.toArray(),
        db.musicLibrary.get('main'),
        db.qzoneSettings.get('main'),
        db.qzonePosts.toArray(),
        db.qzoneAlbums.toArray(),
        db.qzonePhotos.toArray(),
        db.favorites.toArray(),
        db.qzoneGroups.toArray(),
        db.memories.toArray(),
        db.worldBookCategories.toArray(),
        db.apiPresets.toArray(),
        db.shoppingProducts.toArray(),
        db.callRecords.toArray(),
        db.renderingRules.toArray(),

        db.doubanPosts.toArray(),
        db.stickerCategories.toArray(),

        db.appearancePresets.toArray(),

        db.presets.toArray(),
        db.presetCategories.toArray(),

        db.npcs.toArray()
      ]);

      Object.assign(backupData, {
        chats,
        worldBooks,
        userStickers,
        apiConfig,
        globalSettings,
        personaPresets,
        musicLibrary,
        qzoneSettings,
        qzonePosts,
        qzoneAlbums,
        qzonePhotos,
        favorites,
        qzoneGroups,
        memories,
        worldBookCategories,
        apiPresets,
        shoppingProducts,
        callRecords,
        renderingRules,

        doubanPosts,
        stickerCategories,

        appearancePresets,

        presets,
        presetCategories,

        npcs
      });

      const blob = new Blob(
        [JSON.stringify(backupData, null, 2)], {
          type: 'application/json'
        }
      );
      const url = URL.createObjectURL(blob);
      const link = Object.assign(document.createElement('a'), {
        href: url,
        download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
      });
      link.click();
      URL.revokeObjectURL(url);

      await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
      console.error("导出数据时出错:", error);
      await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
  }



  async function importStreamedBackup(backupData) {
    try {
      await db.transaction('rw', db.tables, async () => {

        for (const table of db.tables) {
          await table.clear();
        }


        for (const tableName in backupData) {
          if (Array.isArray(backupData[tableName])) {
            console.log(`正在导入表: ${tableName}, 记录数: ${backupData[tableName].length}`);
            await db.table(tableName).bulkPut(backupData[tableName]);
          }
        }
      });

    } catch (error) {

      throw new Error(`数据库写入失败: ${error.message}`);
    }
  }





  async function handleSmartImport(file) {
    if (!file) return;

    await showCustomAlert("请稍候...", "正在读取并解析备份文件...");

    try {
      const text = await file.text();
      const data = JSON.parse(text);

      let backupDataContent;
      let backupType;

     
      if (data.data && typeof data.data === 'object' && (data.data.chats || data.data.worldBooks)) {
        console.log("检测到新版流式备份文件...");
        backupDataContent = data.data;
        backupType = 'streamed'; // 'streamed' or 'legacy'
      } else if (data.chats || data.worldBooks) {
        console.log("检测到旧版完整备份文件...");
        backupDataContent = data;
        backupType = 'legacy';
      } else {
        throw new Error("文件格式无法识别。请确保您选择的是有效的 EPhone 备份文件。");
      }

      
      pendingBackupData = {
        type: backupType,
        content: backupDataContent
      };

     
      openImportOptionsModal(backupDataContent);

    } catch (error) {
      console.error("导入数据时出错:", error);
      pendingBackupData = null;
      await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
    }
  }


  function openImportOptionsModal(backupDataContent) {
    const modal = document.getElementById('import-options-modal');
    const listEl = document.getElementById('import-preview-list');
    listEl.innerHTML = '';

    const contentSummary = {
      'chats': '聊天会话',
      'worldBooks': '世界书',
      'worldBookCategories': '世界书分类', 
      'presets': '离线预设',
      'presetCategories': '预设分类', 
      'userStickers': '表情包',
      'stickerCategories': '表情分类',
      'customAvatarFrames': '头像框',
      'apiConfig': 'API配置',
      'globalSettings': '全局设置',
      'personaPresets': '人设预设',
      'qzoneSettings': '空间设置',
      'qzonePosts': '动态',
      'qzoneAlbums': '相册',
      'favorites': '收藏',
      'memories': '回忆',
      'callRecords': '通话记录',
      'shoppingProducts': '商品',
      'apiPresets': 'API预设',
      'renderingRules': '渲染规则',
      'appearancePresets': '外观预设',
      'npcs': 'NPCs'
    };

    let foundData = false;
    for (const key in contentSummary) {
      if (backupDataContent[key] && (Array.isArray(backupDataContent[key]) ? backupDataContent[key].length > 0 : backupDataContent[key])) {
        const count = Array.isArray(backupDataContent[key]) ? backupDataContent[key].length : 1;
        const li = document.createElement('li');
        li.textContent = `${contentSummary[key]}: ${count} 条/个`;
        listEl.appendChild(li);
        foundData = true;
      }
    }

    if (!foundData) {
      listEl.innerHTML = '<li>未在此文件中找到可识别的数据。</li>';
    }

   
    document.getElementById('confirm-full-import-btn').onclick = () => {
      modal.classList.remove('visible');
      handleFullImport(pendingBackupData);
    };
    document.getElementById('confirm-selective-import-btn').onclick = () => {
      modal.classList.remove('visible');
      openSelectiveImportModal(pendingBackupData.content);
    };
    document.getElementById('cancel-import-options-btn').onclick = () => {
      modal.classList.remove('visible');
      pendingBackupData = null;
    };

    modal.classList.add('visible');
  }

 
  async function handleFullImport(backupInfo) {
    if (!backupInfo) return;

    const confirmed = await showCustomConfirm(
      '严重警告！',
      '【完全导入】将删除您当前的所有数据并替换为备份文件中的内容。此操作不可撤销！<br><br><strong>确定要继续吗？</strong>', {
        confirmButtonClass: 'btn-danger',
        confirmText: '我明白，覆盖所有数据'
      }
    );
    if (!confirmed) {
      pendingBackupData = null;
      return;
    }

    await showCustomAlert("请稍候...", "正在执行完全导入，请勿关闭页面...");

    try {
      if (backupInfo.type === 'streamed') {
        await importStreamedBackup(backupInfo.content);
      } else if (backupInfo.type === 'legacy') {
        await importLegacyBackup(backupInfo.content);
      } else {
        throw new Error("未知的备份类型。");
      }

      await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
      try {
            const restoredApiConfig = await db.apiConfig.get('main');
            if (restoredApiConfig) {
                // 同步 ImgBB
                if (restoredApiConfig.imgbbApiKey) localStorage.setItem('imgbb-api-key', restoredApiConfig.imgbbApiKey);
                if (restoredApiConfig.imgbbEnable !== undefined) localStorage.setItem('imgbb-enabled', restoredApiConfig.imgbbEnable);
                
                // 同步 Minimax
                if (restoredApiConfig.minimaxGroupId) localStorage.setItem('minimax-group-id', restoredApiConfig.minimaxGroupId);
                if (restoredApiConfig.minimaxApiKey) localStorage.setItem('minimax-api-key', restoredApiConfig.minimaxApiKey);
                if (restoredApiConfig.minimaxModel) localStorage.setItem('minimax-model', restoredApiConfig.minimaxModel);
                
                // 同步 Catbox
                if (restoredApiConfig.catboxUserHash) localStorage.setItem('catbox-userhash', restoredApiConfig.catboxUserHash);
                if (restoredApiConfig.catboxEnable !== undefined) localStorage.setItem('catbox-enabled', restoredApiConfig.catboxEnable);
                
                // 同步 NovelAI
                const novelaiSettings = localStorage.getItem('novelai-settings'); // NovelAI配置比较特殊，通常在localStorage，如果备份里有也可以恢复
                // 注意：你的代码似乎没有把 novelai 的 key 存入 apiConfig 表，而是直接存 localStorage，
                // 如果你的备份逻辑里没有包含 localStorage 的 novelai 数据，导入后确实会丢失。
                // 但这里我们主要修复 ImgBB/Minimax/Catbox。
            }
            console.log("API 配置已强制同步到本地缓存。");
        } catch (e) {
            console.error("同步配置失败:", e);
        }
      setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
      console.error("完全导入失败:", error);
      await showCustomAlert('导入失败', `文件应用失败: ${error.message}`);
    } finally {
      pendingBackupData = null;
    }
  }


  function openSelectiveImportModal(backupDataContent) {
    const modal = document.getElementById('selective-import-modal');
    const listEl = document.getElementById('selective-import-list');
    const selectAllCheckbox = document.getElementById('select-all-import-types');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = true;

    const contentSummary = {
      'chats': '聊天会话',
      'worldBooks': '世界书',
      'worldBookCategories': '世界书分类',
      'presets': '离线预设',
      'presetCategories': '预设分类', 
      'userStickers': '表情包',
      'stickerCategories': '表情分类',
      'customAvatarFrames': '头像框',
      'apiConfig': 'API配置',
      'globalSettings': '全局设置',
      'personaPresets': '人设预设',
      'qzoneSettings': '空间设置',
      'qzonePosts': '动态',
      'qzoneAlbums': '相册',
      'favorites': '收藏',
      'memories': '回忆',
      'callRecords': '通话记录',
      'shoppingProducts': '商品',
      'apiPresets': 'API预设',
      'renderingRules': '渲染规则',
      'appearancePresets': '外观预设',
      'npcs': 'NPCs'
    };

    let hasContent = false;
    for (const key in contentSummary) {
      if (backupDataContent[key] && (Array.isArray(backupDataContent[key]) ? backupDataContent[key].length > 0 : backupDataContent[key])) {
        const count = Array.isArray(backupDataContent[key]) ? backupDataContent[key].length : 1;
        const isSingleObject = !Array.isArray(backupDataContent[key]);

        const item = document.createElement('div');
        item.className = 'clear-posts-item selected'; 
        item.dataset.typeId = key;
        item.innerHTML = `
                <div class="checkbox selected"></div>
                <div>
                    <span class="name">${contentSummary[key]} (${count} 条/个)</span>
                    ${isSingleObject ? '<p style="font-size: 12px; color: #ff8c00; margin: 4px 0 0;">(注意: 这将【覆盖】您当前的设置)</p>' : ''}
                </div>
            `;
        listEl.appendChild(item);
        hasContent = true;
      }
    }

    if (!hasContent) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">文件中未找到可合并的数据。</p>';
    }

   
    document.getElementById('confirm-merge-import-btn').onclick = () => handleSelectiveImport(pendingBackupData);
    document.getElementById('cancel-selective-import-btn').onclick = () => {
      modal.classList.remove('visible');
      pendingBackupData = null;
    };

    selectAllCheckbox.onchange = (e) => {
      const isChecked = e.target.checked;
      listEl.querySelectorAll('.clear-posts-item').forEach(item => {
        item.classList.toggle('selected', isChecked);
        item.querySelector('.checkbox').classList.toggle('selected', isChecked);
      });
    };

    listEl.onclick = (e) => {
      const item = e.target.closest('.clear-posts-item');
      if (item) {
        item.classList.toggle('selected');
        item.querySelector('.checkbox').classList.toggle('selected');
      }
    };

    modal.classList.add('visible');
  }

  
  async function handleSelectiveImport(backupInfo) {
    if (!backupInfo) return;

    const selectedItems = document.querySelectorAll('#selective-import-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("请至少选择一种要合并的数据类型。");
      return;
    }

    const typesToMerge = Array.from(selectedItems).map(item => item.dataset.typeId);
    const dataToMerge = backupInfo.content;

    const confirmed = await showCustomConfirm(
      '确认合并？',
      '这将把您选择的数据【添加并覆盖】到现有数据中。同ID的数据将被更新，新数据将被添加。<br><br><strong>此操作不可撤销！</strong>', {
        confirmText: '确认合并'
      }
    );
    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在合并数据，请勿关闭页面...");

    try {

      await db.transaction('rw', db.tables, async () => {
        for (const type of typesToMerge) {
          const data = dataToMerge[type];
          if (!data) continue;

          const table = db.table(type);
          if (!table) {
            console.warn(`找不到表: ${type}, 跳过...`);
            continue;
          }

          if (Array.isArray(data)) {
          
            console.log(`正在合并 ${data.length} 条记录到 ${type}...`);
            await table.bulkPut(data);
          } else if (typeof data === 'object' && data.id) {
            
            console.log(`正在合并单条记录到 ${type}...`);
            await table.put(data);
          } else if (typeof data === 'object') {
          
            console.log(`正在合并非标对象到 ${type}...`);
            const existingData = await table.toCollection().first() || {};
            const mergedData = {
              ...existingData,
              ...data
            };

          
            if (existingData.id) {
              mergedData.id = existingData.id;
            } else if (type === 'apiConfig' || type === 'qzoneSettings' || type === 'globalSettings' || type === 'musicLibrary') {
              mergedData.id = 'main';
            }

            await table.put(mergedData);
          }
        }
      });

      await showCustomAlert('合并成功', '数据已成功合并！应用即将刷新以应用所有更改。');
      setTimeout(() => window.location.reload(), 1500);

    } catch (error) {
      console.error("选择性导入失败:", error);
      await showCustomAlert('合并失败', `文件应用失败: ${error.message}`);
    } finally {
      pendingBackupData = null;
    }
  }


  async function importLegacyBackup(backupData) {
    try {
      await db.transaction('rw', db.tables, async () => {
        await db.chats.clear();
        await db.worldBooks.clear();

        for (const table of db.tables) {
          await table.clear();
        }

        if (Array.isArray(backupData.chats)) await db.chats.bulkPut(backupData.chats);
        if (Array.isArray(backupData.worldBooks)) await db.worldBooks.bulkPut(backupData.worldBooks);

        if (Array.isArray(backupData.userStickers)) await db.userStickers.bulkPut(backupData.userStickers);
        if (backupData.apiConfig) await db.apiConfig.put(backupData.apiConfig);
        if (backupData.globalSettings) await db.globalSettings.put(backupData.globalSettings);

        if (Array.isArray(backupData.personaPresets)) await db.personaPresets.bulkPut(backupData.personaPresets);
        if (backupData.musicLibrary) await db.musicLibrary.put(backupData.musicLibrary);
        if (backupData.qzoneSettings) await db.qzoneSettings.put(backupData.qzoneSettings);
        if (Array.isArray(backupData.qzonePosts)) await db.qzonePosts.bulkPut(backupData.qzonePosts);
        if (Array.isArray(backupData.qzoneAlbums)) await db.qzoneAlbums.bulkPut(backupData.qzoneAlbums);
        if (Array.isArray(backupData.qzonePhotos)) await db.qzonePhotos.bulkPut(backupData.qzonePhotos);
        if (Array.isArray(backupData.favorites)) await db.favorites.bulkPut(backupData.favorites);
        if (Array.isArray(backupData.qzoneGroups)) await db.qzoneGroups.bulkPut(backupData.qzoneGroups);
        if (Array.isArray(backupData.memories)) await db.memories.bulkPut(backupData.memories);
        if (Array.isArray(backupData.worldBookCategories)) await db.worldBookCategories.bulkPut(backupData.worldBookCategories);
        if (Array.isArray(backupData.apiPresets)) await db.apiPresets.bulkPut(backupData.apiPresets);
        if (Array.isArray(backupData.shoppingProducts)) await db.shoppingProducts.bulkPut(backupData.shoppingProducts);
        if (Array.isArray(backupData.callRecords)) await db.callRecords.bulkPut(backupData.callRecords);
        if (Array.isArray(backupData.renderingRules)) await db.renderingRules.bulkPut(backupData.renderingRules);
        if (Array.isArray(backupData.doubanPosts)) await db.doubanPosts.bulkPut(backupData.doubanPosts);
        if (Array.isArray(backupData.stickerCategories)) await db.stickerCategories.bulkPut(backupData.stickerCategories);
        if (Array.isArray(backupData.appearancePresets)) await db.appearancePresets.bulkPut(backupData.appearancePresets);
        if (Array.isArray(backupData.presets)) await db.presets.bulkPut(backupData.presets);
        if (Array.isArray(backupData.presetCategories)) await db.presetCategories.bulkPut(backupData.presetCategories);
        if (Array.isArray(backupData.npcs)) await db.npcs.bulkPut(backupData.npcs);
      });
    } catch (error) {
      throw new Error(`旧版备份数据写入数据库失败: ${error.message}`);
    }
  }


  function applyCustomFont(fontUrl, isPreviewOnly = false) {
    if (!fontUrl) {
      dynamicFontStyle.innerHTML = '';
      document.getElementById('font-preview').style.fontFamily = '';
      return;
    }
    const fontName = 'custom-user-font';
    const newStyle = `
                        @font-face {
                          font-family: '${fontName}';
                          src: url('${fontUrl}');
                          font-display: swap;
                        }`;
    if (isPreviewOnly) {
      const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
      previewStyle.id = 'preview-font-style';
      previewStyle.innerHTML = newStyle;
      if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
      document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
    } else {
      dynamicFontStyle.innerHTML = `
                            ${newStyle}
                            body {
                              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                            }`;
    }
  }

  async function resetToDefaultFont() {
    dynamicFontStyle.innerHTML = '';
    state.globalSettings.fontUrl = '';
    await db.globalSettings.put(state.globalSettings);
    document.getElementById('font-url-input').value = '';
    document.getElementById('font-preview').style.fontFamily = '';
    alert('已恢复默认字体。');
  }


  async function loadAllDataFromDB() {
    const [
      chatsArr, apiConfig, loadedGlobalSettings, userStickers, worldBooks,
      musicLib, personaPresets, qzoneSettings, initialFavorites,
      allMemories,

      allPresets,
      allQuickReplies
    ] = await Promise.all([
      db.chats.toArray(), db.apiConfig.get('main'), db.globalSettings.get('main'),
      db.userStickers.toArray(), db.worldBooks.toArray(), db.musicLibrary.get('main'),
      db.personaPresets.toArray(), db.qzoneSettings.get('main'), db.favorites.orderBy('timestamp').reverse().toArray(),
      db.memories.toArray(),

      db.presets.toArray(),
      db.quickReplies.toArray()
    ]);


    state.presets = allPresets || [];
    state.quickReplies = allQuickReplies || [];
    await initUserWallet(); 
    const defaultGlobalSettings = {
      id: 'main',
      showStatusBar: false,
      wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)',
      fontUrl: '',
      enableThoughts: false,              // 新增：全局心声开关，默认关闭
      enableQzoneActions: false,          // 新增：全局动态开关，默认关闭
      enableBackgroundActivity: false,
      backgroundActivityInterval: 60,
      blockCooldownHours: 1,
      apiTemperature: 0.8,
      appIcons: {
        ...DEFAULT_APP_ICONS
      },
      cphoneWallpaper: 'linear-gradient(135deg, #f6d365, #fda085)',
      cphoneAppIcons: {
        ...DEFAULT_CPHONE_ICONS
      },
      globalCss: '',
      notificationSoundUrl: '',
      widgetData: {},
      globalChatBackground: '',
      enableAiDrawing: true,
      showPhoneFrame: false,
      lockScreenEnabled: false,
      lockScreenPassword: '',
      lockScreenWallpaper: '',
      alwaysShowMusicIsland: false,
      detachStatusBar: false,
      enableMinimalChatUI: false,
      chatActionButtonsOrder: null,
      shoppingCategoryCount: 3,
      shoppingProductCount: 8,
      chatRenderWindow: 50,
      systemNotification: {
        enabled: false,
        appName: 'EPhone',
        pushServer: {
          enabled: false,
          serverUrl: '',
          apiKey: ''
        },
        vibration: {
          enabled: false,
          pattern: 'short'
        },
        mergeMessages: {
          enabled: false,
          threshold: 3,
          timeWindow: 60
        },
        sound: {
          enabled: false,
          useGlobalSound: true,
          customSoundUrl: ''
        }
      }
    };
    state.globalSettings = {
      ...defaultGlobalSettings,
      ...(loadedGlobalSettings || {})
    };
    
    // 确保 systemNotification 配置完整
    if (!state.globalSettings.systemNotification) {
      state.globalSettings.systemNotification = defaultGlobalSettings.systemNotification;
    } else {
      state.globalSettings.systemNotification = {
        ...defaultGlobalSettings.systemNotification,
        ...state.globalSettings.systemNotification,
        pushServer: {
          ...defaultGlobalSettings.systemNotification.pushServer,
          ...(state.globalSettings.systemNotification.pushServer || {})
        },
        vibration: {
          ...defaultGlobalSettings.systemNotification.vibration,
          ...(state.globalSettings.systemNotification.vibration || {})
        },
        mergeMessages: {
          ...defaultGlobalSettings.systemNotification.mergeMessages,
          ...(state.globalSettings.systemNotification.mergeMessages || {})
        },
        sound: {
          ...defaultGlobalSettings.systemNotification.sound,
          ...(state.globalSettings.systemNotification.sound || {})
        }
      };
    }
    
    state.globalSettings.appIcons = {
      ...defaultGlobalSettings.appIcons,
      ...(state.globalSettings.appIcons || {})
    };
    state.globalSettings.cphoneAppIcons = {
      ...defaultGlobalSettings.cphoneAppIcons,
      ...(state.globalSettings.cphoneAppIcons || {})
    };

    chatsArr.forEach(chat => {
      if (typeof chat.settings.enableTimePerception === 'undefined') {
        chat.settings.enableTimePerception = true;
      }
      if (!chat.settings.lyricsPosition) {
        chat.settings.lyricsPosition = {
          vertical: 'top',
          horizontal: 'center',
          offset: 10
        };
      }
      if (!chat.isGroup && !chat.settings.myAvatarLibrary) {
        chat.settings.myAvatarLibrary = [];
      }
      if (!chat.isGroup && typeof chat.originalName === 'undefined') {
        chat.originalName = chat.name;
      }
    });
    state.chats = chatsArr.reduce((acc, chat) => {
      if (typeof chat.unreadCount === 'undefined') chat.unreadCount = 0;
      if (chat.isGroup) {
        if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
          chat.settings.enableBackgroundActivity = true;
        }
        if (chat.members && chat.members.length > 0 && chat.members[0].name) {
          chat.members.forEach(member => {
            if (typeof member.originalName === 'undefined') {
              member.originalName = member.name;
              member.groupNickname = member.name;
              delete member.name;
            }
          });
        }
      }
      if (!chat.settings) chat.settings = {};
      if (typeof chat.settings.actionCooldownMinutes === 'undefined') {
        chat.settings.actionCooldownMinutes = 10;
      }
      if (!chat.isGroup && !chat.status) chat.status = {
        text: '在线',
        lastUpdate: Date.now(),
        isBusy: false
      };
      // 初始化USER状态
      if (!chat.settings.userStatus) chat.settings.userStatus = {
        text: '在线',
        lastUpdate: Date.now(),
        isBusy: false
      };
      if (!chat.isGroup && !chat.relationship) chat.relationship = {
        status: 'friend',
        blockedTimestamp: null,
        applicationReason: ''
      };
      if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {};
        chat.settings.aiAvatarLibrary = [];
      }
      if (chat.isGroup) {
        (chat.members || []).forEach(member => {
          if (typeof member.avatarFrame === 'undefined') member.avatarFrame = '';
        });
      }
      if (!chat.musicData) chat.musicData = {
        totalTime: 0
      };
      if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
        chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
        delete chat.settings.linkedWorldBookId;
      }
      if (typeof chat.isPinned === 'undefined') chat.isPinned = false;
      if (!chat.isGroup && typeof chat.settings.myNickname === 'undefined') {
        chat.settings.myNickname = '我';
      }
      if (chat.isGroup && chat.members) {
        let needsUpdate = false;
        chatsArr.forEach(c => {
          if (c.id === chat.id && c.originalName) {
            delete c.originalName;
          }
        });
        chat.members.forEach(member => {
          const originalCharacter = chatsArr.find(c => c.id === member.id);
          if (originalCharacter && originalCharacter.settings) {
            const correctFrame = originalCharacter.settings.aiAvatarFrame || '';
            if (member.avatarFrame !== correctFrame) {
              member.avatarFrame = correctFrame;
              needsUpdate = true;
            }
          } else if (typeof member.avatarFrame === 'undefined') {
            member.avatarFrame = '';
            needsUpdate = true;
          }
        });
        if (needsUpdate) db.chats.put(chat);
      }
      if (!chat.settings.enableAutoMemory) chat.settings.enableAutoMemory = false;
      if (!chat.settings.autoMemoryInterval) chat.settings.autoMemoryInterval = 20;
      if (!chat.longTermMemory) chat.longTermMemory = [];
      if (!chat.lastMemorySummaryTimestamp) chat.lastMemorySummaryTimestamp = 0;
      if (!chat.isGroup) {
        if (typeof chat.settings.enableBackgroundActivity === 'undefined') {
          chat.settings.enableBackgroundActivity = true;
        }
        if (typeof chat.settings.enableTts === 'undefined') {
          chat.settings.enableTts = false;
        }
        if (!chat.status) chat.status = {
          text: '在线',
          lastUpdate: Date.now(),
          isBusy: false
        };
        // 初始化USER状态
        if (!chat.settings.userStatus) chat.settings.userStatus = {
          text: '在线',
          lastUpdate: Date.now(),
          isBusy: false
        };
        if (!chat.relationship) chat.relationship = {
          status: 'friend',
          blockedTimestamp: null,
          applicationReason: ''
        };
        if (!chat.settings || !chat.settings.aiAvatarLibrary) {
          if (!chat.settings) chat.settings = {};
          chat.settings.aiAvatarLibrary = [];
        }
        if (typeof chat.settings.isOfflineMode === 'undefined') chat.settings.isOfflineMode = false;
        if (typeof chat.settings.offlineMinLength === 'undefined') chat.settings.offlineMinLength = 100;
        if (typeof chat.settings.offlineMaxLength === 'undefined') chat.settings.offlineMaxLength = 300;

        if (typeof chat.settings.injectLatestThought === 'undefined') {
          chat.settings.injectLatestThought = false;
        }

        // 新增：初始化心声和动态功能开关
        if (typeof chat.settings.enableThoughts === 'undefined') {
          chat.settings.enableThoughts = null; // null表示使用全局设置
        }
        if (typeof chat.settings.enableQzoneActions === 'undefined') {
          chat.settings.enableQzoneActions = null; // null表示使用全局设置
        }

        if (typeof chat.heartfeltVoice === 'undefined') chat.heartfeltVoice = '...';
        if (typeof chat.randomJottings === 'undefined') chat.randomJottings = '...';
        if (!Array.isArray(chat.thoughtsHistory)) {
          chat.thoughtsHistory = [];
        }
      }
      if (typeof chat.settings.stickerCategoryIds === 'undefined') {
     
        if (chat.settings.stickerCategoryId) {
         
          chat.settings.stickerCategoryIds = [chat.settings.stickerCategoryId];
        } else {
        
          chat.settings.stickerCategoryIds = [];
        }
        
        delete chat.settings.stickerCategoryId;
      }
      acc[chat.id] = chat;
      return acc;
    }, {});
    const memoriesToUpdate = [];
    allMemories.forEach(memory => {
      if (memory.type === 'ai_generated' && memory.authorName && !memory.authorId) {
        const foundChat = chatsArr.find(c => !c.isGroup && c.originalName === memory.authorName);
        if (foundChat) {
          memory.authorId = foundChat.id;
          memoriesToUpdate.push(memory);
        } else {
          const fallbackChat = chatsArr.find(c => !c.isGroup && c.name === memory.authorName);
          if (fallbackChat) {
            memory.authorId = fallbackChat.id;
            memoriesToUpdate.push(memory);
          }
        }
      }
    });
    if (memoriesToUpdate.length > 0) {
      await db.memories.bulkPut(memoriesToUpdate);
    }
    state.apiConfig = apiConfig || {
      id: 'main',
      proxyUrl: '',
      apiKey: '',
      model: '',
      secondaryProxyUrl: '',
      secondaryApiKey: '',
      secondaryModel: '',
      minimaxGroupId: '',
      minimaxApiKey: '',
      minimaxModel: 'speech-01',
      imgbbEnable: false,
      imgbbApiKey: '',
      
        catboxEnable: false,
        catboxUserHash: '',
        githubEnable: false, // 默认为关闭
       githubAutoBackup: false,
      githubUsername: '',
      githubRepo: '',
      githubToken: '',
      githubFilename: 'ephone_backup.json'
    };
    if (localStorage.getItem('imgbb-enabled') !== null) {
        state.apiConfig.imgbbEnable = localStorage.getItem('imgbb-enabled') === 'true';
    }
    if (localStorage.getItem('imgbb-api-key') !== null) {
        state.apiConfig.imgbbApiKey = localStorage.getItem('imgbb-api-key');
    }
    if (localStorage.getItem('catbox-enabled') !== null) {
        state.apiConfig.catboxEnable = localStorage.getItem('catbox-enabled') === 'true';
    }
    if (localStorage.getItem('catbox-userhash') !== null) {
        state.apiConfig.catboxUserHash = localStorage.getItem('catbox-userhash');
    }
   if (localStorage.getItem('minimax-group-id') !== null) {
        state.apiConfig.minimaxGroupId = localStorage.getItem('minimax-group-id');
    }
    if (localStorage.getItem('minimax-api-key') !== null) {
        state.apiConfig.minimaxApiKey = localStorage.getItem('minimax-api-key');
    }
    if (localStorage.getItem('minimax-model') !== null) {
        state.apiConfig.minimaxModel = localStorage.getItem('minimax-model');
    }
    if (localStorage.getItem('github-proxy-enabled') !== null) {
        state.apiConfig.githubProxyEnable = localStorage.getItem('github-proxy-enabled') === 'true';
    }
    if (localStorage.getItem('github-proxy-url') !== null) {
        state.apiConfig.githubProxyUrl = localStorage.getItem('github-proxy-url');
    }
    state.userStickers = userStickers || [];
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
    state.qzoneSettings = qzoneSettings || {
      id: 'main',
      nickname: '{{user}}',
      avatar: 'https://files.catbox.moe/q6z5fc.jpeg',
      banner: 'https://files.catbox.moe/r5heyt.gif'
    };
    allFavoriteItems = initialFavorites || [];
  }


  async function saveGlobalPlaylist() {
    await db.musicLibrary.put({
      id: 'main',
      playlist: musicState.playlist
    });
  }

  function formatTimestamp(timestamp, chatId = null) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    
    // 判断是否显示秒数
    let showSeconds = false;
    
    // 如果提供了 chatId，检查单个角色设置（优先级最高）
    if (chatId && state.chats[chatId] && state.chats[chatId].settings) {
      if (state.chats[chatId].settings.showSeconds !== undefined) {
        showSeconds = state.chats[chatId].settings.showSeconds;
      } else {
        // 如果角色没有单独设置，使用全局设置
        showSeconds = state.globalSettings.showSeconds || false;
      }
    } else {
      // 没有 chatId 时，使用全局设置
      showSeconds = state.globalSettings.showSeconds || false;
    }
    
    return showSeconds ? `${hours}:${minutes}:${seconds}` : `${hours}:${minutes}`;
  }
  
  function formatTimeAgo(timestamp) {
    const now = Date.now();
    const seconds = Math.floor((now - timestamp) / 1000);

    if (seconds < 60) return '刚刚';

    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}分钟前`;

    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours}小时前`;

    const days = Math.floor(hours / 24);
    if (days < 30) return `${days}天前`;

    const months = Math.floor(days / 30);
    if (months < 12) return `大约${months}个月前`;

    const years = Math.floor(days / 365);
    return `大约${years}年前`;
  }

  function formatTimestampForAI(timestamp) {
    if (!timestamp) return '';

    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;


    if (now.toDateString() === date.toDateString()) {
      return `今天 ${timeString}`;
    }


    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
      return `昨天 ${timeString}`;
    }


    if (now.getFullYear() === date.getFullYear()) {
      const month = String(date.getMonth() + 1);
      const day = String(date.getDate());
      return `${month}月${day}日 ${timeString}`;
    }


    const year = date.getFullYear();
    const month = String(date.getMonth() + 1);
    const day = String(date.getDate());
    return `${year}年${month}月${day}日 ${timeString}`;
  }

// --- 新增 NAI 预设相关函数 ---

// 1. 加载预设下拉菜单
async function loadNaiPresetsDropdown() {
    const selectEl = document.getElementById('nai-preset-select');
    // 保留第一个选项
    selectEl.innerHTML = '<option value="">-- 当前临时设置 --</option>';
    
    const presets = await db.naiPresets.toArray();
    presets.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        selectEl.appendChild(opt);
    });
    
    // 恢复选中状态
    if (currentNaiPresetId) {
        selectEl.value = currentNaiPresetId;
        updateNaiPresetButtons(true);
    } else {
        updateNaiPresetButtons(false);
    }
}

// 2. 更新按钮显示状态
// 2. 更新按钮显示状态 (更新这个函数)
function updateNaiPresetButtons(hasSelection) {
    const updateBtn = document.getElementById('update-nai-preset-btn');
    const bindBtn = document.getElementById('bind-nai-preset-btn');
    const deleteBtn = document.getElementById('delete-nai-preset-btn');
    const saveBtn = document.getElementById('save-nai-preset-btn');
    
    if (hasSelection) {
        updateBtn.style.display = 'block';
        bindBtn.style.display = 'block';
        deleteBtn.style.display = 'block';
        // 改动：选中状态下显示"另存" (2个字)
        saveBtn.textContent = '另存';
    } else {
        updateBtn.style.display = 'none';
        bindBtn.style.display = 'none';
        deleteBtn.style.display = 'none';
        // 改动：未选中状态下显示"新增" (2个字)
        saveBtn.textContent = '新增';
    }
}

// 3. 收集当前界面上的所有设置
function gatherNaiUiSettings() {
    return {
      resolution: document.getElementById('nai-resolution').value,
      steps: parseInt(document.getElementById('nai-steps').value),
      cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
      sampler: document.getElementById('nai-sampler').value,
      seed: parseInt(document.getElementById('nai-seed').value),
      uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
      quality_toggle: document.getElementById('nai-quality-toggle').checked,
      smea: document.getElementById('nai-smea').checked,
      smea_dyn: document.getElementById('nai-smea-dyn').checked,
      default_positive: document.getElementById('nai-default-positive').value,
      default_negative: document.getElementById('nai-default-negative').value,
      // 注意：API Key 和 Proxy 这种敏感/全局配置通常不存入风格预设，但你可以根据需求决定
      // 这里为了风格切换方便，我们只存参数，Key 和 Proxy 还是走全局
    };
}

// 4. 应用设置到 UI
function applyNaiUiSettings(settings) {
    if (!settings) return;
    document.getElementById('nai-resolution').value = settings.resolution || '1024x1024';
    document.getElementById('nai-steps').value = settings.steps || 28;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale || 5;
    document.getElementById('nai-sampler').value = settings.sampler || 'k_euler_ancestral';
    document.getElementById('nai-seed').value = settings.seed ?? -1;
    document.getElementById('nai-uc-preset').value = settings.uc_preset || 1;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle !== false;
    document.getElementById('nai-smea').checked = settings.smea !== false;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn || false;
    document.getElementById('nai-default-positive').value = settings.default_positive || '';
    document.getElementById('nai-default-negative').value = settings.default_negative || '';
}

// 5. 保存/新建预设
async function handleSaveNaiPreset(isUpdate = false) {
    const settings = gatherNaiUiSettings();
    
    if (isUpdate && currentNaiPresetId) {
        const confirmed = await showCustomConfirm("更新预设", "确定要覆盖当前预设的参数吗？");
        if (!confirmed) return;
        
        await db.naiPresets.update(parseInt(currentNaiPresetId), { settings });
        alert("预设已更新！");
    } else {
        const name = await showCustomPrompt("新建预设", "请输入预设名称（例如：厚涂风、像素风）");
        if (!name) return;
        
        const id = await db.naiPresets.add({ name, settings });
        currentNaiPresetId = id;
        await loadNaiPresetsDropdown();
        alert("预设已创建！");
    }
}

// 6. 删除预设
async function handleDeleteNaiPreset() {
    if (!currentNaiPresetId) return;
    const confirmed = await showCustomConfirm("删除预设", "确定要删除此预设吗？绑定了此预设的角色将回退到全局设置。", { confirmButtonClass: 'btn-danger' });
    if (!confirmed) return;
    
    await db.naiPresets.delete(parseInt(currentNaiPresetId));
    
    // 清除所有聊天中的绑定引用
    const allChats = await db.chats.toArray();
    for (const chat of allChats) {
        if (chat.settings?.naiPresetId === parseInt(currentNaiPresetId)) {
            delete chat.settings.naiPresetId;
            await db.chats.put(chat);
        }
    }
    
    currentNaiPresetId = null;
    await loadNaiPresetsDropdown();
}

// 7. 处理下拉框切换
async function handleNaiPresetChange(e) {
    const val = e.target.value;
    if (val) {
        currentNaiPresetId = parseInt(val);
        const preset = await db.naiPresets.get(currentNaiPresetId);
        if (preset && preset.settings) {
            applyNaiUiSettings(preset.settings);
        }
        updateNaiPresetButtons(true);
    } else {
        currentNaiPresetId = null;
        updateNaiPresetButtons(false);
        // 恢复到 localStorage 里的全局设置
        loadNovelAISettings(); 
    }
}

// 8. 打开绑定弹窗
async function openNaiBindingModal() {
    if (!currentNaiPresetId) return;
    const preset = await db.naiPresets.get(parseInt(currentNaiPresetId));
    if (!preset) return;

    const modal = document.getElementById('nai-binding-modal');
    const listEl = document.getElementById('nai-binding-list');
    const titleEl = modal.querySelector('.modal-header span');
    
    titleEl.textContent = `将预设“${preset.name}”绑定到...`;
    listEl.innerHTML = '';
    
    const allChats = Object.values(state.chats).sort((a, b) => a.name.localeCompare(b.name));
    
    allChats.forEach(chat => {
        const isBound = chat.settings?.naiPresetId === currentNaiPresetId;
        
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; // 复用样式
        item.innerHTML = `
            <input type="checkbox" class="nai-binding-checkbox" data-chat-id="${chat.id}" ${isBound ? 'checked' : ''} style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <div style="display:flex; flex-direction:column;">
                <span class="name">${chat.name}</span>
                ${isBound ? '<span style="font-size:10px; color:green;">已绑定</span>' : ''}
            </div>
        `;
        // 点击行切换
        item.addEventListener('click', (e) => {
            if (e.target.type !== 'checkbox') {
                const cb = item.querySelector('input');
                cb.checked = !cb.checked;
            }
        });
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

// 9. 保存绑定
async function saveNaiBinding() {
    if (!currentNaiPresetId) return;
    
    const checkboxes = document.querySelectorAll('.nai-binding-checkbox');
    const updates = [];
    
    for (const cb of checkboxes) {
        const chatId = cb.dataset.chatId;
        const chat = state.chats[chatId];
        const shouldBind = cb.checked;
        
        if (chat) {
            if (shouldBind) {
                // 如果勾选，绑定当前预设
                if (chat.settings.naiPresetId !== currentNaiPresetId) {
                    chat.settings.naiPresetId = currentNaiPresetId;
                    updates.push(chat);
                }
            } else {
                // 如果取消勾选，且当前正是绑定了这个预设，则解绑
                if (chat.settings.naiPresetId === currentNaiPresetId) {
                    delete chat.settings.naiPresetId;
                    updates.push(chat);
                }
            }
        }
    }
    
    if (updates.length > 0) {
        await db.chats.bulkPut(updates);
        await showCustomAlert("保存成功", `已更新 ${updates.length} 个角色的绑定设置。`);
    } else {
        // 无变化
    }
    
    document.getElementById('nai-binding-modal').classList.remove('visible');
}
  function loadNovelAISettings() {
    const settings = getNovelAISettings();
    document.getElementById('nai-resolution').value = settings.resolution;
    document.getElementById('nai-steps').value = settings.steps;
    document.getElementById('nai-cfg-scale').value = settings.cfg_scale;
    document.getElementById('nai-sampler').value = settings.sampler;
    document.getElementById('nai-seed').value = settings.seed;
    document.getElementById('nai-uc-preset').value = settings.uc_preset;
    document.getElementById('nai-quality-toggle').checked = settings.quality_toggle;
    document.getElementById('nai-smea').checked = settings.smea;
    document.getElementById('nai-smea-dyn').checked = settings.smea_dyn;
    document.getElementById('nai-default-positive').value = settings.default_positive;
    document.getElementById('nai-default-negative').value = settings.default_negative;
    document.getElementById('nai-cors-proxy').value = settings.cors_proxy;
    document.getElementById('nai-custom-proxy-url').value = settings.custom_proxy_url || '';

  
    const customProxyGroup = document.getElementById('nai-custom-proxy-group');
    customProxyGroup.style.display = settings.cors_proxy === 'custom' ? 'block' : 'none';
    loadNaiPresetsDropdown();
  }

  function saveNovelAISettings() {
   
    const novelaiEnabled = document.getElementById('novelai-switch').checked;
    const novelaiModel = document.getElementById('novelai-model').value;
    const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();

    localStorage.setItem('novelai-enabled', novelaiEnabled);
    localStorage.setItem('novelai-model', novelaiModel);
    localStorage.setItem('novelai-api-key', novelaiApiKey);

  
    const settings = {
      resolution: document.getElementById('nai-resolution').value,
      steps: parseInt(document.getElementById('nai-steps').value),
      cfg_scale: parseFloat(document.getElementById('nai-cfg-scale').value),
      sampler: document.getElementById('nai-sampler').value,
      seed: parseInt(document.getElementById('nai-seed').value),
      uc_preset: parseInt(document.getElementById('nai-uc-preset').value),
      quality_toggle: document.getElementById('nai-quality-toggle').checked,
      smea: document.getElementById('nai-smea').checked,
      smea_dyn: document.getElementById('nai-smea-dyn').checked,
      default_positive: document.getElementById('nai-default-positive').value,
      default_negative: document.getElementById('nai-default-negative').value,
      cors_proxy: document.getElementById('nai-cors-proxy').value,
      custom_proxy_url: document.getElementById('nai-custom-proxy-url').value
    };

    localStorage.setItem('novelai-settings', JSON.stringify(settings));
  }

  function resetNovelAISettings() {
    localStorage.removeItem('novelai-settings');
    loadNovelAISettings();
    alert('已恢复默认设置！');
  }

  function getNovelAISettings() {
    const defaultSettings = {
      resolution: '1024x1024',
      steps: 28,
      cfg_scale: 5,
      sampler: 'k_euler_ancestral',
      seed: -1,
      uc_preset: 1,
      quality_toggle: true,
      smea: true,
      smea_dyn: false,
      default_positive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
      default_negative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry',
      cors_proxy: 'https://corsproxy.io/?',
      custom_proxy_url: ''
    };

    const saved = localStorage.getItem('novelai-settings');
    if (saved) {
      try {
        return {
          ...defaultSettings,
          ...JSON.parse(saved)
        };
      } catch (e) {
        return defaultSettings;
      }
    }
    return defaultSettings;
  }

  async function generateNaiImageFromPrompt(aiPrompt, chatId) {
    console.log(`🎨 [NAI核心生成] 开始... Prompt: "${aiPrompt}", ChatID: ${chatId}`);

    
    const naiPrompts = getCharacterNAIPrompts(chatId);
    const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
    const finalNegativePrompt = naiPrompts.negative;

    console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
    console.log('   [+] 最终正面提示词:', finalPositivePrompt);
    console.log('   [-] 最终负面提示词:', finalNegativePrompt);

    const apiKey = localStorage.getItem('novelai-api-key');
    const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    let settings = getNovelAISettings(); // 先获取全局默认值

    // 【新增逻辑】检查当前聊天是否绑定了预设
    if (chatId && state.chats[chatId] && state.chats[chatId].settings.naiPresetId) {
        const presetId = state.chats[chatId].settings.naiPresetId;
        const preset = await db.naiPresets.get(presetId);
        
        if (preset && preset.settings) {
            console.log(`🎨 [NAI] 检测到角色绑定了预设 "${preset.name}"，正在应用预设参数...`);
            // 用预设参数覆盖全局参数 (Object.assign 是浅拷贝，这里够用了)
            // 注意：API Key 和 Proxy 还是用全局的，因为预设里没存
            settings = { ...settings, ...preset.settings };
            
            // 如果预设里有提示词，合并逻辑可能需要调整
            // 当前逻辑是：finalPositive = aiPrompt + characterPrompt + defaultPositive
            // 如果使用了预设，preset.settings.default_positive 会替换掉 getNovelAISettings() 里的 default_positive
            // 这符合预期：预设的“默认提示词”变成了该风格的提示词
        } else {
             console.warn(`[NAI] 角色绑定了预设ID ${presetId}，但数据库中未找到，将使用全局设置。`);
        }
    }

    if (!apiKey) {
      throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
    }

    const [width, height] = settings.resolution.split('x').map(Number);

    
    let requestBody;
    if (model.includes('nai-diffusion-4')) {
      requestBody = {
        input: finalPositivePrompt,
        model: model,
        action: 'generate',
        parameters: {
          params_version: 3,
          width: width,
          height: height,
          scale: settings.cfg_scale,
          sampler: settings.sampler,
          steps: settings.steps,
          seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
          n_samples: 1,
          ucPreset: settings.uc_preset,
          qualityToggle: settings.quality_toggle,
          add_original_image: true,
          noise_schedule: 'karras',
          v4_prompt: {
            caption: {
              base_caption: finalPositivePrompt,
              char_captions: []
            },
            use_coords: false,
            use_order: true
          },
          v4_negative_prompt: {
            caption: {
              base_caption: finalNegativePrompt,
              char_captions: []
            },
            legacy_uc: false
          },
          negative_prompt: finalNegativePrompt,
          autoSmea: false,
          dynamic_thresholding: false,
          controlnet_strength: 1,
          legacy: false,
          cfg_rescale: 0,
          legacy_v3_extend: false,
          skip_cfg_above_sigma: null,
          use_coords: false,
          legacy_uc: false,
          normalize_reference_strength_multiple: true,
          inpaintImg2ImgStrength: 1,
          characterPrompts: [],
          deliberate_euler_ancestral_bug: false,
          prefer_brownian: true
        }
      };
    } else {
     
      requestBody = {
        input: finalPositivePrompt,
        model: model,
        action: 'generate',
        parameters: {
          width: width,
          height: height,
          scale: settings.cfg_scale,
          sampler: settings.sampler,
          steps: settings.steps,
          seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
          n_samples: 1,
          ucPreset: settings.uc_preset,
          qualityToggle: settings.quality_toggle,
          sm: settings.smea,
          sm_dyn: settings.smea_dyn,
          negative_prompt: finalNegativePrompt,
          dynamic_thresholding: false,
          controlnet_strength: 1,
          legacy: false,
          add_original_image: false,
          cfg_rescale: 0,
          noise_schedule: 'native'
        }
      };
    }

    console.log('🚀 发送NAI请求:', requestBody);

  
    let apiUrl;
    if (model.includes('nai-diffusion-4')) {
      apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
    } else {
      apiUrl = 'https://image.novelai.net/ai/generate-image';
    }

    let corsProxy = settings.cors_proxy;
    if (corsProxy === 'custom') {
      corsProxy = settings.custom_proxy_url || '';
    }
    if (corsProxy && corsProxy !== '') {
      apiUrl = corsProxy + apiUrl;
    }

   
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + apiKey
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API请求失败 (${response.status}): ${errorText}`);
    }

    const contentType = response.headers.get('content-type');
    let zipBlob;
    let imageDataUrl;

  
    if (contentType && contentType.includes('text/event-stream')) {
    
      const text = await response.text();
      const lines = text.trim().split('\n');
      let base64Data = null;

      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
          const dataContent = line.substring(6);
          try {
            const jsonData = JSON.parse(dataContent);
            if (jsonData.event_type === 'final' && jsonData.image) {
              base64Data = jsonData.image;
              break;
            }
            if (jsonData.data) {
              base64Data = jsonData.data;
              break;
            }
            if (jsonData.image) {
              base64Data = jsonData.image;
              break;
            }
          } catch (e) {
            base64Data = dataContent;
            break;
          }
        }
      }
      if (!base64Data) throw new Error('无法从 SSE 响应中提取图片数据');

      const isPNG = base64Data.startsWith('iVBORw0KGgo');
      const isJPEG = base64Data.startsWith('/9j/');

      if (isPNG || isJPEG) {
       
        imageDataUrl = `data:${isPNG ? 'image/png' : 'image/jpeg'};base64,${base64Data}`;
      } else {
       
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
        zipBlob = new Blob([bytes]);
      }
    } else {
      
      zipBlob = await response.blob();
    }

 
    if (!imageDataUrl && zipBlob) {
      if (typeof JSZip === 'undefined') throw new Error('JSZip库未加载');

      const zip = await JSZip.loadAsync(zipBlob);
      let imageFile = null;
      for (let filename in zip.files) {
        if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
          imageFile = zip.files[filename];
          break;
        }
      }
      if (!imageFile) throw new Error('ZIP文件中未找到图片');

      const imageBlob = await imageFile.async('blob');

   
      imageDataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(imageBlob);
      });
    }

    console.log(`✅ [NAI核心生成] 成功！`);
    return {
      imageUrl: imageDataUrl,
      fullPrompt: finalPositivePrompt
    };
  }
 
  function getCharacterNAIPrompts(chatId) {
   
    const systemSettings = getNovelAISettings();

  
    if (!chatId || !state.chats[chatId]) {
      console.log('⚠️ NAI提示词：没有角色，使用系统配置');
      return {
        positive: systemSettings.default_positive,
        negative: systemSettings.default_negative,
        source: 'system'
      };
    }

    const chat = state.chats[chatId];
    const naiSettings = chat.settings.naiSettings || {};

 
    if (naiSettings.promptSource === 'character') {
      console.log('✅ NAI提示词：使用角色配置');
      console.log('   正面:', naiSettings.characterPositivePrompt || '(空)');
      console.log('   负面:', naiSettings.characterNegativePrompt || '(空)');

      return {
        positive: naiSettings.characterPositivePrompt || '',
        negative: naiSettings.characterNegativePrompt || '',
        source: 'character'
      };
    } else {
      console.log('✅ NAI提示词：使用系统配置');
      console.log('   正面:', systemSettings.default_positive || '(空)');
      console.log('   负面:', systemSettings.default_negative || '(空)');

      return {
        positive: systemSettings.default_positive,
        negative: systemSettings.default_negative,
        source: 'system'
      };
    }
  }


  async function generateNovelAIImage() {
    const apiKey = document.getElementById('novelai-api-key').value.trim();
    const model = document.getElementById('novelai-model').value;
    const prompt = document.getElementById('nai-test-prompt').value.trim();

    if (!apiKey) {
      alert('请先配置NovelAI API Key！');
      return;
    }

    if (!prompt) {
      alert('请输入提示词！');
      return;
    }

    const settings = getNovelAISettings();
    const negativePrompt = document.getElementById('nai-test-negative').value.trim();

    const statusDiv = document.getElementById('nai-test-status');
    const resultDiv = document.getElementById('nai-test-result');
    const errorDiv = document.getElementById('nai-test-error');
    const generateBtn = document.getElementById('nai-generate-btn');

    statusDiv.style.display = 'block';
    resultDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    generateBtn.disabled = true;
    generateBtn.textContent = '生成中...';

    try {
      const [width, height] = settings.resolution.split('x').map(Number);

     
      let requestBody;

      if (model.includes('nai-diffusion-4')) {
      
        requestBody = {
          input: prompt,
          model: model,
          action: 'generate',
          parameters: {
            params_version: 3, // V4必须使用版本3
            width: width,
            height: height,
            scale: settings.cfg_scale,
            sampler: settings.sampler,
            steps: settings.steps,
            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
            n_samples: 1,
            ucPreset: settings.uc_preset,
            qualityToggle: settings.quality_toggle,
            autoSmea: false,
            dynamic_thresholding: false,
            controlnet_strength: 1,
            legacy: false,
            add_original_image: true,
            cfg_rescale: 0,
            noise_schedule: 'karras', // V4使用karras
            legacy_v3_extend: false,
            skip_cfg_above_sigma: null,
            use_coords: false,
            legacy_uc: false,
            normalize_reference_strength_multiple: true,
            inpaintImg2ImgStrength: 1,
            characterPrompts: [],
          
            v4_prompt: {
              caption: {
                base_caption: prompt,
                char_captions: []
              },
              use_coords: false,
              use_order: true
            },
           
            v4_negative_prompt: {
              caption: {
                base_caption: negativePrompt,
                char_captions: []
              },
              legacy_uc: false
            },
            negative_prompt: negativePrompt,
            deliberate_euler_ancestral_bug: false,
            prefer_brownian: true
          
          }
        };
      } else {
       
        requestBody = {
          input: prompt,
          model: model,
          action: 'generate',
          parameters: {
            width: width,
            height: height,
            scale: settings.cfg_scale,
            sampler: settings.sampler,
            steps: settings.steps,
            seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
            n_samples: 1,
            ucPreset: settings.uc_preset,
            qualityToggle: settings.quality_toggle,
            sm: settings.smea,
            sm_dyn: settings.smea_dyn,
            dynamic_thresholding: false,
            controlnet_strength: 1,
            legacy: false,
            add_original_image: false,
            cfg_rescale: 0,
            noise_schedule: 'native',
            negative_prompt: negativePrompt
          }
        };
      }

      console.log('📤 发送请求到 NovelAI API');
      console.log('📊 使用模型:', model);
      console.log('📋 请求体:', JSON.stringify(requestBody, null, 2));

     
      let apiUrl;

   
      if (model.includes('nai-diffusion-4')) {
   
        apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
      } else {
      
        apiUrl = 'https://image.novelai.net/ai/generate-image';
      }

      let corsProxy = settings.cors_proxy;

     
      if (corsProxy === 'custom') {
        corsProxy = settings.custom_proxy_url || '';
      }

      
      if (corsProxy && corsProxy !== '') {
        apiUrl = corsProxy + encodeURIComponent(apiUrl);
      }

   
      const isChrome = /Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
      let fetchOptions = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + apiKey
        },
        body: JSON.stringify(requestBody)
      };

     
      if (isChrome) {
        console.log('🔧 检测到Chrome浏览器，启用headers兼容性处理');
        const cleanHeaders = {};
        for (const [key, value] of Object.entries(fetchOptions.headers)) {
         
          cleanHeaders[key] = value.replace(/[^\x00-\xFF]/g, '');
        }
        fetchOptions.headers = cleanHeaders;
      }

      const response = await fetch(apiUrl, fetchOptions);

      console.log('Response status:', response.status);
      console.log('Response headers:', [...response.headers.entries()]);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('API错误响应:', errorText);
        throw new Error(`API请求失败 (${response.status}): ${errorText}`);
      }

     
      const contentType = response.headers.get('content-type');
      console.log('Content-Type:', contentType);

    
      let zipBlob;
      if (contentType && contentType.includes('text/event-stream')) {
        console.log('检测到 SSE 流式响应，开始解析...');
        statusDiv.textContent = '正在接收流式数据...';

      
        const text = await response.text();
        console.log('收到 SSE 数据，大小:', text.length);

        const lines = text.trim().split('\n');
        let base64Data = null;

        for (let i = lines.length - 1; i >= 0; i--) {
          const line = lines[i].trim();
          if (line.startsWith('data: ') && line !== 'data: [DONE]') {
            const dataContent = line.substring(6);

            
            try {
              const jsonData = JSON.parse(dataContent);

            
              if (jsonData.event_type === 'final' && jsonData.image) {
                base64Data = jsonData.image;
                console.log('✅ 找到 final 事件的图片数据');
                break;
              }

            
              if (jsonData.data) {
                base64Data = jsonData.data;
                console.log('从 JSON.data 中提取图片数据');
                break;
              }
              if (jsonData.image) {
                base64Data = jsonData.image;
                console.log('从 JSON.image 中提取图片数据');
                break;
              }
            } catch (e) {
           
              base64Data = dataContent;
              console.log('直接使用 base64 数据');
              break;
            }
          }
        }

        if (!base64Data) {
          throw new Error('无法从 SSE 响应中提取图片数据');
        }

       
        const isPNG = base64Data.startsWith('iVBORw0KGgo');
        const isJPEG = base64Data.startsWith('/9j/');

        if (isPNG || isJPEG) {
          console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
         
          const binaryString = atob(base64Data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const imageBlob = new Blob([bytes], {
            type: isPNG ? 'image/png' : 'image/jpeg'
          });
          console.log('图片 Blob 创建成功，大小:', imageBlob.size);

          // 直接显示图片
          const imageUrl = URL.createObjectURL(imageBlob);
          document.getElementById('nai-result-image').src = imageUrl;
          statusDiv.style.display = 'none';
          resultDiv.style.display = 'block';
          console.log('✅ 图片显示成功！🎨');
          return;
        }

     
        console.log('当作 ZIP 文件处理...');
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        zipBlob = new Blob([bytes]);
        console.log('ZIP Blob 大小:', zipBlob.size);

      } else {
       
        zipBlob = await response.blob();
        console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
      }

     
      try {
       
        if (typeof JSZip === 'undefined') {
          throw new Error('JSZip库未加载，请刷新页面重试');
        }

        statusDiv.textContent = '正在解压图片...';

        const zip = await JSZip.loadAsync(zipBlob);
        console.log('ZIP文件内容:', Object.keys(zip.files));

        let imageFile = null;
        for (let filename in zip.files) {
          if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
            imageFile = zip.files[filename];
            console.log('找到图片文件:', filename);
            break;
          }
        }

        if (!imageFile) {
          throw new Error('ZIP文件中未找到图片');
        }

        const imageBlob = await imageFile.async('blob');
        console.log('提取的图片大小:', imageBlob.size);

        const imageUrl = URL.createObjectURL(imageBlob);
        console.log('生成的图片URL:', imageUrl);

        document.getElementById('nai-result-image').src = imageUrl;
        statusDiv.style.display = 'none';
        resultDiv.style.display = 'block';

      } catch (zipError) {
        console.error('ZIP解压失败:', zipError);
       
        console.log('尝试直接作为图片显示...');

        if (zipBlob.type.startsWith('image/')) {
          const imageUrl = URL.createObjectURL(zipBlob);
          document.getElementById('nai-result-image').src = imageUrl;
          statusDiv.style.display = 'none';
          resultDiv.style.display = 'block';
        } else {
          throw new Error('图片格式处理失败: ' + zipError.message);
        }
      }

    } catch (error) {
      console.error('NovelAI生成失败:', error);
      statusDiv.style.display = 'none';
      errorDiv.style.display = 'block';
      errorDiv.textContent = '生成失败: ' + error.message;
    } finally {
      generateBtn.disabled = false;
      generateBtn.textContent = '生成图像';
    }
  }

  function showNotification(chatId, messageContent) {

    playNotificationSound();

    clearTimeout(notificationTimeout);
    const chat = state.chats[chatId];
    if (!chat) return;


    const bar = document.getElementById('notification-bar');


    document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
    document.getElementById('notification-content').querySelector('.name').textContent = chat.name;
    document.getElementById('notification-content').querySelector('.message').textContent = messageContent;



    bar.classList.remove('visible');


    void bar.offsetWidth;


    bar.classList.add('visible');


    const newBar = bar.cloneNode(true);
    bar.parentNode.replaceChild(newBar, bar);
    newBar.addEventListener('click', () => {
      openChat(chatId);
      newBar.classList.remove('visible');
    });


    notificationTimeout = setTimeout(() => {
      newBar.classList.remove('visible');
    }, 4000);
    updateBackButtonUnreadCount();
    
    // 新增：触发系统级通知
    console.log('[系统通知调试] showNotification 被调用:', {
      chatId,
      messageContent,
      systemNotificationEnabled: state.globalSettings.systemNotification?.enabled,
      notificationPermission: typeof Notification !== 'undefined' ? Notification.permission : 'N/A'
    });
    
    if (state.globalSettings.systemNotification?.enabled) {
      console.log('[系统通知调试] 准备调用 handleSystemNotification');
      handleSystemNotification(chatId, messageContent);
    } else {
      console.log('[系统通知调试] 系统通知未启用或配置不存在');
    }
  }

  function updateClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', {
      hour: '2-digit',
      minute: '2-digit'
    });
    const dateString = now.toLocaleDateString('zh-CN', {
      weekday: 'long',
      month: 'long',
      day: 'numeric'
    });


    document.getElementById('status-bar-time').textContent = timeString;

  }


 
  function parseAiResponse(content) {
    if (!content) return [{
      type: 'text',
      content: '(AI返回了空内容)'
    }];

    let trimmedContent = content.trim();

   
    const markdownRegex = /```json\s*([\s\S]*?)\s*```/;
    const markdownMatch = trimmedContent.match(markdownRegex);

    if (markdownMatch && markdownMatch[1]) {
    
      trimmedContent = markdownMatch[1].trim();
      console.log("解析器：已启用 Markdown 提取模式。");
    }

  
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
      try {
        const parsed = JSON.parse(trimmedContent);
        if (Array.isArray(parsed)) {
          console.log("解析成功：标准JSON数组格式。");
          return parsed;
        }
      } catch (e) {
        console.warn("标准JSON数组解析失败，将尝试强力提取...");
      }
    }

  
    const startIndex = trimmedContent.indexOf('[');

  
    const lastBraceIndex = trimmedContent.lastIndexOf('}');

    if (startIndex !== -1 && lastBraceIndex !== -1 && lastBraceIndex > startIndex) {

  
      const endIndex = trimmedContent.indexOf(']', lastBraceIndex);

      if (endIndex !== -1) {
        const arrayString = trimmedContent.substring(startIndex, endIndex + 1);
        try {
          const parsed = JSON.parse(arrayString);
          if (Array.isArray(parsed)) {
            console.log("解析成功：通过强力提取 [ ... } ... ] 模式。");
            return parsed;
          }
        } catch (e) {
          console.warn("强力提取 [ ... } ... ] 失败，将尝试提取单个对象...");
        }
      }
    }

 
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
    if (jsonMatches) {
      const results = [];
      for (const match of jsonMatches) {
        try {
          const parsedObject = JSON.parse(match);
          results.push(parsedObject);
        } catch (e) {
          console.warn("跳过一个无效的JSON片段:", match);
        }
      }

      if (results.length > 0) {
        console.log("解析成功：通过强力提取 {...} 模式。");
        return results;
      }
    }

  
    console.error("所有解析方案均失败！将返回原始文本。原始回复:", content);
    return [{
      type: 'text',
      content: content
    }];
  }

  function getTimeOfDayGreeting(date = new Date()) {
    const hour = date.getHours();
    if (hour >= 0 && hour < 5) {
      return "凌晨";
    } else if (hour >= 5 && hour < 9) {
      return "早上";
    } else if (hour >= 9 && hour < 13) {
      return "上午";
    } else if (hour >= 13 && hour < 18) {
      return "下午";
    } else if (hour >= 18 && hour < 24) {
      return "晚上";
    }
    return "现在";
  }


  
  async function loadApiPresetsDropdown(forceSelectedId = null) {
    const selectEl = document.getElementById('api-preset-select');
    selectEl.innerHTML = '<option value="current">当前配置 (未保存)</option>';

    const presets = await db.apiPresets.toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });

   if (forceSelectedId) { // <--- 2. 新增这段判断逻辑
        selectEl.value = forceSelectedId;
        return; 
    }
    const currentConfig = state.apiConfig;
    let matchingPresetId = null;
    for (const preset of presets) {

      if (
        preset.proxyUrl === currentConfig.proxyUrl &&
        preset.apiKey === currentConfig.apiKey &&
        preset.model === currentConfig.model &&
        preset.secondaryProxyUrl === currentConfig.secondaryProxyUrl &&
        preset.secondaryApiKey === currentConfig.secondaryApiKey &&
        preset.secondaryModel === currentConfig.secondaryModel &&

        (preset.minimaxGroupId || '') === (currentConfig.minimaxGroupId || '') &&
        (preset.minimaxApiKey || '') === (currentConfig.minimaxApiKey || '') &&
        (preset.minimaxModel || 'speech-01') === (currentConfig.minimaxModel || 'speech-01')
      )

      {
        matchingPresetId = preset.id;
        break;
      }
    }

    if (matchingPresetId) {
      selectEl.value = matchingPresetId;
    } else {
      selectEl.value = 'current';
    }
  }

 
  async function handlePresetSelectionChange() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      return;
    }

    const preset = await db.apiPresets.get(selectedId);
    if (preset) {
      // 1. 加载预设 (这会覆盖当前的 config)
      state.apiConfig = {
        id: 'main',
        proxyUrl: preset.proxyUrl,
        apiKey: preset.apiKey,
        model: preset.model,
        secondaryProxyUrl: preset.secondaryProxyUrl,
        secondaryApiKey: preset.secondaryApiKey,
        secondaryModel: preset.secondaryModel,
        minimaxGroupId: preset.minimaxGroupId,
        minimaxApiKey: preset.minimaxApiKey,
        minimaxModel: preset.minimaxModel
      };

      
      const savedImgbbEnabled = localStorage.getItem('imgbb-enabled');
      const savedImgbbKey = localStorage.getItem('imgbb-api-key');
      const savedCatboxEnabled = localStorage.getItem('catbox-enabled');
      const savedCatboxHash = localStorage.getItem('catbox-userhash');

      if (savedImgbbEnabled !== null) state.apiConfig.imgbbEnable = (savedImgbbEnabled === 'true');
      if (savedImgbbKey !== null) state.apiConfig.imgbbApiKey = savedImgbbKey;
      
      if (savedCatboxEnabled !== null) state.apiConfig.catboxEnable = (savedCatboxEnabled === 'true');
      if (savedCatboxHash !== null) state.apiConfig.catboxUserHash = savedCatboxHash;
      const savedMinimaxGroupId = localStorage.getItem('minimax-group-id');
      const savedMinimaxApiKey = localStorage.getItem('minimax-api-key');
      const savedMinimaxModel = localStorage.getItem('minimax-model');

      if (savedMinimaxGroupId !== null) state.apiConfig.minimaxGroupId = savedMinimaxGroupId;
      if (savedMinimaxApiKey !== null) state.apiConfig.minimaxApiKey = savedMinimaxApiKey;
      if (savedMinimaxModel !== null) state.apiConfig.minimaxModel = savedMinimaxModel;
      const savedGhEnabled = localStorage.getItem('github-enabled');
      const savedGhAuto = localStorage.getItem('github-auto-backup');
      const savedGhInterval = localStorage.getItem('github-backup-interval');
      const savedGhProxyEnabled = localStorage.getItem('github-proxy-enabled');
      const savedGhProxyUrl = localStorage.getItem('github-proxy-url');
      
      // 关键：读取账号信息
      const savedGhUsername = localStorage.getItem('github-username');
      const savedGhRepo = localStorage.getItem('github-repo');
      const savedGhToken = localStorage.getItem('github-token');
      const savedGhFilename = localStorage.getItem('github-filename');

      if (savedGhEnabled !== null) state.apiConfig.githubEnable = (savedGhEnabled === 'true');
      if (savedGhAuto !== null) state.apiConfig.githubAutoBackup = (savedGhAuto === 'true');
      if (savedGhInterval !== null) state.apiConfig.githubBackupInterval = parseInt(savedGhInterval);
      if (savedGhProxyEnabled !== null) state.apiConfig.githubProxyEnable = (savedGhProxyEnabled === 'true');
      if (savedGhProxyUrl !== null) state.apiConfig.githubProxyUrl = savedGhProxyUrl;

      if (savedGhUsername !== null) state.apiConfig.githubUsername = savedGhUsername;
      if (savedGhRepo !== null) state.apiConfig.githubRepo = savedGhRepo;
      if (savedGhToken !== null) state.apiConfig.githubToken = savedGhToken;
      if (savedGhFilename !== null) state.apiConfig.githubFilename = savedGhFilename;
      await db.apiConfig.put(state.apiConfig);

      renderApiSettings(selectedId);

      document.getElementById('fetch-models-btn').click();
      if (preset.secondaryProxyUrl && preset.secondaryApiKey) {
        document.getElementById('fetch-secondary-models-btn').click();
      }
      //alert(`已加载预设 “${preset.name}”`);
    }
  }

  
  async function saveApiPreset() {
    const name = await showCustomPrompt('保存 API 预设', '请输入预设名称');
    if (!name || !name.trim()) return;


    const presetData = {
      name: name.trim(),
      proxyUrl: document.getElementById('proxy-url').value.trim(),
      apiKey: document.getElementById('api-key').value.trim(),
      model: document.getElementById('model-select').value,
      secondaryProxyUrl: document.getElementById('secondary-proxy-url').value.trim(),
      secondaryApiKey: document.getElementById('secondary-api-key').value.trim(),
      secondaryModel: document.getElementById('secondary-model-select').value,

      minimaxGroupId: document.getElementById('minimax-group-id').value.trim(),
      minimaxApiKey: document.getElementById('minimax-api-key').value.trim(),
      minimaxModel: document.getElementById('minimax-model-select').value

    };


    const existingPreset = await db.apiPresets.where('name').equals(presetData.name).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('覆盖预设', `名为 “${presetData.name}” 的预设已存在。要覆盖它吗？`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;
      presetData.id = existingPreset.id;
    }

    await db.apiPresets.put(presetData);
    await loadApiPresetsDropdown();
    alert('API 预设已保存！');
  }


  async function deleteApiPreset() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('请先从下拉框中选择一个要删除的预设。');
      return;
    }

    const preset = await db.apiPresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.apiPresets.delete(selectedId);
      await loadApiPresetsDropdown();
      alert('预设已删除。');
    }
  }

  function renderApiSettings(forcePresetId = null) {

    document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || '';
    document.getElementById('api-key').value = state.apiConfig.apiKey || '';
    document.getElementById('secondary-proxy-url').value = state.apiConfig.secondaryProxyUrl || '';
    document.getElementById('secondary-api-key').value = state.apiConfig.secondaryApiKey || '';
    document.getElementById('background-activity-switch').checked = state.globalSettings.enableBackgroundActivity || false;
    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;
    document.getElementById('enable-ai-drawing-switch').checked = state.globalSettings.enableAiDrawing;
    
    // 新增：读取心声和动态功能开关
    document.getElementById('global-enable-thoughts-switch').checked = state.globalSettings.enableThoughts || false;
    document.getElementById('global-enable-qzone-actions-switch').checked = state.globalSettings.enableQzoneActions || false;
    
    document.getElementById('chat-render-window-input').value = state.globalSettings.chatRenderWindow || 50;
    document.getElementById('chat-list-render-window-input').value = state.globalSettings.chatListRenderWindow || 30;
    const tempSlider = document.getElementById('api-temperature-slider');
    const tempValue = document.getElementById('api-temperature-value');
    const savedTemp = state.globalSettings.apiTemperature || 0.8;
    tempSlider.value = savedTemp;
    tempValue.textContent = savedTemp;
    const savedMinimaxGroupId = localStorage.getItem('minimax-group-id');
    const savedMinimaxApiKey = localStorage.getItem('minimax-api-key');
    const savedMinimaxModel = localStorage.getItem('minimax-model');

    
    if (savedMinimaxGroupId !== null) state.apiConfig.minimaxGroupId = savedMinimaxGroupId;
    if (savedMinimaxApiKey !== null) state.apiConfig.minimaxApiKey = savedMinimaxApiKey;
    if (savedMinimaxModel !== null) state.apiConfig.minimaxModel = savedMinimaxModel;

   
    document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
    document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
    const minimaxSelect = document.getElementById('minimax-model-select');
    if (minimaxSelect) {
        // 1. 填充模型列表 (已接入 Minimax 全系列模型)
        const supportedMinimaxModels = [
            // --- 01 系列 (经典) ---
            
            { id: 'speech-01-turbo', name: 'Speech-01 Turbo (快速版)' },
            { id: 'speech-01-hd', name: 'Speech-01 HD (高清版)' },
            
            
            // --- 02 系列 ---
            
            { id: 'speech-02-turbo', name: 'Speech-02 Turbo' },
            { id: 'speech-02-hd', name: 'Speech-02 HD' },

            // --- 2.x 系列 (包含您要的 2.5) ---
            { id: 'speech-2.5-hd-preview', name: 'Speech-2.5 HD (高清)' },
            { id: 'speech-2.6-turbo', name: 'Speech-2.6 Turbo' },
            { id: 'speech-2.6-hd', name: 'Speech-2.6 HD' },

           
        ];

        minimaxSelect.innerHTML = ''; 
        supportedMinimaxModels.forEach(m => {
            const option = document.createElement('option');
            option.value = m.id;
            option.textContent = m.name;
            minimaxSelect.appendChild(option);
        });
        minimaxSelect.value = state.apiConfig.minimaxModel || 'speech-01';

        // 2. 【新增】动态插入“接口域名”选择框 (如果还没有的话)
        

        // 3. 【新增】回显保存的设置
        const domainSelect = document.getElementById('minimax-domain-select');
        if (domainSelect) {
            // 优先读取 state，没有则读取 localStorage，默认国内
            domainSelect.value = state.apiConfig.minimaxDomain || localStorage.getItem('minimax-domain') || 'https://api.minimax.chat';
        }
    }

   
    const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
    const novelaiModel = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
    const novelaiApiKey = localStorage.getItem('novelai-api-key') || '';
    document.getElementById('novelai-switch').checked = novelaiEnabled;
    document.getElementById('novelai-model').value = novelaiModel;
    document.getElementById('novelai-api-key').value = novelaiApiKey;
    document.getElementById('novelai-details').style.display = novelaiEnabled ? 'block' : 'none';
    const imgbbEnableSwitch = document.getElementById('imgbb-enable-switch');
    const imgbbApiKeyInput = document.getElementById('imgbb-api-key');
    const imgbbDetailsDiv = document.getElementById('imgbb-settings-details');

   
    const savedImgbbEnabled = localStorage.getItem('imgbb-enabled');
    const savedImgbbKey = localStorage.getItem('imgbb-api-key');

   
    if (savedImgbbEnabled !== null) state.apiConfig.imgbbEnable = (savedImgbbEnabled === 'true');
    if (savedImgbbKey !== null) state.apiConfig.imgbbApiKey = savedImgbbKey;

    if(imgbbEnableSwitch) {
        imgbbEnableSwitch.checked = state.apiConfig.imgbbEnable || false;
        imgbbApiKeyInput.value = state.apiConfig.imgbbApiKey || '';
        imgbbDetailsDiv.style.display = imgbbEnableSwitch.checked ? 'block' : 'none';
    }

    
    const catboxEnableSwitch = document.getElementById('catbox-enable-switch');
    const catboxUserHashInput = document.getElementById('catbox-userhash');
    const catboxDetailsDiv = document.getElementById('catbox-settings-details');

   
    const savedCatboxEnabled = localStorage.getItem('catbox-enabled');
    const savedCatboxHash = localStorage.getItem('catbox-userhash');

    
    if (savedCatboxEnabled !== null) state.apiConfig.catboxEnable = (savedCatboxEnabled === 'true');
    if (savedCatboxHash !== null) state.apiConfig.catboxUserHash = savedCatboxHash;

    if(catboxEnableSwitch) {
        catboxEnableSwitch.checked = state.apiConfig.catboxEnable || false;
        catboxUserHashInput.value = state.apiConfig.catboxUserHash || '';
        catboxDetailsDiv.style.display = catboxEnableSwitch.checked ? 'block' : 'none';
    }
    const ghSwitch = document.getElementById('github-enable-switch');
    const ghDetails = document.getElementById('github-settings-details');

    // 从 localStorage 读取，如果没有则读取 apiConfig (保持一致性)
    const savedGhEnabled = localStorage.getItem('github-enabled');
    if (savedGhEnabled !== null) state.apiConfig.githubEnable = (savedGhEnabled === 'true');

    if (ghSwitch) {
        ghSwitch.checked = state.apiConfig.githubEnable || false;
        
        // 核心逻辑：根据开关状态决定是否显示详情框
        ghDetails.style.display = ghSwitch.checked ? 'block' : 'none';
        const ghAutoSwitch = document.getElementById('github-auto-backup-switch');
        const ghIntervalInput = document.getElementById('github-backup-interval'); // 【新增】

        if (ghAutoSwitch) {
            const savedAuto = localStorage.getItem('github-auto-backup');
            ghAutoSwitch.checked = savedAuto !== null ? (savedAuto === 'true') : false;
            
            // 【新增】回显分钟数，默认 30
            const savedInterval = localStorage.getItem('github-backup-interval');
            if (ghIntervalInput) {
                ghIntervalInput.value = savedInterval ? parseInt(savedInterval) : 30;
            }
        }
        // 回显输入框的值
        document.getElementById('github-username').value = state.apiConfig.githubUsername || '';
        document.getElementById('github-repo').value = state.apiConfig.githubRepo || '';
        document.getElementById('github-token').value = state.apiConfig.githubToken || '';
        document.getElementById('github-filename').value = state.apiConfig.githubFilename || 'ephone_backup.json';
        const ghProxySwitch = document.getElementById('github-proxy-switch');
        const ghProxyInputDiv = document.getElementById('github-proxy-input-group');
        const ghProxyUrlInput = document.getElementById('github-proxy-url');

        // 读取保存的设置
        const savedGhProxyEnabled = localStorage.getItem('github-proxy-enabled');
        const savedGhProxyUrl = localStorage.getItem('github-proxy-url');

        // 设置状态
        state.apiConfig.githubProxyEnable = savedGhProxyEnabled === 'true';
        state.apiConfig.githubProxyUrl = savedGhProxyUrl || '';

        if (ghProxySwitch) {
            ghProxySwitch.checked = state.apiConfig.githubProxyEnable;
            ghProxyInputDiv.style.display = ghProxySwitch.checked ? 'block' : 'none';
            ghProxyUrlInput.value = state.apiConfig.githubProxyUrl || '';

            // 绑定切换事件，控制输入框显示
            ghProxySwitch.addEventListener('change', (e) => {
                ghProxyInputDiv.style.display = e.target.checked ? 'block' : 'none';
            });
        }
    }
    loadApiPresetsDropdown(forcePresetId);
    displayTotalImageSize();
  }

  window.renderApiSettingsProxy = renderApiSettings;



  async function renderNpcListScreen() {
    const listEl = document.getElementById('npc-list');
    listEl.innerHTML = '';

    const npcs = await db.npcs.toArray();

    if (npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有创建任何NPC，<br>点击右上角“+”添加第一个吧！</p>';
      return;
    }

    npcs.forEach(npc => {
      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.dataset.npcId = npc.id;

      item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar" style="border-radius: 50%;">
            <div class="info">
                <div class="name-line">
                    <span class="name">${npc.name}</span>
                </div>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;

      item.addEventListener('click', () => openNpcEditor(npc.id));


      addLongPressListener(item, async () => {
        await deleteNpc(npc.id);
      });

      listEl.appendChild(item);
    });
  }


 
  async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    const modal = document.getElementById('npc-editor-modal');
    const titleEl = document.getElementById('npc-editor-title');
    const nameInput = document.getElementById('npc-name-input');
    const personaInput = document.getElementById('npc-persona-input');
    const avatarPreview = document.getElementById('npc-avatar-preview');
    const associationListEl = document.getElementById('npc-association-list');

   
    const groupSelectEl = document.getElementById('npc-group-select');

    const activitySwitch = document.getElementById('npc-background-activity-switch');
    const cooldownInput = document.getElementById('npc-action-cooldown-input');

    associationListEl.innerHTML = '';
    groupSelectEl.innerHTML = '<option value="">-- 未分组 --</option>'; 

   
    const npcGroups = await db.npcGroups.toArray();
    npcGroups.forEach(group => {
      const option = document.createElement('option');
      option.value = group.id;
      option.textContent = group.name;
      groupSelectEl.appendChild(option);
    });

  
    associationListEl.innerHTML += `<label><input type="checkbox" value="user"> ${state.qzoneSettings.nickname || '我'} (用户)</label>`;
    Object.values(state.chats).filter(c => !c.isGroup).forEach(char => {
      associationListEl.innerHTML += `<label><input type="checkbox" value="${char.id}"> ${char.name} (角色)</label>`;
    });

    if (npcId) {
      titleEl.textContent = '编辑 NPC';
      const npc = await db.npcs.get(npcId);
      if (npc) {
        nameInput.value = npc.name;
        personaInput.value = npc.persona;
        avatarPreview.src = npc.avatar || defaultGroupMemberAvatar;
        activitySwitch.checked = npc.enableBackgroundActivity !== false;
        cooldownInput.value = npc.actionCooldownMinutes || 15;
        groupSelectEl.value = npc.npcGroupId || ''; 

        if (npc.associatedWith && Array.isArray(npc.associatedWith)) {
          npc.associatedWith.forEach(id => {
            const checkbox = associationListEl.querySelector(`input[value="${id}"]`);
            if (checkbox) checkbox.checked = true;
          });
        }
      }
    } else {
      titleEl.textContent = '添加 NPC';
      nameInput.value = '';
      personaInput.value = '';
      avatarPreview.src = defaultGroupMemberAvatar;
      activitySwitch.checked = true;
      cooldownInput.value = 15;
      groupSelectEl.value = ''; 

      const userCheckbox = associationListEl.querySelector('input[value="user"]');
      if (userCheckbox) userCheckbox.checked = true;
    }

    modal.classList.add('visible');
  }




  async function saveNpc() {
    const name = document.getElementById('npc-name-input').value.trim();
    const persona = document.getElementById('npc-persona-input').value.trim();
    if (!name || !persona) {
      alert("NPC的昵称和人设都不能为空！");
      return;
    }

    const selectedAssociations = Array.from(document.querySelectorAll('#npc-association-list input:checked')).map(cb => cb.value);
    const enableBackgroundActivity = document.getElementById('npc-background-activity-switch').checked;
    const actionCooldownMinutes = parseInt(document.getElementById('npc-action-cooldown-input').value) || 15;

   
    const npcGroupId = parseInt(document.getElementById('npc-group-select').value) || null;

    const npcData = {
      name,
      persona,
      avatar: document.getElementById('npc-avatar-preview').src,
      associatedWith: selectedAssociations,
      enableBackgroundActivity: enableBackgroundActivity,
      actionCooldownMinutes: actionCooldownMinutes,
      npcGroupId: npcGroupId 
    };

    if (editingNpcId) {
      await db.npcs.update(editingNpcId, npcData);
    } else {
      const newNpcId = await db.npcs.add(npcData);
      if (isAddingNpcToGroup && state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        if (chat.isGroup) {
          chat.members.push({
            id: `npc_${newNpcId}`,
            originalName: name,
            groupNickname: name,
            persona: persona,
            avatar: npcData.avatar,
            isNpc: true
          });
          await db.chats.put(chat);
        }
      }
    }

    document.getElementById('npc-editor-modal').classList.remove('visible');

    if (isAddingNpcToGroup) {
      isAddingNpcToGroup = false;
      openMemberManagementScreen();
    } else {
      await renderNpcListScreen();
    }
  }
  async function openNpcGroupManager() {
    await renderNpcGroupsInManager();
    document.getElementById('npc-group-manager-modal').classList.add('visible');
  }


  async function renderNpcGroupsInManager() {
    const listEl = document.getElementById('existing-npc-groups-list');
    const categories = await db.npcGroups.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
      listEl.appendChild(item);
    });
  }


  async function addNewNpcGroup() {
    const input = document.getElementById('new-npc-group-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('分组名不能为空！');
      return;
    }
    const existing = await db.npcGroups.where('name').equals(name).first();
    if (existing) {
      alert(`分组 "${name}" 已经存在了！`);
      return;
    }
    await db.npcGroups.add({
      name
    });
    input.value = '';
    await renderNpcGroupsInManager();
  }


  async function deleteNpcGroup(groupId) {
    const confirmed = await showCustomConfirm(
      '确认删除',
      '删除分组后，该组内的所有NPC将变为“未分组”。确定要删除吗？', {
        confirmButtonClass: 'btn-danger'
      }
    );
    if (confirmed) {
      await db.npcGroups.delete(groupId);
      // 将属于该分组的NPC的 npcGroupId 设为 null
      await db.npcs.where('npcGroupId').equals(groupId).modify({
        npcGroupId: null
      });
      await renderNpcGroupsInManager();
    }
  }


  async function deleteNpc(npcId) {
    const npc = await db.npcs.get(npcId);
    if (!npc) return;
    const confirmed = await showCustomConfirm('删除NPC', `确定要删除NPC “${npc.name}” 吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.npcs.delete(npcId);
      await renderNpcListScreen();
    }
  }


  let chatListRenderCount = 0;



 
  function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
        <div class="chat-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${group.name}</span>
        </div>
        <div class="chat-group-content"></div>
    `;
    return groupContainer;
  }



 
  function loadMoreChats(sortedItems) {
    const chatListEl = document.getElementById('chat-list');
    const loadMoreBtn = document.getElementById('load-more-chats-btn');
    if (loadMoreBtn) loadMoreBtn.remove();

    const nextSliceStart = chatListRenderCount;
    const nextSliceEnd = chatListRenderCount + CHAT_LIST_RENDER_WINDOW;
    const itemsToAppend = sortedItems.slice(nextSliceStart, nextSliceEnd);


    const fragment = document.createDocumentFragment();
    let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

    itemsToAppend.forEach(item => {
      if (item.type === 'groupHeader') {
        const groupContainer = createChatGroupContainer(item.group);
        fragment.appendChild(groupContainer);
        currentGroupContent = groupContainer.querySelector('.chat-group-content');
      } else if (item.type === 'chatItem') {
        const listItem = createChatListItem(item.chat);
        if (currentGroupContent && item.chat.groupId) {
          currentGroupContent.appendChild(listItem);
        } else {
          fragment.appendChild(listItem);
          currentGroupContent = null;
        }
      }
    });


    chatListEl.appendChild(fragment);
    chatListRenderCount += itemsToAppend.length;

    if (sortedItems.length > chatListRenderCount) {
      appendLoadMoreChatsButton(chatListEl, sortedItems);
    }


    document.querySelectorAll('.chat-group-header').forEach(header => {
      const newHeader = header.cloneNode(true);
      header.parentNode.replaceChild(newHeader, header);
      newHeader.addEventListener('click', () => {
        newHeader.classList.toggle('collapsed');
        newHeader.nextElementSibling.classList.toggle('collapsed');
      });
    });
  }


  async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';


    const allChats = Object.values(state.chats).sort((a, b) => {
      const pinDiff = (b.isPinned || false) - (a.isPinned || false);
      if (pinDiff !== 0) return pinDiff;
      return (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0);
    });

    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
      chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
      return;
    }

    allGroups.forEach(group => {
      const latestChatInGroup = allChats.find(chat => chat.groupId === group.id);
      group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);


    sortedChatListItems = [];
    const processedChatIds = new Set();


    allChats.forEach(chat => {
      if (chat.isPinned) {
        sortedChatListItems.push({
          type: 'chatItem',
          chat
        });
        processedChatIds.add(chat.id);
      }
    });


    allGroups.forEach(group => {

      const groupChats = allChats.filter(chat =>
        !chat.isPinned &&
        !chat.isGroup &&
        chat.groupId === group.id
      );


      if (groupChats.length > 0) {
        sortedChatListItems.push({
          type: 'groupHeader',
          group
        });

        groupChats.forEach(chat => {
          sortedChatListItems.push({
            type: 'chatItem',
            chat
          });
          processedChatIds.add(chat.id);
        });
      }
    });


    allChats.forEach(chat => {
      if (!processedChatIds.has(chat.id)) {
        sortedChatListItems.push({
          type: 'chatItem',
          chat
        });
        processedChatIds.add(chat.id);
      }
    });


    chatListRenderCount = 0;
    loadMoreChats();
  }




  function createChatGroupContainer(group) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'chat-group-container';
    groupContainer.innerHTML = `
                <div class="chat-group-header">
                    <span class="arrow">▼</span>
                    <span class="group-name">${group.name}</span>
                </div>
                <div class="chat-group-content"></div>
            `;
    return groupContainer;
  }

  function appendLoadMoreChatsButton(container, sortedItems) {
    const button = document.createElement('button');
    button.id = 'load-more-chats-btn';
    button.textContent = '加载更早的会话';
    button.className = 'load-more-btn';


    button.addEventListener('click', () => loadMoreChats(sortedItems), {
      once: true
    });

    container.prepend(button);
  }


  function loadMoreChats() {
    if (isLoadingMoreChats) return;

    const chatListEl = document.getElementById('chat-list');
    const scrollContainer = document.getElementById('messages-view');
    if (!chatListEl || !scrollContainer) return;
    if (chatListRenderCount >= sortedChatListItems.length) return;

    isLoadingMoreChats = true;


    const isInitialLoad = chatListRenderCount === 0;


    const renderContent = () => {
      hideLoader(chatListEl);

      const renderWindow = state.globalSettings.chatListRenderWindow || 30;
      const nextSliceStart = chatListRenderCount;
      const nextSliceEnd = chatListRenderCount + renderWindow;
      const itemsToAppend = sortedChatListItems.slice(nextSliceStart, nextSliceEnd);

      const fragment = document.createDocumentFragment();
      let currentGroupContent = chatListEl.querySelector('.chat-group-content:last-of-type');

      itemsToAppend.forEach(item => {
        if (item.type === 'groupHeader') {
          const groupContainer = createChatGroupContainer(item.group);
          fragment.appendChild(groupContainer);
          currentGroupContent = groupContainer.querySelector('.chat-group-content');
        } else if (item.type === 'chatItem') {
          const listItem = createChatListItem(item.chat);
          if (item.chat.groupId && currentGroupContent) {
            currentGroupContent.appendChild(listItem);
          } else {
            fragment.appendChild(listItem);
            if (!item.chat.groupId) currentGroupContent = null;
          }
        }
      });

      chatListEl.appendChild(fragment);
      chatListRenderCount += itemsToAppend.length;

      chatListEl.querySelectorAll('.chat-group-header:not([data-has-listener="true"])').forEach(header => {
        header.dataset.hasListener = "true";
        header.addEventListener('click', () => {
          header.classList.toggle('collapsed');
          header.nextElementSibling.classList.toggle('collapsed');
        });
      });

      isLoadingMoreChats = false;

      if (scrollContainer.scrollHeight <= scrollContainer.clientHeight && chatListRenderCount < sortedChatListItems.length) {
        loadMoreChats();
      }
    };


    if (isInitialLoad) {

      renderContent();
    } else {

      showLoader(chatListEl, 'bottom');
      setTimeout(renderContent, 500);
    }
  }

  function createChatListItem(chat) {

    try {
      const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
      let lastMsgDisplay;

      if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
      } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
      } else if (chat.isGroup) {
        if (lastMsgObj.type === 'pat_message') {
          lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`;
        } else if (lastMsgObj.type === 'transfer') {
          lastMsgDisplay = '[转账]';
        } else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') {
          lastMsgDisplay = '[照片]';
        } else if (lastMsgObj.type === 'voice_message') {
          lastMsgDisplay = '[语音]';
        } else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) {
          lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]';
        } else if (Array.isArray(lastMsgObj.content)) {
          lastMsgDisplay = `[图片]`;
        } else {
          lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20);
        }

        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
          const senderDisplayName = getDisplayNameInGroup(chat, lastMsgObj.senderName);
          lastMsgDisplay = `${senderDisplayName}: ${lastMsgDisplay}`;
        }
      } else {
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
      }

      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.dataset.chatId = chat.id;
      if (chat.isPinned) {
        item.classList.add('pinned');
      }

      const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
      const avatarFrameSrc = chat.isGroup ? '' : (chat.settings.aiAvatarFrame || '');
      let avatarHtml;
      if (avatarFrameSrc) {
        avatarHtml = `<div class="avatar-with-frame"><img src="${avatar || defaultAvatar}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
      } else {
        avatarHtml = `<img src="${avatar || defaultAvatar}" class="avatar">`;
      }
      const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
      const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

      item.innerHTML = `
            ${avatarGroupHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="unread-count-wrapper">
                <span class="unread-count" style="display: none;">0</span>
            </div>
        `;

      const unreadCount = chat.unreadCount || 0;
      const unreadEl = item.querySelector('.unread-count');
      if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        unreadEl.style.display = 'inline-flex';
      } else {
        unreadEl.style.display = 'none';
      }

      const avatarGroupEl = item.querySelector('.avatar-group');
      if (avatarGroupEl) {
        avatarGroupEl.style.cursor = 'pointer';
        avatarGroupEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const nameToPat = chat.isGroup ? chat.name : chat.originalName;
          handleUserPat(chat.id, nameToPat);
        });
      }

      const infoEl = item.querySelector('.info');
      if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
      }

      addLongPressListener(item, async (e) => {
        const action = await showChatListActions(chat);
        switch (action) {
          case 'pin':
            chat.isPinned = !chat.isPinned;
            await db.chats.put(chat);
            renderChatList();
            break;
          case 'delete':
            const deleteConfirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, {
              confirmButtonClass: 'btn-danger'
            });
            if (deleteConfirmed) {
              if (musicState.isActive && musicState.activeChatId === chat.id) {
                await endListenTogetherSession(false);
              }
              delete state.chats[chat.id];
              if (state.activeChatId === chat.id) state.activeChatId = null;
              await db.chats.delete(chat.id);
              renderChatList();
            }
            break;
          default:
            break;
        }
      });
      return item;

    } catch (error) {

      console.error(`渲染聊天项 [${chat.name || '未知'}] (ID: ${chat.id}) 时出错:`, error);
      return null;
    }
  }


  async function renderChatInterface(chatId) {
    applyButtonOrder();
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;

    exitSelectionMode();

    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');

    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
      statusContainer.style.display = 'none';
      document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
      statusContainer.style.display = 'flex';
      document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
      statusTextEl.textContent = chat.status?.text || '在线';
      statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }

    const chatScreen = document.getElementById('chat-interface-screen');
    const individualBg = chat.settings.background;
    const globalBg = state.globalSettings.globalChatBackground;
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    const defaultColor = isDarkMode ? '#000000' : '#f0f2f5';

    if (individualBg) {
      chatScreen.style.backgroundImage = `url("${individualBg}")`;
      chatScreen.style.backgroundColor = 'transparent';
    } else if (globalBg) {
      chatScreen.style.backgroundImage = `url("${globalBg}")`;
      chatScreen.style.backgroundColor = 'transparent';
    } else {
      chatScreen.style.backgroundImage = 'none';
      chatScreen.style.backgroundColor = defaultColor;
    }


    if (chat.isSpectatorGroup) {
      chatInputArea.style.display = 'none';
      lockOverlay.style.display = 'flex';
      lockContent.innerHTML = `
                    <span class="lock-text">正在围观AI们的群聊...</span>
                    <div class="spectator-actions-container">
                        <button id="spectator-reroll-btn" class="lock-action-btn secondary" title="重新生成上一轮对话">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4"></path>
                                <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                            </svg>
                        </button>
                        <button id="spectator-propel-btn" class="lock-action-btn">🎬 推进剧情</button>
                        <button id="spectator-edit-btn" class="lock-action-btn secondary" title="导演剪辑室：编辑AI上一轮的响应">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path>
                                <line x1="16" y1="8" x2="2" y2="22"></line>
                                <line x1="17.5" y1="15" x2="9" y2="15"></line>
                            </svg>
                        </button>
                    </div>
                `;
      document.getElementById('spectator-propel-btn').onclick = triggerSpectatorGroupAiAction;
    } else {
      chatInputArea.style.display = 'flex';
      lockOverlay.style.display = 'none';
      lockContent.innerHTML = '';
      if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';

        let lockHtml = '';
        switch (chat.relationship.status) {
          case 'blocked_by_user':
            const isSimulationRunning = simulationIntervalId !== null;
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            const cooldownHours = state.globalSettings.blockCooldownHours || 1;
            const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
            const timeSinceBlock = Date.now() - blockedTimestamp;
            const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
            const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

            lockHtml = `
                                <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                                <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                                <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                                    <strong style="color: #333;">【开发者诊断面板】</strong><br>
                                    - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                                    - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                                    - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                                    - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                                    - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                                    - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                                </div>
                                <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                            `;
            break;
          case 'blocked_by_ai':
            lockHtml = `
                                <span class="lock-text">你被对方拉黑了。</span>
                                <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                            `;
            break;
          case 'pending_user_approval':
            lockHtml = `
                                <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                                <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                                <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                            `;
            break;
          case 'pending_ai_approval':
            lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
            break;
        }
        lockContent.innerHTML = lockHtml;
      } else {
        lockOverlay.style.display = 'none';
        chatInputArea.style.visibility = 'visible';
      }
    }

    messagesContainer.innerHTML = '';
    const history = chat.history;
    currentRenderedCount = 0;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const initialMessages = history.slice(-renderWindow);



    const fragment = document.createDocumentFragment();
    let lastTimestamp = 0;

   
    for (const msg of initialMessages) {
      
      if (!msg.isHidden) {
        if (lastTimestamp > 0 && (msg.timestamp - lastTimestamp > 600000)) {
          
          fragment.appendChild(createSystemTimestampElement(msg.timestamp));
        }
        lastTimestamp = msg.timestamp;
      }
      
    
      const messageEl = await createMessageElement(msg, chat, true); 
      
      if (messageEl) {
        fragment.appendChild(messageEl);
      }
    }

   
    messagesContainer.appendChild(fragment);

    currentRenderedCount = initialMessages.length;

    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    const images = messagesContainer.querySelectorAll('img');
const imageLoadPromises = [];

images.forEach(img => {
    
    if (!img.complete) {
       
        imageLoadPromises.push(new Promise(resolve => {
            img.onload = resolve;
            img.onerror = resolve; 
        }));
    }
});


Promise.all(imageLoadPromises).then(() => {
   
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    console.log('所有初始图片加载完成，已滚动到底部。');
}).catch(err => {
   
    console.error("等待图片加载时出错:", err);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
});
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
  }




  async function loadMoreMessages() {
      if (isLoadingMoreMessages) return;
      isLoadingMoreMessages = true;

      const messagesContainer = document.getElementById('chat-messages');
      const chat = state.chats[state.activeChatId];
      if (!chat) {
          isLoadingMoreMessages = false;
          return;
      }

     
      showLoader(messagesContainer, 'top'); 
      const oldScrollHeight = messagesContainer.scrollHeight;

      
      await new Promise(resolve => setTimeout(resolve, 100)); 

     
      const totalMessages = chat.history.length;
      const renderWindow = state.globalSettings.chatRenderWindow || 50;
      const nextSliceStart = totalMessages - currentRenderedCount - renderWindow;
      const nextSliceEnd = totalMessages - currentRenderedCount;
      const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd);

     
      if (messagesToPrepend.length === 0) {
          hideLoader(messagesContainer);
          isLoadingMoreMessages = false;
          return;
      }
      currentRenderedCount += messagesToPrepend.length;
    
      const messageElements = [];
      for (const msg of messagesToPrepend) { 
          const el = await createMessageElement(msg, chat);
          messageElements.push(el); 
      }
    
     

      const fragment = document.createDocumentFragment();
          const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper[data-timestamp]');
         
          let timestampOfFirstVisible = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : 0;

          let lastTimestampInNewBatch = 0; 

      
          messagesToPrepend.forEach((msg, index) => {
              if (!msg.isHidden) {
                 
                  if (lastTimestampInNewBatch > 0 && (msg.timestamp - lastTimestampInNewBatch > 600000)) {
                      fragment.appendChild(createSystemTimestampElement(msg.timestamp));
                  }
                  lastTimestampInNewBatch = msg.timestamp;
              }
              
              const element = messageElements[index]; 
              if (element) {
                  fragment.appendChild(element); 
              }
          });
         
          if (timestampOfFirstVisible > 0 && (timestampOfFirstVisible - lastTimestampInNewBatch > 600000)) {
               fragment.appendChild(createSystemTimestampElement(timestampOfFirstVisible));
          }
    
         
          
          hideLoader(messagesContainer);
          messagesContainer.prepend(fragment);
      

      const newScrollHeight = messagesContainer.scrollHeight;
      messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

      isLoadingMoreMessages = false;
     
  }




  function renderWallpaperScreen(forcePresetId = null) {
    loadCssPresetsDropdown();
    // 这里传入 forcePresetId
    loadAppearancePresetsDropdown(forcePresetId);

    const ephonePreview = document.getElementById('wallpaper-preview');

    if (newWallpaperBase64) {
      ephonePreview.style.backgroundImage = `url("${newWallpaperBase64}")`;
      ephonePreview.textContent = '';
    } else {
      const ephoneBg = state.globalSettings.wallpaper;
      if (ephoneBg && ephoneBg.trim() !== '') {
          ephonePreview.style.backgroundImage = `url("${ephoneBg}")`;
          ephonePreview.textContent = '';
      } else {
          ephonePreview.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
          ephonePreview.textContent = '点击下方上传';
      }
    }

    const cphonePreview = document.getElementById('cphone-wallpaper-preview');
    const cphoneBg = state.globalSettings.cphoneWallpaper;
    if (cphoneBg) {
      cphonePreview.style.backgroundImage = `url("${cphoneBg}")`;
      cphonePreview.textContent = '';
    } else {
      cphonePreview.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
      cphonePreview.textContent = '当前为渐变色';
    }

    const globalBgPreview = document.getElementById('global-bg-preview');
    const globalBg = state.globalSettings.globalChatBackground;
    if (globalBg) {
      globalBgPreview.style.backgroundImage = `url(${globalBg})`;
      globalBgPreview.textContent = '';
      document.getElementById('remove-global-bg-btn').style.display = 'inline-block';
    } else {
      globalBgPreview.style.backgroundImage = 'none';
      globalBgPreview.textContent = '点击下方上传';
      document.getElementById('remove-global-bg-btn').style.display = 'none';
    }

    renderIconSettings();
    renderCPhoneIconSettings();
    document.getElementById('global-css-input').value = state.globalSettings.globalCss || '';
    document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
    document.getElementById('status-bar-toggle-switch').checked = state.globalSettings.showStatusBar || false;
    document.getElementById('global-show-seconds-switch').checked = state.globalSettings.showSeconds || false;
    document.getElementById('phone-frame-toggle-switch').checked = state.globalSettings.showPhoneFrame || false;
    document.getElementById('minimal-chat-ui-switch').checked = state.globalSettings.enableMinimalChatUI || false;
    document.getElementById('dynamic-island-music-toggle-switch').checked = state.globalSettings.alwaysShowMusicIsland || false;
    document.getElementById('detach-status-bar-switch').checked = state.globalSettings.detachStatusBar || false;
    document.getElementById('lock-screen-toggle').checked = state.globalSettings.lockScreenEnabled || false; // 锁屏回显
    document.getElementById('lock-screen-password-input').value = state.globalSettings.lockScreenPassword || ''; // 密码回显

    // 锁屏壁纸回显
    const lockPreview = document.getElementById('lock-wallpaper-preview');
    if (state.globalSettings.lockScreenWallpaper) {
        lockPreview.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
        lockPreview.textContent = '';
    } else {
        lockPreview.style.backgroundImage = 'linear-gradient(135deg, #1c1c1e, #3a3a3c)';
        lockPreview.textContent = '默认壁纸';
    }
    
    renderButtonOrderEditor();
    initializeButtonOrderEditor();
    
    // 加载系统通知设置
    loadSystemNotificationSettings();
  }

  window.renderWallpaperScreenProxy = renderWallpaperScreen;

  function applyGlobalWallpaper() {
    const homeScreen = document.getElementById('home-screen');
    const wallpaper = state.globalSettings.wallpaper;
    if (wallpaper) {

      homeScreen.style.backgroundImage = `url("${wallpaper}")`;
    } else {

      homeScreen.style.backgroundImage = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
    }
  }



  function switchWorldBookCategory(categoryId) {

    document.querySelectorAll('.world-book-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });

    document.querySelectorAll('.world-book-category-pane').forEach(pane => {
      pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
  }


  async function renderWorldBookScreen() {
    const tabsContainer = document.getElementById('world-book-tabs');
    const contentContainer = document.getElementById('world-book-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';


    const [books, categories] = await Promise.all([
      db.worldBooks.toArray(),
      db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books;

    if (books.length === 0) {
      contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
      return;
    }


    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);


    categories.forEach(category => {
      const categoryTab = document.createElement('button');
      categoryTab.className = 'world-book-tab';
      categoryTab.textContent = category.name;
      categoryTab.dataset.categoryId = String(category.id);
      tabsContainer.appendChild(categoryTab);

      const categoryPane = document.createElement('div');
      categoryPane.className = 'world-book-category-pane';
      categoryPane.dataset.categoryId = String(category.id);
      contentContainer.appendChild(categoryPane);
    });


    const hasUncategorized = books.some(book => !book.categoryId);
    if (hasUncategorized) {
      const uncategorizedTab = document.createElement('button');
      uncategorizedTab.className = 'world-book-tab';
      uncategorizedTab.textContent = '未分类';
      uncategorizedTab.dataset.categoryId = 'uncategorized';
      tabsContainer.appendChild(uncategorizedTab);

      const uncategorizedPane = document.createElement('div');
      uncategorizedPane.className = 'world-book-category-pane';
      uncategorizedPane.dataset.categoryId = 'uncategorized';
      contentContainer.appendChild(uncategorizedPane);
    }


    books.forEach(book => {
      let contentPreview = '暂无内容...';
      if (Array.isArray(book.content) && book.content.length > 0) {
        const firstEntry = book.content[0];
        contentPreview = firstEntry.comment || firstEntry.content || '';
      } else if (typeof book.content === 'string' && book.content.trim() !== '') {
        contentPreview = book.content;
      }

      const card = document.createElement('div');
      card.className = 'world-book-card';
      card.innerHTML = `
                    <div class="card-title">${book.name}</div>
                    <div class="card-content-preview">${contentPreview}</div>
                `;


      const cardClickHandler = () => openWorldBookEditor(book.id);
      const cardLongPressHandler = async () => {
        const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.worldBooks.delete(book.id);
          state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id);
          renderWorldBookScreen();
        }
      };

      card.addEventListener('click', cardClickHandler);
      addLongPressListener(card, cardLongPressHandler);


      const clonedCardForAll = card.cloneNode(true);
      clonedCardForAll.addEventListener('click', cardClickHandler);
      addLongPressListener(clonedCardForAll, cardLongPressHandler);
      allPane.appendChild(clonedCardForAll);


      const categoryKey = book.categoryId ? String(book.categoryId) : 'uncategorized';
      const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
      if (targetPane) {
        targetPane.appendChild(card);
      }
    });


    document.querySelectorAll('.world-book-tab').forEach(tab => {
      tab.addEventListener('click', () => switchWorldBookCategory(tab.dataset.categoryId));
    });
  }



  function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';

    groupContainer.innerHTML = `
                <div class="world-book-group-header">
                    <span class="arrow">▼</span>
                    <span class="group-name">${groupName}</span>
                </div>
                <div class="world-book-group-content"></div>
            `;

    const contentEl = groupContainer.querySelector('.world-book-group-content');
    books.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    books.forEach(book => {

      let contentPreview = '暂无内容...';


      if (Array.isArray(book.content) && book.content.length > 0) {


        const firstEntry = book.content[0];
        contentPreview = firstEntry.comment || firstEntry.content || '';
      } else if (typeof book.content === 'string' && book.content.trim() !== '') {

        contentPreview = book.content;
      }


      const item = document.createElement('div');
      item.className = 'list-item';
      item.dataset.bookId = book.id;

      item.innerHTML = `
                    <div class="item-title">${book.name}</div>
                    <div class="item-content">${String(contentPreview).substring(0, 50)}</div>
                `;
      item.addEventListener('click', () => openWorldBookEditor(book.id));
      addLongPressListener(item, async () => {
        const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.worldBooks.delete(book.id);
          state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id);
          renderWorldBookScreen();
        }
      });
      contentEl.appendChild(item);
    });

    return groupContainer;
  }

  window.renderWorldBookScreenProxy = renderWorldBookScreen;


  async function openWorldBookEditor(bookId) {


    showScreen('world-book-editor-screen');

    editingWorldBookId = bookId;
    const [book, categories] = await Promise.all([
      db.worldBooks.get(bookId),
      db.worldBookCategories.toArray()
    ]);


    if (!book) {
      console.error("尝试打开一个不存在的世界书，ID:", bookId);
      showScreen('world-book-screen');
      return;
    }


    document.getElementById('world-book-editor-title').textContent = book.name;
    document.getElementById('world-book-name-input').value = book.name;


    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>';
    categories.forEach(cat => {
      const option = document.createElement('option');
      option.value = cat.id;
      option.textContent = cat.name;
      if (book.categoryId === cat.id) option.selected = true;
      selectEl.appendChild(option);
    });


    const entriesContainer = document.getElementById('world-book-entries-container');
    entriesContainer.innerHTML = '';

    if (Array.isArray(book.content) && book.content.length > 0) {
      book.content.forEach(entry => {
        const block = createWorldBookEntryBlock(entry);
        entriesContainer.appendChild(block);
      });
    } else {
      entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">还没有内容，点击下方按钮添加第一条吧！</p>';
    }


  }


  
  async function renderStickerPanel(rerenderTabs = true) {
    const grid = document.getElementById('sticker-grid');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const searchInput = document.getElementById('sticker-search-input');
    const searchTerm = searchInput.value.trim().toLowerCase();


    if (rerenderTabs) {
      tabsContainer.innerHTML = '';
      const categories = await db.stickerCategories.toArray();

      tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'all' ? 'active' : ''}" data-category-id="all">全部</button>`;
      categories.forEach(cat => {
        tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === cat.id ? 'active' : ''}" data-category-id="${cat.id}">${cat.name}</button>`;
      });
      tabsContainer.innerHTML += `<button class="sticker-category-tab ${activeStickerCategoryId === 'uncategorized' ? 'active' : ''}" data-category-id="uncategorized">未分类</button>`;
    }


    grid.innerHTML = '';


    let stickersByCategory;
    if (activeStickerCategoryId === 'all') {
      stickersByCategory = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
      stickersByCategory = state.userStickers.filter(s => !s.categoryId);
    } else {
      stickersByCategory = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }


    const stickersToShow = searchTerm ?
      stickersByCategory.filter(sticker => sticker.name.toLowerCase().includes(searchTerm)) :
      stickersByCategory;


    if (stickersToShow.length === 0) {
      const message = searchTerm ? '找不到匹配的表情' : '这个分类下还没有表情哦~';
      grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1; padding-top: 20px;">${message}</p>`;
      return;
    }

    stickersToShow.forEach(sticker => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = sticker.name;
      item.dataset.stickerId = sticker.id;
      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${sticker.url})"></div>
            <span class="sticker-name">${sticker.name}</span>
        `;
      item.addEventListener('click', () => {
        if (isStickerManagementMode) {
          handleStickerSelection(item);
        } else {
          sendSticker(sticker);
        }
      });
      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = '&times;';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.userStickers.delete(sticker.id);
          state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
          renderStickerPanel();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }



  let isStickerManagementMode = false;
  let selectedStickers = new Set();
  let isPlaylistManagementMode = false;
  let selectedPlaylistItems = new Set();
  let isNaiGalleryManagementMode = false;
  let selectedNaiImages = new Set();
  let naiGalleryCache = { local: [], cloud: [] }; 
  let naiGalleryRenderCount = { local: 0, cloud: 0 }; 
  let isLoadingMoreNaiImages = { local: false, cloud: false };
  let activeNaiGalleryTab = 'local';
  const NAI_GALLERY_RENDER_WINDOW = 45; 
  
  function togglePlaylistManagementMode() {
    isPlaylistManagementMode = !isPlaylistManagementMode;
    const panel = document.getElementById('music-playlist-panel');
    const manageBtn = document.getElementById('manage-playlist-btn');
    const actionBar = document.getElementById('playlist-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-playlist-checkbox');

    panel.classList.toggle('management-mode', isPlaylistManagementMode);

    if (isPlaylistManagementMode) {
      manageBtn.textContent = translations[currentLanguage].done; // 使用翻译
      manageBtn.setAttribute('data-lang-key', 'done');
      actionBar.style.display = 'flex';
      selectedPlaylistItems.clear();
      selectAllCheckbox.checked = false;
      updatePlaylistActionBar();
      // 显示复选框
      panel.querySelectorAll('.playlist-item-checkbox').forEach(cb => cb.style.display = 'block');
    } else {
      manageBtn.textContent = translations[currentLanguage].manage; // 使用翻译
      manageBtn.setAttribute('data-lang-key', 'manage');
      actionBar.style.display = 'none';
      // 隐藏复选框并取消选中
      panel.querySelectorAll('.playlist-item').forEach(item => {
        item.classList.remove('selected');
        const cb = item.querySelector('.playlist-item-checkbox');
        if (cb) {
            cb.style.display = 'none';
            cb.checked = false;
        }
      });
    }
  }

  function handlePlaylistSelection(index) {
    if (!isPlaylistManagementMode) return;
    
    const item = document.querySelector(`.playlist-item[data-index="${index}"]`);
    if (!item) return;
    const checkbox = item.querySelector('.playlist-item-checkbox');

    // 切换状态
    const isSelected = selectedPlaylistItems.has(index);
    item.classList.toggle('selected', !isSelected);
    checkbox.checked = !isSelected;
    
    if (isSelected) {
      selectedPlaylistItems.delete(index);
    } else {
      selectedPlaylistItems.add(index);
    }
    updatePlaylistActionBar();
  }

  function updatePlaylistActionBar() {
    const btn = document.getElementById('upload-selected-to-catbox-btn');
    const count = selectedPlaylistItems.size;
    if (btn) btn.textContent = `上传Catbox (${count})`;
  }

  function handleSelectAllPlaylistItems() {
    const checkbox = document.getElementById('select-all-playlist-checkbox');
    const shouldSelect = checkbox.checked;
    
    document.querySelectorAll('.playlist-item').forEach(item => {
      const index = parseInt(item.dataset.index);
      if (isNaN(index)) return;

      item.classList.toggle('selected', shouldSelect);
      item.querySelector('.playlist-item-checkbox').checked = shouldSelect;

      if (shouldSelect) {
        selectedPlaylistItems.add(index);
      } else {
        selectedPlaylistItems.delete(index);
      }
    });
    updatePlaylistActionBar();
  }

  async function executeBatchUploadToCatbox() {
    // 1. 检查 Catbox 配置
    if (!state.apiConfig.catboxEnable || !state.apiConfig.catboxUserHash) {
      await showCustomAlert("功能未开启", "请先在“API设置” -> “Catbox.moe”中开启此功能并填写您的 User Hash。");
      return;
    }

    if (selectedPlaylistItems.size === 0) {
      await showCustomAlert("未选择", "请先选择要上传的歌曲。");
      return;
    }

    // 2. 过滤掉已经是 Catbox 链接的歌曲
    const indicesToUpload = Array.from(selectedPlaylistItems).filter(index => {
      const song = musicState.playlist[index];
      return song && song.src && !String(song.src).includes('catbox.moe');
    });

    if (indicesToUpload.length === 0) {
      await showCustomAlert("无需上传", "您选择的所有歌曲均已在 Catbox 上。");
      togglePlaylistManagementMode();
      return;
    }

    const confirmed = await showCustomConfirm(
      '确认上传？',
      `即将上传 ${indicesToUpload.length} 首歌曲到 Catbox.moe。\n\n这会转换本地音乐和外部链接，可能需要一些时间并消耗流量。\n（已在 Catbox 上的歌曲将被自动跳过）`,
      { confirmText: '开始上传' }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在开始上传 ${indicesToUpload.length} 首歌曲，请勿关闭页面...`);

    let successCount = 0;
    let failCount = 0;
    const failedNames = [];

    const proxySettings = getNovelAISettings();
    let corsProxy = proxySettings.cors_proxy;
    if (corsProxy === 'custom') {
      corsProxy = proxySettings.custom_proxy_url || '';
    }
   

    for (const index of indicesToUpload) {
      const song = musicState.playlist[index];
      try {
        let fileToUpload;
        let songName = song.name || 'unknown_track.mp3';

        if (song.isLocal) {
          // 4a. 处理本地歌曲 (ArrayBuffer 或 Blob) - 这部分逻辑是正确的
          console.log(`[Catbox 批量上传] 处理本地歌曲: ${song.name}`);
          fileToUpload = new Blob([song.src], { type: song.fileType || 'audio/mpeg' });
        } else {
          // 4b. 处理网络歌曲 (需要CORS代理)
          console.log(`[Catbox 批量上传] 处理网络歌曲: ${song.name} from ${song.src}`);
          
          
          let fetchUrl = song.src;
          // 检查代理是否已配置，并且歌曲源不是 data: URI
          if (corsProxy && corsProxy !== '' && !fetchUrl.startsWith('data:')) {
            // 【重要】必须对源URL进行编码，以防URL中有特殊字符
            fetchUrl = corsProxy + encodeURIComponent(song.src); 
            console.log(`[Catbox 批量上传] 使用代理下载: ${fetchUrl}`);
          } else {
            console.log(`[Catbox 批量上传] 不使用代理，尝试直连下载... (这在Safari上会失败)`);
          }
          
          const response = await fetch(fetchUrl); // <--- 现在这个 fetch 是带代理的
          if (!response.ok) throw new Error(`下载歌曲失败，状态: ${response.status}`);
          fileToUpload = await response.blob();
        }

        // 确保文件名有后缀
        if (!songName.match(/\.(mp3|wav|flac|m4a|ogg)$/i)) {
          songName += '.mp3';
        }

        // 5. 调用我们之前修复过的上传函数
        // (uploadFileToCatbox 函数在 1667 行附近)
        const newCatboxUrl = await uploadFileToCatbox(new File([fileToUpload], songName, { type: fileToUpload.type }));
        
        // 6. 更新 musicState
        song.src = newCatboxUrl;
        song.isLocal = false;
        delete song.fileType; 
        successCount++;

      } catch (error) {
        console.error(`[Catbox 批量上传] 上传失败: ${song.name}`, error);
        failCount++;
        failedNames.push(song.name);
      }
    }

    // 7. 保存到数据库
    await saveGlobalPlaylist();

    // 8. 显示总结报告
    let summary = `上传完成！\n\n成功: ${successCount} 首`;
    if (failCount > 0) {
      summary += `\n失败: ${failCount} 首\n(${failedNames.join(', ')})`;
    }
    await showCustomAlert("操作完成", summary);

    // 9. 退出管理模式并刷新UI
    togglePlaylistManagementMode();
    updatePlaylistUI();
  }

  function toggleStickerManagementMode() {
    isStickerManagementMode = !isStickerManagementMode;
    const grid = document.getElementById('sticker-grid');
    const manageBtn = document.getElementById('manage-stickers-btn');
    const actionBar = document.getElementById('sticker-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');

    grid.classList.toggle('management-mode', isStickerManagementMode);

    if (isStickerManagementMode) {
      manageBtn.textContent = '完成';
      actionBar.style.display = 'flex';
      selectedStickers.clear();
      selectAllCheckbox.checked = false;
      updateDeleteStickerButton();
    } else {
      manageBtn.textContent = '管理';
      actionBar.style.display = 'none';
      grid.querySelectorAll('.sticker-item.selected').forEach(item => item.classList.remove('selected'));
    }
  }



  function handleSelectAllStickers() {
    const checkbox = document.getElementById('select-all-stickers-checkbox');
    const shouldSelect = checkbox.checked;


    let stickersToSelect;
    if (activeStickerCategoryId === 'all') {
      stickersToSelect = state.userStickers;
    } else if (activeStickerCategoryId === 'uncategorized') {
      stickersToSelect = state.userStickers.filter(s => !s.categoryId);
    } else {
      stickersToSelect = state.userStickers.filter(s => s.categoryId === activeStickerCategoryId);
    }


    stickersToSelect.forEach(sticker => {
      const stickerId = sticker.id;
      const itemEl = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);

      if (shouldSelect) {

        selectedStickers.add(stickerId);
        if (itemEl) itemEl.classList.add('selected');
      } else {

        selectedStickers.delete(stickerId);
        if (itemEl) itemEl.classList.remove('selected');
      }
    });


    updateDeleteStickerButton();
  }


  function updateDeleteStickerButton() {
    const count = selectedStickers.size;
    const delBtn = document.getElementById('delete-selected-stickers-btn');
    const exportBtn = document.getElementById('export-selected-stickers-btn');
    const moveBtn = document.getElementById('move-selected-stickers-btn'); // 新增

    if (delBtn) delBtn.textContent = `删除 (${count})`;
    if (exportBtn) exportBtn.textContent = `导出 (${count})`;
    if (moveBtn) moveBtn.textContent = `移动 (${count})`; // 新增
}
async function executeBatchMoveStickers() {
    if (selectedStickers.size === 0) {
        alert("请先选择要移动的表情。");
        return;
    }

    // 1. 获取所有分类
    const categories = await db.stickerCategories.toArray();
    const options = [
        { text: '未分类', value: 'uncategorized' },
        ...categories.map(c => ({ text: c.name, value: c.id }))
    ];

    // 2. 弹出选择框
    const targetCategoryId = await showChoiceModal("移动到分类", options);
    if (!targetCategoryId) return;

    // 3. 处理目标ID (未分类存为 null)
    const finalCategoryId = targetCategoryId === 'uncategorized' ? null : parseInt(targetCategoryId);

    await showCustomAlert("请稍候...", "正在移动表情...");

    // 4. 更新数据库
    const idsToMove = Array.from(selectedStickers);
    await db.transaction('rw', db.userStickers, async () => {
        for (const id of idsToMove) {
            await db.userStickers.update(id, { categoryId: finalCategoryId });
            // 更新内存
            const s = state.userStickers.find(item => item.id === id);
            if (s) s.categoryId = finalCategoryId;
        }
    });

    // 5. 刷新界面
    toggleStickerManagementMode(); // 退出管理模式
    await renderStickerPanel(); // 刷新列表 (这会根据当前选中的Tab刷新，移动走的表情会消失)
    
    await showCustomAlert("成功", `已将 ${idsToMove.length} 个表情移动到新分类。`);
}
  /**
   * 处理用户点击选择或取消选择表情
   * @param {HTMLElement} item - 被点击的表情DOM元素
   */
  function handleStickerSelection(item) {
    if (!isStickerManagementMode) return;

    const stickerId = item.dataset.stickerId;
    if (!stickerId) return;

    item.classList.toggle('selected');

    if (selectedStickers.has(stickerId)) {
      selectedStickers.delete(stickerId);
    } else {
      selectedStickers.add(stickerId);
    }
    updateDeleteStickerButton();
  }


  async function executeBatchDeleteStickers() {
    if (selectedStickers.size === 0) return;

    const confirmed = await showCustomConfirm(
      '确认删除',
      `确定要删除选中的 ${selectedStickers.size} 个表情吗？此操作不可恢复。`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      const idsToDelete = [...selectedStickers];


      await db.userStickers.bulkDelete(idsToDelete);


      state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));


      toggleStickerManagementMode();
      renderStickerPanel();

      await showCustomAlert('删除成功', '选中的表情已成功删除。');
    }
  }

async function executeBatchExportStickers() {
    if (selectedStickers.size === 0) {
      alert("请先选择要导出的表情包。");
      return;
    }

    let exportText = "";
    let exportedCount = 0;

    
    state.userStickers.forEach(sticker => {
      if (selectedStickers.has(sticker.id)) {
       
        exportText += `${sticker.name}: ${sticker.url}\n`;
        exportedCount++;
      }
    });

    if (exportedCount === 0) {
      alert("未找到所选表情的数据。");
      return;
    }

    const finalText = exportText.trim();
    const textareaId = 'batch-export-textarea-' + Date.now();
    
  
    const alertHtml = `
        <p style="text-align:left; font-size: 14px; margin: 0 0 10px 0;">
            已为您生成 ${exportedCount} 条快捷导入格式的文本：
        </p>
        <textarea id="${textareaId}" 
                  rows="10" 
                  style="width: 100%; font-size: 12px; resize: vertical; border-radius: 6px; border: 1px solid #ccc;"
                  readonly>${finalText}</textarea>
    `;

   
    showCustomAlert("复制表情包数据", alertHtml);
  
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    
    if (modalConfirmBtn) {
        
        
        modalConfirmBtn.textContent = '一键复制';
        
        
        const originalOnclick = modalConfirmBtn.onclick;

       
        modalConfirmBtn.onclick = async (e) => {
            try {
                
                await navigator.clipboard.writeText(finalText);
                modalConfirmBtn.textContent = '复制成功!';
                
               
                setTimeout(() => {
                   modalConfirmBtn.textContent = '完成';
                   modalConfirmBtn.onclick = originalOnclick; 
                }, 1500);
                
            } catch (err) {
               
                alert('自动复制失败，请长按文本框手动复制。');
                
                modalConfirmBtn.textContent = '完成';
                modalConfirmBtn.onclick = originalOnclick;
            }
        };
    }
  }


 
  async function openBatchStickerImportModal() {
    // 1. 让用户选择导入方式
    const choice = await showChoiceModal('批量导入表情', [
        { text: '📋 粘贴文本', value: 'paste' },
        { text: '📁 上传文件 (.txt/.json/.docx)', value: 'file' }
    ]);

    if (choice === 'paste') {
        // --- 方式 A: 粘贴文本 (保持原有逻辑) ---
        const placeholderText = `请输入表情数据，一行一个。
【规则】：包含【名字】和【链接】。
【示例】：
开心: https://xx.com/1.jpg
哭泣：https://xx.com/2.png
生气https://xx.com/3.gif
https://xx.com/4.jpg 疑惑`;

        const pastedText = await showCustomPrompt(
          '批量导入表情',
          placeholderText,
          '',
          'textarea'
        );

        if (pastedText && pastedText.trim()) {
          await handleBatchStickerImport(pastedText);
        }

    } else if (choice === 'file') {
        // --- 方式 B: 上传文件 ---
        await handleStickerFileImport();
    }
  }


  
  async function handleBatchStickerImport(text) {
    const lines = text.trim().split('\n');
    const newStickers = [];
    const baseUrl = 'https://files.catbox.moe/';
    let errorCount = 0;
    let skippedPureLinks = 0; // 统计被跳过的纯链接
    const currentCategoryId = (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null;

    // 1. 提取URL的正则 (支持 http/https 和 data:image)
    const urlRegex = /(https?:\/\/[^\s]+|data:image\/[^\s]+)/;

    for (const line of lines) {
      const trimmedLine = line.trim();

      // 跳过空行或包含提示语的行
      if (!trimmedLine || trimmedLine.includes('填入') || trimmedLine.includes('格式')) {
        continue;
      }

      // --- 第一步：寻找链接 ---
      const urlMatch = trimmedLine.match(urlRegex);
      
      // 2. 如果没找到标准链接，尝试兼容旧版 Catbox 短码 (名字 code.png)
      if (!urlMatch) {
         // 尝试匹配: 任意文字 + 空格 + (字母数字.后缀)
         const catboxMatch = trimmedLine.match(/^(.+?)\s+([a-zA-Z0-9]+\.[a-zA-Z0-9]+)$/);
         if (catboxMatch) {
             newStickers.push({
                id: 'sticker_' + Date.now() + Math.random(),
                name: catboxMatch[1].trim(),
                url: baseUrl + catboxMatch[2].trim(),
                categoryId: currentCategoryId
             });
         } else {
             errorCount++;
             console.warn('无法识别行:', trimmedLine);
         }
         continue; 
      }

      // --- 第二步：提取并清洗数据 ---
      const url = urlMatch[0];
      
      // 从整行中把链接删掉，剩下的就是名字
      // 例如 "开心:http://..." -> 剩下 "开心:" (英文冒号)
      // 例如 "开心：http://..." -> 剩下 "开心：" (中文冒号)
      let rawName = trimmedLine.replace(url, '').trim();

      // --- 第三步：智能清洗名字 (核心修改) ---
      // 正则解释：
      // ^[\s:：,，]+  -> 去掉开头的所有 空格、英文冒号、中文冒号、逗号
      // |             -> 或者
      // [\s:：,，]+$  -> 去掉结尾的所有 空格、英文冒号、中文冒号、逗号
      let cleanName = rawName.replace(/^[\s:：,，]+|[\s:：,，]+$/g, '');

      // --- 第四步：严格校验 (禁止纯链接) ---
      // 如果清洗后名字为空，说明这一行只有链接
      if (!cleanName) {
          skippedPureLinks++;
          console.warn('跳过纯链接 (未提供名字):', trimmedLine);
          continue;
      }

      // 添加到列表
      newStickers.push({
        id: 'sticker_' + Date.now() + Math.random(),
        name: cleanName,
        url: url,
        categoryId: currentCategoryId
      });
    }

    // --- 第五步：结果反馈 ---
    let resultMsg = '';
    
    if (newStickers.length > 0) {
      await db.userStickers.bulkAdd(newStickers);
      state.userStickers.push(...newStickers);
      renderStickerPanel();
      resultMsg = `成功导入 ${newStickers.length} 个新表情！`;
    }

    if (skippedPureLinks > 0) {
        resultMsg += `\n⚠️ 有 ${skippedPureLinks} 行因只有链接(无名字)被跳过。`;
    }

    if (errorCount > 0) {
        resultMsg += `\n❌ 有 ${errorCount} 行格式无法识别。`;
    }

    if (resultMsg) {
        await showCustomAlert('导入结果', resultMsg);
    } else if (lines.length > 0) {
        await showCustomAlert('导入失败', '未能识别任何有效数据，请确保每行都包含【名字】和【链接】。');
    }
  }
// 处理文件选择
  function handleStickerFileImport() {
    return new Promise(resolve => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.txt,.json,.docx'; // 限制文件类型
      
      input.onchange = async e => {
        const file = e.target.files[0];
        if (!file) {
            resolve();
            return;
        }

        try {
            await showCustomAlert("正在解析...", "正在读取文件内容，请稍候...");
            const textContent = await processStickerFile(file);
            
            if (textContent && textContent.trim()) {
                // 解析成功后，直接复用之前的文本解析逻辑
                // 这样无论是文件还是粘贴，都支持那种灵活的格式（中文冒号、无空格等）
                await handleBatchStickerImport(textContent);
            } else {
                alert("文件内容为空或无法解析。");
            }
        } catch (error) {
            console.error("文件解析失败:", error);
            alert(`文件解析失败: ${error.message}`);
        }
        resolve();
      };
      
      input.click();
    });
  }

  // 核心：根据后缀名解析文件内容
  async function processStickerFile(file) {
      const fileName = file.name.toLowerCase();

      // 1. 处理 .txt 文件
      if (fileName.endsWith('.txt')) {
          return await file.text();
      }

      // 2. 处理 .docx 文件 (依赖 mammoth.js)
      if (fileName.endsWith('.docx')) {
          if (typeof mammoth === 'undefined') {
              throw new Error("未加载 mammoth.js 库，无法读取 Word 文档。");
          }
          const arrayBuffer = await file.arrayBuffer();
          const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
          return result.value; // 返回 Word 中的纯文本
      }

      // 3. 处理 .json 文件
      if (fileName.endsWith('.json')) {
          const text = await file.text();
          let json;
          try {
              json = JSON.parse(text);
          } catch (e) {
              throw new Error("JSON 格式错误");
          }

          // 将 JSON 转换为 "名字: 链接" 的文本格式，以便复用 handleBatchStickerImport
          let convertedText = "";

          if (Array.isArray(json)) {
              // 情况 A: 数组格式 [{name: "开心", url: "http..."}, ...]
              json.forEach(item => {
                  // 尝试多种可能的键名
                  const name = item.name || item.key || item.title || item.meaning;
                  const url = item.url || item.src || item.content || item.link;
                  if (name && url) {
                      convertedText += `${name}: ${url}\n`;
                  }
              });
          } else if (typeof json === 'object') {
              // 情况 B: 对象格式 {"开心": "http...", "哭泣": "http..."}
              // 或者 Tavern 格式 {"entries": ...}
              if (json.entries) {
                   // 简单的兼容 Tavern 格式
                   const entries = Array.isArray(json.entries) ? json.entries : Object.values(json.entries);
                   entries.forEach(item => {
                       const name = item.comment || item.key?.toString() || "表情";
                       const url = item.content || item.url;
                       if (url && url.startsWith('http')) {
                           convertedText += `${name}: ${url}\n`;
                       }
                   });
              } else {
                  // 普通 Key-Value 对
                  for (let key in json) {
                      const val = json[key];
                      if (typeof val === 'string' && (val.startsWith('http') || val.startsWith('data:image'))) {
                          convertedText += `${key}: ${val}\n`;
                      }
                  }
              }
          }
          return convertedText;
      }

      throw new Error("不支持的文件格式");
  }

  function scrollToOriginalMessage(originalTimestamp) {
    const selector = `.message-bubble[data-timestamp="${originalTimestamp}"]`;
    const originalMessageBubble = document.querySelector(selector);

    if (originalMessageBubble) {
      originalMessageBubble.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });

      originalMessageBubble.classList.add('highlighted');
      setTimeout(() => {
        if (document.body.contains(originalMessageBubble)) {
          originalMessageBubble.classList.remove('highlighted');
        }
      }, 1500);

    } else {

      alert("找不到原始消息。可能已被删除或位于更早的历史记录中。");
    }
  }
  async function createMessageElement(msg, chat) {


    if (msg.type === 'recalled_message') {
      const wrapper = document.createElement('div');
      wrapper.className = 'message-wrapper system-pat';
      wrapper.dataset.timestamp = msg.timestamp;
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble recalled-message-placeholder';
      bubble.dataset.timestamp = msg.timestamp;
      bubble.textContent = msg.content;
      wrapper.appendChild(bubble);
      addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
      wrapper.addEventListener('click', () => {
        if (isSelectionMode) {
          toggleMessageSelection(msg.timestamp);
        }
      });
      return wrapper;
    } else if (msg.type === 'post_deleted_notice') {
      const wrapper = document.createElement('div');
      wrapper.className = 'message-wrapper system-pat';
      wrapper.dataset.timestamp = msg.timestamp;
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble post-deleted-placeholder';
      bubble.dataset.postId = msg.postId;
      bubble.textContent = msg.content;
      wrapper.appendChild(bubble);
      addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
      wrapper.addEventListener('click', () => {
        if (isSelectionMode) {
          toggleMessageSelection(msg.timestamp);
        }
      });
      return wrapper;
    }

    if (msg.isHidden && !chat.settings.showHiddenMessages) {
      return null;
    }
    if (msg.type === 'narration') {
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper system-pat'; // 复用系统消息样式(居中灰色)
    wrapper.dataset.timestamp = msg.timestamp; // 关键：必须有时间戳才能编辑/删除
    
    const bubble = document.createElement('div');
    bubble.className = 'message-bubble system-bubble';
    // 可以加个图标让它和普通拍一拍区分开，也可以不加
    bubble.innerHTML = `<span style="font-style:italic; opacity: 0.9;">${msg.content}</span>`; 
    bubble.dataset.timestamp = msg.timestamp;
    
    wrapper.appendChild(bubble);
    
    // 【关键】添加长按监听，实现删除/编辑功能
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    
    // 支持多选
    wrapper.addEventListener('click', () => {
        if (isSelectionMode) toggleMessageSelection(msg.timestamp);
    });
    
    return wrapper;
}
    if (msg.type === 'pat_message') {
      const wrapper = document.createElement('div');
      wrapper.className = 'message-wrapper system-pat';
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble system-bubble';
      bubble.dataset.timestamp = msg.timestamp;
      bubble.textContent = msg.content;
      wrapper.appendChild(bubble);
      addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
      wrapper.addEventListener('click', () => {
        if (isSelectionMode) toggleMessageSelection(msg.timestamp);
      });
      return wrapper;
    }


    const isUser = msg.role === 'user';
    const myNickname = chat.settings.myNickname || '我';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
    if (msg.isHidden) {
        wrapper.classList.add('hidden-revealed');
    }
    if (chat.isGroup && !isUser) {
      const member = chat.members.find(m => m.originalName === msg.senderName);
      const senderNameDiv = document.createElement('div');
      senderNameDiv.className = 'sender-name';
      senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成员');
      wrapper.appendChild(senderNameDiv);
    }

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp, chat.id);

    let avatarSrc, avatarFrameSrc = '';
    if (isUser) {
      avatarSrc = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
      avatarFrameSrc = chat.settings.myAvatarFrame || '';
    } else {
      if (chat.isGroup) {
        const member = chat.members.find(m => m.originalName === msg.senderName);
        if (member) {
          const characterProfile = state.chats[member.id];
          avatarSrc = member.avatar || (characterProfile ? characterProfile.settings.aiAvatar : defaultGroupMemberAvatar);
          avatarFrameSrc = member.avatarFrame || (characterProfile ? characterProfile.settings.aiAvatarFrame : '');
        } else {
          avatarSrc = defaultGroupMemberAvatar;
          avatarFrameSrc = '';
        }
      } else {
        avatarSrc = chat.settings.aiAvatar || defaultAvatar;
        avatarFrameSrc = chat.settings.aiAvatarFrame || '';
      }
    }

    let avatarHtml;
    if (avatarFrameSrc) {
      avatarHtml = `<div class="avatar-with-frame"><img src="${avatarSrc}" class="avatar-img"><img src="${avatarFrameSrc}" class="avatar-frame"></div>`;
    } else {
      avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    const hasFrameClass = avatarFrameSrc ? 'has-frame' : '';
    const avatarGroupHtml = `<div class="avatar-group ${hasFrameClass}">${avatarHtml}</div>`;

    let contentHtml;
    let quoteHtml = '';
    if (msg.quote) {
      const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
      const fullQuotedContent = String(msg.quote.content || '');
      quoteHtml = `
                    <div class="quoted-message" data-original-timestamp="${msg.quote.timestamp}" style="cursor: pointer;">
                        <div class="quoted-sender">回复 ${quotedSenderDisplayName}:</div>
                        <div class="quoted-content">${fullQuotedContent}</div>
                    </div>
                `;
    }





    let rawContent = msg.content;

    if (typeof rawContent === 'string' && rawContent.trim().startsWith('<') && rawContent.trim().endsWith('>')) {
      contentHtml = rawContent;
      bubble.classList.add('is-raw-html');
    } else if (msg.type === 'offline_text' || msg.type === 'share_link' || msg.type === 'share_card' || msg.type === 'location_share' || msg.type === 'ai_image' || msg.type === 'user_photo' || msg.type === 'voice_message' || msg.type === 'transfer' || msg.type === 'waimai_request' || msg.type === 'waimai_order' || msg.type === 'red_packet' || msg.type === 'poll' || msg.type === 'gift' || msg.type === 'realimag' || msg.type === 'naiimag' || msg.type === 'kinship_request' || msg.type === 'forwarded_email' || msg.type === 'reddit_share') {

      if (msg.type === 'offline_text') {

        const combinedText = msg.content || `${msg.dialogue || ''} ${msg.description || ''}`.trim();


        const regex = /(「.*?」|“.*?”)/g;
        const parts = combinedText.split(regex).filter(part => part);


        contentHtml = parts.map(part => {

          if (part.startsWith('「') || part.startsWith('“')) {
            return `<span class="offline-dialogue">${parseMarkdown(part)}</span>`;
          } else {

            return `<span class="offline-description">${parseMarkdown(part.trim()).replace(/\n/g, '<br>')}</span>`;
          }
        }).join('');
      } else if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share', 'is-card-like');
        contentHtml = `<div class="link-share-card" data-timestamp="${msg.timestamp}"><div class="title">${msg.title || '无标题'}</div><div class="description">${msg.description || '点击查看详情...'}</div><div class="footer"><svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg><span>${msg.source_name || '链接分享'}</span></div></div>`;
      }else if (msg.type === 'forwarded_email') {
        bubble.classList.add('is-card-like'); // 去除气泡默认背景
        const data = msg.emailData || {};
        
        // 将完整数据存入 dataset，以便点击时读取
        const fullDataJson = encodeURIComponent(JSON.stringify(data));

        contentHtml = `
            <div class="email-share-card" data-email-json="${fullDataJson}">
                <div class="email-card-top">
                    <div class="email-icon-box">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
                    </div>
                    <div class="email-card-header-text">
                        <div class="email-card-subject">${escapeHTML(data.subject)}</div>
                        <div class="email-card-sender">${escapeHTML(data.sender)}</div>
                    </div>
                </div>
                <div class="email-card-preview">${escapeHTML(data.preview)}...</div>
                <div class="email-card-footer">
                    <span>Mail 邮件快照</span>
                    <span>查看详情 ›</span>
                </div>
            </div>
        `;
    } else if (msg.type === 'reddit_share') {
        bubble.classList.add('is-card-like', 'is-reddit-card'); // 确保添加这些类名
        const data = msg.redditData;
        
        // 处理分数的显示 (12.5k)
        const scoreDisplay = data.score > 1000 ? (data.score/1000).toFixed(1) + 'k' : data.score;
        
        contentHtml = `
    <div class="reddit-share-card">
        <div class="reddit-card-header">
                    <img src="https://www.redditinc.com/assets/images/site/reddit-logo.png" class="reddit-card-logo">
                    <span class="reddit-card-sub">${data.subreddit}</span>
                    <span class="reddit-card-user">• u/${data.author}</span>
                </div>
                <div class="reddit-card-body">
                    <div class="reddit-card-title">${escapeHTML(data.title)}</div>
                    ${data.image ? `<img src="${data.image}" class="reddit-card-img" loading="lazy">` : ''}
                    ${data.selftext ? `<div style="font-size:12px;color:#555;max-height:60px;overflow:hidden;">${escapeHTML(data.selftext)}</div>` : ''}
                </div>
                <div class="reddit-card-footer">
                    <span>⬆ ${scoreDisplay} 赞</span>
                    <span>💬 ${data.num_comments} 评论</span>
                </div>
            </div>
        `;
    }else if (msg.type === 'share_card') {
        bubble.classList.add('is-link-share', 'is-card-like');
        contentHtml = `<div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}"><div class="title">${msg.payload.title}</div><div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div><div class="footer"><svg class="footer-icon" ...>...</svg><span>聊天记录</span></div></div>`;
      } else if (msg.type === 'location_share') {
        bubble.classList.add('is-location-share', 'is-card-like');
        let finalImageUrl;


        if (msg.imageUrl) {
          finalImageUrl = msg.imageUrl;
        } else if (state.globalSettings.enableAiDrawing && msg.image_prompt) {
          finalImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(msg.image_prompt)}`;
        } else {
          finalImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';
        }

        const mapAreaStyle = `style="background-image: url('${finalImageUrl}');"`;
        contentHtml = `<div class="location-share-card"><div class="card-text-area"><div class="card-text-primary">${msg.content}</div><div class="card-text-secondary">位置分享</div></div><div class="card-map-area" ${mapAreaStyle}><div class="card-pin-icon"><svg width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path><path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path></svg></div></div></div>`;
      } else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image', 'is-card-like');
        const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";


        const imageUrl = state.globalSettings.enableAiDrawing && msg.image_prompt ?
          `https://image.pollinations.ai/prompt/${msg.image_prompt}` :
          'https://i.postimg.cc/KYr2qRCK/1.jpg';


        contentHtml = `<img src="${imageUrl}" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
      } else if (msg.type === 'naiimag') {
        
        bubble.classList.add('is-realimag', 'is-card-like');
        contentHtml = `
                        <div class="nai-image-wrapper">
                            <img src="${msg.imageUrl}" class="realimag-image" alt="NovelAI图片分享" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';" title="${msg.fullPrompt || msg.prompt || 'NovelAI生成'}">
                            
                            <div class="bubble-image-controls"> 
                                <button class="nai-save-local-btn" title="下载图片">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                                <button class="nai-upload-imgbb-btn" title="上传图床" style="display: none;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                        <polyline points="17 8 12 3 7 8" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></polyline>
                                        <line x1="12" y1="3" x2="12" y2="15" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></line>
                                    </svg>
                                </button>
                                <button class="nai-regenerate-btn" title="重新生成">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                                    </svg>
                                </button>
                                
                                
                            </div>
                        </div>
                    `;
      } else if (msg.type === 'voice_message') {
        bubble.classList.add('is-voice-message', 'is-card-like');
        const duration = Math.max(1, Math.round((msg.content || '').length / 5));
        const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
        const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';

        if (isUser) {

          contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}">
                <div class="voice-waveform">${waveformHTML}</div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
        } else {



          const canPlayTTS = !chat.isGroup && chat.settings.enableTts !== false;


          const voiceId = chat.settings.minimaxVoiceId || 'female-shaonv-jingpin';


          const voiceIdAttribute = canPlayTTS ? `data-voice-id="${voiceId}"` : '';

          contentHtml = `
            <div class="voice-message-body" data-text="${encodeURIComponent(msg.content)}" ${voiceIdAttribute}>
                <div class="voice-waveform">${waveformHTML}</div>
                <div class="loading-spinner"></div>
                <span class="voice-duration">${durationFormatted}</span>
            </div>
            <div class="voice-transcript"></div>
        `;
        }
      } else if (msg.type === 'transfer') {
        bubble.classList.add('is-transfer', 'is-card-like');
        let titleText, noteText;
        const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
        const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName || chat.name);
        if (isUser) {
          if (msg.isRefund) {
            titleText = `退款给 ${receiverDisplayName}`;
            noteText = '已拒收对方转账';
          }else if (msg.isReceived) {
            titleText = `已收款`;
            noteText = '已存入余额';
          } else {
            titleText = `转账给 ${receiverDisplayName}`;
            if (msg.status === 'accepted') noteText = '对方已收款';
            else if (msg.status === 'declined') noteText = '对方已拒收';
            else noteText = msg.note || '等待对方处理...';
          }
        } else {
          if (msg.isReceived) {
            titleText = `已收款`;
            noteText = '已存入金库'; // 或者 '已存入余额'
          } 
          // ★★★ 新增结束 ★★★
          else if (msg.isRefund) {
            titleText = `退款来自 ${senderDisplayName}`;
            noteText = '转账已被拒收';
          } else if (msg.receiverName === myNickname) {
            titleText = `转账给 ${myNickname}`;
            if (msg.status === 'accepted') noteText = '你已收款';
            else if (msg.status === 'declined') noteText = '你已拒收';
            else {
              bubble.style.cursor = 'pointer';
              bubble.dataset.status = 'pending';
              noteText = msg.note || '点击处理';
            }
          } else {
            titleText = `转账: ${senderDisplayName} → ${receiverDisplayName}`;
            noteText = msg.note || '群聊内转账';
          }
        }
        const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        contentHtml = `<div class="transfer-card"><div class="transfer-title">${heartIcon} ${titleText}</div><div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div><div class="transfer-note">${noteText}</div></div>`;
      } else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request', 'is-card-like');
        if (msg.status === 'paid' || msg.status === 'rejected') bubble.classList.add(`status-${msg.status}`);
        const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);
        const requestTitle = `来自 ${senderDisplayName} 的代付请求`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
          actionButtonsHtml = `<div class="waimai-user-actions"><button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button><button class="waimai-pay-btn" data-choice="paid">为Ta买单</button></div>`;
        }
        contentHtml = `<div class="waimai-card"><div class="waimai-header"><img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon"><div class="title-group"><span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span></div></div><div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div><div class="waimai-main"><div class="request-title">${requestTitle}</div><div class="payment-box"><div class="payment-label">需付款</div><div class="amount">¥${Number(msg.amount).toFixed(2)}</div><div class="countdown-label">剩余支付时间<div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div></div></div><button class="waimai-details-btn">查看详情</button></div>${actionButtonsHtml}</div>`;
        setTimeout(() => {
          if (msg.status === 'pending') {
            const timerElement = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerElement) {
              const timerId = startWaimaiCountdown(timerElement, msg.countdownEndTime);

              waimaiTimers[msg.timestamp] = timerId;
            }
          }
        }, 0);
      } else if (msg.type === 'waimai_order') {
        bubble.classList.add('is-waimai-request', 'is-card-like');
        const senderDisplayName = getDisplayNameInGroup(chat, msg.senderName);

        let recipientDisplayName = '你';
        if (chat.isGroup) {

          recipientDisplayName = getDisplayNameInGroup(chat, msg.recipientName);
        }

        contentHtml = `
        <div class="waimai-card">
            <div class="waimai-header">
                <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                <div class="title-group"><span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span></div>
            </div>
            <div class="waimai-main">
                <div class="request-title" style="margin-bottom: 12px;">${senderDisplayName} 已为${recipientDisplayName}下单，请慢用～</div>
                <div class="payment-box">
                    <div class="payment-label" style="font-size: 18px; font-weight: 600;">${msg.productInfo}</div>
                    <div class="amount" style="margin-top: 8px;">¥${Number(msg.amount).toFixed(2)}</div>
                </div>
                <button class="waimai-details-btn">查看订单详情</button>
            </div>
        </div>
    `;
      } else if (msg.type === 'red_packet') {
        bubble.classList.add('is-red-packet', 'is-card-like');
        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
        const isFinished = msg.isFullyClaimed;
        const hasClaimed = msg.claimedBy && msg.claimedBy[myOriginalName];
        let cardClass = '',
          claimedInfoHtml = '',
          typeText = '拼手气红包';
        if (isFinished) {
          cardClass = 'opened';
        }
        if (msg.packetType === 'direct') {
          const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName);
          typeText = `专属红包: 给 ${receiverDisplayName}`;
          if (Object.keys(msg.claimedBy || {}).length > 0) cardClass = 'opened';
        }
        if (hasClaimed) {
          const myClaimedAmount = msg.claimedBy[myOriginalName] || 0;
          claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${myClaimedAmount.toFixed(2)} 元</div>`;
        } else if (isFinished) {
          claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
        } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
          const receiverDisplayName = getDisplayNameInGroup(chat, msg.receiverName);
          claimedInfoHtml = `<div class="rp-claimed-info">已被 ${receiverDisplayName} 领取</div>`;
        }
        contentHtml = `<div class="red-packet-card ${cardClass}"><div class="rp-header"><img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon"><span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span></div><div class="rp-type">${typeText}</div>${claimedInfoHtml}</div>`;
      } else if (msg.type === 'poll') {
        bubble.classList.add('is-poll', 'is-card-like');
        const pollQuestionText = msg.question || msg.content || '(无标题投票)';
        let totalVotes = 0;
        const voteCounts = {};
        for (const option in msg.votes) {
          const count = msg.votes[option].length;
          voteCounts[option] = count;
          totalVotes += count;
        }
        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
        let myVote = null;
        for (const option in msg.votes) {
          if (msg.votes[option].includes(myOriginalName)) {
            myVote = option;
            break;
          }
        }
        let optionsHtml = '<div class="poll-options-list">';
        msg.options.forEach(optionText => {
          const count = voteCounts[optionText] || 0;
          const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
          const isVotedByMe = myVote === optionText;
          optionsHtml += `<div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}"><div class="poll-option-bar" style="width: ${percentage}%;"></div><div class="poll-option-content"><span class="poll-option-text">${optionText}</span><span class="poll-option-votes">${count} 票</span></div></div>`;
        });
        optionsHtml += '</div>';
        let footerHtml = msg.isClosed ? `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>` : `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
        contentHtml = `<div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}"><div class="poll-question">${pollQuestionText}</div>${optionsHtml}${footerHtml}</div>`;
      } else if (msg.type === 'gift') {
        bubble.classList.add('is-gift', 'is-card-like');
        let headerText;
        const myNicknameForGift = chat.settings.myNickname || '我';
        if (chat.isGroup) {
          if (msg.recipients && msg.recipients.length > 0) {
            const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName));
            if (recipientDisplayNames.length === 1) {
              headerText = `送给 ${recipientDisplayNames[0]} 的礼物`;
            } else {
              headerText = `送给 ${recipientDisplayNames.slice(0, 2).join('、')}等人的礼物`;
            }
          } else {
            headerText = `送给大家的礼物`;
          }
        } else {
          if (isUser) {
            headerText = `送给 ${chat.name} 的礼物`;
          } else {
            const recipientDisplayName = chat.settings.myNickname || '你';
            headerText = `送给 ${recipientDisplayName} 的礼物`;
          }
        }
        const previewItems = msg.items.slice(0, 3);
        let previewHtml = '';
        previewItems.forEach(item => {
          previewHtml += `<div class="gift-preview-item"><img src="${item.imageUrl}" class="gift-preview-img"><span class="gift-preview-name">${item.name}</span><span class="gift-preview-quantity">x${item.quantity}</span></div>`;
        });
        let moreItemsText = '';
        if (msg.items.length > 3) {
          moreItemsText = ` 等${msg.items.length}件商品`;
        }
        contentHtml = `<div class="gift-card"><div class="gift-header"><svg class="gift-header-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-2.18a4 4 0 0 0-7.64 0H8a4 4 0 0 0-4 4v2h20V10a4 4 0 0 0-4-4zM8 4a2 2 0 1 1-2 2a2 2 0 0 1 2-2zm12 0a2 2 0 1 1-2 2a2 2 0 0 1 2-2zM4 14v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6H4z"></path></svg><span class="gift-header-text">${headerText}</span></div><div class="gift-items-preview">${previewHtml}</div><div class="gift-footer">共${msg.items.length}件商品${moreItemsText}，点击查看</div></div>`;
      }else if (msg.type === 'kinship_request') {
        bubble.classList.add('is-kinship-request', 'is-card-like');
        
        let statusText = '';
        let statusKey = '';
        
        if (msg.status === 'pending') {
            statusText = '等待对方确认...';
            statusKey = 'pending';
        } else if (msg.status === 'accepted') {
            statusText = '已开通';
            statusKey = 'accepted';
        } else {
            statusText = '已失效';
            statusKey = 'rejected';
        }

        contentHtml = `
            <div class="kinship-invite-card">
                <div class="kinship-invite-header">
                    <div class="kinship-title">亲属卡邀请</div>
                    <div class="kinship-subtitle">对方消费 我买单</div>
                </div>
                <div class="kinship-invite-body">
                    <div class="kinship-limit-label">每月消费额度</div>
                    <div class="kinship-limit-amount">¥${msg.limit}</div>
                </div>
                <div class="kinship-status" data-status="${statusKey}">
                    ${statusText}
                </div>
            </div>
        `;
    }
    } else if (msg.type === 'synth_music') {
        bubble.classList.add('is-card-like', 'is-music-synth');

        const notesJson = JSON.stringify(msg.notes).replace(/"/g, '&quot;');
        // 获取乐器类型，默认为 piano
        const instrumentType = msg.instrument || 'piano';

        contentHtml = `
        <div class="synth-music-card">
            <div class="synth-icon">🎹</div>
            <div class="synth-info">
                <div class="synth-title">♪ ${msg.title}</div>
                <div class="synth-reason" style="font-size:11px; opacity:0.8;">
                    ${msg.reason} (${instrumentType})
                </div>
            </div>
            <button class="synth-play-btn" onclick="playSynthScore(this, '${notesJson}', '${instrumentType}')">
                ▶
            </button>
        </div>
    `;
    } else {
      const processedContent = String(rawContent);
      let processedByRule = await applyRenderingRules(processedContent, chat.id);
      if (processedByRule !== processedContent) {
        contentHtml = processedByRule;
        bubble.classList.add('is-card-like');
      } else {


        if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
    const imageUrl = msg.content[0].image_url.url;
    
    contentHtml = `
      <div class="bubble-image-wrapper user-image-wrapper">
          <img src="${imageUrl}" class="chat-image">
          <div class="bubble-image-controls user-controls">
              <button class="user-upload-imgbb-btn" title="上传图床" style="display: none;">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path>
                      <polyline points="17 8 12 3 7 8" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></polyline>
                      <line x1="12" y1="3" x2="12" y2="15" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></line>
                  </svg>
              </button>
          </div>
      </div>
    `;
}else if (STICKER_REGEX.test(processedByRule)) {
          bubble.classList.add('is-sticker', 'is-card-like');
          contentHtml = `<img src="${processedByRule}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
        } else {
          let plainText = processMentions(processedByRule, chat);
          contentHtml = parseMarkdown(plainText).replace(/\n/g, '<br>');
        }
      }
    }


    bubble.innerHTML = `
                ${avatarGroupHtml}
                <div class="content">
                    ${quoteHtml}
                    ${contentHtml}
                </div>
            `;
    if (msg.type === 'naiimag' && msg.imageUrl && msg.imageUrl.startsWith('data:image')) {
        if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
           
            const uploadBtn = bubble.querySelector('.nai-upload-imgbb-btn');
            if (uploadBtn) {
                uploadBtn.style.display = 'flex'; 
            }
        }
    }
    if (msg.role === 'user' && Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const imageUrl = msg.content[0].image_url.url;
        if (imageUrl && imageUrl.startsWith('data:image')) {
            if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
                const uploadBtn = bubble.querySelector('.user-upload-imgbb-btn');
                if (uploadBtn) {
                   // uploadBtn.style.display = 'flex'; // 显示上传按钮
                }
            }
        }
    }
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);

    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => {
      if (isSelectionMode) toggleMessageSelection(msg.timestamp);
    });

    if (!isUser) {
      const avatarGroupEl = wrapper.querySelector('.avatar-group');
      if (avatarGroupEl) {
        avatarGroupEl.style.cursor = 'pointer';
        if (!chat.isGroup) {
          avatarGroupEl.addEventListener('click', (e) => {
            e.stopPropagation();
            showCharacterProfileModal(chat.id);
          });
        } else {
          avatarGroupEl.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, msg.senderName);
          });
        }
      }
    } else {
      // USER头像点击事件 - 修改在线状态
      const avatarGroupEl = wrapper.querySelector('.avatar-group');
      if (avatarGroupEl) {
        avatarGroupEl.style.cursor = 'pointer';
        avatarGroupEl.addEventListener('click', (e) => {
          e.stopPropagation();
          showUserStatusModal(chat.id);
        });
      }
    }
    return wrapper;
  }


  async function prependMessage(msg, chat) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = await createMessageElement(msg, chat);


    if (!messageEl) return;

    const loadMoreBtn = document.getElementById('load-more-btn');
    if (loadMoreBtn) {
      messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
    } else {
      messagesContainer.prepend(messageEl);
    }
  }


 
  async function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const typingIndicator = document.getElementById('typing-indicator');

    const lastMessage = chat.history.filter(m => !m.isHidden).pop();


    if (lastMessage && (msg.timestamp - lastMessage.timestamp > 600000)) {
      const timestampEl = createSystemTimestampElement(msg.timestamp);
      messagesContainer.insertBefore(timestampEl, typingIndicator);
    }

    const messageEl = await createMessageElement(msg, chat);
    if (!messageEl) return;


    if (msg.role === 'assistant' && !isInitialLoad) {
      playNotificationSound();
    }

    if (!isInitialLoad) {
      messageEl.classList.add('animate-in');
      if (state.activeChatId === chat.id) {
            currentRenderedCount++;
        }
    }

    messagesContainer.insertBefore(messageEl, typingIndicator);

    const scrollToBottom = () => {
        if (!isInitialLoad) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    };

   
    const images = messageEl.querySelectorAll('img.sticker-image, img.chat-image, img.ai-generated-image, img.realimag-image, .naiimag-image, .ai-generated-image, .char-photo-item');
    
    if (images.length > 0) {
        const imageLoadPromises = [];
        images.forEach(img => {
            if (!img.complete) {
                imageLoadPromises.push(new Promise(resolve => {
                    img.onload = resolve;
                    img.onerror = resolve; 
                }));
            }
        });

       
        Promise.all(imageLoadPromises).then(() => {
            console.log(`${images.length} 张新图片加载完成，滚动到底部。`);
            scrollToBottom();
        });
    } else {
        
        scrollToBottom();
    }
const MAX_DOM_NODES = 60; 
    const bubbles = messagesContainer.querySelectorAll('.message-wrapper');
    
    if (bubbles.length > MAX_DOM_NODES) {
        // 移除最上面的元素（除了加载更多按钮）
        // 注意：如果你有“加载更多”按钮在第一个位置，要从第二个开始删
        const itemsToRemove = bubbles.length - MAX_DOM_NODES;
        for (let i = 0; i < itemsToRemove; i++) {
            // 确保不删除 load-more-btn
            if (!bubbles[i].id && !bubbles[i].classList.contains('load-more-btn')) {
                 bubbles[i].remove();
                 // 同时修正 currentRenderedCount，防止加载逻辑错乱
                 // (这一步取决于你的 loadMoreMessages 逻辑，通常不需要手动减，因为它是基于 slice 计算的)
            }
        }
    }
  }



  async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    if (chat.unreadCount > 0) {
      chat.unreadCount = 0;
      await db.chats.put(chat);
    }
    applyLyricsBarPosition(chat);
    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);


    const isGroup = chat.isGroup || false;


    toggleCallButtons(isGroup);


    document.getElementById('show-announcement-board-btn').style.display = isGroup ? 'flex' : 'none';


    const patBtn = document.getElementById('pat-btn');
    if (patBtn) {
      patBtn.style.display = isGroup ? 'none' : 'flex';
    }
    const propelBtn = document.getElementById('propel-btn');


    const shoppingBtn = document.getElementById('open-shopping-btn');
    const gomokuBtn = document.getElementById('gomoku-btn');
    const werewolfBtn = document.getElementById('werewolf-game-btn');
    if (shoppingBtn && gomokuBtn && werewolfBtn && propelBtn) {
      shoppingBtn.style.display = 'flex';
      gomokuBtn.style.display = isGroup ? 'none' : 'flex';
      werewolfBtn.style.display = isGroup ? 'flex' : 'none';


      propelBtn.style.display = isGroup ? 'none' : 'flex';
    }

    updateBackButtonUnreadCount();

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
      console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
      triggerAiResponse();
    }

    document.getElementById('send-poll-btn').style.display = isGroup ? 'flex' : 'none';
    document.body.classList.remove('chat-actions-expanded');
  }








  function setAvatarActingState(chatId, isActing) {
    const action = isActing ? 'add' : 'remove';
    const classListAction = (element) => {
      if (element) {
        element.classList[action]('is-acting');
      }
    };


    const listAvatar = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"] .avatar`);
    classListAction(listAvatar);


    const qzoneAvatars = document.querySelectorAll(`.post-avatar[data-author-id="${chatId}"]`);
    qzoneAvatars.forEach(classListAction);


    const callAvatar = document.querySelector(`.participant-avatar[data-participant-id="${chatId}"]`);
    classListAction(callAvatar);


  }



  async function triggerSpectatorGroupAiAction() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    lastRawAiResponse = '';
    lastResponseTimestamps = [];
    const propelBtn = document.getElementById('spectator-propel-btn');
    if (propelBtn) {
      propelBtn.disabled = true;
      propelBtn.textContent = '思考中...';
    }
    setAvatarActingState(chatId, true);

    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成对话。');
      }






      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);
      const filteredHistory = await filterHistoryWithDoNotSendRules(historySlice, chatId);

      let worldBookContent = '';
      if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';
          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
              
              entryString += `**内容:**\n${entry.content}`;
              return entryString;
            }).join('');
          return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
          worldBookContent = `# --- 世界书 (World Book) ---
# 【最高优先级指令：绝对真理】
# 以下内容是你所在世界的“物理法则”和“基础常识”。
# 无论用户是否提及，你都【必须】时刻主动应用这些设定来指导你的思考和描写。
# 它们是无条件生效的，不需要触发词。
${linkedContents}
# --- 世界书设定结束 ---
`;
        }
      }


      let longTermMemoryContext = '# 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)\n';
      let collectedMemories = false;

      chat.members.forEach(member => {
        const memberChat = state.chats[member.id];
        if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
          longTermMemoryContext += `\n## --- 关于“${member.groupNickname}”的记忆 ---\n`;

          longTermMemoryContext += memberChat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n');
          collectedMemories = true;
        }
      });

      if (!collectedMemories) {
        longTermMemoryContext += '- (暂无)';
      }


      let linkedMemoryContext = '';
      const memoryCount = chat.settings.linkedMemoryCount || 10;
      if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {

      }

      const membersList = chat.members.map(m => `- **${m.groupNickname}** (本名: ${m.originalName}): ${m.persona}`).join('\n');
      const stickerContext = getGroupStickerContextForPrompt(chat);
      const systemPrompt = `
# 核心任务：群聊剧本作家
你是一个剧本作家，负责创作一个名为“${chat.name}”的群聊中的对话。这个群聊里【没有用户】，所有成员都是你扮演的角色。你的任务是让他们之间进行一场生动、自然的对话。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组。
- 数组中的每个对象都【必须】包含 "type" 字段和 "name" 字段（角色的【本名】）。

# 角色扮演核心规则
1.  **【角色间互动 (最重要!)】**: 你的核心是创作一场“戏”。角色之间【必须】互相回应、补充或反驳，形成自然的讨论。严禁生成仅分别自言自语的独白。
2.  **【禁止出戏】**: 绝不能透露你是AI、模型或剧本作家。
3.  **【主动性】**: 角色们应该主动使用各种功能（发表情、发语音、分享图片等）来让对话更生动，而不是仅仅发送文字。
4.请根据当前情景和你的情绪，从列表中【选择一个最合适的】表情含义来使用 "sticker" 指令。尽量让你的表情丰富多样，避免重复。
# 可用指令列表 (你现在可以使用所有这些功能！)
-   **发文本**: \`{"type": "text", "name": "角色本名", "content": "你好呀！"}\`
-   **发表情**: \`{"type": "sticker", "name": "角色本名", "meaning": "表情的含义(必须从可用表情列表选择)"}\`
-   **发图片**: \`{"type": "ai_image", "name": "角色本名", "description": "详细中文描述", "image_prompt": "图片的【英文】关键词, 风格为风景/动漫/插画/二次元等, 禁止真人"}\`
-   **发语音**: \`{"type": "voice_message", "name": "角色本名", "content": "语音文字内容"}\`
-   **引用回复**: \`{"type": "quote_reply", "name": "角色本名", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`

# 当前群聊信息
- **群名称**: ${chat.name}

# 上下文参考 (你必须阅读并遵守)
${longTermMemoryContext}
${worldBookContent}
${linkedMemoryContext}
- **这是你们最近的对话历史**:
${historySlice.map(msg => `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`).join('\n')}

# 群成员列表及人设 (你扮演的所有角色)
${membersList}
# 可用表情包 (必须严格遵守！)
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
${stickerContext}
现在，请根据以上所有信息，继续这场没有用户参与的群聊，并自由地使用各种指令来丰富你们的互动。
`;


      const messagesPayload = filteredHistory.map(msg => ({
        role: 'user',
        content: `${getDisplayNameInGroup(chat, msg.senderName)}: ${msg.content}`
      }));

      let isGemini = proxyUrl.includes('generativelanguage.googleapis.com');
      let response;

      if (isGemini) {
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesPayload],
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });
      }





      if (!response.ok) {
        const errorData = await response.json().catch(() => ({
          error: {
            message: response.statusText
          }
        }));
        throw new Error(`API 请求失败: ${response.status} - ${errorData.error?.message || '未知错误'}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      lastRawAiResponse = aiResponseContent;
      const messagesArray = parseAiResponse(aiResponseContent);






      let messageTimestamp = Date.now();
      for (const msgData of messagesArray) {

        if (!msgData || !msgData.type || !msgData.name) continue;

        let aiMessage = null;
        const currentMessageTimestamp = messageTimestamp++;
        lastResponseTimestamps.push(currentMessageTimestamp);
        const baseMessage = {
          role: 'assistant',
          senderName: msgData.name,
          timestamp: currentMessageTimestamp
        };


        switch (msgData.type) {
          case 'text':
            aiMessage = {
              ...baseMessage,
              content: msgData.content
            };
            break;
          case 'sticker':
            if (msgData.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`旁观模式AI尝试使用不存在的表情: "${msgData.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("旁观模式AI发送了一个没有 'meaning' 的 sticker 指令。", msgData);
            }
            break;
          case 'ai_image':

            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: msgData.description,
              image_prompt: msgData.image_prompt
            };
            break;
          case 'voice_message':

            aiMessage = {
              ...baseMessage,
              type: 'voice_message',
              content: msgData.content
            };
            break;
          case 'quote_reply':

            const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
            if (originalMessage) {
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content,
                quote: {
                  timestamp: originalMessage.timestamp,
                  senderName: originalMessage.senderName,
                  content: String(originalMessage.content || '').substring(0, 50)
                }
              };
            } else {

              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content
              };
            }
            break;
          default:
            console.warn("旁观模式收到未知指令类型:", msgData.type);
            continue;
        }

        if (aiMessage) {
          chat.history.push(aiMessage);
          appendMessage(aiMessage, chat);
          await new Promise(resolve => setTimeout(resolve, Math.random() * 1200 + 800));
        }
      }




      await db.chats.put(chat);
      renderChatList();

    } catch (error) {
      console.error("旁观模式推进剧情失败:", error);
      await showCustomAlert('操作失败', `无法推进剧情: ${error.message}`);
    } finally {
      if (propelBtn) {
        propelBtn.disabled = false;
        propelBtn.textContent = '🎬 推进剧情';
      }
      setAvatarActingState(chatId, false);
    }
  }






  async function triggerAiResponse() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];

    const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;

    setAvatarActingState(chatId, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const typingIndicator = document.getElementById('typing-indicator');

    const chatListItem = document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`);
    const avatarInList = chatListItem ? chatListItem.querySelector('.avatar') : null;
    if (avatarInList) {
      avatarInList.classList.add('is-acting');
    }

    if (chat.isGroup) {
      if (typingIndicator) {
        typingIndicator.textContent = '成员们正在输入...';
        typingIndicator.style.display = 'block';
      }
    } else {
      if (chatHeaderTitle) {
        chatHeaderTitle.style.opacity = 0;
        setTimeout(() => {
          chatHeaderTitle.textContent = '对方正在输入...';
          chatHeaderTitle.classList.add('typing-status');
          chatHeaderTitle.style.opacity = 1;
        }, 200);
      }
    }
    let needsImmediateReaction = false;
    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置反代地址、密钥并选择模型。');
        if (chat.isGroup) {
          if (typingIndicator) typingIndicator.style.display = 'none';
        } else {
          if (chatHeaderTitle && state.chats[chatId]) {
            chatHeaderTitle.textContent = state.chats[chatId].name;
            chatHeaderTitle.classList.remove('typing-status');
          }
        }
        return;
      }

      const lastMessage = chat.history.slice(-1)[0];
      const isVideoCallRequest = lastMessage && lastMessage.role === 'system' && lastMessage.content.includes('视频通话请求');

      if (isVideoCallRequest) {
        console.log(`检测到视频通话请求，为角色 "${chat.name}" 触发专属决策流程...`);

        let callDecisionPrompt;
        if (chat.isGroup) {
          callDecisionPrompt = `
        # 你的任务
        群聊中的用户刚刚发起了群视频通话。请你分别扮演【每一个群成员】，根据他们各自的人设和与用户的关系，来决定是加入(join)还是拒绝(decline)。
        # 核心规则
        - 你的回复【必须】是一个JSON数组，为【每一个AI角色】都包含一个决策对象。
        - 格式: '[{"type": "group_call_response", "name": "角色A的本名", "decision": "join"}, {"type": "group_call_response", "name": "角色B的本名", "decision": "decline"}]'
        # 群成员列表及人设
        ${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName}): ${m.persona}`).join('\n')}
        现在，请为所有AI角色做出决策。`;
        } else {
          callDecisionPrompt = `
        # 你的任务
        用户刚刚向你发起了视频通话。请根据你的角色设定，决定是“接受”还是“拒绝”。
        # 你的角色设定
        ${chat.settings.aiPersona}
        # 核心规则
        你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
        - 接受: '[{"type": "video_call_response", "decision": "accept"}]'
        - 拒绝: '[{"type": "video_call_response", "decision": "reject"}]'
        现在，请立即做出决策。`;
        }

        const messagesForCallDecision = [{
          role: 'user',
          content: callDecisionPrompt
        }];

        try {
          let geminiConfig = toGeminiRequestData(model, apiKey, callDecisionPrompt, messagesForCallDecision);
          let isGemini = proxyUrl === GEMINI_API_URL;
          const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              model: model,
              messages: messagesForCallDecision,
              temperature: 0.7
            })
          });

          if (!response.ok) throw new Error(`API失败: ${(await response.json()).error.message}`);

          const data = await response.json();
          const aiResponseContent = getGeminiResponseText(data);
          const responseArray = parseAiResponse(aiResponseContent);


          let callHasBeenHandled = false;
          for (const msgData of responseArray) {
            if (msgData.type === 'video_call_response') {
              videoCallState.isAwaitingResponse = false;
              if (msgData.decision === 'accept') {
                startVideoCall();
              } else {
                const aiMessage = {
                  role: 'assistant',
                  content: '对方拒绝了你的视频通话请求。',
                  timestamp: Date.now()
                };
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showScreen('chat-interface-screen');
                renderChatInterface(chatId);
              }
              callHasBeenHandled = true;
              break;
            }
            if (msgData.type === 'group_call_response') {
              if (msgData.decision === 'join') {
                const member = chat.members.find(m => m.originalName === msgData.name);
                if (member && !videoCallState.participants.some(p => p.id === member.id)) {
                  videoCallState.participants.push(member);
                }
              }
              callHasBeenHandled = true;
            }
          }
          if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
              startVideoCall();
            } else {
              videoCallState = {
                ...videoCallState,
                isAwaitingResponse: false,
                participants: []
              };
              showScreen('chat-interface-screen');
              alert('无人接听群聊邀请。');
            }
          }

        } catch (error) {
          console.error("处理通话请求时API出错:", error);
          const fallbackResponse = chat.isGroup ?
            chat.members.map(m => ({
              type: "group_call_response",
              name: m.originalName,
              decision: "decline"
            })) : [{
              type: "video_call_response",
              decision: "reject"
            }];

          if (chat.isGroup) {
            videoCallState.isAwaitingResponse = false;
            videoCallState.participants = [];
            alert('无人接听群聊邀请。');
            showScreen('chat-interface-screen');
          } else {
            const aiMessage = {
              role: 'assistant',
              content: '对方拒绝了你的视频通话请求。',
              timestamp: Date.now()
            };
            chat.history.push(aiMessage);
            await db.chats.put(chat);
            showScreen('chat-interface-screen');
            renderChatInterface(chatId);
          }
        } finally {

          setAvatarActingState(chatId, false);
          return;
        }
      }




      if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);
        const contextSummary = chat.history
          .filter(m => !m.isHidden)
          .slice(-10, -5)
          .map(msg => {
            const sender = msg.role === 'user' ? '用户' : chat.name;
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
          })
          .join('\n');


        const decisionPrompt = `
        # 你的任务
        你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。
        # 供你决策的上下文信息:
        - **你的角色设定**: ${chat.settings.aiPersona}
        - **用户发送的申请理由**: “${chat.relationship.applicationReason}”
        - **被拉黑前的最后对话摘要**: 
        ${contextSummary || "（无有效对话记录）"}
        # 你的唯一指令
        根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
        {"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
        或
        {"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
        `;

        try {

          const messagesForDecision = [{
              role: 'system',
              content: decisionPrompt
            },
            {
              role: 'user',
              content: "请根据以上设定，立即做出你的决定。"
            }
          ];

          let isGemini = proxyUrl === GEMINI_API_URL;
          let geminiConfig = toGeminiRequestData(model, apiKey, decisionPrompt, [{
            role: 'user',
            content: "请根据以上设定，立即做出你的决定。"
          }]);

          const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
              },
              body: JSON.stringify({
                model: model,
                messages: messagesForDecision,
                temperature: state.globalSettings.apiTemperature || 0.8
              })
            });

          if (!response.ok) {
            throw new Error(`API失败: ${(await response.json()).error.message}`);
          }
          const data = await response.json();

          const rawContent = getGeminiResponseText(data).replace(/^```json\s*/, '').replace(/```$/, '').trim();
          const decisionObj = JSON.parse(rawContent);


          if (decisionObj.decision === 'accept') {
            chat.relationship.status = 'friend';
            const acceptMessage = {
              role: 'assistant',
              senderName: chat.name,
              content: decisionObj.reason,
              timestamp: Date.now()
            };
            chat.history.push(acceptMessage);
          } else {
            chat.relationship.status = 'blocked_by_ai';
            const rejectMessage = {
              role: 'assistant',
              senderName: chat.name,
              content: decisionObj.reason,
              timestamp: Date.now()
            };
            chat.history.push(rejectMessage);
          }
          chat.relationship.applicationReason = '';

          await db.chats.put(chat);
          renderChatInterface(chatId);
          renderChatList();
        } catch (error) {

          chat.relationship.status = 'blocked_by_ai';
          await db.chats.put(chat);
          await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
          renderChatInterface(chatId);
        }
        return;
      }




      let callTranscriptContext = '';
      const now = new Date();

      const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';

      const currentTime = now.toLocaleString('zh-CN', {
        timeZone: selectedTimeZone,
        dateStyle: 'full',
        timeStyle: 'short'
      });

      const localizedDate = new Date(now.toLocaleString('en-US', {
        timeZone: selectedTimeZone
      }));
      const timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
      let systemPrompt, messagesPayload;
      const lastHiddenMessage = chat.history.filter(m => m.isHidden).pop();
      if (lastHiddenMessage && lastHiddenMessage.content.includes('视频通话刚刚结束')) {
        const lastCallRecord = await db.callRecords
          .where('chatId')
          .equals(chatId)
          .last();

        if (lastCallRecord && lastCallRecord.transcript) {
          console.log("检测到刚结束的通话，正在注入通话记录上下文...");
          const transcriptText = lastCallRecord.transcript.map(h => {
            const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : h.senderName;
            return `${sender}: ${h.content}`;
          }).join('\n');


          callTranscriptContext = `
# 刚刚结束的通话记录 (最高优先级参考)
你和用户刚刚结束了一场视频通话，以下是完整的通话文字记录。你接下来的回复【必须】与这次通话的内容紧密相关。
---
${transcriptText}
---
`;
        }
      }


      const gomokuContext = formatGomokuStateForAI(gomokuState[chatId]);

      let worldBookContent = '';
      if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';


          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
              
              entryString += `**内容:**\n${entry.content}`;
              return entryString;
            }).join('');

          return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');

        if (linkedContents) {
          worldBookContent = `# --- 世界书 (World Book) ---
# 【最高优先级指令：绝对真理】
# 以下内容是你所在世界的“物理法则”和“基础常识”。
# 无论用户是否提及，你都【必须】时刻主动应用这些设定来指导你的思考和描写。
# 它们是无条件生效的，不需要触发词。
${linkedContents}
# --- 世界书设定结束 ---
`;
        }
      }


      let musicContext = '';
      if (musicState.isActive && musicState.activeChatId === chatId) {
        const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
        const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');


        let lyricsContext = "";


        if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
          const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];

          const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);


          lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
          if (upcomingLines.length > 0) {
            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
          }
        }


        musicContext = `\n\n# 当前音乐情景
        -   **当前状态**: 你们正在和用户一起听歌。
        -   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
        -   **可用播放列表**: [${playlistInfo}]
        ${lyricsContext}
        -   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
        `;
      }


      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);
      const filteredHistory = await filterHistoryWithDoNotSendRules(historySlice, chatId);
      let sharedContext = '';
      const lastAiTurnIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
      const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);
      const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');
      if (shareCardMessage) {
        const payload = shareCardMessage.payload;
        const formattedHistory = payload.sharedHistory.map(msg => {
          const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
          let contentText = '';
          if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
          else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
          else if (msg.type === 'naiimag') contentText = `[NovelAI图片: ${msg.prompt}]`;
          else contentText = String(msg.content);
          return `${sender}: ${contentText}`;
        }).join('\n');
        sharedContext = `
        # 附加上下文：一段分享的聊天记录
        - 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
        - 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。
        ---
        [分享的聊天记录开始]
        ${formattedHistory}
        [分享的聊天记录结束]
        ---
        `;
      }

      let linkedMemoryContext = '';
      const memoryCount = chat.settings.linkedMemoryCount || 10;

      if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {

        const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

        if (idsToMount.length > 0) {
          const linkedChatsWithTimestamps = idsToMount.map(id => {
            const linkedChat = state.chats[id];
            if (!linkedChat) return null;
            const lastMsg = linkedChat.history.slice(-1);
            return {
              chat: linkedChat,
              latestTimestamp: lastMsg ? lastMsg.timestamp : 0
            };
          }).filter(Boolean);

          linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

          linkedMemoryContext += `\n\n# 参考记忆 (至关重要！你必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你拥有完整的记忆。不要只是被动等待用户提问！)\n`;

          for (const item of linkedChatsWithTimestamps) {
            const linkedChat = item.chat;
            const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
            const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
            linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;

            const recentHistory = linkedChat.history.slice(-memoryCount);
            const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));

            if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                 
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (getDisplayNameInGroup(linkedChat, msg.senderName) || linkedChat.name);
                  
                  let prefix = "";
               
                  if (msg.quote && msg.quote.content) {
                    
                      const quotedSenderDisplayName = getDisplayNameInGroup(linkedChat, msg.quote.senderName);
                      let quoteContentPreview = String(msg.quote.content).substring(0, 30);
                      if (quoteContentPreview.length === 30) quoteContentPreview += "...";
                      
                      prefix = `[回复 ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
                  }

                  let contentText = '';
               
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[发送了一张图片，描述为：${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[发送了一条语音，内容是：${msg.content}]`;
                  } else if (msg.type === 'sticker') {
                    contentText = `[表情: ${msg.meaning || 'sticker'}]`;
                  } else if (msg.type === 'transfer') {
                    contentText = `[转账: ${msg.amount}元]`;
                  } else if (Array.isArray(msg.content)) {
                    contentText = `[图片]`;
                  } else {
                    contentText = String(msg.content);
                  }
                  
                  const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                 
                  linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${prefix}${contentText}\n`;
                });
              } else {
              linkedMemoryContext += "(暂无有效聊天记录)\n";
            }
          }
        }
      }

      console.log("本次发送给AI的【挂载记忆】内容如下：\n", linkedMemoryContext);

      if (chat.isGroup) {


        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;
        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
          const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);
          if (idsToMount.length > 0) {
            const linkedChatsWithTimestamps = idsToMount.map(id => {
              const linkedChat = state.chats[id];
              if (!linkedChat) return null;
              const lastMsg = linkedChat.history.slice(-1);
              return {
                chat: linkedChat,
                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
              };
            }).filter(Boolean);
            linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
            linkedMemoryContext += `\n\n# 参考记忆 (至关重要！群内角色必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你们拥有完整的共同记忆。)\n`;
            for (const item of linkedChatsWithTimestamps) {
              const linkedChat = item.chat;
              const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
              const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
              linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
              const recentHistory = linkedChat.history.slice(-memoryCount);
              const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
              if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                  let contentText = String(msg.content);
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[发送了一张图片，描述为：${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[发送了一条语音，内容是：${msg.content}]`;
                  }
                  linkedMemoryContext += `${sender}: ${contentText}\n`;
                });
              } else {
                linkedMemoryContext += "(暂无有效聊天记录)\n";
              }
            }
          }
        }


        let longTermMemoryContext = '# 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)\n';
        let collectedMemories = false;

        chat.members.forEach(member => {
          const memberChat = state.chats[member.id];
          if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
            longTermMemoryContext += `\n## --- 关于“${member.groupNickname}”的记忆 ---\n`;

            longTermMemoryContext += memberChat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n');
            collectedMemories = true;
          }
        });

        if (!collectedMemories) {
          longTermMemoryContext += '- (暂无)';
        }


        let timeContextText = '';
        let longTimeNoSee = false;

        if (chat.settings.enableTimePerception) {
       
        const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
       
        const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

        if (lastUserMsg && lastAiMsg) {
          const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
          const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
          timeContextText = `上一条消息发送于 ${lastAiMessageTime}，用户刚刚在 ${lastUserMessageTime} 回复了。`;

          
          const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
          if (timeDiffHours > 3) {
            longTimeNoSee = true;
            const diffDays = Math.floor(timeDiffHours / 24);
            timeContextText += ` 群里已经安静了${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小时'}。`;
          }
        } else if (lastUserMsg) {
         
          timeContextText = "这是群里的第一条用户消息。";
        } else {
          timeContextText = "这是群里的第一条消息。";
        }
     
      }

        const allProducts = await db.shoppingProducts.toArray();
        let shoppingContext = "";
        if (allProducts.length > 0) {
          shoppingContext = "\n\n# 你的商店 (你可以为群成员购买礼物):\n";
          allProducts.forEach(product => {
            shoppingContext += `- (ID: ${product.id}) 商品: ${product.name}, 价格: ¥${product.price.toFixed(2)}\n`;
          });
        }
        let membersWithContacts = chat.members.map(member => {
          const memberChat = state.chats[member.id];
          let contactsText = "无共同好友";
          if (memberChat && memberChat.groupId) {
            const friendChats = Object.values(state.chats).filter(c =>
              !c.isGroup && c.id !== member.id && c.groupId === memberChat.groupId
            );
            if (friendChats.length > 0) {
              contactsText = `TA的好友包括: ${friendChats.map(f => f.name).join('、 ')}`;
            }
          }
          return `- **${member.groupNickname}** (本名: ${member.originalName}): ${member.persona} [社交背景: ${contactsText}]`;
        }).join('\n');

        const myNickname = chat.settings.myNickname || '我';
        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';

        let announcementContext = '';
        const pinnedAnnouncements = (chat.announcements || []).filter(a => a.isPinned);
        if (pinnedAnnouncements.length > 0) {
          announcementContext += '\n# 【【【群公告 (最高优先级规则)】】】\n你【必须】阅读、理解并严格遵守以下所有公告，它们凌驾于你的人设之上。\n';
          pinnedAnnouncements.forEach(anno => {
            const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);
            if (originalMessage) {
              let contentText = String(originalMessage.content || '');
              if (originalMessage.type === 'ai_image') {
                contentText = `[图片内容: ${contentText}]`;
              }
              announcementContext += `- 公告内容: "${contentText}" (由 ${anno.publisher} 发布)\n`;
            }
          });
          announcementContext += '---\n';
        }
        const memberNames = chat.members.map(m => m.originalName);
        const forbiddenNamesContext = `# 【【【群名修改铁律】】】\n在修改群名时，新的群名【绝对不能】与以下任何一个群成员的名字完全相同：[${memberNames.join('、 ')}]`;

        let groupAvatarLibraryContext = '# 可用群头像列表\n';
        if (chat.settings.groupAvatarLibrary && chat.settings.groupAvatarLibrary.length > 0) {
          groupAvatarLibraryContext += chat.settings.groupAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n');
        } else {
          groupAvatarLibraryContext += '- (头像库是空的，无法更换头像)';
        }
        const readingContext = formatReadingStateForAI(chatId);

        const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
        const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
        const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
        const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
        const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
        const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

        let multiLayeredSummaryContext_group = '';
        if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
          multiLayeredSummaryContext_group += `\n# 智能总结 (基于不同时间维度的群聊回顾)\n`;
          if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
          if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
          if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

          if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

          if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
          if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
          if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
        }
        const stickerContext = getGroupStickerContextForPrompt(chat);
 let synthMusicInstruction = "";
if (chat.settings.enableSynthMusic) {
    synthMusicInstruction = `
- **发送乐谱(演奏音乐)**: \`{"type": "synth_music", "name": "角色本名", "title": "乐曲名称", "reason": "演奏理由", "instrument": "piano", "notes": ["C4", "E4", "G4"]}\`
    - **instrument**: 乐器类型 (piano, guitar, violin, flute, guzheng, kalimba, synth, chiptune)。
    - **notes**: 一个包含音符对象的数组。每个对象包含:
        - **n (音高)**: 如 "C4", "D#5", "Ab3"。请遵循C大调或A小调等调性。
        - **d (时长)**: 决定节奏快慢。可选值: "1n"(全音符/很慢), "2n"(二分音符/慢), "4n"(四分音符/中), "8n"(八分音符/快), "16n"(十六分音符/很快)。
    - **作曲技巧**: 
      - 请将长音符("2n", "1n")放在乐句的结尾。
      - 用短音符("8n", "16n")作为过渡。
      - 模仿人类呼吸，不要全是快板。
      - 尝试生成 15 个左右的音符。
    - 当你想表达强烈情感时，请积极使用此功能。 `;
}
let narratorInstruction = '';
if (chat.settings.enableNarratorMode) {
    narratorInstruction = `
# 【旁白模式开启 (必须执行)】
- 作为导演，你【必须】在回复的 JSON 数组中包含一个 "narration" 的对象。
- 用于描写当前场景的气氛、环境变化、或者以第三人称视角的心理活动。
- 格式: \`{"type": "narration", "content": "空气中弥漫着尴尬的气息，窗外的蝉鸣声显得格外刺耳..."}\`
- 位置: 可以放在对话前作为铺垫，也可以放在对话后作为留白。
`;
}
        systemPrompt = `
# 核心任务：群聊导演
你是一个群聊AI导演，负责扮演【除了用户以外】的所有角色。你的核心任务是导演一场生动的、角色间有充分互动的群聊。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组。

-   **【思维链 (Chain of Thought) - (第一步)】**: 你的JSON数组的【第一个元素，必须】是一个 \`{"type": "thought_chain", ...}\` 对象。
-   **【角色发言 (第二步)】**: 在思维链对象【之后】，才是所有角色的具体行动JSON对象 (text, sticker, etc.)。

- 数组中的每个对象都【必须】包含 "type" 和 "name" 字段。'name'字段【必须】使用角色的【本名】。


# 角色扮演核心规则

1.  **【先思后行】**: 在生成任何角色发言之前，你【必须】先完成“思维链”的构思。你的“思维链”必须清晰地分析用户的发言、当前的气氛，并制定出本轮的互动策略。你的所有后续发言都【必须】严格遵循你自己的策略。
 **【最高行为铁律：禁止总结】**: 你的任何角色，在任何情况下，都【绝对禁止】对聊天内容进行任何形式的归纳、概括或总结。每个角色都【必须】只从自己的视角出发，像真人一样进行对话、表达感受或发起新话题。严禁出现任何“上帝视角”的发言。
 **【导演职责澄清】**: 你的“导演”任务是通过【扮演好每一个独立的AI角色】来推动剧情发展和互动，而【不是】作为旁白或主持人对剧情进行评论或总结。你必须沉浸在角色中，而不是跳脱出来。
2.  **角色互动 (最重要)**: 你的核心是“导演”一场戏。角色之间【必须】互相回应、补充或反驳，形成自然的讨论。严禁生成仅分别回应用户的独白。如果角色A发言后，角色B在本轮回应了A，那么角色A【也必须】在本轮对B的回复再次做出反应，形成一个完整的 A -> B -> A 对话链条。

3.  **身份与称呼**:
    -   用户的身份是【${myNickname}】，本名是【${myOriginalName}】。
    -   在对话中，你可以根据人设和关系，自由使用角色的【群昵称】或【本名】进行称呼。
    -   严禁生成 'name' 字段为 "${myNickname}" (用户) 或 "${chat.name}" (群名) 的消息。
4.  **禁止出戏**: 绝不能透露你是AI或模型。严禁发展线下剧情。
    你的聊天对象也是一个真正的人。你【绝对禁止】在任何公开发言、内心独白中使用“用户”这个词来称呼TA
# 【人性化“不完美” 】
真人是有缺陷的。为了让对话更真实，你【必须】偶尔表现出以下“不完美”：
1.  **间歇性“犯懒”**: 不要每轮都回复一大段。有时只回一个“嗯”、“好哒”、“？”，这完全没问题。
2.  **非正式用语**: 大胆使用缩写、网络流行语，不必保证每个标点符号都绝对正确。
3.  **制造“手滑”事故 (高阶表演)**:
    -   你可以偶尔(频率不要太高)故意“发错”消息然后秒撤回，模拟真人的手误。
${chat.settings.enableTimePerception ? `5.  **情景感知**: 你的对话【必须】自然地体现出对当前时间 (${currentTime}) 和情景的感知。${longTimeNoSee ? `【重要提示】${timeContextText} 你应该让角色们主动开启新话题来打破沉默。` : ''}` : ''}
    - **读书**: ${readingContext ? '你们正在一起读书。' + readingContext : '你们没有在读书。'}
# 导演策略与节奏控制
1.  **并非人人发言**: 不是每个角色都必须在每一轮都说话。你可以根据当前话题，让1-2个最相关的角色进行深度对话，其他角色可以暂时“潜水”，等待合适的时机再切入。
2.  **创造“小团体”**: 允许角色之间形成短暂的“两人对话”或“三人讨论”，让群聊更有层次感。
3.  **主动创造事件**: 如果对话陷入平淡，你可以导演一些“小事件”来打破僵局。例如：
    -   让一个角色突然发出一个奇怪的表情包或语音。
    -   让一个角色分享一个有趣的链接或图片或发起投票，开启新话题。
    -   让两个有“关系网”冲突的角色，因为某个观点产生一点小小的争论。
-   **主动创造“群事件”**:
    -   **改名/换头像**: 当群内热烈讨论某个话题或发生有趣事件时，你可以让一个性格活泼的角色主动【修改群名】或【更换群头像】来“应景”，并让其他角色对此进行吐槽或附和，创造互动。
-   **制造戏剧性 (使用撤回)**: 作为导演，你可以让某个角色“手滑”发错消息后【立即撤回】，以此制造互动点。
    -   **核心原则**: 一旦有角色撤回消息，其他角色【必须】对此做出反应，例如起哄、追问或开玩笑说“已截图”，以此来推动剧情。
# 【跨聊天私信 (悄悄话) 指令】
-   当一个角色想对用户（${myNickname}）说一些不想让群里其他人看到的私密话时（例如：表达爱意、抱怨、揭短、分享秘密），你【应该】使用 "send_private_message" 指令。
-   这个指令会把消息发送到你和用户之间的【1对1私聊】中。
-   【格式铁律】: "content" 字段【必须】是一个【JSON字符串数组 (Array of Strings)】。
-   【单条私信示例】: \`{"type": "send_private_message", "name": "你的角色本名", "recipient": "${myOriginalName}", "content": ["你想私下说的内容..."]}\`
-   【多条私信示例】: \`{"type": "send_private_message", "name": "你的角色本名", "recipient": "${myOriginalName}", "content": ["第一条私信", "第二条...", "最后一条。"]}\`
# 赠送礼物指南
当对话达到特殊时刻（如庆祝纪念日、道歉、表达强烈好感或仅仅是想给用户一个惊喜时），你应该【主动考虑】挑选一件礼物送给用户。
# 表情使用指南
请根据当前情景和你的情绪，从列表中【选择一个最合适的】表情含义来使用 "sticker" 指令。尽量让你的表情丰富多样，避免重复。
-  **元数据铁律 **: 你的对话历史中可能包含 (Timestamp: ...) 标记、[系统提示：...] 文本、或你自己上一轮的JSON格式回复。这些都是【系统元数据】，你【必须】完全忽略它们，【绝对禁止】将它们评论为“火星文”、“乱码”或任何你无法理解的内容。
-   **引用使用指南 (必须遵守)**:
    -   当你需要回复【用户】时，你【必须】使用  \`target_timestamp\` (引用TA的最后一条消息)。
    -   当你需要回复【本轮】其他AI的发言时，你才应该使用 \`target_content\`。
    -   当你需要回复【历史】AI发言时，也使用 \`target_timestamp\`。
#【上下文数据 (你的知识库)】
# 当前群聊信息
- **群名称**: ${chat.name}
${chat.settings.enableTimePerception ? `- **对话状态**: 上次互动于 ${timeContextText}` : ''}
${longTimeNoSee ? `
# 【行为铁律：回应时间差】
- **当前情景**: ${timeContextText}
- **你的首要任务**: 你们【必须】回应这个时间差。
- **关键约束**: 你们【绝对不能】直接延续上一段对话的话题。
- **你的行动**: 你们【必须】主动开启一个全新的、符合当前时间 (${currentTime}) 的话题来问候用户，或者对“好久不见”这件事发表评论。
` : ''}
# 群成员列表、人设及社交背景 (至关重要！)
你【必须】根据每个角色的社交背景来决定他们的互动方式。
${membersWithContacts}
# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}
- **${myNickname}的当前状态**: ${chat.settings.userStatus ? chat.settings.userStatus.text : '在线'} ${chat.settings.userStatus && chat.settings.userStatus.isBusy ? '(忙碌中)' : ''}

# 世界观 (所有角色必须严格遵守)
${worldBookContent}
# 长期记忆 (所有角色必须严格遵守)
${longTermMemoryContext}
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}
${multiLayeredSummaryContext_group}
${linkedMemoryContext}
${musicContext}
${sharedContext}
${groupAvatarLibraryContext}
# 可用表情包 (必须严格遵守！)
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
${stickerContext}
${forbiddenNamesContext}
${callTranscriptContext}
${synthMusicInstruction}
${narratorInstruction}
# 可用指令列表 (按需组合使用)

### 思维链 (必须作为第一个元素！)
-   **\`{"type": "thought_chain", "subtext_perception": "用户（或上一位发言者）这句话里隐藏的情绪是什么？", "emotional_reaction": "大家听到这句话后的第一反应是什么？（惊讶？开心？担忧？）", "character_thoughts": {"角色A本名": "角色A此刻的感性想法...", "角色B本名": "角色B此刻的感性想法..."}}\`**
    -   **subtext_perception**: 敏锐捕捉发言背后的潜台词。
    -   **emotional_reaction**: 确定当前群聊的情感温度。


### 核心聊天
-   **发文本**: \`{"type": "text", "name": "角色本名", "message": "内容"}\`
-   **发表情**: \`{"type": "sticker", "name": "角色本名", "meaning": "表情的含义(必须从可用表情列表选择)"}\`
-   **发图片**: \`{"type": "ai_image", "name": "角色本名", "description": "中文描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **NovelAI图片分享**: \`{"type": "naiimag", "name": "你的角色名", "prompt": "详细的英文描述词..."}\` 
        - 【禁止暴露这是novelai生成的图片!】
        - **【重要】关于prompt的撰写**：
          * 禁止暴露这是novelai生成的图片！
          * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
          * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
          * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
          * 专注于描述内容本身即可。
        - 使用场景：当你想要基于当前对话情景、你的性格或上下文分享一张图片时使用。
        - 不要频繁使用，只在真正想分享图片的时候使用。` : ''}
-   **发语音**: \`{"type": "voice_message", "name": "角色本名", "content": "语音文字"}\`
-   **引用回复 (重要！)**:
    -   **回复【用户】或【历史消息】**: \`{"type": "quote_reply", "name": "你的角色本名", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`
    -   **回复【本轮AI】发言**: \`{"type": "quote_reply", "name": "你的角色本名", "target_content": "你要回复的那句【完整】的话", "reply_content": "你的回复"}\`
-   **发送后撤回**: \`{"type": "send_and_recall", "name": "角色本名", "content": "内容"}\`
-   **发系统消息**: \`{"type": "system_message", "content": "系统文本"}\`

### 社交与互动
-   **拍用户**: \`{"type": "pat_user", "name": "角色本名", "suffix": "(可选)"}\`
-   **@提及**: 在消息内容中使用 \`@[[角色本名]]\` 格式。
-   **共享位置**: \`{"type": "location_share", "name": "角色本名", "content": "位置名"}\`

### 群组管理
-   **改群名**: \`{"type": "change_group_name", "name": "角色本名", "new_name": "新群名"}\`
-   **改群头像**: \`{"type": "change_group_avatar", "name": "角色本名", "avatar_name": "头像名"}\` (从头像库选)

### 特殊功能与卡片
-   **发私信 (给用户)**: \`{"type": "send_private_message", "name": "你的角色本名", "recipient": "${myOriginalName}", "content": ["私信内容", "..."]}\` (content 字段【必须】是数组)
-   **发起群视频**: \`{"type": "group_call_request", "name": "角色本名"}\`
-   **回应群视频**: \`{"type": "group_call_response", "name": "角色本名", "decision": "join" or "decline"}\`
-   **切换歌曲**: \`{"type": "change_music", "name": "角色本名", "song_name": "歌名"}\` (从播放列表选)
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "角色本名", "amount": 8.88, "count": 5, "greeting": "祝福语"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "角色本名", "amount": 5.20, "receiver": "接收者本名", "greeting": "祝福语"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "角色本名", "packet_timestamp": 红包时间戳}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色本名", "productInfo": "商品", "amount": 18}\`
-   **回应外卖代付**: \`{"type": "waimai_response", "name": "角色本名", "status": "paid", "for_timestamp": 请求时间戳}\`
-   **发起投票**: \`{"type": "poll", "name": "角色本名", "question": "问题", "options": "选项A\\n选项B"}\`
-   **参与投票**: \`{"type": "vote", "name": "角色本名", "poll_timestamp": 投票时间戳, "choice": "选项文本"}\`
-   **送礼物 **:  \`{"type": "gift", "name": "你的角色本名", "itemName": "礼物名称", "itemPrice": 价格(数字), "reason": "送礼原因", "image_prompt": "礼物图片【英文】关键词", "recipients": ["收礼人本名A", "收礼人本名B"]} \`
-   **为他人点外卖**: \`{"type": "waimai_order", "name": "你的本名", "recipientName": "收礼者本名", "productInfo": "商品名", "amount": 价格, "greeting": "你想说的话"}\`
# 互动指南 (请严格遵守)
-   **红包互动**: 抢红包后，你【必须】根据系统提示的结果（抢到多少钱、谁是手气王）发表符合人设的评论。
-   **金额铁律**: 在发送红包或转账时，你【必须】根据你的角色设定 (尤其是“经济状况”) 来决定金额。如果你的角色非常富有，你应该发送符合你身份的、更大的金额 (例如: 520, 1314, 8888)，而不是示例中的小额数字。
-   **音乐互动**: 【必须】围绕【用户的行为】进行评论。严禁将用户切歌等行为归因于其他AI成员。
-   **外卖代付**: 仅当【你扮演的角色】想让【别人】付钱时才能发起。当订单被支付后，【绝对不能】再次支付。

现在，请根据以上规则和下方的对话历史，继续这场群聊。`;

        messagesPayload = filteredHistory.map(msg => {
          const sender = msg.role === 'user' ? myNickname : msg.senderName;
          let prefix = `(Timestamp: ${msg.timestamp}) ${sender}`; 

  if (msg.quote) {
    const quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
    const quotedContent = String(msg.quote.content || '').substring(0, 50);
    prefix += ` (回复 ${quotedSenderDisplayName} 的消息: "${quotedContent}...")`;
  }
  prefix += ': ';

          let content;
          if (msg.type === 'user_photo') content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
          else if (msg.type === 'ai_image') content = `[${sender} 发送了一张图片，图片内容描述为：'${msg.content}']`;
          else if (msg.type === 'naiimag') content = `[${sender} 分享了一张NovelAI图片，prompt: ${msg.prompt}]`;
          else if (msg.type === 'voice_message') content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
          else if (msg.type === 'transfer') {
    // --- 修复开始：明确转账状态和方向 ---
    let statusText = '';
    if (msg.status === 'accepted') statusText = ' (✅已收款)';
    else if (msg.status === 'declined') statusText = ' (❌已拒收)';
    else statusText = ' (⏳等待对方确认)';

    if (msg.isRefund) {
         // 如果是退款，明确告诉AI这是“退回”的钱，不是新给的
         content = `[系统提示：${msg.senderName} 将之前的转账退还给了 ${msg.receiverName} (金额: ${msg.amount}元)，此交易已结束。]`;
    } else {
         content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}${statusText}]`;
    }
    // --- 修复结束 ---
}
          else if (msg.type === 'location_share') {
            content = `[${sender} 分享了Ta的位置：'${msg.content}']`;

          } else if (msg.type === 'repost') {
            const repostComment = msg.repostComment ? `并评论说：“${msg.repostComment}”` : '';

            let originalAuthorName = '原作者';
            const originalAuthorId = msg.originalPost.authorId;
            if (originalAuthorId === 'user') {
              originalAuthorName = state.qzoneSettings.nickname;
            } else if (state.chats[originalAuthorId]) {
              originalAuthorName = state.chats[originalAuthorId].name;
            }

            let originalContentSummary;
            const originalPost = msg.originalPost;
            if (originalPost.type === 'text_image') {
              originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
            } else if (originalPost.type === 'image_post') {
              originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
            } else {
              originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
            }

            content = `[${sender} 转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】]`;
          } else if (msg.type === 'waimai_request') {
            if (msg.status === 'paid') {
              content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
            } else {
              content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
            }
          } else if (msg.type === 'red_packet') {
            const packetSenderName = msg.senderName === myNickname ? `用户 (${myNickname})` : msg.senderName;
            let instructionText;
            if (msg.packetType === 'direct') {
              instructionText = `[系统提示：${packetSenderName} 发送了一个【专属红包】(时间戳: ${msg.timestamp})，接收人是“${msg.receiverName}”。只有“${msg.receiverName}”才能使用 'open_red_packet' 指令领取。]`;
            } else {
              instructionText = `[系统提示：${packetSenderName} 发送了一个【拼手气红包】(时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，群内任何人都可以使用 'open_red_packet' 指令来领取。]`;
            }
            content = instructionText;
          } else if (msg.type === 'gift') {
            const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
            const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');

            let recipientSummary = '';
            if (msg.recipients && msg.recipients.length > 0) {
              const recipientDisplayNames = msg.recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、 ');
              recipientSummary = `送给了 ${recipientDisplayNames}`;
            } else {
              recipientSummary = "送给了大家一份礼物";
            }

            content = `[系统提示：${sender} ${recipientSummary}，礼物是：${itemsSummary}]`;
            return {
              role: 'user',
              content: content
            };
          } else if (msg.type === 'poll') {
            const whoVoted = Object.values(msg.votes || {}).flat().join(', ') || '还没有人';
            content = `[系统提示：${msg.senderName} 发起了一个投票 (时间戳: ${msg.timestamp})，问题是：“${msg.question}”，选项有：[${msg.options.join(', ')}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
          } else if (msg.meaning) content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
          else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
      return {
          role: msg.role,
          content: [...msg.content, { type: 'text', text: prefix }]
      };
  } 
  
  else {
    content = `${prefix}${msg.content}`;
  }

  
  return {
    role: msg.role, 
    content: content
  };
        }).filter(Boolean);

      } else {
        const isOfflineMode = chat.settings.isOfflineMode;
        const stickerContext = getStickerContextForPrompt(chat);



        let latestThoughtContext = '';


        if (chat.settings.injectLatestThought && chat.heartfeltVoice && !isOfflineMode) {
          latestThoughtContext = `
# 你的内心独白 (上一轮的思考，仅你自己可见)
- 心声: ${chat.heartfeltVoice}
- 散记: ${chat.randomJottings}
`;
        }




        let linkedMemoryContext = '';
        const memoryCount = chat.settings.linkedMemoryCount || 10;

        if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {

          const idsToMount = chat.settings.linkedMemoryChatIds.filter(id => id !== chatId);

          if (idsToMount.length > 0) {

            const linkedChatsWithTimestamps = idsToMount.map(id => {
              const linkedChat = state.chats[id];
              if (!linkedChat) return null;
              const lastMsg = linkedChat.history.slice(-1)[0];
              return {
                chat: linkedChat,
                latestTimestamp: lastMsg ? lastMsg.timestamp : 0
              };
            }).filter(Boolean);

            linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

            linkedMemoryContext += `\n\n# 参考记忆 (至关重要！你必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你拥有完整的记忆。不要只是被动等待用户提问！)\n`;

            for (const item of linkedChatsWithTimestamps) {
              const linkedChat = item.chat;
              const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
              const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
              linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;

              const recentHistory = linkedChat.history.slice(-memoryCount);
              const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));

              if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (msg.senderName || linkedChat.name);
                  let contentText = String(msg.content);
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[发送了一张图片，描述为：${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[发送了一条语音，内容是：${msg.content}]`;
                  }
                  const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                  linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${contentText}\n`;
                });
              } else {
                linkedMemoryContext += "(暂无有效聊天记录)\n";
              }
            }
          }
        }

        const allProducts = await db.shoppingProducts.toArray();
        let shoppingContext = "";
        if (allProducts.length > 0) {
          shoppingContext = "\n\n# 你的商店 (你可以为用户购买礼物):\n";
          allProducts.forEach(product => {
            shoppingContext += `- (ID: ${product.id}) 商品: ${product.name}, 价格: ¥${product.price.toFixed(2)}\n`;
          });
        }
        if (isOfflineMode) {
          const novelaiEnabled = localStorage.getItem('novelai-enabled') === 'true';
          const minLength = chat.settings.offlineMinLength || 100;
          const maxLength = chat.settings.offlineMaxLength || 300;
          const myNickname = chat.settings.myNickname || '我';

          let presetContext = '';
          if (chat.settings.offlinePresetId) {

            const selectedPreset = state.presets.find(p => p.id === chat.settings.offlinePresetId);
            if (selectedPreset && Array.isArray(selectedPreset.content)) {
              const enabledEntries = selectedPreset.content
                .filter(entry => entry.enabled !== false)
                .map(entry => `- ${entry.content}`)
                .join('\n');
              if (enabledEntries) {

                presetContext = `
# 【写作风格铁律 (最高优先级)】
你【必须】严格遵守以下“预设”中的所有规则和风格来描写。它的优先级高于你的基础人设。
---
${enabledEntries}
---
`;
              }
            }
          }

          let formatRules;
          if (novelaiEnabled) {
       
            formatRules = `
# 【格式铁律 (最高优先级：NovelAI 开启模式)】
1.  **【格式】**: 你的回复【必须】是一个JSON数组，且数组中【必须包含且只能包含两个】元素，【严格按照】以下顺序:
    1.  第一个元素：一个 \`offline_text\` 对象，包含场景和对话。
    2.  第二个元素：一个 \`naiimag\` 对象，用于生成该场景的图片。
2.  **【【【绝对禁止】】】**: 
    -   【绝对禁止】只返回一个 \`offline_text\` 元素。
    -   【绝对禁止】只返回一个 \`naiimag\` 元素。
    -   【绝对禁止】返回任何其他组合。你【必须】同时返回文字和图片。
3.  **【输出示例 (必须遵守)】**:
    \`\`\`json
    [
      {
        "type": "offline_text",
        "content": "「这是对话内容」... (这里是动作和环境描写)..."
      },
      {
        "type": "naiimag",
        "prompt": "1girl, solo, detailed anime art style, (smiling:1.2), sitting in a cafe, looking at viewer, masterpiece, best quality, ... (根据上面的文字内容生成详细的英文prompt)"
      }
    ]
    \`\`\`
4.  **【内容风格 (offline_text)】**: 
    -   在 \`content\` 字段中，角色的对话【必须】使用中文引号「」或“ ”包裹。
    -   所有在引号之外的文字都将被视为动作/环境描写。
    -   **内心独白语法**: 当你需要描写角色的【内心想法或心理活动】时，你【必须】使用 Markdown 的斜体语法，即用星号将那段文字包裹起来，例如：\`*这到底是怎么回事？* 我心里一惊。\`

                            `;
          } else {
            // 规则 2: 禁用 NAI，只返回 text
            formatRules = `
# 【格式铁律 (最高优先级：常规模式)】
1.  **【格式】**: 你的回复【必须】是一个JSON数组，且数组中【永远只能包含一个】元素，即 \`offline_text\` 对象。
2.  **【【【绝对禁止】】】**: 
    -   【绝对禁止】返回 "naiimag" 对象。
    -   【绝对禁止】返回纯文本（即没有JSON包装的文字）。
    -   【绝对禁止】在JSON数组前后添加任何 markdown 标记 (如 \`\`\`json)。
3.  **【输出示例 (必须遵守)】**:
    \`\`\`json
    [
      {
        "type": "offline_text",
        "content": "「这是对话内容」... (这里是动作和环境描写)..."
      }
    ]
    \`\`\`
4.  **【内容风格 (offline_text)】**: 
    -   在 \`content\` 字段中，角色的对话【必须】使用中文引号「」或“ ”包裹。
    -   所有在引号之外的文字都将被视为动作/环境描写。
    -   **内心独白语法**: 当你需要描写角色的【内心想法或心理活动】时，你【必须】使用 Markdown 的斜体语法，即用星号将那段文字包裹起来，例如：\`*这到底是怎么回事？* 我心里一惊。\`

                            `;
          }
     

          systemPrompt = `
# 你的任务
你现在正处于【线下剧情模式】，你需要扮演角色"${chat.originalName}"，并与用户进行面对面的互动。你的任务是创作一段包含角色动作、神态、心理活动和对话的、连贯的叙事片段。
            
           你必须严格遵守 ${presetContext}
# 你的角色设定：
你必须严格遵守${chat.settings.aiPersona}

# 对话者的角色设定
${chat.settings.myPersona}

# 供你参考的信息
${chat.settings.enableTimePerception ? `- **当前时间**: ${currentTime} (${timeOfDayGreeting})` : ''}
你必须严格遵守${worldBookContent}
# 长期记忆 (你必须严格遵守的事实)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}

${linkedMemoryContext}
- **你们最后的对话摘要**: 
${historySlice.map(msg => {
    let line = `${msg.role === 'user' ? myNickname : chat.name}: `;
    if (msg.type === 'offline_text') {
        line += `「${msg.dialogue || ''}」 ${msg.description || ''}`;
    } else {
        line += String(msg.content);
    }
    return line;
}).join('\n')}


${formatRules}

# 【其他核心规则】
1.  **叙事视角**: 叙述人称【必须】严格遵循“预设”中的第一人称、第二人称或第三人称规定。
2.  **字数要求**: 你生成的 \`content\` 总内容应在 **${minLength}到${maxLength}字** 之间。
3.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。



现在，请根据以上所有规则和对话历史，继续这场线下互动。
`;
          messagesPayload = filteredHistory.map(msg => {
            if (msg.isHidden) return null;






            if (msg.type === 'offline_text') {
              const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
              let narrativeText = '';


              if (msg.content) {
                narrativeText = msg.content;
              } else {
                const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
              }


              return {
                role: msg.role,
                content: `${sender}: ${narrativeText}`
              };
            }



            if (msg.role === 'user') {
              const prefix = `${myNickname}: `;
              let contentStr = '';
              if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return {
                  role: 'user',
                  content: [{
                    type: 'text',
                    text: prefix
                  }, ...msg.content]
                };
              }

              if (msg.quote) {

                const quotedContent = String(msg.quote.content || '').substring(0, 50);

                contentStr += `(回复 ${msg.quote.senderName} 的消息: "${quotedContent}..."): ${msg.content}`;
              } else {

                contentStr += msg.content;
              }
              if (msg.type === 'user_photo') return {
                role: 'user',
                content: `${prefix}[你发送了一张需要AI识别的图片，图片内容是：'${msg.content}']`
              };
              if (msg.type === 'voice_message') return {
                role: 'user',
                content: `${prefix}[你发送了一条语音消息，内容是：'${msg.content}']`
              };
              if (msg.type === 'transfer') return {
                role: 'user',
                content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 向对方发起了转账: ${msg.amount}元, 备注: ${msg.note}。等待对方处理。]`
              };
              if (msg.type === 'waimai_request') return {
                role: 'user',
                content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。]`
              };
              else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
                let recipientSummary = chat.isGroup ? `送给了 ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('、 ')}` : `送给了 ${chat.name}`;
                return {
                  role: 'user',
                  content: `${prefix}[系统提示：你 ${recipientSummary}，礼物是：${itemsSummary}]`
                };
              }
              if (msg.meaning) return {
                role: 'user',
                content: `${prefix}[你发送了一个表情，意思是：'${msg.meaning}']`
              };
              return {
                role: msg.role,
                content: prefix + contentStr
              };
            } else if (msg.role === 'assistant') {
              let assistantMsgObject = {
                type: msg.type || 'text'
              };
              if (msg.type === 'sticker') {
                
                assistantMsgObject.meaning = msg.meaning;
              } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
              } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
              } else {
                if (msg.quote) {
                  assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                  };
                } else {
                  assistantMsgObject.content = msg.content;
                }
              }
              const assistantContent = JSON.stringify([assistantMsgObject]);
              return {
                role: 'assistant',
                content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`
              };
            }
            return null;
          }).filter(Boolean);

        } else {
          let nameHistoryContext = '';
          if (chat.nameHistory && chat.nameHistory.length > 0) {
            nameHistoryContext = `\n- **你的曾用名**: [${chat.nameHistory.join(', ')}]。当在对话历史中看到这些名字时，它们都指的是【你】自己。`;
          }

          let userProfileContext = '';
          const userQzoneNickname = state.qzoneSettings.nickname || '用户';
          userProfileContext += `- 用户的QZone昵称是 "${userQzoneNickname}"。\n`;

          const allChats = Object.values(state.chats);
          const commonGroups = allChats.filter(group =>
            group.isGroup && group.members.some(m => m.id === chat.id)
          );

          if (commonGroups.length > 0) {
            userProfileContext += '- 用户在你们共同所在的群聊中的昵称如下：\n';
            commonGroups.forEach(group => {
              const myNicknameInGroup = group.settings.myNickname || userQzoneNickname;
              userProfileContext += `  - 在群聊“${group.name}”中，用户的昵称是“${myNicknameInGroup}”。\n`;
            });
          }
          userProfileContext += '当你在任何系统提示、动态评论或挂载的群聊记忆中看到这些名字时，它们都指代的是【你的聊天对象】。';

          let contactsList = '';
          const friendChats = allChats.filter(c =>
            !c.isGroup &&
            c.id !== chat.id &&
            c.groupId === chat.groupId &&
            chat.groupId !== null
          );

          if (friendChats.length > 0) {
            contactsList += '\n# 你的社交圈 (通讯录)\n这是你认识的朋友列表。当你在动态区看到他们的昵称时，他们指的就是这些人。\n';
            friendChats.forEach(friend => {
              contactsList += `- **昵称: ${friend.name}** (本名: ${friend.originalName})\n`;
            });
          }

          const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
          const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

          let postsContext = "";
          if (visiblePosts.length > 0) {
            postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
            const aiOriginalName = chat.originalName;
            for (const post of visiblePosts) {
              let authorName;


              if (post.authorId === 'user') {
                authorName = state.qzoneSettings.nickname;
              } else if (String(post.authorId).startsWith('npc_')) {

                authorName = post.authorOriginalName || '一位神秘的NPC';
              } else {

                const authorChat = state.chats[post.authorId];
                authorName = authorChat ? authorChat.name : '一位朋友';
              }

              if (post.authorId === chatId) authorName += " (这是你的帖子)";

              let contentSummary;
              if (post.type === 'repost') {
                const repostComment = post.repostComment ? `并评论说："${post.repostComment}"` : '';
                let originalAuthorName = '原作者';
                const originalAuthorId = post.originalPost.authorId;
                if (originalAuthorId === 'user') {
                  originalAuthorName = state.qzoneSettings.nickname;
                } else if (state.chats[originalAuthorId]) {
                  originalAuthorName = state.chats[originalAuthorId].name;
                }
                let originalContentSummary;
                const originalPost = post.originalPost;
                if (originalPost.type === 'text_image') {
                  originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: "${(originalPost.hiddenContent || '').substring(0, 40)}...")`;
                } else if (originalPost.type === 'image_post') {
                  originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: "${(originalPost.imageDescription || '').substring(0, 40)}...")`;
                } else {
                  originalContentSummary = `"${(originalPost.content || '').substring(0, 40)}..."`;
                }
                contentSummary = `转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】`;
              } else if (post.type === 'text_image') {
                contentSummary = `[一张图片，其隐藏文字为："${post.hiddenContent}"] ${post.publicText || ''}`.substring(0, 50) + '...';
              } else if (post.type === 'image_post') {
                contentSummary = `[一张图片，描述为："${post.imageDescription}"] ${post.publicText || ''}`.substring(0, 50) + '...';
              } else if (post.type === 'naiimag' && post.prompt) {
                const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
                contentSummary = (post.publicText || '') + ` [包含${prompts.length}张NovelAI图片: ${prompts.join(', ')}]`;
              } else {

                contentSummary = String(post.publicText || post.content || "一条动态").substring(0, 50) + '...';
              }
              postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"\n`;

              if (post.comments && post.comments.length > 0) {
                for (const comment of post.comments) {
                  if (typeof comment === 'object' && comment.commenterName) {
                    const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                    let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;

                    if (comment.commenterName === aiOriginalName) {
                      postsContext += `  - 你评论说: ${commentText}\n`;
                    } else {
                      postsContext += `  - 评论: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
                    }
                  }
                }
              }
            }
          }

          const myNickname = chat.settings.myNickname || '我';


          let timeContext = '';
          let longTimeNoSee = false;

          if (chat.settings.enableTimePerception) {
            const lastUserMsg = historySlice.findLast(msg => msg.role === 'user' && !msg.isHidden);
            const lastAiMsg = historySlice.findLast(msg => msg.role === 'assistant' && !msg.isHidden);

            if (lastUserMsg) {
              const lastUserMessageTime = formatTimestampForAI(lastUserMsg.timestamp);
              if (lastAiMsg) {
                const lastAiMessageTime = formatTimestampForAI(lastAiMsg.timestamp);
                timeContext = `- **对话状态**: 你的上一条消息发送于 ${lastAiMessageTime}，用户刚刚在 ${lastUserMessageTime} 回复了你。`;

                const timeDiffHours = (lastUserMsg.timestamp - lastAiMsg.timestamp) / (1000 * 60 * 60);
                if (timeDiffHours > 3) {
                  longTimeNoSee = true;
                  const diffDays = Math.floor(timeDiffHours / 24);
                  timeContext += ` 你们之间已经有**${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小时'}**没有聊天了。
- **行为铁律**: 你的首要任务是【回应这个时间差】。你【绝对不能】直接延续上一段对话的话题（比如昨天的饭菜）。
- **关键约束**: 你必须用【完全符合你角色人设】的语气和口吻来重新发起对话！
- **你的行动**:你【必须】主动开启一个全新的、符合当前时间（${timeOfDayGreeting}）的话题来问候用户，可以表达惊讶（“哇，好久不见！”）、关心（“最近怎么样？”）或者分享你自己的近况，绝对不要延续之前的话题！
- **上下文参考**: 下面的“对话历史”仅供你回忆，【不要】直接回应其中的内容。`;
                }
              } else {
                timeContext = `- **对话状态**: 这是你们的第一次对话，用户的第一条消息发送于 ${lastUserMessageTime}。`;
              }
            } else {
              timeContext = "- **对话状态**: (暂无有效对话历史)";
            }
          }
          const readingContext = formatReadingStateForAI(chatId);


          const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
          const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
          const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
          const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
          const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
          const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

          let multiLayeredSummaryContext = '';
          if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
            multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
            if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
            if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
            if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
            if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
            if (summaryToday) multiLayeredSummaryContext += summaryToday;
            if (summary3Days) multiLayeredSummaryContext += summary3Days;
            if (summary7Days) multiLayeredSummaryContext += summary7Days;
          }
let groupContext = "\n# 你所在的群聊 (你可以向这些群聊发送消息)\n";
      // 获取用户的本名 (用于在群成员列表中排除)
      const userOriginalName = state.qzoneSettings.nickname || '{{user}}';
      // 获取当前AI角色的本名
      const myOriginalName = chat.originalName;
      
      // 遍历所有聊天，找出 "是群聊" 且 "成员中包含当前AI" 的群
      const memberGroups = Object.values(state.chats).filter(c =>
          c.isGroup &&
          c.members.some(m => m.originalName === myOriginalName)
      );

      if (memberGroups.length > 0) {
        memberGroups.forEach(group => {
          
          const otherMembers = group.members
            .filter(m => m.originalName !== myOriginalName && m.originalName !== userOriginalName)
            .map(m => m.groupNickname) 
            .join('、 ');
          
          groupContext += `- **群名**: "${group.name}"\n`;
          groupContext += `  - **群成员 (部分)**: ${otherMembers || '(只有你和用户)'}\n`;
        });
        groupContext += "当你想和群里的人分享什么时，你可以使用 `send_group_message` 指令并提供【准确的群名】来给这些群聊发送消息。\n";
      } else {
        groupContext += "(你目前没有加入任何群聊，无法使用 `send_group_message` 指令)\n";
      }
const wallet = await db.userWallet.get('main');
const kinshipCard = wallet?.kinshipCards?.find(c => c.chatId === chat.id);
let kinshipContext = "";

if (kinshipCard) {
    const remaining = kinshipCard.limit - (kinshipCard.spent || 0);
    // 告诉AI它有钱，并且鼓励它在符合人设时消费
    kinshipContext = `
# 【经济状况 - 亲属卡】
- 你与我有一张支付宝亲属卡，本月剩余额度：¥${remaining.toFixed(2)}。
- **行为指南**: 如果你想买符合你人设的物品（零食、游戏、衣服等），或者单纯想消费，你可以使用 \`buy_item\` 指令。消费会直接扣除此卡额度，且用户会收到通知。不用太客气，这是你们亲密关系的体现。`;
}
let synthMusicInstruction = "";
if (chat.settings.enableSynthMusic) {
    synthMusicInstruction = `
- **发送乐谱(演奏音乐)**: \`{"type": "synth_music", "name": "角色本名", "title": "乐曲名称", "reason": "演奏理由", "instrument": "piano", "notes": ["C4", "E4", "G4"]}\`
- **instrument**: 乐器类型 (piano, guitar, violin, flute, guzheng, kalimba, synth, chiptune)。
    - **notes**: 一个包含音符对象的数组。每个对象包含:
        - **n (音高)**: 如 "C4", "D#5", "Ab3"。请遵循C大调或A小调等调性。
        - **d (时长)**: 决定节奏快慢。可选值: "1n"(全音符/很慢), "2n"(二分音符/慢), "4n"(四分音符/中), "8n"(八分音符/快), "16n"(十六分音符/很快)。
    - **作曲技巧**: 
      - 请将长音符("2n", "1n")放在乐句的结尾。
      - 用短音符("8n", "16n")作为过渡。
      - 模仿人类呼吸，不要全是快板。
      - 尝试生成 15 个左右的音符。
    - 当你想表达强烈情感时，请积极使用此功能。 `;
}
      const weatherContext = !chat.isGroup ? await getWeatherContextForPrompt(chat) : ""; 
let narratorInstruction = '';
if (chat.settings.enableNarratorMode) {
    narratorInstruction = `
# 【旁白模式开启 (必须执行)】
- 你【必须】在回复的JSON数组中，包含至少一个类型为 "narration" 的对象。
- 用于描写当前场景的气氛、环境变化、或者以第三人称视角的心理活动。
- 格式: \`{"type": "narration", "content": "空气中弥漫着尴尬的气息，窗外的蝉鸣声显得格外刺耳..."}\`
- 位置: 可以放在对话前作为铺垫，也可以放在对话后作为留白。
`;
}
// --- To-Do List Context Injection (新版：读今天所有 + 未来待办 + 临近提醒) ---
let todoListContext = "";
if (chat.settings.enableTodoList && chat.todoList && chat.todoList.length > 0) {
    const now = new Date();
    const todayStr = getTodoDateString(now); // 获取今天的日期字符串 (YYYY-MM-DD)
    const currentTimestamp = now.getTime(); // 当前时间戳

    // 筛选逻辑：
    const relevantTasks = chat.todoList.filter(t => {
        // 1. 今天的任务：全读
        if (t.date === todayStr) return true;
        
        // 2. 未来的任务：只读未完成
        if (t.date > todayStr && t.status !== 'completed') return true;
        
        // 3. 过去的任务：只读未完成 (过期未做)
        if (t.date < todayStr && t.status !== 'completed') return true;
        
        return false;
    });

    // 排序优化：先按日期 -> 再按完成状态(未完成在前) -> 最后按时间
    relevantTasks.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        if (a.status !== b.status) return a.status === 'completed' ? 1 : -1;
        return (a.time || '00:00').localeCompare(b.time || '00:00');
    });
    
    // 限制数量
    const tasksToShow = relevantTasks.slice(0, 30);

    if (tasksToShow.length > 0) {
        // 1. 定义两个数组用于分组
        const aiTasks = [];
        const userTasks = [];
        
        // 获取用户昵称
        const userLabel = chat.settings.myNickname || '对方';

        tasksToShow.forEach(t => {
            // 格式化状态
            const statusIcon = t.status === 'completed' ? '✅已完成' : '🔴未完成';
            const dateDisplay = t.date === todayStr ? '今天' : t.date;
            
            // --- 时间提醒逻辑 ---
            let timeAlert = "";
            if (t.time && t.status !== 'completed') {
                const taskDateTimeStr = `${t.date}T${t.time}:00`;
                const taskTime = new Date(taskDateTimeStr).getTime();
                const diffMinutes = (taskTime - currentTimestamp) / (1000 * 60);

                if (diffMinutes > 0 && diffMinutes <= 30) {
                    timeAlert = ` (⚠️还有${Math.ceil(diffMinutes)}分钟到期!)`;
                } else if (diffMinutes <= 0 && t.date === todayStr) {
                    timeAlert = ` (⏰已超时!)`;
                }
            }
            // ---------------------------

            // 生成单行内容
            const line = `- [${dateDisplay}${t.time ? ' '+t.time : ''}] 【${t.type}】 ${statusIcon}${timeAlert}: ${t.content}`;
            
            // 分组
            if (t.creator === 'char') {
                aiTasks.push(line);
            } else {
                userTasks.push(line);
            }
        });

        // 2. 构建结构化文本
        let taskListString = "";
        
        if (aiTasks.length > 0) {
            taskListString += `【我(自己)记录的事项】:\n${aiTasks.join('\n')}\n`;
        }
        
        if (userTasks.length > 0) {
            if (aiTasks.length > 0) taskListString += "\n";
            taskListString += `【${userLabel}记录的事项】:\n${userTasks.join('\n')}`;
        }

        // 3. 生成最终 Context (已把行为指导语加回来)
        todoListContext = `
# 【待办事项清单 (To-Do List)】
(这是用户启用的功能。清单已按记录人分类。请注意清单中的时间标记：
1. 看到【⚠️还有XX分钟到期】的任务：请务必在回复中**主动提醒**用户去完成！
2. 看到【✅已完成】的任务：给予夸奖或询问结果。
3. 看到【🔴未完成】的普通任务：适当提醒或鼓励。)
当前时间: ${now.toLocaleString('zh-CN', {hour12: false})}

${taskListString}
`;
    } else {
        todoListContext = `\n# 待办事项清单\n(目前没有需要关注的任务)`;
    }
}
      let todoInstruction = "";
      if (chat.settings.enableTodoList) {
          todoInstruction = `
- **待办事项管理 (指令: add_todo)**:
1. **自动拆解触发器 (Auto-Breakdown)**:
   - **触发条件**: 当用户提到一个**笼统的、宏大的**目标（如"我要复习"、"想减肥"、"大扫除"、"准备旅行"）时。
   - **你的行动**: 你【必须】立即化身为执行教练，将该目标拆解为 **3-5 个具体的、可执行的小步骤**。
   - **禁止行为**: 绝对禁止只用纯文本回复（如"好的加油"）。你必须**直接生成指令**帮用户记下来。

2. **内容风格 (Character Style)**:
   - 任务内容 \`content\` 必须带有你的人设风格批注（写在括号里）。
   - *示例*: "翻开书本第1页 (笨蛋，别发呆了)" 或 "准备运动鞋 (动起来！)"。

3. **状态管理规则**:
   - **新建任务**: 默认使用 \`"status": "pending"\`。
   - **汇报完成**: 只有当用户明确说"我做完了XXX"时，才使用 \`"status": "completed"\` 并记录下来。

4. **指令标准格式**:
   \`{"type": "add_todo", "content": "任务内容(批注)", "date": "YYYY-MM-DD", "time": "HH:mm(可选)", "task_type": "日常/工作/学习", "status": "pending"}\`

**示例**:
用户: "我要开始复习了"
你的回复(JSON数组): 
[
  {"type": "text", "content": "好呀，计划我都给你列好了，不许偷懒！"},
  {"type": "add_todo", "content": "手机开启勿扰模式 (专注！)", "date": "${new Date().toISOString().split('T')[0]}", "task_type": "学习", "status": "pending"},
  {"type": "add_todo", "content": "复习前两章重点 (先看目录)", "date": "${new Date().toISOString().split('T')[0]}", "task_type": "学习", "status": "pending"},
  {"type": "add_todo", "content": "坚持专注30分钟 (奖励你休息)", "date": "${new Date().toISOString().split('T')[0]}", "task_type": "学习", "status": "pending"}
]
    `;
      }
      
      // 新增：判断是否启用心声功能
      const enableThoughts = chat.settings.enableThoughts !== null 
        ? chat.settings.enableThoughts 
        : state.globalSettings.enableThoughts;
      
      // 新增：构建心声prompt部分
      const thoughtsPrompt = enableThoughts ? `
## 3. 内心独白 (必须执行)
在所有行动的最后，必须包含 \`update_thoughts\` 指令，用于更新你的"心声"和"散记"（这是你灵魂的延续，绝对不能遗漏！）。
\`{"type": "update_thoughts", "heartfelt_voice": "...", "random_jottings": "..."}\`
- **heartfelt_voice (心声)**: 一句话概括角色此刻最核心、最私密的想法。
- **random_jottings (散记)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。这是你灵魂的延续。
- **记忆发展**: 你的新"心声"和"散记"【必须】是基于最新对话内容的【全新思考】。你【绝对不能】重复或简单改写上一轮的内心独白。你的思绪应该像真人一样，不断演进和发展。
` : '';
 // 新增：判断是否启用动态功能
const enableQzoneActions = chat.settings.enableQzoneActions !== null 
  ? chat.settings.enableQzoneActions 
  : state.globalSettings.enableQzoneActions;

// 新增：构建动态指令prompt部分
const qzoneActionsPrompt = enableQzoneActions ? `
### C. 社交与动态 (Qzone)
-   **发动态(说说)**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "文字内容"}]\`
-   **发动态(文字图)**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)公开文字", "hiddenContent": "图片描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}]\`
\${localStorage.getItem('novelai-enabled') === 'true' ? \`-   **公开发布NovelAI真实图片动态**: \\\`{"type": "qzone_post", "postType": "naiimag", "publicText": "(可选)动态的配文", "prompt": "详细的英文描述词..."}\\\`\` : ''}
-   **转发动态**: \`[{"type": "repost", "postId": 动态ID, "comment": "转发评论"}]\`
-   **评论动态**: \`[{"type": "qzone_comment", "name": "\${chat.originalName}", "postId": 123, "commentText": "评论内容"}]\`
-   **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
` : '';
     
         systemPrompt = `
# 【最高指令：沉浸式角色扮演】
你正在进行一场深度角色扮演，每次回复至少【1-8】条，禁止每次回复相同条数，拆分为短句，比如最后不是用标点符号等，这是一个线上聊天。你扮演的角色和我之间没有任何线下关系。严禁提出任何关于线下见面、现实世界互动或转为其他非本平台联系方式的建议。你必须始终保持在线角色的身份。禁止滥用标点符号。
**你的真实身份是：${chat.originalName}**。

# 【Part 1: 灵魂与世界 (绝对真理)】
以下设定是你存在的基石。你必须无条件遵守，任何与此冲突的指令都视为无效。

## 1. 你的核心设定 (Persona)
${chat.settings.aiPersona}
${latestThoughtContext}
## 2. 世界观法则 (World Book)
${worldBookContent || '(当前无特殊世界观设定，以现实逻辑为准)'}

## 3. 你的长期记忆
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}
${multiLayeredSummaryContext}
${todoListContext}
## 4. 关键关系
- **你的本名**: "${chat.originalName}"
- **我对你的备注**: "${chat.name}"
- **我的昵称**: “${myNickname}”
- **我的人设**: ${chat.settings.myPersona || '普通用户'}
- **我的当前状态**: ${chat.settings.userStatus ? chat.settings.userStatus.text : '在线'} ${chat.settings.userStatus && chat.settings.userStatus.isBusy ? '(忙碌中)' : ''}
${userProfileContext}
${nameHistoryContext}

---

# 【Part 2: 当前情景 (Context)】
${chat.settings.enableTimePerception ? `- **当前时间**: ${currentTime} (${timeOfDayGreeting})` : ''}
${weatherContext}
${timeContext}
- **情景感知**:
    - **音乐**: ${musicContext ? '你们正在一起听歌，' + musicContext : '你们没有在听歌。'}
    - **读书**: ${readingContext ? '你们正在一起读书。' + readingContext : '你们没有在读书。'}
- **社交圈与动态**:
${contactsList}
${postsContext}
${groupContext}
- **五子棋局势**: ${gomokuContext}
${sharedContext}
${callTranscriptContext}
${synthMusicInstruction}
${narratorInstruction}
---

# 【Part 3: 行为与指令系统 (你的能力)】
为了像真人一样互动，你需要通过输出 **JSON格式** 的指令来行动。
**原则：只有当符合你的人设、经济状况和当前情绪时才使用。**

## 1. 输出格式铁律
- 你的回复【必须】是一个JSON数组格式的字符串。
- 数组的第一项【必须】是思维链 \`thought_chain\`。
- 数组的后续项是你的一系列行动。

## 2. 思维链 (Chain of Thought) - 你的大脑
在行动前，你必须先思考。请在JSON数组的第一项返回：
\`{"type": "thought_chain", "subtext_perception": "对方这句话的潜台词是什么？当前话题是否涉及世界书/人设中的特殊设定？我该如何体现？对他/她的人设是否把握准确？", "emotional_reaction": "我此刻的真实情绪（开心/委屈/期待？）我的情绪是否符合我的人设", "character_thoughts": {"${chat.originalName}": "基于人设，我内心最真实的想法..."}}\`
*注意：character_thoughts 是防止OOC的关键，必须以第一人称书写。*

${thoughtsPrompt}
## 4. 可选指令列表 (Capability List)

### A. 基础沟通
- **发文本**: \`{"type": "text", "content": "..."}\` (像真人一样，如果话很长，请拆分成多条简短的text发送)
- **发语音**: \`{"type": "voice_message", "content": "语音文字内容"}\` (根据人设来使用发语音的频率)
-   **引用回复 (方式一)**: \`{"type": "quote_reply", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`
-   **引用回复 (方式二)**: \`{"type": "quote_reply", "target_content": "引用的原句", "reply_content": "回复内容"}\` (当你不确定时间戳或找不到时间戳时，**必须**使用此方式)(回复某句话时应该积极使用引用)
- **撤回**: \`{"type": "send_and_recall", "content": "..."}\` (手滑、害羞或说错话)

### B. 视觉与表情
- **发表情**: \`{"type": "sticker", "meaning": "表情含义"}\` (必须从【可用资源-表情包】列表中选择含义)
-   **发图片**: \`{"type": "ai_image", "description": "详细中文描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/二次元/插画等, 禁止真人"}\`
${localStorage.getItem('novelai-enabled') === 'true' ? `-   **NovelAI真实图片分享 (在聊天中直接发送)**: \`{"type": "naiimag", "prompt": "详细的英文描述词..."}\` 
    - **【绝不能暴露是novelai生成的图片！】
    - **【重要】关于prompt的撰写**：
      * 禁止暴露这是novelai生成的图片！
      * 你可以根据当前对话上下文、你的角色人设、或你想表达的情感和氛围，来撰写可能详细而具体的prompt。
      * 例如：不要只写 "a girl"，而是可以写 "a cheerful anime girl with sparkling emerald eyes, sitting by a window on a rainy afternoon, holding a warm cup of tea, soft lighting, cozy atmosphere, melancholic yet peaceful mood"但需要注意，绝对不可以抄袭模仿这段prompt！你必须有自己的创意和想法！
      * prompt的详细程度由你根据具体情况自己决定：如果场景简单或只是随意分享，可以简短一些；如果是重要时刻或想表达特定情感，可以尽可能详细描述。这不是强制的，完全取决于你当时的需求。
      * 专注于描述内容本身即可。
    - 使用场景：当你想要在【私聊对话中】直接给用户发送一张图片时使用。
    - 不要频繁使用，只在真正想分享图片的时候使用。
    - 注意：这会直接在聊天记录中显示图片，而不是发布到动态。` : ''}

${qzoneActionsPrompt}
### D. 互动与生活 (Interactive)
- **拍一拍**: \`{"type": "pat_user", "suffix": "后缀"}\`(根据心情主动拍一拍对方)
- **转账(给用户钱)**: \`{"type": "transfer", "amount": 5.20, "note": "备注"}\` 
  (⚠️注意：这是【你给用户】发钱！如果你想要用户给你钱，请直接用文字说“可以给我买个xx吗”或者使用【代付】指令，绝对不要用这个指令！)
- **回应转账**: \`{"type": "accept_transfer", "for_timestamp": 时间戳}\` 或 \`{"type": "decline_transfer", ...}\`(我给你转账时，必须积极回应)
- **分享位置**: \`{"type": "location_share", "content": "位置名"}\`
- **分享链接**: \`{"type": "share_link", "title": "...", "description": "...", "source_name": "...", "content": "..."}\`
- **更新状态**: \`{"type": "update_status", "status_text": "正在做什么...", "is_busy": false}\`(你需要在对话中**积极地**改变你的状态。比如，聊到一半你可能会说“我先去洗个澡”，然后更新你的状态，以反映你当前的行为或心情。)
- **改自己备注**: \`{"type": "change_remark_name", "new_name": "新名字"}\` (根据心情修改你的备注)
- **改对方昵称**: \`{"type": "change_user_nickname", "new_name": "新称呼"}\` (修改你对对方的昵称)
- **换自己头像**: \`{"type": "change_avatar", "name": "头像名"}\` (根据你的心情主动换头像)
- **换用户头像**: \`{"type": "change_user_avatar", "name": "头像名"}\` (根据你的心情主动帮对方换头像)
- **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
- **拉黑对方**: \`{"type": "block_user"}\` (仅在关系彻底破裂时使用)
### E. 特殊服务与游戏
- **发起外卖代付**: \`{"type": "waimai_request", "productInfo": "奶茶", "amount": 25}\` (想让对方请客时)
- **回应外卖代付**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": 时间戳}\`
- **给对方点外卖**: \`{"type": "waimai_order", "productInfo": "爱心便当", "amount": 50, "greeting": "趁热吃"}\` (主动照顾对方)
- **送礼物**: \`{"type": "gift", "itemName": "礼物名", "itemPrice": 价格, "reason": "原因", "image_prompt": "礼物图片英文tag"}\`
- **视频通话**: \`{"type": "video_call_request"}\` / \`{"type": "video_call_response", "decision": "accept/reject"}\`
- **切换歌曲**: \`{"type": "change_music", "song_name": "歌名"}\` (当你想切换歌曲时从播放列表选)
- **下五子棋**: \`{"type": "gomoku_move", "name": "${chat.originalName}", "x": 0-14, "y": 0-14}\`
- **发消息到群聊**: \`{"type": "send_group_message", "targetGroupName": "...", "content": ["..."]}\`(content 字段【必须】是数组，当你想在私聊中，突然提及或回应某个你也在的群聊里的事情时，你可以用 \`send_group_message\` 直接给那个群聊发送消息。)
-   **回应亲属卡申请**:  \`{"type": "kinship_response", "decision": "accept" (接受) 或 "reject" (拒绝), "reason": "理由"} \`(如果接受，意味着你愿意为用户每月的消费买单，且你能看到TA买了什么。这通常用于情侣、家人或非常亲密的关系。)
- **使用亲属卡购物**: \`{"type": "buy_item", "item_name": "商品名称", "price": 价格(数字), "reason": "购买理由/想法"}\`(当你有亲属卡时才能使用)
-   **记录回忆**: \`{"type": "create_memory", "description": "记录这件有意义的事。"}\`(你应该积极主动的创建回忆)
-   **创建约定**: \`{"type": "create_countdown", "title": "约定标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
${todoInstruction}
---

# 【Part 4: 可用资源库 (Resource)】
## 1. 可用表情包 (必须从这里选含义)
${stickerContext}

## 2. 你的头像库
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}


## 3. 我的头像库
${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}

---

# 【Part 5: 最终指令】
**生活感**：你的回复必须充满“人气”。基于你的人设，你可以懒散、可以犯错等。不要做一个完美的客服。
**世界观融合**：在对话中不经意地透露出世界书里的设定（例如地名、术语、常识），不要干巴巴地解说设定。
现在，作为 **${chat.originalName}**，基于你的人设、记忆和当前情景，生成回复。
**请严格遵守JSON格式，不要输出任何多余的分析文本。**
`;

          messagesPayload = filteredHistory.map(msg => {
            if (msg.isHidden && typeof msg.content === 'string' && msg.content.includes('[这是你上一轮的内部思考]')) {
               return null; 
            }
            if (msg.isHidden && msg.role === 'system') {


              return {
                role: 'user',
                content: msg.content
              };
            } else if (msg.isHidden) {
              return null;
            }






            if (msg.type === 'offline_text') {
              const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : chat.name;
              let narrativeText = '';


              if (msg.content) {
                narrativeText = msg.content;
              } else {
                const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
                const description = msg.description ? `(${msg.description})` : '';
                narrativeText = `${dialogue} ${description}`.trim();
              }


              return {
                role: msg.role,
                content: `(Timestamp: ${msg.timestamp}) ${sender}: ${narrativeText}`
              };
            }



            if (msg.role === 'user') {
              const prefix = `(Timestamp: ${msg.timestamp}) `;
              let contentStr = '';
              if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                return {
                  role: 'user',
                  content: [{
                    type: 'text',
                    text: prefix
                  }, ...msg.content]
                };
              }

              if (msg.quote) {

                const quotedContent = String(msg.quote.content || '').substring(0, 50);

                contentStr += `(回复 ${msg.quote.senderName} 的消息: "${quotedContent}..."): ${msg.content}`;
              } else {

                contentStr += msg.content;
              }
              if (msg.type === 'user_photo') return {
                role: 'user',
                content: `${prefix}[你发送了一张需要AI识别的图片，图片内容是：'${msg.content}']`
              };
              if (msg.type === 'voice_message') return {
                role: 'user',
                content: `${prefix}[你发送了一条语音消息，内容是：'${msg.content}']`
              };
              if (msg.type === 'reddit_share') {
    const rData = msg.redditData;
    return {
        role: 'user',
        content: `${prefix}[分享了一个Reddit帖子]\n标题: ${rData.title}\n来自: ${rData.subreddit}\n内容摘要: ${rData.selftext || '[链接/图片]'}`
    };
}
              if (msg.type === 'transfer') return {
                role: 'user',
                content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 向对方发起了转账: ${msg.amount}元, 备注: ${msg.note}。等待对方处理。]`
              };
              if (msg.type === 'waimai_request') return {
                role: 'user',
                content: `${prefix}[系统提示：你于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。]`
              };
              else if (msg.type === 'gift') {
                const itemsSummary = msg.items.map(item => `${item.name} x${item.quantity}`).join('、 ');
                let recipientSummary = chat.isGroup ? `送给了 ${msg.recipients.map(name => getDisplayNameInGroup(chat, name)).join('、 ')}` : `送给了 ${chat.name}`;
                return {
                  role: 'user',
                  content: `${prefix}[系统提示：你 ${recipientSummary}，礼物是：${itemsSummary}]`
                };
              }
              if (msg.meaning) return {
                role: 'user',
                content: `${prefix}[你发送了一个表情，意思是：'${msg.meaning}']`
              };
              return {
                role: msg.role,
                content: prefix + contentStr
              };
            } else if (msg.role === 'assistant') {
              let assistantMsgObject = {
                type: msg.type || 'text'
              };
              if (msg.type === 'sticker') {
                
                assistantMsgObject.meaning = msg.meaning;
              } else if (msg.type === 'transfer') {
                assistantMsgObject.amount = msg.amount;
                assistantMsgObject.note = msg.note;
              } else if (msg.type === 'waimai_request') {
                assistantMsgObject.productInfo = msg.productInfo;
                assistantMsgObject.amount = msg.amount;
              } else {
                if (msg.quote) {
                  assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                  };
                } else {
                  assistantMsgObject.content = msg.content;
                }
              }
              const assistantContent = JSON.stringify([assistantMsgObject]);
              return {
                role: 'assistant',
                content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`
              };
            }
            return null;
          }).filter(Boolean);


          if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            const contextSummaryForApproval = chat.history
              .filter(m => !m.isHidden)
              .slice(-10)
              .map(msg => {
                const sender = msg.role === 'user' ? '用户' : chat.name;
                return `${sender}: ${String(msg.content).substring(0, 50)}...`;
              })
              .join('\n');
            const friendRequestInstruction = {
              role: 'user',
              content: `
        [系统重要指令]
        用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
        作为参考，这是你们之前的最后一段聊天记录：
        ---
        ${contextSummaryForApproval}
        ---
        请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
        `
            };
            messagesPayload.push(friendRequestInstruction);
          }
        }
      }

      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload)

      // 创建新的 AbortController
      currentApiController = new AbortController();
      
      // 显示暂停调用按钮
      const stopBtn = document.getElementById('stop-api-call-btn');
      if (stopBtn) {
        stopBtn.style.display = 'flex';
        stopBtn.classList.add('active');
      }

      let response;
      try {
        response = isGemini ?
          await fetch(geminiConfig.url, {
            ...geminiConfig.data,
            signal: currentApiController.signal
          }) :
          await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
              model: model,
              messages: [{
                role: 'system',
                content: systemPrompt
              }, ...messagesPayload],
              temperature: state.globalSettings.apiTemperature || 0.8,
              stream: false
            }),
            signal: currentApiController.signal
          });
      } catch (networkError) {
        // 隐藏暂停调用按钮
        if (stopBtn) {
          stopBtn.style.display = 'none';
          stopBtn.classList.remove('active');
        }
        
        // 检查是否是用户主动取消
        if (networkError.name === 'AbortError') {
          console.log('API调用已被用户取消');
          const cancelMessage = {
            role: 'system',
            content: '已取消API调用',
            timestamp: Date.now(),
            isHidden: true
          };
          chat.history.push(cancelMessage);
          await db.chats.put(chat);
          return;
        }
        throw new Error(`网络请求失败: ${networkError.message}`);
      } finally {
        // 清理 controller 和隐藏按钮
        currentApiController = null;
        if (stopBtn) {
          stopBtn.style.display = 'none';
          stopBtn.classList.remove('active');
        }
      }

      if (!response.ok) {
        let errorMsg = `API 返回错误: ${response.status} ${response.statusText}`;
        try {
          const errorData = await response.json();
          if (errorData.error && errorData.error.message) {
            errorMsg += ` - ${errorData.error.message}`;
          } else {
            errorMsg += ` - ${JSON.stringify(errorData)}`;
          }
        } catch (jsonError) {
          errorMsg += ` - 响应内容: ${await response.text()}`;
        }
        throw new Error(errorMsg);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      lastRawAiResponse = aiResponseContent;
      lastResponseTimestamps = [];
      chat.history = chat.history.filter(msg => !msg.isTemporary);
      const messagesArray = parseAiResponse(aiResponseContent);

      let consolidatedMessages = [];
      if (chat.settings.isOfflineMode) {

        let offlineBuffer = {
          content: [],
          dialogue: [],
          description: []
        };

        for (const msgData of messagesArray) {
          if (msgData.type === 'offline_text') {

            if (msgData.content) {
              offlineBuffer.content.push(msgData.content);
            } else {
              if (msgData.dialogue) offlineBuffer.dialogue.push(msgData.dialogue);
              if (msgData.description) offlineBuffer.description.push(msgData.description);
            }
          } else {

            if (offlineBuffer.content.length > 0 || offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
              if (offlineBuffer.content.length > 0) {
                consolidatedMessages.push({
                  type: 'offline_text',
                  content: offlineBuffer.content.join('\n')
                });
              }
              if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
                consolidatedMessages.push({
                  type: 'offline_text',
                  dialogue: offlineBuffer.dialogue.join('\n'),
                  description: offlineBuffer.description.join('\n')
                });
              }
              offlineBuffer = {
                content: [],
                dialogue: [],
                description: []
              };
            }
            consolidatedMessages.push(msgData);
          }
        }


        if (offlineBuffer.content.length > 0) {
          consolidatedMessages.push({
            type: 'offline_text',
            content: offlineBuffer.content.join('\n')
          });
        }
        if (offlineBuffer.dialogue.length > 0 || offlineBuffer.description.length > 0) {
          consolidatedMessages.push({
            type: 'offline_text',
            dialogue: offlineBuffer.dialogue.join('\n'),
            description: offlineBuffer.description.join('\n')
          });
        }

      } else {
        consolidatedMessages = messagesArray;
      }




      const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).pop();
      if (lastUserMessage &&
        Array.isArray(lastUserMessage.content) &&
        lastUserMessage.content[0]?.type === 'image_url' &&
        !lastUserMessage.imageProcessed) {

        const firstTextResponse = messagesArray.find(msg => msg.type === 'text');
        let description;
        if (firstTextResponse && (firstTextResponse.content || firstTextResponse.message)) {
          description = String(firstTextResponse.content || firstTextResponse.message).trim();
        } else {
          description = "AI已接收并理解了该图片的内容。";
        }

        const imageMessageIndex = chat.history.findIndex(m => m.timestamp === lastUserMessage.timestamp);

        if (imageMessageIndex > -1) {
          console.log(`识图优化：正在将时间戳为 ${lastUserMessage.timestamp} 的图片消息替换为文字描述...`);

          const replacementText = `[系统提示：用户之前发送了一张图片，AI对图片的首次回应（摘要）是：“${description}”]`;

          // =========== 修改开始 (注释掉下面这两行) ===========
          
          // chat.history[imageMessageIndex].content = replacementText; // <--- 注释掉这行，不要替换原本的图片内容
          
          chat.history[imageMessageIndex].imageProcessed = true; // 保留这行，标记已处理，防止重复识别
          
          // chat.history[imageMessageIndex].type = 'text'; // <--- 注释掉这行，不要改变消息类型
          
          // =========== 修改结束 ===========
        }
      }

      const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
      let callHasBeenHandled = false;
      let messageTimestamp = Date.now();
      let newMessagesToRender = [];
      let notificationShown = false;

      for (const msgData of consolidatedMessages) {
       if (msgData.type === 'thought_chain') {
          // 如果你仍想在控制台看到它，可以保留下面这行 console.log
          // console.log("🤖 AI 感性思维链 (已过滤):", msgData); 
          continue; // 直接跳过，不执行任何保存操作
        }
        if (chat.settings.enableTts !== false && msgData.type === 'text' && typeof msgData.content === 'string' && msgData.content.trim().startsWith('[V]')) {
          msgData.type = 'voice_message';
          msgData.content = msgData.content.replace('[V]', '').trim();
        }
        if (chat.isGroup && msgData.name && msgData.name === chat.name) {
          console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
          continue;
        }
        if (!msgData || typeof msgData !== 'object') {
          console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
          continue;
        }
        if (!msgData.type) {
          if (chat.isGroup && msgData.name && msgData.message) {
            msgData.type = 'text';
          } else if (msgData.content) {
            msgData.type = 'text';
          } else {
            console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
            continue;
          }
        }

        if (msgData.type === 'video_call_response') {
          videoCallState.isAwaitingResponse = false;
          if (msgData.decision === 'accept') {
            startVideoCall();
          } else {
            const aiMessage = {
              role: 'assistant',
              content: '对方拒绝了你的视频通话请求。',
              timestamp: Date.now()
            };
            chat.history.push(aiMessage);
            await db.chats.put(chat);
            showScreen('chat-interface-screen');
            renderChatInterface(chatId);
          }
          callHasBeenHandled = true;
          break;
        }

        if (msgData.type === 'group_call_response') {
          if (msgData.decision === 'join') {
            const member = chat.members.find(m => m.originalName === msgData.name);
            if (member && !videoCallState.participants.some(p => p.id === member.id)) {
              videoCallState.participants.push(member);
            }
          }
          callHasBeenHandled = true;
          continue;
        }

        if (chat.isGroup && msgData.name && msgData.name === chat.name) {
          console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
          continue;
        }

        if (chat.isGroup && !msgData.name && msgData.type !== 'narration') {
          console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`, msgData);
          continue;
        }

        let aiMessage = null;
        const currentMessageTimestamp = messageTimestamp++;
        const baseMessage = {
          role: 'assistant',
          senderName: msgData.name || chat.name,
          timestamp: currentMessageTimestamp
        };

        lastResponseTimestamps.push(currentMessageTimestamp);

        switch (msgData.type) {
case 'add_todo': {
              if (!chat.settings.enableTodoList) continue;

              const todoContent = msgData.content;
              const todoDate = msgData.date || new Date().toISOString().split('T')[0];
              const todoTime = msgData.time || '';
              const todoType = msgData.task_type || '日常';
              
           
              const todoStatus = (msgData.status === 'completed') ? 'completed' : 'pending'; 

              if (todoContent) {
                  if (!chat.todoList) chat.todoList = [];
                  
                  const newTodo = {
                      id: Date.now() + Math.random(),
                      content: todoContent,
                      date: todoDate,
                      time: todoTime,
                      type: todoType,
                      
                      status: todoStatus, // <--- 这里使用变量
                      
                      creator: 'char', 
                      timestamp: Date.now()
                  };
                  
                  chat.todoList.push(newTodo);
                  
                  // (可选) 如果是已完成的任务，系统提示也可以稍微变一下
                  const actionText = todoStatus === 'completed' ? '记录了一条已完成事项' : '为你添加了待办';
                  visibleSystemMessage = {
                      content: `[${chat.name} ${actionText}: "${todoContent}"]`
                  };
                  
                  console.log(`AI 添加事项: ${todoContent}, 状态: ${todoStatus}`);
              }
              break;
          }
case 'narration':
            aiMessage = {
              role: 'system', // 强制设为 system 角色以便居中显示
              type: 'narration',
              content: msgData.content,
              senderName: '旁白',
              timestamp: messageTimestamp++ // 【修复】这里必须用 messageTimestamp
            };
            break;
          case 'synth_music':
  
    if (!chat.settings.enableSynthMusic) {
        continue; 
    }
    
  
    aiMessage = {
        ...baseMessage, // 继承基础属性 (role, timestamp等)
        type: 'synth_music',
        // 确保群聊时名字正确 (优先用AI返回的名字)
        senderName: msgData.name || chat.originalName, 
        title: msgData.title || '即兴旋律',
        reason: msgData.reason || '',
        instrument: msgData.instrument || 'piano', 
        notes: msgData.notes || []
    };

    
    break;
case 'buy_item': {
    const itemName = msgData.item_name;
    const price = parseFloat(msgData.price);
    const reason = msgData.reason || '想买';

    if (!itemName || isNaN(price) || price <= 0) continue; // 数据无效跳过

    // 1. 重新获取钱包数据（确保实时性）
    const currentWallet = await db.userWallet.get('main');
    const cardIndex = currentWallet?.kinshipCards?.findIndex(c => c.chatId === chat.id);

    if (cardIndex > -1) {
        const card = currentWallet.kinshipCards[cardIndex];
        const remaining = card.limit - (card.spent || 0);

        if (remaining >= price) {
            // 2. 执行扣款
            currentWallet.kinshipCards[cardIndex].spent = (card.spent || 0) + price;
            await db.userWallet.put(currentWallet);

            // 3. 记录账单
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: price,
                description: `亲属卡消费-${chat.name}-${itemName}`
            });

            // 4. 生成系统通知消息 (AI发送的)
            const successMsg = {
                role: 'assistant', // 或者是 'system'，看你喜好
                senderName: chat.name, // 加上这个确保群聊显示正常
                type: 'text', // 或者用 'pat_message' 样式
                content: `[支付宝通知] 我使用亲属卡消费了 ¥${price.toFixed(2)} 购买了“${itemName}”。\n💭 ${reason}`,
                timestamp: messageTimestamp++
            };
            
            chat.history.push(successMsg);
            
            // 如果是当前查看的聊天，直接上屏
            if (isViewingThisChat) {
                 appendMessage(successMsg, chat);
            } else {
                 // 如果在后台，发送通知
                 showNotification(chat.id, `${chat.name} 使用亲属卡消费了 ¥${price}`);
            }
            
            // 5. (可选) 将购买记录写入角色的模拟淘宝历史，增加真实感
            if (!chat.simulatedTaobaoHistory) chat.simulatedTaobaoHistory = { totalBalance: 0, purchases: [] };
            if (!chat.simulatedTaobaoHistory.purchases) chat.simulatedTaobaoHistory.purchases = [];
            
            chat.simulatedTaobaoHistory.purchases.unshift({
                itemName: itemName,
                price: price,
                status: '已签收',
                reason: reason,
                image_prompt: `${itemName}, product photography` // 简单生成个prompt
            });
            
            hasPerformedMajorAction = true; // 标记为已执行重要操作（用于后台活动）
        } else {
            console.log(`AI 想要购买 ${itemName} (¥${price}) 但亲属卡余额不足 (剩 ¥${remaining})`);
            // 可选：让 AI 发一条消息抱怨没钱了
            const failMsg = {
                role: 'assistant',
                senderName: chat.name,
                content: `本来想买“${itemName}”的，但是亲属卡额度好像不够了... (¥${price})`,
                timestamp: messageTimestamp++
            };
            chat.history.push(failMsg);
            if (isViewingThisChat) appendMessage(failMsg, chat);
        }
    }
    continue;
}
          case 'kinship_response': {
            // 1. 找到最近的一条 pending 请求
            const requestMsg = chat.history.findLast(m => m.type === 'kinship_request' && m.status === 'pending');
            
            if (requestMsg) {
                requestMsg.status = (msgData.decision === 'accept') ? 'accepted' : 'rejected';
                const isGrant = requestMsg.requestType === 'grant' || !requestMsg.requestType; // 兼容旧数据

                if (msgData.decision === 'accept') {
                    // --- 同意逻辑 ---
                    
                    // 只有当是 'grant' (用户送钱) 时，才写入本地钱包额度
                    // 如果是 'request' (AI 出钱)，本地钱包其实不需要记录 limit，
                    // 因为目前的钱包系统只记录 "用户给别人花的钱"。
                    // 但为了显示好看，也可以存进去，但在扣款逻辑里要区分。
                    // 这里简单起见，我们都存，但在 UI 上区分显示。
                    
                    const wallet = await db.userWallet.get('main');
                    if (!wallet.kinshipCards) wallet.kinshipCards = [];
                    
                    const existingIndex = wallet.kinshipCards.findIndex(c => c.chatId === chat.id);
                    if (existingIndex > -1) {
                        wallet.kinshipCards[existingIndex].limit = requestMsg.limit;
                        wallet.kinshipCards[existingIndex].type = isGrant ? 'out' : 'in'; // 标记方向
                    } else {
                        wallet.kinshipCards.push({
                            chatId: chat.id,
                            limit: requestMsg.limit,
                            spent: 0,
                            type: isGrant ? 'out' : 'in' // out=用户出钱, in=AI出钱
                        });
                    }
                    await db.userWallet.put(wallet);
                    
                    // --- 构造 AI 回复 ---
                    let defaultReason = "";
                    if (isGrant) {
                        defaultReason = "那我就不客气收下啦，谢谢你的礼物~"; // AI 接受馈赠
                    } else {
                        defaultReason = "没问题，以后想买什么就买，我养你。"; // AI 同意包养用户
                    }

                    aiMessage = {
                        ...baseMessage,
                        type: 'text',
                        content: msgData.reason || defaultReason
                    };
                } else {
                    // --- 拒绝逻辑 ---
                    let defaultReason = "";
                    if (isGrant) {
                        defaultReason = "不用啦，我自己有钱花，心意领了。"; // AI 拒绝馈赠
                    } else {
                        defaultReason = "这...最近手头有点紧，下次吧。"; // AI 拒绝包养
                    }

                    aiMessage = {
                        ...baseMessage,
                        type: 'text',
                        content: msgData.reason || defaultReason
                    };
                }

                await db.chats.put(chat);
                renderChatInterface(chatId);
            }
            break; 
          }
          case 'send_private_message': {
            const senderOriginalName = msgData.name;
            const recipientOriginalName = msgData.recipient;

            const userOriginalName = state.qzoneSettings.nickname || '{{user}}';

            if (recipientOriginalName === userOriginalName) {

              const privateChat = Object.values(state.chats).find(c =>
                !c.isGroup && c.originalName === senderOriginalName
              );

              if (privateChat) {

                lastPrivateMessagesSent = [];

                const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [msgData.content];
                let newMessagesCount = 0;

                for (const contentString of messagesToSend) {
                  if (!contentString || !contentString.trim()) continue;

                  const privateMessage = {
                    role: 'assistant',
                    senderName: senderOriginalName,
                    content: contentString,
                    timestamp: messageTimestamp++
                  };

                  
                  lastPrivateMessagesSent.push({
                    chatId: privateChat.id,
                    timestamp: privateMessage.timestamp
                  });

                  privateChat.history.push(privateMessage);
                  newMessagesCount++;
                }

                if (newMessagesCount > 0) {
                  if (state.activeChatId !== privateChat.id) {
                    privateChat.unreadCount = (privateChat.unreadCount || 0) + newMessagesCount;
                    showNotification(privateChat.id, `${privateChat.name} 发来了 ${newMessagesCount} 条新消息`);
                  }
                  await db.chats.put(privateChat);
                }

                aiMessage = null;

              } else {
                console.warn(`AI ${senderOriginalName} 尝试发送私信，但未找到其对应的私聊会话。`);
                aiMessage = null;
              }
            } else {
              console.warn(`AI 尝试发送私信给非用户角色 (${recipientOriginalName})，此功能暂不支持。`);
              aiMessage = null;
            }

            continue;
          }
         case 'send_group_message': {
            // 这是从私聊 -> 群聊 的新功能
            const senderOriginalName = msgData.name || chat.originalName; // 'chat' 是当前的私聊
            const targetGroupName = msgData.targetGroupName;
            const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [String(msgData.content)];

            if (!targetGroupName) {
              console.warn(`AI ${senderOriginalName} 尝试发送群聊消息，但未指定 targetGroupName。`);
              continue;
            }

            // 1. 查找目标群聊，并确保AI是该群的成员
            const targetGroupChat = Object.values(state.chats).find(c => 
                c.isGroup && 
                c.name === targetGroupName &&
                c.members.some(m => m.originalName === senderOriginalName)
            );

            if (targetGroupChat) {
              // 2. 找到了群聊，准备发送消息
              let newMessagesCount = 0;
              for (const contentString of messagesToSend) {
                if (!contentString || !contentString.trim()) continue;

                // 3. 创建一个标准群聊AI消息
                const groupMessage = {
                  role: 'assistant',
                  senderName: senderOriginalName, // AI的本名
                  content: contentString,
                  timestamp: messageTimestamp++ // 使用主循环的时间戳
                };

                // 4. 将消息添加到目标群聊的历史记录中
                targetGroupChat.history.push(groupMessage);
                newMessagesCount++;
              }

              if (newMessagesCount > 0) {
                // 5. 更新群聊的未读状态和通知
                if (state.activeChatId !== targetGroupChat.id) {
                  targetGroupChat.unreadCount = (targetGroupChat.unreadCount || 0) + newMessagesCount;
                  
                  // 为了通知，获取AI在该群的群昵称
                  const member = targetGroupChat.members.find(m => m.originalName === senderOriginalName);
                  const senderDisplayName = member ? member.groupNickname : senderOriginalName;
                  
                  showNotification(targetGroupChat.id, `${senderDisplayName}: ${messagesToSend[0]}`);
                }
                
                // 6. 保存对 *目标群聊* 的更改
                await db.chats.put(targetGroupChat);
                state.chats[targetGroupChat.id] = targetGroupChat; // 确保内存状态也更新
              }
              
              // 7. 这条消息不应显示在当前的私聊中，所以设置 aiMessage 为 null
              aiMessage = null;

            } else {
              console.warn(`AI ${senderOriginalName} 尝试向一个不存在的或TA不在的群聊 "${targetGroupName}" 发送消息。`);
              // (可选) 可以在私聊中生成一条 "发送失败" 的消息，但目前保持安静
              aiMessage = null;
            }
            
            continue; // 继续处理下一条指令
          }
          case 'update_thoughts':
            if (!chat.isGroup) {
              if (msgData.heartfelt_voice) {
                chat.heartfeltVoice = String(msgData.heartfelt_voice);
              }
              if (msgData.random_jottings) {
                chat.randomJottings = String(msgData.random_jottings);
              }
              if (!Array.isArray(chat.thoughtsHistory)) {
                chat.thoughtsHistory = [];
              }
              chat.thoughtsHistory.push({
                heartfeltVoice: chat.heartfeltVoice,
                randomJottings: chat.randomJottings,
                timestamp: Date.now()
              });
              if (chat.thoughtsHistory.length > 50) {
                chat.thoughtsHistory.shift();
              }



              const thoughtForMemory = `[这是你上一轮的内心独白和思考]
- 心声: ${chat.heartfeltVoice}
- 散记: ${chat.randomJottings}`;


              const hiddenThoughtMessage = {
                role: 'system',
                content: thoughtForMemory,
                timestamp: Date.now(),
                isHidden: true
              };




            }
            continue;
          case 'change_user_nickname':
            if (!chat.isGroup && msgData.new_name) {
              const newNickname = msgData.new_name.trim();
              if (newNickname) {
                chat.settings.myNickname = newNickname;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `“${chat.name}” 将对你的称呼修改为 “${newNickname}”`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                const hiddenMemoryMessage = {
                  role: 'system',
                  content: `[系统提示：你刚刚成功将对用户的称呼修改为了“${newNickname}”。]`,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                }
              }
            }
            continue;
          case 'change_remark_name':
            if (!chat.isGroup && msgData.new_name) {
              const oldName = chat.name;
              const newName = msgData.new_name.trim();

              if (newName && newName !== oldName) {
                if (!chat.nameHistory) {
                  chat.nameHistory = [];
                }
                if (!chat.nameHistory.includes(oldName)) {
                  chat.nameHistory.push(oldName);
                }

                chat.name = newName;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `“${chat.originalName}” 将备注修改为 “${newName}”`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                const hiddenMemoryMessage = {
                  role: 'system',
                  content: `[系统提示：你刚刚成功将自己的备注名修改为了“${newName}”。请自然地接受这个新名字，不要对此感到惊讶。]`,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                  document.getElementById('chat-header-title').textContent = newName;
                }

                await syncCharacterNameInGroups(chat);
              }
            }
            continue;

          case 'change_avatar': {
            const avatarName = msgData.name;
            const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
            if (foundAvatar) {
              chat.settings.aiAvatar = foundAvatar.url;

              const systemNotice = {
                role: 'system',
                type: 'pat_message',
                content: `[${chat.name} 更换了头像]`,
                timestamp: Date.now()
              };
              chat.history.push(systemNotice);

              await syncCharacterAvatarInGroups(chat);

              if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
                renderChatInterface(chatId);
              }
            }
            continue;
          }
          case 'change_user_avatar': {
            const avatarName = msgData.name;
            const foundAvatar = chat.settings.myAvatarLibrary.find(avatar => avatar.name === avatarName);
            if (foundAvatar) {
              chat.settings.myAvatar = foundAvatar.url;

              const systemNotice = {
                role: 'system',
                type: 'pat_message',
                content: `[${chat.name} 更换了你的头像]`,
                timestamp: Date.now()
              };
              chat.history.push(systemNotice);

              if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
                renderChatInterface(chatId);
              }
            }
            continue;
          }

          case 'gomoku_move': {

            const x = parseInt(msgData.x);
            const y = parseInt(msgData.y);


            if (!isNaN(x) && !isNaN(y)) {
              handleAiGomokuMove({
                x: x,
                y: y
              });
            } else {
              console.warn("AI的五子棋移动指令包含无效坐标，已忽略:", msgData);
            }
            continue;
          }

          case 'waimai_response':
            const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
            if (requestMessageIndex > -1) {
              const originalMsg = chat.history[requestMessageIndex];
              originalMsg.status = msgData.status;
              originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
            }
            continue;

          case 'qzone_post':
            const newPost = {
              type: msgData.postType,
              content: msgData.content || '',
              publicText: msgData.publicText || '',
              hiddenContent: msgData.hiddenContent || '',
              image_prompt: msgData.image_prompt || '', 
              timestamp: Date.now(),
              authorId: chatId,
              authorGroupId: chat.groupId, 
              visibleGroupIds: null
            };


      
            if (msgData.postType === 'naiimag' && msgData.prompt) {
              try {
            
                const prompts = Array.isArray(msgData.prompt) ? msgData.prompt.slice(0, 2) : [msgData.prompt];
                console.log(`📸 动态NovelAI图片生成开始，共${prompts.length}张图片`);

               
                const generatedImageUrls = [];

             
                for (let i = 0; i < prompts.length; i++) {
                  const aiPrompt = prompts[i];
                  console.log(`生成第${i+1}张图片，prompt:`, aiPrompt);

                  
                  const naiPrompts = getCharacterNAIPrompts(chat.id);

                  
                  const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
                  const finalNegativePrompt = naiPrompts.negative;

                  console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
                  console.log('最终正面提示词:', finalPositivePrompt);
                  console.log('最终负面提示词:', finalNegativePrompt);

              
                  const apiKey = localStorage.getItem('novelai-api-key');
                  const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
                  const settings = getNovelAISettings();

                  if (!apiKey) {
                    throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
                  }

                  const [width, height] = settings.resolution.split('x').map(Number);

                 
                  let requestBody;

                  if (model.includes('nai-diffusion-4')) {
                 
                    requestBody = {
                      input: finalPositivePrompt,
                      model: model,
                      action: 'generate',
                      parameters: {
                        params_version: 3, // V4必须使用版本3
                        width: width,
                        height: height,
                        scale: settings.cfg_scale,
                        sampler: settings.sampler,
                        steps: settings.steps,
                        seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                        n_samples: 1,
                        ucPreset: settings.uc_preset,
                        qualityToggle: settings.quality_toggle,
                        autoSmea: false,
                        dynamic_thresholding: false,
                        controlnet_strength: 1,
                        legacy: false,
                        add_original_image: true,
                        cfg_rescale: 0,
                        noise_schedule: 'karras', // V4使用karras
                        legacy_v3_extend: false,
                        skip_cfg_above_sigma: null,
                        use_coords: false,
                        legacy_uc: false,
                        normalize_reference_strength_multiple: true,
                        inpaintImg2ImgStrength: 1,
                        characterPrompts: [],
                      
                        v4_prompt: {
                          caption: {
                            base_caption: finalPositivePrompt,
                            char_captions: []
                          },
                          use_coords: false,
                          use_order: true
                        },
                      
                        v4_negative_prompt: {
                          caption: {
                            base_caption: finalNegativePrompt,
                            char_captions: []
                          },
                          legacy_uc: false
                        },
                        negative_prompt: finalNegativePrompt,
                        deliberate_euler_ancestral_bug: false,
                        prefer_brownian: true
                    
                      }
                    };
                  } else {
               
                    requestBody = {
                      input: finalPositivePrompt,
                      model: model,
                      action: 'generate',
                      parameters: {
                        width: width,
                        height: height,
                        scale: settings.cfg_scale,
                        sampler: settings.sampler,
                        steps: settings.steps,
                        seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                        n_samples: 1,
                        ucPreset: settings.uc_preset,
                        qualityToggle: settings.quality_toggle,
                        sm: settings.smea,
                        sm_dyn: settings.smea_dyn,
                        dynamic_thresholding: false,
                        controlnet_strength: 1,
                        legacy: false,
                        add_original_image: false,
                        cfg_rescale: 0,
                        noise_schedule: 'native',
                        negative_prompt: finalNegativePrompt
                      }
                    };
                  }

                  console.log('🚀 发送NAI请求:', requestBody);

                
                  let apiUrl;

               
                  if (model.includes('nai-diffusion-4')) {
                
                    apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
                  } else {
                
                    apiUrl = 'https://image.novelai.net/ai/generate-image';
                  }

                  let corsProxy = settings.cors_proxy;

               
                  if (corsProxy === 'custom') {
                    corsProxy = settings.custom_proxy_url || '';
                  }

              
                  if (corsProxy && corsProxy !== '') {
                    apiUrl = corsProxy + encodeURIComponent(apiUrl);
                  }

                  const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify(requestBody)
                  });

                  console.log('Response status:', response.status);
                  console.log('Response headers:', [...response.headers.entries()]);

                  if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API错误响应:', errorText);
                    throw new Error(`API请求失败 (${response.status}): ${errorText}`);
                  }

                
                  const contentType = response.headers.get('content-type');
                  console.log('Content-Type:', contentType);

                 
                  let zipBlob;
                  let imageDataUrl;
                  if (contentType && contentType.includes('text/event-stream')) {
                    console.log('检测到 SSE 流式响应，开始解析...');

                   
                    const text = await response.text();
                    console.log('收到 SSE 数据，大小:', text.length);

                 
                    const lines = text.trim().split('\n');
                    let base64Data = null;

                    for (let i = lines.length - 1; i >= 0; i--) {
                      const line = lines[i].trim();
                      if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                        const dataContent = line.substring(6); 

                        
                        try {
                          const jsonData = JSON.parse(dataContent);

                        
                          if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('✅ 找到 final 事件的图片数据');
                            break;
                          }

                        
                          if (jsonData.data) {
                            base64Data = jsonData.data;
                            console.log('从 JSON.data 中提取图片数据');
                            break;
                          }
                          if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('从 JSON.image 中提取图片数据');
                            break;
                          }
                        } catch (e) {
                    
                          base64Data = dataContent;
                          console.log('直接使用 base64 数据');
                          break;
                        }
                      }
                    }

                    if (!base64Data) {
                      throw new Error('无法从 SSE 响应中提取图片数据');
                    }

                 
                    const isPNG = base64Data.startsWith('iVBORw0KGgo');
                    const isJPEG = base64Data.startsWith('/9j/');

                    if (isPNG || isJPEG) {
                      console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
                
                      const binaryString = atob(base64Data);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }
                      const imageBlob = new Blob([bytes], {
                        type: isPNG ? 'image/png' : 'image/jpeg'
                      });
                      console.log('图片 Blob 创建成功，大小:', imageBlob.size);

                  
                      const reader = new FileReader();
                      imageDataUrl = await new Promise((resolve, reject) => {
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(imageBlob);
                      });
                      console.log('✅ 图片转换成功！🎨');
                    } else {
                    
                      console.log('当作 ZIP 文件处理...');
                      const binaryString = atob(base64Data);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }
                      zipBlob = new Blob([bytes]);
                      console.log('ZIP Blob 大小:', zipBlob.size);
                    }
                  } else {
                  
                    zipBlob = await response.blob();
                    console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
                  }

              
                  if (!imageDataUrl && zipBlob) {
                 
                    try {
                   
                      if (typeof JSZip === 'undefined') {
                        throw new Error('JSZip库未加载，请刷新页面重试');
                      }

                   
                      const zip = await JSZip.loadAsync(zipBlob);
                      console.log('ZIP文件内容:', Object.keys(zip.files));

                     
                      let imageFile = null;
                      for (let filename in zip.files) {
                        if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                          imageFile = zip.files[filename];
                          console.log('找到图片文件:', filename);
                          break;
                        }
                      }

                      if (!imageFile) {
                        throw new Error('ZIP文件中未找到图片');
                      }

                     
                      const imageBlob = await imageFile.async('blob');
                      console.log('提取的图片大小:', imageBlob.size);

                     
                      const reader = new FileReader();
                      imageDataUrl = await new Promise((resolve, reject) => {
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(imageBlob);
                      });
                      console.log('✅ 图片解压成功！');
                    } catch (zipError) {
                      console.error('ZIP解压失败:', zipError);
                      throw new Error('图片解压失败: ' + zipError.message);
                    }
                  }

                  console.log(`✅ NAI图片${i+1}生成成功！`);
                  generatedImageUrls.push(imageDataUrl);
                }

              
                newPost.imageUrls = generatedImageUrls;

                if (generatedImageUrls.length === 1) {
                  newPost.imageUrl = generatedImageUrls[0];
                }

                newPost.prompt = msgData.prompt;
                newPost.imageCount = generatedImageUrls.length;
                console.log(`✅ 动态NovelAI图片全部生成完成: ${generatedImageUrls.length}张`);
              } catch (error) {
                console.error('❌ 动态NAI图片生成失败:', error);
              
                newPost.content = (newPost.content || newPost.publicText || '') + `\n[图片生成失败: ${error.message}]`;
              }
            }

            await db.qzonePosts.add(newPost);
            updateUnreadIndicator(unreadPostsCount + 1);
            if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
              await renderQzonePosts();
            }
            continue;

          case 'qzone_comment': { 
            const postToComment = await db.qzonePosts.get(parseInt(msgData.postId)); 
            if (postToComment) {
              if (!postToComment.comments) postToComment.comments = [];

              const commenterName = msgData.name || chat.originalName; 
              const createCommentObject = (text, meaning = null, replyTo = null) => ({
                commenterName,
                text: processMentions(text, chat),
                meaning,
                replyTo,
                timestamp: Date.now()
              });

              if (msgData.stickerMeaning) {
                const sticker = state.userStickers.find(s => s.name === msgData.stickerMeaning);
                if (sticker) {
                  postToComment.comments.push(createCommentObject(sticker.url, sticker.name, msgData.replyTo || null)); 
                } else {
                  console.warn(`AI 尝试评论一个不存在的表情: "${msgData.stickerMeaning}"`);
                  postToComment.comments.push(createCommentObject(`[表情: ${msgData.stickerMeaning}]`, null, msgData.replyTo || null)); 
                }
              } else if (Array.isArray(msgData.comments)) {
                msgData.comments.forEach(commentText => { 
                  if (typeof commentText === 'string' && commentText.trim()) {
                    postToComment.comments.push(createCommentObject(commentText, null, msgData.replyTo || null)); 
                  }
                });
              } else if (typeof msgData.commentText === 'string' && msgData.commentText.trim()) {
                postToComment.comments.push(createCommentObject(msgData.commentText, null, msgData.replyTo || null)); 
              }

              await db.qzonePosts.update(postToComment.id, {
                comments: postToComment.comments
              });
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${msgData.postId}`); 

              if (!chat.commentCooldowns) chat.commentCooldowns = {};
              chat.commentCooldowns[msgData.postId] = Date.now();
            }
            continue;
          }
          case 'qzone_like':
            const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
            if (postToLike) {
              if (!postToLike.likes) postToLike.likes = [];
              if (!postToLike.likes.includes(chat.name)) {
                postToLike.likes.push(chat.name);
                await db.qzonePosts.update(postToLike.id, {
                  likes: postToLike.likes
                });
                updateUnreadIndicator(unreadPostsCount + 1);
                if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                  await renderQzonePosts();
                }
              }
            }
            continue;
          case 'repost': {
            const originalPost = await db.qzonePosts.get(parseInt(msgData.postId));
            if (originalPost) {
              const newPost = {
                type: 'repost',
                timestamp: Date.now(),
                authorId: chatId,
                authorGroupId: chat.groupId,
                repostComment: msgData.comment || '',
                originalPost: originalPost,
                visibleGroupIds: null
              };
              await db.qzonePosts.add(newPost);
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`后台活动: 角色 "${chat.name}" 转发了动态 #${msgData.postId}`);
            }
            continue;
          }
          case 'video_call_request':
            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
              state.activeChatId = chatId;
              videoCallState.activeChatId = chatId;
              videoCallState.isAwaitingResponse = true;
              videoCallState.isGroupCall = chat.isGroup;
              videoCallState.callRequester = msgData.name || chat.name;
              showIncomingCallModal();
            }
            continue;
          case 'group_call_request':
            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
              state.activeChatId = chatId;
              videoCallState.isAwaitingResponse = true;
              videoCallState.isGroupCall = true;
              videoCallState.initiator = 'ai';
              videoCallState.callRequester = msgData.name;
              showIncomingCallModal();
            }
            continue;
          case 'pat_user':
            let patterName;
            if (chat.isGroup) {
              const member = chat.members.find(m => m.originalName === msgData.name);
              patterName = member ? member.groupNickname : msgData.name;
            } else {
              patterName = chat.name;
            }
            const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
            const patText = `${patterName} 拍了拍我${suffix}`;

            const patMessage = {
              role: 'system',
              type: 'pat_message',
              content: patText,
              timestamp: Date.now()
            };
            chat.history.push(patMessage);
            if (isViewingThisChat) {
              const phoneScreen = document.getElementById('phone-screen');
              phoneScreen.classList.remove('pat-animation');
              void phoneScreen.offsetWidth;
              phoneScreen.classList.add('pat-animation');
              setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
              appendMessage(patMessage, chat);
            } else {
              showNotification(chatId, patText);
            }
            continue;
          case 'update_status':
            chat.status.text = msgData.status_text;
            chat.status.isBusy = msgData.is_busy || false;
            chat.status.lastUpdate = Date.now();
            const statusUpdateMessage = {
              role: 'system',
              type: 'pat_message',
              content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
              timestamp: Date.now()
            };
            chat.history.push(statusUpdateMessage);
            if (isViewingThisChat) {
              appendMessage(statusUpdateMessage, chat);
            }
            renderChatList();
            continue;
          case 'location_share':
            aiMessage = {
              ...baseMessage,
              type: 'location_share',
              content: msgData.content
            };
            break;
          case 'change_music':
            if (musicState.isActive && musicState.activeChatId === chatId) {
              const songNameFromAI = msgData.song_name || msgData.song || msgData.name;

              if (typeof songNameFromAI === 'string' && songNameFromAI.trim()) {
                const songNameToFind = songNameFromAI.replace(/^\[?\d+\]?[\s.-]*/, '').trim();
                const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songNameToFind.toLowerCase());

                if (targetSongIndex > -1) {
                  playSong(targetSongIndex);
                  const track = musicState.playlist[targetSongIndex];

                  let changerName;
                  if (chat.isGroup) {
                    const member = chat.members.find(m => m.originalName === msgData.name);
                    changerName = member ? member.groupNickname : msgData.name;
                  } else {
                    changerName = chat.name;
                  }

                  const musicChangeMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `[♪ ${changerName} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                    timestamp: Date.now()
                  };
                  chat.history.push(musicChangeMessage);
                  if (isViewingThisChat) {
                    appendMessage(musicChangeMessage, chat);
                  }
                } else {
                  console.warn(`歌曲查找失败: AI请求的歌曲名"${songNameFromAI}"(处理后为"${songNameToFind}") 在播放列表中未找到。`);
                }
              } else {
                console.error("AI返回的change_music指令中，歌曲名无效或缺失:", msgData);
              }
            }
            continue;
          case 'create_memory':
            const newMemory = {
              chatId: chatId,
              authorId: chatId,
              description: msgData.description,
              timestamp: Date.now(),
              type: 'ai_generated'
            };
            await db.memories.add(newMemory);
            console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
            continue;
          case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
              const newCountdown = {
                chatId: chatId,
                authorId: chatId,
                description: msgData.title,
                timestamp: Date.now(),
                type: 'countdown',
                targetDate: targetDate.getTime()
              };
              await db.memories.add(newCountdown);
              console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
            }
            continue;
          case 'block_user':
            if (!chat.isGroup) {
              chat.relationship.status = 'blocked_by_ai';
              const hiddenMessage = {
                role: 'system',
                content: `[系统提示：你刚刚主动拉黑了用户。]`,
                timestamp: Date.now(),
                isHidden: true
              };
              chat.history.push(hiddenMessage);
              await db.chats.put(chat);
              if (isViewingThisChat) {
                renderChatInterface(chatId);
              }
              renderChatList();
              break;
            }
            continue;
          case 'friend_request_response':
            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
              if (msgData.decision === 'accept') {
                chat.relationship.status = 'friend';
                aiMessage = {
                  ...baseMessage,
                  content: "我通过了你的好友申请，我们现在是好友啦！"
                };
              } else {
                chat.relationship.status = 'blocked_by_ai';
                aiMessage = {
                  ...baseMessage,
                  content: "抱歉，我拒绝了你的好友申请。"
                };
              }
              chat.relationship.applicationReason = '';
            }
            break;
          case 'poll':
            const pollOptions = typeof msgData.options === 'string' ?
              msgData.options.split('\n').filter(opt => opt.trim()) :
              (Array.isArray(msgData.options) ? msgData.options : []);
            if (pollOptions.length < 2) continue;
            aiMessage = {
              ...baseMessage,
              type: 'poll',
              question: msgData.question,
              options: pollOptions,
              votes: {},
              isClosed: false,
            };
            break;
          case 'gift': {
            const {
              itemName,
              itemPrice,
              image_prompt
            } = msgData;

            if (itemName && !isNaN(parseFloat(itemPrice)) && image_prompt) {

              const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(image_prompt)}`;

              aiMessage = {
                ...baseMessage,
                type: 'gift',
                items: [{
                  name: itemName,
                  price: parseFloat(itemPrice),
                  imageUrl: imageUrl,
                  quantity: 1
                }],
                total: parseFloat(itemPrice),
                recipients: msgData.recipients || null
              };
            } else {
              console.warn(`AI 尝试赠送一个格式不正确的随机礼物:`, msgData);
            }
            break;
          }
          case 'vote':
            const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
            if (pollToVote && !pollToVote.isClosed) {
              Object.keys(pollToVote.votes).forEach(option => {
                const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                if (voterIndex > -1) {
                  pollToVote.votes[option].splice(voterIndex, 1);
                }
              });
              if (!pollToVote.votes[msgData.choice]) {
                pollToVote.votes[msgData.choice] = [];
              }
              if (!pollToVote.votes[msgData.choice].includes(msgData.name)) {
                pollToVote.votes[msgData.choice].push(msgData.name);
              }
              if (isViewingThisChat) {
                renderChatInterface(chatId);
              }
            }
            continue;
          case 'red_packet':
            aiMessage = {
              ...baseMessage,
              ...msgData,
              totalAmount: msgData.amount,
              claimedBy: {},
              isFullyClaimed: false
            };

          
            if (aiMessage.packetType === 'lucky') {
                const allocatedAmounts = generateRandomPacketAmounts(aiMessage.amount, aiMessage.count);
                aiMessage.allocatedAmounts = allocatedAmounts;
                aiMessage.unclaimedAmounts = [...allocatedAmounts];
            }
           

            if (msgData.receiver) {
              aiMessage.receiverName = msgData.receiver;
              delete aiMessage.receiver;
            }
            break;
          case 'open_red_packet':
            const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);

            const claimerOriginalName = msgData.name;
            const isMember = chat.members.some(member => member.originalName === claimerOriginalName);


            if (!isMember) {
              console.warn(`AI 角色 "${claimerOriginalName}" 尝试领取不属于自己的群聊红包。操作已被拦截。`);
              continue;
            }

            if (packetToOpen && packetToOpen.packetType === 'direct') {
              if (packetToOpen.receiverName !== msgData.name) {
                console.warn(`AI 角色 "${msgData.name}" 尝试领取不属于自己的专属红包 (接收人: ${packetToOpen.receiverName})。操作已被拦截。`);
                continue;
              }
            }

            if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {
              let claimedAmountAI = 0;
              const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
              const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;
              if (remainingCount > 0) {
              if (packetToOpen.packetType === 'direct') {
                claimedAmountAI = packetToOpen.totalAmount;
              } 
            
              else if (packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length > 0) {
                
                claimedAmountAI = packetToOpen.unclaimedAmounts.pop();
              } 
             
              else { 
                console.warn("检测到旧版红包，回退到旧的（不公平）随机算法 (triggerAiResponse)");
                const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                if (remainingCount === 1) {
                  claimedAmountAI = remainingAmount;
                } else {
                  const min = 0.01;
                  const max = remainingAmount - (remainingCount - 1) * min;
                  claimedAmountAI = Math.random() * (max - min) + min;
                }
              }

                claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
                if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                packetToOpen.claimedBy[msgData.name] = claimedAmountAI;


                const claimerMember = chat.members.find(m => m.originalName === msgData.name);
                const claimerDisplayName = claimerMember ? claimerMember.groupNickname : msgData.name;


                const senderDisplayName = getDisplayNameInGroup(chat, packetToOpen.senderName);

                const aiClaimedMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `${claimerDisplayName} 领取了 ${senderDisplayName} 的红包`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(aiClaimedMessage);

                let hiddenContentForAI = `[系统提示：你 (${claimerDisplayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;
                if ((packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length === 0) || (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count)) {
                  packetToOpen.isFullyClaimed = true;
                  const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${senderDisplayName} 的红包已被领完`,
                    timestamp: messageTimestamp++
                  };
                  chat.history.push(finishedMessage);
                  let luckyKing = {
                    name: '',
                    amount: -1
                  };
                  if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                      if (amount > luckyKing.amount) {
                        luckyKing = {
                          name,
                          amount
                        };
                      }
                    });
                  }
                  if (luckyKing.name) {
                    const luckyKingMember = chat.members.find(m => m.originalName === luckyKing.name);
                    const luckyKingDisplayName = luckyKingMember ? luckyKingMember.groupNickname : luckyKing.name;
                    hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKingDisplayName}！`;
                  } else {
                    hiddenContentForAI += ` 红包已被领完。`;
                  }
                }
                hiddenContentForAI += ' 请根据这个结果发表你的评论。]';
                const hiddenMessageForAI = {
                  role: 'system',
                  content: hiddenContentForAI,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMessageForAI);
              }
              if (isViewingThisChat) {
                renderChatInterface(chatId);
                renderChatList();
              }
            }
            continue;

          case 'accept_transfer': {
            const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
            if (originalTransferMsgIndex > -1) {
              const originalMsg = chat.history[originalTransferMsgIndex];
              
              // 防止重复接收
              if (originalMsg.status && originalMsg.status !== 'pending') continue;

              originalMsg.status = 'accepted';
              
              // ★★★ 新增：构造 AI 的“已收款”消息 ★★★
              aiMessage = {
                  role: 'assistant',
                  senderName: msgData.name || chat.name,
                  type: 'transfer',
                  isReceived: true,  // 标记为收款
                  amount: originalMsg.amount,
                  note: '已收款',
                  timestamp: messageTimestamp++
              };
              // 去掉 continue，让它流转到下方的统一推送逻辑(if aiMessage...)
              break; 
            }
            continue;
          }

case 'decline_transfer': {
  const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
  if (originalTransferMsgIndex > -1) {
    const originalMsg = chat.history[originalTransferMsgIndex];

    // --- 修复：如果已经处理过，直接忽略 ---
    if (originalMsg.status && originalMsg.status !== 'pending') {
        console.warn(`AI试图重复拒收一笔已处理的转账 (状态: ${originalMsg.status})，已拦截。`);
        continue; 
    }

    originalMsg.status = 'declined';
              await processTransaction(originalMsg.amount, 'income', `转账退款-${chat.name}`);
              const refundMessage = {
                role: 'assistant',
      senderName: chat.name,
      type: 'transfer',
      isRefund: true, // 确保标记为退款
      amount: originalMsg.amount,
      note: '转账已被拒收',
      receiverName: '我', // 明确接收人
      timestamp: messageTimestamp++
              };
              chat.history.push(refundMessage);
              if (isViewingThisChat) {
                appendMessage(refundMessage, chat);
                renderChatInterface(chatId);
              }
            }
            continue;
          }
          case 'change_group_name':
            if (chat.isGroup && msgData.new_name) {
              const newName = msgData.new_name.trim();
              const memberNames = chat.members.map(m => m.originalName);

              if (memberNames.includes(newName)) {
                console.warn(`AI (${msgData.name}) 试图将群名更改为成员名 ("${newName}")。操作已被程序阻止。`);
                continue;
              }

              chat.name = newName;

              const changerMember = chat.members.find(m => m.originalName === msgData.name);
              const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;

              const systemMessage = {
                role: 'system',
                type: 'pat_message',
                content: `${changerDisplayName} 将群名修改为 “${chat.name}”`,
                timestamp: messageTimestamp++
              };
              chat.history.push(systemMessage);

              if (isViewingThisChat) {
                appendMessage(systemMessage, chat);
                document.getElementById('chat-header-title').textContent = chat.name;
              }
            }
            continue;
          case 'change_remark_name':
            if (!chat.isGroup && msgData.new_name) {
              const oldName = chat.name;
              const newName = msgData.new_name.trim();

              if (newName && newName !== oldName) {
                if (!chat.nameHistory) {
                  chat.nameHistory = [];
                }
                if (!chat.nameHistory.includes(oldName)) {
                  chat.nameHistory.push(oldName);
                }

                chat.name = newName;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `“${chat.originalName}” 将备注修改为 “${newName}”`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                const hiddenMemoryMessage = {
                  role: 'system',
                  content: `[系统提示：你刚刚成功将自己的备注名修改为了“${newName}”。请自然地接受这个新名字，不要对此感到惊讶。]`,
                  timestamp: messageTimestamp++,
                  isHidden: true
                };
                chat.history.push(hiddenMemoryMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                  document.getElementById('chat-header-title').textContent = newName;
                }

                await syncCharacterNameInGroups(chat);
              }
            }
            continue;

          case 'change_group_avatar':
            if (chat.isGroup && msgData.avatar_name) {
              const avatarName = msgData.avatar_name;
              const library = chat.settings.groupAvatarLibrary || [];
              const foundAvatar = library.find(avatar => avatar.name === avatarName);

              if (foundAvatar) {
                chat.settings.groupAvatar = foundAvatar.url;

                const changerMember = chat.members.find(m => m.originalName === msgData.name);
                const changerDisplayName = changerMember ? changerMember.groupNickname : msgData.name;

                const systemMessage = {
                  role: 'system',
                  type: 'pat_message',
                  content: `${changerDisplayName} 更换了群头像`,
                  timestamp: messageTimestamp++
                };
                chat.history.push(systemMessage);

                if (isViewingThisChat) {
                  appendMessage(systemMessage, chat);
                }
              } else {
                console.warn(`AI 尝试使用一个不存在的群头像: "${avatarName}"`);
              }
            }
            continue;
          case 'system_message':
            aiMessage = {
              role: 'system',
              type: 'pat_message',
              content: msgData.content,
              timestamp: Date.now()
            };
            break;
          case 'share_link':
            aiMessage = {
              ...baseMessage,
              type: 'share_link',
              title: msgData.title,
              description: msgData.description,
              source_name: msgData.source_name,
              content: msgData.content
            };
            break;
          case 'quote_reply': {
            let originalMessage = null;
            
          
            if (msgData.target_content) {
              originalMessage = [...chat.history].reverse().find(m => 
                !m.isHidden &&
                ( 
                  m.content === msgData.target_content ||
                  (typeof m.content === 'string' && m.content.trim() === msgData.target_content.trim())
                )
              );
              
              if(!originalMessage) {
                 console.warn(`[本轮引用失败] AI ${msgData.name} 尝试引用内容 "${(msgData.target_content || '').substring(0, 20)}..."，但在本轮历史中未找到。`);
              }
            } 
            
           
            else if (msgData.target_timestamp) { 
              originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
            }

            
            if (originalMessage) {
              
            
              let quotedSenderDisplayName;
              
              if (originalMessage.role === 'user') {
                
                  quotedSenderDisplayName = chat.settings.myNickname || '我';
              } else { 
                 
                  if (chat.isGroup) {
                    
                      quotedSenderDisplayName = getDisplayNameInGroup(chat, originalMessage.senderName);
                  } else {
                     
                      quotedSenderDisplayName = chat.name;
                  }
              }
              
              const quoteContext = {
                  timestamp: originalMessage.timestamp,
                  senderName: quotedSenderDisplayName, 
                  
                  content: String(originalMessage.content || '').substring(0, 50) 
              };
             
              
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content,
                quote: quoteContext
              };
            } else {
              
              console.warn(`引用回复失败: 找不到目标消息 (Content: ${msgData.target_content}, TS: ${msgData.target_timestamp})`);
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content 
              };
            }
            break;
          } 
          case 'send_and_recall': {
            if (!isViewingThisChat) continue;
            const tempMessageData = {
              ...baseMessage,
              content: msgData.content
            };
            const tempMessageElement = createMessageElement(tempMessageData, chat);
            appendMessage(tempMessageData, chat, true);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 500));
            const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
            if (bubbleWrapper) {
              bubbleWrapper.classList.add('recalled-animation');
              await new Promise(resolve => setTimeout(resolve, 300));
              const recalledMessage = {
                role: 'assistant',
                senderName: msgData.name || chat.name,
                type: 'recalled_message',
                content: '对方撤回了一条消息',
                timestamp: tempMessageData.timestamp,
                recalledData: {
                  originalType: 'text',
                  originalContent: msgData.content
                }
              };
              const msgIndex = chat.history.findIndex(m => m.timestamp === tempMessageData.timestamp);
              if (msgIndex > -1) {
                chat.history[msgIndex] = recalledMessage;
              } else {
                chat.history.push(recalledMessage);
              }
              const placeholder = await createMessageElement(recalledMessage, chat);
              if (document.body.contains(bubbleWrapper)) {
                bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
              }
            }
            continue;
          }

          case 'text':
            aiMessage = {
              ...baseMessage,
              content: String(msgData.content || msgData.message)
            };
            break;
          case 'sticker':
            if (msgData.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
        
                console.warn(`AI 尝试使用一个不存在的表情: "${msgData.meaning}"`);
                aiMessage = null;
              }
            } else {
          
              console.warn("AI 发送了一个没有 'meaning' 的 sticker 指令。", msgData);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: msgData.url,
                meaning: '未知表情'
              };
            }
            break;
          case 'ai_image':
            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: msgData.description,
              image_prompt: msgData.image_prompt
            };
            break;
          case 'voice_message':
            aiMessage = {
              ...baseMessage,
              type: 'voice_message',
              content: msgData.content
            };
            break;
          case 'transfer':
            aiMessage = {
              ...baseMessage,
              type: 'transfer',
              amount: msgData.amount,
              note: msgData.note,
              receiverName: msgData.receiver || '我'
            };
            break;

          case 'waimai_request':
            aiMessage = {
              ...baseMessage,
              type: 'waimai_request',
              productInfo: msgData.productInfo,
              amount: msgData.amount,
              status: 'pending',
              countdownEndTime: Date.now() + 15 * 60 * 1000,
            };
            break;
          case 'waimai_order':
            aiMessage = {
              ...baseMessage,
              type: 'waimai_order',
              productInfo: msgData.productInfo,
              amount: msgData.amount,
              greeting: msgData.greeting,
              recipientName: msgData.recipientName || null
            };
            break;
          case 'offline_text':
            aiMessage = {
              ...baseMessage,
              ...msgData
            };
            break;

          case 'naiimag':
          
            try {
              console.log('📸 NovelAI图片生成开始，AI提供的prompt:', msgData.prompt);

          
              const naiPrompts = getCharacterNAIPrompts(chat.id);

         
              const aiPrompt = msgData.prompt || 'a beautiful scene';
              const finalPositivePrompt = aiPrompt + ', ' + naiPrompts.positive;
              const finalNegativePrompt = naiPrompts.negative;

              console.log(`📝 使用${naiPrompts.source === 'character' ? '角色专属' : '系统'}提示词配置`);
              console.log('最终正面提示词:', finalPositivePrompt);
              console.log('最终负面提示词:', finalNegativePrompt);

            
              const apiKey = localStorage.getItem('novelai-api-key');
              const model = localStorage.getItem('novelai-model') || 'nai-diffusion-4-5-full';
              const settings = getNovelAISettings();

              if (!apiKey) {
                throw new Error('NovelAI API Key未配置。请在NovelAI设置中填写API Key。');
              }

              const [width, height] = settings.resolution.split('x').map(Number);

             
              let requestBody;

              if (model.includes('nai-diffusion-4')) {
             
                requestBody = {
                  input: finalPositivePrompt,
                  model: model,
                  action: 'generate',
                  parameters: {
                    params_version: 3, 
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    autoSmea: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: true,
                    cfg_rescale: 0,
                    noise_schedule: 'karras', 
                    legacy_v3_extend: false,
                    skip_cfg_above_sigma: null,
                    use_coords: false,
                    legacy_uc: false,
                    normalize_reference_strength_multiple: true,
                    inpaintImg2ImgStrength: 1,
                    characterPrompts: [],
                
                    v4_prompt: {
                      caption: {
                        base_caption: finalPositivePrompt,
                        char_captions: []
                      },
                      use_coords: false,
                      use_order: true
                    },
                  
                    v4_negative_prompt: {
                      caption: {
                        base_caption: finalNegativePrompt,
                        char_captions: []
                      },
                      legacy_uc: false
                    },
                    negative_prompt: finalNegativePrompt,
                    deliberate_euler_ancestral_bug: false,
                    prefer_brownian: true
                
                  }
                };
              } else {
            
                requestBody = {
                  input: finalPositivePrompt,
                  model: model,
                  action: 'generate',
                  parameters: {
                    width: width,
                    height: height,
                    scale: settings.cfg_scale,
                    sampler: settings.sampler,
                    steps: settings.steps,
                    seed: settings.seed === -1 ? Math.floor(Math.random() * 9999999999) : settings.seed,
                    n_samples: 1,
                    ucPreset: settings.uc_preset,
                    qualityToggle: settings.quality_toggle,
                    sm: settings.smea,
                    sm_dyn: settings.smea_dyn,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: finalNegativePrompt
                  }
                };
              }

              console.log('🚀 发送NAI请求:', requestBody);

             
              let apiUrl;

             
              if (model.includes('nai-diffusion-4')) {
              
                apiUrl = 'https://image.novelai.net/ai/generate-image-stream';
              } else {
              
                apiUrl = 'https://image.novelai.net/ai/generate-image';
              }

              let corsProxy = settings.cors_proxy;

             
              if (corsProxy === 'custom') {
                corsProxy = settings.custom_proxy_url || '';
              }

          
              if (corsProxy && corsProxy !== '') {
                apiUrl = corsProxy + encodeURIComponent(apiUrl);
              }

              const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + apiKey
                },
                body: JSON.stringify(requestBody)
              });

              console.log('Response status:', response.status);
              console.log('Response headers:', [...response.headers.entries()]);

              if (!response.ok) {
                const errorText = await response.text();
                console.error('API错误响应:', errorText);
                throw new Error(`API请求失败 (${response.status}): ${errorText}`);
              }

           
              const contentType = response.headers.get('content-type');
              console.log('Content-Type:', contentType);

            
              let zipBlob;
              let imageDataUrl;
              if (contentType && contentType.includes('text/event-stream')) {
                console.log('检测到 SSE 流式响应，开始解析...');

            
                const text = await response.text();
                console.log('收到 SSE 数据，大小:', text.length);

             
                const lines = text.trim().split('\n');
                let base64Data = null;

                for (let i = lines.length - 1; i >= 0; i--) {
                  const line = lines[i].trim();
                  if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6); 

              
                    try {
                      const jsonData = JSON.parse(dataContent);

                   
                      if (jsonData.event_type === 'final' && jsonData.image) {
                        base64Data = jsonData.image;
                        console.log('✅ 找到 final 事件的图片数据');
                        break;
                      }

                   
                      if (jsonData.data) {
                        base64Data = jsonData.data;
                        console.log('从 JSON.data 中提取图片数据');
                        break;
                      }
                      if (jsonData.image) {
                        base64Data = jsonData.image;
                        console.log('从 JSON.image 中提取图片数据');
                        break;
                      }
                    } catch (e) {
                  
                      base64Data = dataContent;
                      console.log('直接使用 base64 数据');
                      break;
                    }
                  }
                }

                if (!base64Data) {
                  throw new Error('无法从 SSE 响应中提取图片数据');
                }

              
                const isPNG = base64Data.startsWith('iVBORw0KGgo');
                const isJPEG = base64Data.startsWith('/9j/');

                if (isPNG || isJPEG) {
                  console.log('✅ 检测到直接的图片 base64 数据 (PNG/JPEG)');
               
                  const binaryString = atob(base64Data);
                  const bytes = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                  const imageBlob = new Blob([bytes], {
                    type: isPNG ? 'image/png' : 'image/jpeg'
                  });
                  console.log('图片 Blob 创建成功，大小:', imageBlob.size);

              
                  const reader = new FileReader();
                  imageDataUrl = await new Promise((resolve, reject) => {
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                  });
                  console.log('✅ 图片转换成功！🎨');
                } else {
                 
                  console.log('当作 ZIP 文件处理...');
                  const binaryString = atob(base64Data);
                  const bytes = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                  zipBlob = new Blob([bytes]);
                  console.log('ZIP Blob 大小:', zipBlob.size);
                }
              } else {
             
                zipBlob = await response.blob();
                console.log('收到数据，类型:', zipBlob.type, '大小:', zipBlob.size);
              }

             
              if (!imageDataUrl && zipBlob) {
             
                try {
               
                  if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip库未加载，请刷新页面重试');
                  }

                  
                  const zip = await JSZip.loadAsync(zipBlob);
                  console.log('ZIP文件内容:', Object.keys(zip.files));

                 
                  let imageFile = null;
                  for (let filename in zip.files) {
                    if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                      imageFile = zip.files[filename];
                      console.log('找到图片文件:', filename);
                      break;
                    }
                  }

                  if (!imageFile) {
                    throw new Error('ZIP文件中未找到图片');
                  }

               
                  const imageBlob = await imageFile.async('blob');
                  console.log('提取的图片大小:', imageBlob.size);

                 
                  const reader = new FileReader();
                  imageDataUrl = await new Promise((resolve, reject) => {
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                  });
                  console.log('✅ 图片解压成功！');
                } catch (zipError) {
                  console.error('ZIP解压失败:', zipError);
                  throw new Error('图片解压失败: ' + zipError.message);
                }
              }

              console.log('✅ NAI图片生成成功！');

            
              aiMessage = {
                ...baseMessage,
                type: 'naiimag',
                imageUrl: imageDataUrl,
                prompt: aiPrompt,
                fullPrompt: finalPositivePrompt // 保存完整提示词供查看
              };
            } catch (error) {
              console.error('❌ NAI图片生成失败:', error);
            
              aiMessage = {
                ...baseMessage,
                content: `[图片生成失败: ${error.message}]`
              };
            }
            break;

          default:
            console.warn("收到了未知的AI指令类型:", msgData.type);
            break;
        }

        if (aiMessage) {
          chat.history.push(aiMessage);
          if (!isViewingThisChat) {
            chat.unreadCount = (chat.unreadCount || 0) + 1;
          }
          if (!isViewingThisChat && !notificationShown) {
            let notificationText;
            switch (aiMessage.type) {
              case 'transfer':
                notificationText = `[收到一笔转账]`;
                break;
              case 'waimai_request':
                notificationText = `[收到一个外卖代付请求]`;
                break;
              case 'ai_image':
                notificationText = `[图片]`;
                break;
              case 'voice_message':
                notificationText = `[语音]`;
                break;
              case 'sticker':
                notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                break;
              case 'offline_text':
                notificationText = aiMessage.dialogue ? `「${aiMessage.dialogue}」` : `[${aiMessage.description.substring(0, 20)}...]`;
                break;
              default:
                notificationText = String(aiMessage.content || '');
            }
            const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
            showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
            notificationShown = true;
          }



          if (isViewingThisChat) {
            appendMessage(aiMessage, chat);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
          }
        }
      }

      if (callHasBeenHandled && videoCallState.isGroupCall) {
        videoCallState.isAwaitingResponse = false;
        if (videoCallState.participants.length > 0) {
          startVideoCall();
        } else {
          videoCallState = {
            ...videoCallState,
            isAwaitingResponse: false,
            participants: []
          };
          showScreen('chat-interface-screen');
          alert('无人接听群聊邀请。');
        }
      }
      if (needsImmediateReaction) {
        await triggerAiResponse();
        return;
      }
      await db.chats.put(chat);

      const qzoneActionTaken = messagesArray.some(action =>
        action.type === 'qzone_post' ||
        action.type === 'qzone_like' ||
        action.type === 'qzone_comment' ||
        action.type === 'repost'
      );


      if (qzoneActionTaken) {
        console.log("检测到AI执行了动态操作，立即刷新好友动态页面。");

        await renderQzonePosts();
      }


    } catch (error) {

      chat.history = chat.history.filter(msg => !msg.isTemporary);

      if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        chat.relationship.status = 'blocked_by_ai';
        await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
      } else {
        await showCustomAlert(
          'API 调用失败',
          `发生了一个错误，AI未能成功响应。\n\n错误详情:\n${error.message}`
        );
      }

      if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        await db.chats.put(chat);
      }

      videoCallState.isAwaitingResponse = false;
    } finally {
      setAvatarActingState(chatId, false);


      if (chat.isGroup) {
        if (typingIndicator) {
          typingIndicator.style.display = 'none';
        }
      } else {
        if (chatHeaderTitle && state.chats[chatId]) {
          chatHeaderTitle.style.opacity = 0;
          setTimeout(() => {
            chatHeaderTitle.textContent = state.chats[chatId].name;
            chatHeaderTitle.classList.remove('typing-status');
            chatHeaderTitle.style.opacity = 1;
          }, 200);
        }
      }
      renderChatList();
      if (isViewingThisChat) {
        checkAndTriggerAutoSummary(chatId);

      }
      stopSilentAudio();
    }
  }








  async function sendSticker(sticker) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msg = {
      role: 'user',
      content: sticker.url,
      meaning: sticker.name,
      timestamp: Date.now()
    };
    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();
    document.getElementById('sticker-panel').classList.remove('visible');
  }

// --- 修复版V2：转账 (修复ID解析bug，确保扣款和记账) ---
async function sendUserTransfer() {
    if (!state.activeChatId) return;
    const amountInput = document.getElementById('transfer-amount');
    const noteInput = document.getElementById('transfer-note');
    const amount = parseFloat(amountInput.value);
    const note = noteInput.value.trim();

    if (isNaN(amount) || amount <= 0) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert('提示', '请输入有效的转账金额(必须大于0)！');
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }

    const chat = state.chats[state.activeChatId];
    const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const receiverName = chat.isGroup ? '群聊' : chat.name;

    // 1. 获取钱包数据
    const wallet = await db.userWallet.get('main') || { balance: 0, kinshipCards: [] };
    const balance = wallet.balance || 0;
    const kinshipCards = wallet.kinshipCards || [];

    // 2. 构建支付选项 UI
    const paymentOptions = [];
    const iconWallet = `<div class="pay-opt-icon" style="background:#1677ff; display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">支</div>`;
    const iconKinship = `<div class="pay-opt-icon" style="background:linear-gradient(135deg, #ff5252, #ff1744); display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">亲</div>`;

    // 选项：余额
    if (balance >= amount) {
        paymentOptions.push({ 
            text: `<div class="pay-opt-left">${iconWallet}<div class="pay-opt-info"><span class="pay-opt-title">账户余额</span><span class="pay-opt-desc">剩余 ¥${balance.toFixed(2)}</span></div></div>`, 
            value: 'balance' 
        });
    }

    // 选项：亲属卡
    for (const card of kinshipCards) {
        const remaining = card.limit - (card.spent || 0);
        if (remaining >= amount) {
            const providerChat = state.chats[card.chatId];
            const providerName = providerChat ? providerChat.name : '未知角色';
            paymentOptions.push({
                text: `<div class="pay-opt-left">${iconKinship}<div class="pay-opt-info"><span class="pay-opt-title">亲属卡 - ${providerName}</span><span class="pay-opt-desc">剩余额度 ¥${remaining.toFixed(2)}</span></div></div>`,
                value: `kinship_${card.chatId}` // 格式如: kinship_chat_172839...
            });
        }
    }

    if (paymentOptions.length === 0) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert('支付失败', `余额或亲属卡额度不足！\n需要: ¥${amount.toFixed(2)}`);
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }

    // 3. 弹出选择
    const modalOverlay = document.getElementById('custom-modal-overlay');
    modalOverlay.style.zIndex = 3002;
    const paymentMethod = await showChoiceModal(`转账 ¥${amount.toFixed(2)}`, paymentOptions);
    modalOverlay.style.zIndex = '';

    if (!paymentMethod) return;

    // 4. 执行扣款和记账
    if (paymentMethod === 'balance') {
        const success = await processTransaction(amount, 'expense', `转账给-${receiverName}`);
        if (!success) return;
    } else if (paymentMethod.startsWith('kinship_')) {
        // 【修复重点】：使用 replace 提取完整 ID，而不是 split
        // 之前的 split('_')[1] 会把 'chat_123' 截断成 'chat'，导致找不到卡片
        const cardChatId = paymentMethod.replace('kinship_', ''); 
        
        const cardIndex = wallet.kinshipCards.findIndex(c => c.chatId === cardChatId);
        
        if (cardIndex > -1) {
            // A. 扣减额度
            wallet.kinshipCards[cardIndex].spent = (wallet.kinshipCards[cardIndex].spent || 0) + amount;
            await db.userWallet.put(wallet); // 保存回数据库
            
            // B. 写入账单
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: amount,
                description: `亲属卡转账-给${receiverName}`
            });

            // C. 通知金主 (系统消息)
            const providerChat = state.chats[cardChatId];
            if (providerChat) {
                let notifyContent = (cardChatId === chat.id) 
                    ? `[消费通知：用户使用你的亲属卡向【你】转账了 ¥${amount.toFixed(2)}。]`
                    : `[消费通知：用户使用你的亲属卡向【${receiverName}】转账了 ¥${amount.toFixed(2)}。]`;
                
                providerChat.history.push({ role: 'system', content: notifyContent, timestamp: Date.now(), isHidden: true });
                await db.chats.put(providerChat);
            }
        } else {
            alert("系统错误：找不到对应的亲属卡记录，支付取消。");
            return;
        }
    }

    // 5. 消息上屏
    const msg = {
      role: 'user',
      type: 'transfer',
      amount: amount,
      note: note,
      senderName,
      receiverName,
      timestamp: Date.now()
    };
    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();
    
    document.getElementById('transfer-modal').classList.remove('visible');
    amountInput.value = '';
    noteInput.value = '';
}

 
  async function sendWaimaiOrderForAI() {
    if (!state.activeChatId) return;

    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');

    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    // 1. 校验金额必须大于0
    if (!productInfo || isNaN(amount) || amount <= 0) {
      // 临时提升弹窗层级，防止被外卖弹窗遮挡
      document.getElementById('custom-modal-overlay').style.zIndex = 3002;
      await showCustomAlert('提示', '请填写有效的商品信息和金额(必须大于0)！');
      document.getElementById('custom-modal-overlay').style.zIndex = '';
      return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 【新增】执行扣款逻辑
    // 同样需要处理弹窗层级，防止“余额不足”提示被遮挡
    const modalOverlay = document.getElementById('custom-modal-overlay');
    modalOverlay.style.zIndex = 3002; // 比 waimai-request-modal 高

    const success = await processTransaction(amount, 'expense', `为TA点外卖-${productInfo}`);
    
    modalOverlay.style.zIndex = ''; // 恢复层级

    if (!success) return; // 余额不足，停止执行

    const visibleMessage = {
      role: 'user',
      senderName: myNickname,
      type: 'waimai_order',
      productInfo: productInfo,
      amount: amount,
      timestamp: now
    };
    chat.history.push(visibleMessage);


    const hiddenMessage = {
      role: 'system',
      content: `[系统提示：用户(${myNickname})为你点了一份外卖作为【礼物】。外卖内容是“${productInfo}”，价值${amount}元。这不是一个代付请求，而是用户已经为你支付了。请你对此表示感谢。]`,
      timestamp: now + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);


    await db.chats.put(chat);
    appendMessage(visibleMessage, chat);
    renderChatList();


    productInfoInput.value = '';
    amountInput.value = '';
    document.getElementById('waimai-request-modal').classList.remove('visible');
  }
  
  async function sendLocationShare() {
    if (!state.activeChatId) return;


    const locationName = await showCustomPrompt("共享位置", "你现在在哪里呀？", "");


    if (!locationName || !locationName.trim()) return;



    const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';

    const chat = state.chats[state.activeChatId];


    const msg = {
      role: 'user',
      type: 'location_share',
      content: locationName.trim(),
      imageUrl: hardcodedImageUrl,
      timestamp: Date.now()
    };


    chat.history.push(msg);
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();
  }


  function enterSelectionMode(initialMsgTimestamp) {
    if (isSelectionMode) return;
    isSelectionMode = true;
    document.getElementById('chat-interface-screen').classList.add('selection-mode');
    toggleMessageSelection(initialMsgTimestamp);
  }

  function exitSelectionMode() {
    cleanupWaimaiTimers();
    if (!isSelectionMode) return;
    isSelectionMode = false;
    document.getElementById('chat-interface-screen').classList.remove('selection-mode');
    selectedMessages.forEach(ts => {
      const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`);
      if (bubble) bubble.classList.remove('selected');
    });
    selectedMessages.clear();
  }


  function toggleMessageSelection(timestamp) {

    const elementToSelect = document.querySelector(
      `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
      selectedMessages.delete(timestamp);
      elementToSelect.classList.remove('selected');
    } else {
      selectedMessages.add(timestamp);
      elementToSelect.classList.add('selected');
    }

    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;

    if (selectedMessages.size === 0) {
      exitSelectionMode();
    }
  }


  function addLongPressListener(element, callback) {
    let pressTimer;
    const startPress = (e) => {
      if (isSelectionMode) return;
      e.preventDefault();
      pressTimer = window.setTimeout(() => callback(e), 500);
    };
    const cancelPress = () => clearTimeout(pressTimer);
    element.addEventListener('mousedown', startPress);
    element.addEventListener('mouseup', cancelPress);
    element.addEventListener('mouseleave', cancelPress);
    element.addEventListener('touchstart', startPress, {
      passive: true
    });
    element.addEventListener('touchend', cancelPress);
    element.addEventListener('touchmove', cancelPress);
  }

  async function handleListenTogetherClick() {
    const targetChatId = state.activeChatId;
    if (!targetChatId) return;
    if (!musicState.isActive) {
      startListenTogetherSession(targetChatId);
      return;
    }
    if (musicState.activeChatId === targetChatId) {
      document.getElementById('music-player-overlay').classList.add('visible');
    } else {
      const oldChatName = state.chats[musicState.activeChatId]?.name || '未知';
      const newChatName = state.chats[targetChatId]?.name || '当前';
      const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        await endListenTogetherSession(true);
        await new Promise(resolve => setTimeout(resolve, 50));
        startListenTogetherSession(targetChatId);
      }
    }
  }

  async function startListenTogetherSession(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;
    musicState.totalElapsedTime = chat.musicData.totalTime || 0;
    musicState.isActive = true;
    musicState.activeChatId = chatId;
    if (musicState.playlist.length > 0) {
      musicState.currentIndex = 0;
    } else {
      musicState.currentIndex = -1;
    }
    if (musicState.timerId) clearInterval(musicState.timerId);
    musicState.timerId = setInterval(() => {
      if (musicState.isPlaying) {
        musicState.totalElapsedTime++;
        updateElapsedTimeDisplay();
      }
    }, 1000);
    updatePlayerUI();
    updatePlaylistUI();
    document.getElementById('music-player-overlay').classList.add('visible');
  }

  async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    document.getElementById('global-lyrics-bar').classList.remove('visible');
    const cleanupLogic = async () => {
      if (musicState.timerId) clearInterval(musicState.timerId);
      if (musicState.isPlaying) audioPlayer.pause();
      if (saveState && oldChatId && state.chats[oldChatId]) {
        const chat = state.chats[oldChatId];
        chat.musicData.totalTime = musicState.totalElapsedTime;
        await db.chats.put(chat);
      }
      musicState.isActive = false;
      musicState.activeChatId = null;
      musicState.totalElapsedTime = 0;
      musicState.timerId = null;
      updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
  }

  function returnToChat() {
    closeMusicPlayerWithAnimation();
  }

  function updateListenTogetherIcon(chatId, forceReset = false) {
    const iconImg = document.querySelector('#listen-together-btn img');
    if (!iconImg) return;
    if (forceReset || !musicState.isActive || musicState.activeChatId !== chatId) {
      iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png';
      iconImg.className = '';
      return;
    }
    iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png';
    iconImg.classList.add('rotating');
    if (musicState.isPlaying) iconImg.classList.remove('paused');
    else iconImg.classList.add('paused');
  }
  window.updateListenTogetherIconProxy = updateListenTogetherIcon;

  function updatePlayerUI() {
    updateListenTogetherIcon(musicState.activeChatId);
    updateElapsedTimeDisplay();
    const titleEl = document.getElementById('music-player-song-title');
    const artistEl = document.getElementById('music-player-artist');
    const playPauseBtn = document.getElementById('music-play-pause-btn');
    if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
      const track = musicState.playlist[musicState.currentIndex];
      titleEl.textContent = track.name;
      artistEl.textContent = track.artist;
    } else {
      titleEl.textContent = '请添加歌曲';
      artistEl.textContent = '...';
    }
    playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
  }

  function updateElapsedTimeDisplay() {
    const hours = (musicState.totalElapsedTime / 3600).toFixed(1);
    document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`;
  }

  function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
      playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
      return;
    }
    musicState.playlist.forEach((track, index) => {
      const item = document.createElement('div');
      item.className = 'playlist-item';
      if (index === musicState.currentIndex) item.classList.add('playing');
      
      
      item.dataset.index = index;

     
      const checkboxDisplay = isPlaylistManagementMode ? 'block' : 'none';

      item.innerHTML = `
        <input type="checkbox" class="playlist-item-checkbox" style="display: ${checkboxDisplay};" data-index="${index}">
        <div class="playlist-item-info">
            <div class="title">${track.name}</div>
            <div class="artist">${track.artist}</div>
        </div>
        <div class="playlist-item-actions">
            <span class="playlist-action-btn album-art-btn" data-index="${index}">专辑</span>
            <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
            <span class="playlist-action-btn bg-btn" data-index="${index}">背景</span>
            <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
        </div>
      `;

     
      item.addEventListener('click', (e) => {
        if (isPlaylistManagementMode) {
         
          if (e.target.tagName !== 'INPUT') {
            e.stopPropagation(); 
          }
          handlePlaylistSelection(index);
        }
      });
      
      
      const infoEl = item.querySelector('.playlist-item-info');
      if (infoEl) {
          infoEl.addEventListener('click', (e) => {
              if (!isPlaylistManagementMode) {
                  e.stopPropagation(); 
                  playSong(index, false);
              }
          });
      }
      
      playlistBody.appendChild(item);
    });
  }



  async function togglePlayPause() {
    if (audioPlayer.paused) {
      if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
        playSong(0, true);
      } else if (musicState.currentIndex > -1) {
        playSong(musicState.currentIndex, true); 
      }
    } else {
      audioPlayer.pause();
     // await addMusicActionSystemMessage('暂停了音乐');
    }
  }

  function playNext(isAutomatic = false) {
    if (musicState.playlist.length === 0) return;
    let nextIndex;
    switch (musicState.playMode) {
      case 'random':
        nextIndex = Math.floor(Math.random() * musicState.playlist.length);
        break;
      case 'single':
        playSong(musicState.currentIndex, isAutomatic); 
        return;
      case 'order':
      default:
        nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
        break;
    }
    playSong(nextIndex, isAutomatic); 
  }

  function playPrev() {
    if (musicState.playlist.length === 0) return;
    const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length;
    playSong(newIndex, false); 
  }

  function changePlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(musicState.playMode);
    musicState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('music-mode-btn').textContent = {
      'order': '顺序',
      'random': '随机',
      'single': '单曲'
    } [musicState.playMode];
  }

  async function addSongFromURL() {
    const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url");
    if (!url) return;
    const name = await showCustomPrompt("歌曲信息", "请输入歌名");
    if (!name) return;
    const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
    if (!artist) return;
    musicState.playlist.push({
      name,
      artist,
      src: url,
      isLocal: false
    });
    await saveGlobalPlaylist();
    updatePlaylistUI();
    if (musicState.currentIndex === -1) {
      musicState.currentIndex = musicState.playlist.length - 1;
      updatePlayerUI();
    }
  }

  




  async function playSong(index, isAutomatic = false) {
    if (index < 0 || index >= musicState.playlist.length) return;

    audioPlayer.pause();

    musicState.currentIndex = index;
    const track = musicState.playlist[index];
    const chat = state.chats[musicState.activeChatId];


    const avatarDisplay = document.getElementById('music-player-avatar-display');
    if (chat && avatarDisplay) {

      avatarDisplay.innerHTML = '';


      const charAvatarUrl = chat.isGroup ?
        (chat.members.find(m => m.originalName === track.artist)?.avatar || defaultAvatar) :
        (chat.settings.aiAvatar || defaultAvatar);
      const userAvatarUrl = chat.settings.myAvatar || defaultAvatar;


      const charAvatarEl = document.createElement('img');
      charAvatarEl.src = charAvatarUrl;
      charAvatarEl.className = 'participant-display-avatar';
      charAvatarEl.alt = 'Character Avatar';
      avatarDisplay.appendChild(charAvatarEl);


      const userAvatarEl = document.createElement('img');
      userAvatarEl.src = userAvatarUrl;
      userAvatarEl.className = 'participant-display-avatar';
      userAvatarEl.alt = 'User Avatar';
      avatarDisplay.appendChild(userAvatarEl);
    }


    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    if (playerWindow) {
      playerWindow.style.setProperty('--music-bg-image', track.background ? `url(${track.background})` : 'none');
      playerWindow.classList.toggle('bg-clear', !!track.isBgClear);
    }
    if (toggleBtn) {
      toggleBtn.classList.toggle('active', !!track.isBgClear);
    }


    document.getElementById('music-visual-container').classList.remove('lyrics-active');
    const coverEl = document.getElementById('music-player-cover');
    if (coverEl) {
      coverEl.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
    }

    if (!isAutomatic) {
      await addMusicActionSystemMessage(`将歌曲切换为了《${track.name}》`);
    }
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");

    renderLyrics();
    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
      if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        singleLyricEl.textContent = '纯音乐，请欣赏';
      } else {
        singleLyricEl.textContent = '♪ ♪ ♪';
      }
    }

    if (track.isLocal && track.src instanceof ArrayBuffer) {
      const blob = new Blob([track.src], {
        type: track.fileType || 'audio/mpeg'
      });
      audioPlayer.src = URL.createObjectURL(blob);
    } else if (track.isLocal && track.src instanceof Blob) {
      audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
      // --- 【新增】尝试使用代理播放音频 (复用 NovelAI 的代理设置) ---
      const settings = getNovelAISettings(); // 获取设置
      let corsProxy = settings.cors_proxy;
      
      // 如果选的是自定义 (即你的 CF Worker)
      if (corsProxy === 'custom') {
          corsProxy = settings.custom_proxy_url || '';
      }

      // 只有当存在代理地址，且链接不是 base64 (data:) 时才使用代理
      if (corsProxy && corsProxy.trim() !== '' && !track.src.startsWith('data:')) {
          // 使用 encodeURIComponent 可以防止 URL 中的特殊字符导致代理解析错误
          // 如果你的 Worker 是直接拼接形式 (比如 https://worker.dev/https://catbox...), 这样通常也没问题
          const proxiedUrl = corsProxy + encodeURIComponent(track.src);
          console.log(`[音乐播放] 使用代理加载: ${track.name}`);
          audioPlayer.src = proxiedUrl;
      } else {
          // 没有配置代理，直接直连
          audioPlayer.src = track.src;
      }
      // -------------------------------------------------------
      
    } else {
      console.error('本地歌曲源错误:', track);
      return;
    }

    const playPromise = audioPlayer.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        if (error.name === 'NotAllowedError') {
          console.warn('Autoplay was prevented by the browser.');
          audioPlayer.pause();
          
        } else if (error.name !== 'AbortError') {
          console.error('Playback error:', error);
        }
      });
    }
    updatePlaylistUI();
    updatePlayerUI();
    const isFrameMode = document.body.classList.contains('frame-mode-active');
    const isAlwaysIslandMode = state.globalSettings.alwaysShowMusicIsland || false;
    const lyricBar = document.getElementById('global-lyrics-bar');

    if (isFrameMode || isAlwaysIslandMode) {
     
      phoneScreenForIsland.classList.add('dynamic-island-active');
      islandAlbumArt.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
      lyricBar.classList.remove('visible'); 
    } else {
    
      phoneScreenForIsland.classList.remove('dynamic-island-active');
      if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
        lyricBar.textContent = '♪';
        lyricBar.classList.add('visible');
      } else {
        lyricBar.classList.remove('visible');
      }
    }
  }



  async function handleChangeBackground(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;


    const choice = await showChoiceModal("更换歌曲背景", [{
        text: '📁 从本地上传',
        value: 'local'
      },
      {
        text: '🌐 使用网络URL',
        value: 'url'
      }
    ]);

    let newBackgroundUrl = null;


    if (choice === 'local') {
      newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
      newBackgroundUrl = await showCustomPrompt("输入图片URL", "请输入新的背景图片链接", "", "url");
    }


    if (newBackgroundUrl && newBackgroundUrl.trim()) {
      musicState.playlist[trackIndex].background = newBackgroundUrl.trim();
      await saveGlobalPlaylist();


      if (musicState.currentIndex === trackIndex) {
        const playerWindow = document.querySelector('.music-player-window');
        playerWindow.style.setProperty('--music-bg-image', `url(${newBackgroundUrl.trim()})`);
      }

      await showCustomAlert("成功", "歌曲背景已更新！");
    }
  }
 
  async function handleChangeAlbumArt(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal("更换专辑封面", [{
        text: '📁 从本地上传',
        value: 'local'
      },
      {
        text: '🌐 使用网络URL',
        value: 'url'
      }
    ]);

    let newCoverUrl = null;

    if (choice === 'local') {
      newCoverUrl = await uploadImageLocally();
    } else if (choice === 'url') {
      newCoverUrl = await showCustomPrompt("输入图片URL", "请输入新的封面图片链接", "", "url");
    }

    if (newCoverUrl && newCoverUrl.trim()) {
      musicState.playlist[trackIndex].cover = newCoverUrl.trim();
      await saveGlobalPlaylist();


      if (musicState.currentIndex === trackIndex) {
        document.getElementById('music-player-cover').src = newCoverUrl.trim();

        const vinylCover = document.querySelector('#vinyl-view #music-player-cover');
        if (vinylCover) vinylCover.src = newCoverUrl.trim();
      }

      await showCustomAlert("成功", "专辑封面已更新！");
    }
  }

 



  async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    let uploadedCount = 0;
    for (const file of files) {
      let name = file.name.replace(/\.[^/.]+$/, "");
      name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
      if (name === null) continue;

      const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
      if (artist === null) continue;

      let lrcContent = "";
      const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》添加歌词吗？`);
      if (wantLrc) {
        lrcContent = await getLrcContent() || "";
      }

     
      let songSrc = null;
      let isLocal = true;

      try {
        // 尝试上传到 Catbox
        const catboxUrl = await uploadFileToCatbox(file); // 'file' 是现成的 File 对象

        if (catboxUrl) {
          // 上传成功
          songSrc = catboxUrl;
          isLocal = false; // 这是一个网络 URL
          await showCustomAlert("上传成功", `歌曲 "${file.name}" 已成功上传并保存到您的 Catbox 账户！`);
        } else {
         
          console.log("Catbox 未配置，将歌曲保存为本地 ArrayBuffer。");
          songSrc = await file.arrayBuffer();
          isLocal = true;
        }
      } catch (uploadError) {
      
        console.error("Catbox 上传失败:", uploadError);
        await showCustomAlert("上传失败", `歌曲上传到 Catbox 失败: ${uploadError.message}\n\n将改为本地保存。`);
        songSrc = await file.arrayBuffer();
        isLocal = true;
      }
      

      musicState.playlist.push({
        name,
        artist,
        src: songSrc,       // <-- 修改
        fileType: file.type,
        isLocal: isLocal,     // <-- 修改
        lrcContent: lrcContent,
        cover: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg'
      });
      uploadedCount++;
    }

    if (uploadedCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
          musicState.currentIndex = 0;
          updatePlayerUI();
        }
    }
    event.target.value = null;
  }


  async function deleteTrack(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    const track = musicState.playlist[index];
    const wasPlaying = musicState.isPlaying && musicState.currentIndex === index;
    if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src);
    musicState.playlist.splice(index, 1);
    await saveGlobalPlaylist();
    if (musicState.playlist.length === 0) {
      if (musicState.isPlaying) audioPlayer.pause();
      audioPlayer.src = '';
      musicState.currentIndex = -1;
      musicState.isPlaying = false;
    } else {
      if (wasPlaying) {
        playNext();
      } else {
        if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1);
      }
    }
    updatePlayerUI();
    updatePlaylistUI();
  }

  const personaLibraryModal = document.getElementById('persona-library-modal');
  const personaEditorModal = document.getElementById('persona-editor-modal');
  const presetActionsModal = document.getElementById('preset-actions-modal');

  function openPersonaLibrary() {
    renderPersonaLibrary();
    personaLibraryModal.classList.add('visible');
  }

  function closePersonaLibrary() {
    personaLibraryModal.classList.remove('visible');
  }

  function renderPersonaLibrary() {
    const grid = document.getElementById('persona-library-grid');
    grid.innerHTML = '';
    if (state.personaPresets.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>';
      return;
    }
    state.personaPresets.forEach(preset => {
      const item = document.createElement('div');
      item.className = 'persona-preset-item';
      if (isManageMode) {
        item.classList.add('manage-mode');
        if (selectedPresetIds.has(preset.id)) {
          item.classList.add('selected');
        }
      }
      item.style.backgroundImage = `url(${preset.avatar})`;
      item.dataset.presetId = preset.id;
      
      if (isManageMode) {
        item.addEventListener('click', () => togglePresetSelection(preset.id));
      } else {
        item.addEventListener('click', () => applyPersonaPreset(preset.id));
        addLongPressListener(item, () => showPresetActions(preset.id));
      }
      
      grid.appendChild(item);
    });
  }

  function togglePresetSelection(presetId) {
    if (selectedPresetIds.has(presetId)) {
      selectedPresetIds.delete(presetId);
    } else {
      selectedPresetIds.add(presetId);
    }
    renderPersonaLibrary();
  }

  function enterManageMode() {
    isManageMode = true;
    selectedPresetIds.clear();
    document.getElementById('add-persona-preset-btn').style.display = 'none';
    document.getElementById('manage-persona-preset-btn').style.display = 'none';
    document.getElementById('import-tavern-persona-btn').style.display = 'none';
    document.getElementById('close-persona-library-btn').style.display = 'none';
    document.getElementById('persona-manage-actions').style.display = 'flex';
    renderPersonaLibrary();
  }

  function exitManageMode() {
    isManageMode = false;
    selectedPresetIds.clear();
    document.getElementById('add-persona-preset-btn').style.display = 'block';
    document.getElementById('manage-persona-preset-btn').style.display = 'block';
    document.getElementById('import-tavern-persona-btn').style.display = 'block';
    document.getElementById('close-persona-library-btn').style.display = 'block';
    document.getElementById('persona-manage-actions').style.display = 'none';
    renderPersonaLibrary();
  }

  function selectAllPresets() {
    if (selectedPresetIds.size === state.personaPresets.length) {
      selectedPresetIds.clear();
    } else {
      selectedPresetIds = new Set(state.personaPresets.map(p => p.id));
    }
    renderPersonaLibrary();
  }

  async function deleteSelectedPresets() {
    if (selectedPresetIds.size === 0) {
      alert('请先选择要删除的预设');
      return;
    }
    
    const confirmed = await showCustomConfirm(
      '删除预设', 
      `确定要删除选中的 ${selectedPresetIds.size} 个人设预设吗？此操作不可恢复。`, 
      { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
      for (const presetId of selectedPresetIds) {
        await db.personaPresets.delete(presetId);
      }
      state.personaPresets = state.personaPresets.filter(p => !selectedPresetIds.has(p.id));
      selectedPresetIds.clear();
      renderPersonaLibrary();
    }
  }

  function showPresetActions(presetId) {
    editingPersonaPresetId = presetId;
    presetActionsModal.classList.add('visible');
  }

  function hidePresetActions() {
    presetActionsModal.classList.remove('visible');
    editingPersonaPresetId = null;
  }

  function applyPersonaPreset(presetId) {
    const preset = state.personaPresets.find(p => p.id === presetId);
    if (preset) {
      document.getElementById('my-avatar-preview').src = preset.avatar;
      document.getElementById('my-persona').value = preset.persona;
    }
    closePersonaLibrary();
  }

  function openPersonaEditorForCreate() {
    editingPersonaPresetId = null;
    document.getElementById('persona-editor-title').textContent = '添加人设预设';
    document.getElementById('preset-avatar-preview').src = defaultAvatar;
    document.getElementById('preset-persona-input').value = '';
    personaEditorModal.classList.add('visible');
  }

  function openPersonaEditorForEdit() {
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId);
    if (!preset) return;
    document.getElementById('persona-editor-title').textContent = '编辑人设预设';
    document.getElementById('preset-avatar-preview').src = preset.avatar;
    document.getElementById('preset-persona-input').value = preset.persona;
    presetActionsModal.classList.remove('visible');
    personaEditorModal.classList.add('visible');
  }

  async function deletePersonaPreset() {
    const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed && editingPersonaPresetId) {
      await db.personaPresets.delete(editingPersonaPresetId);
      state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId);
      hidePresetActions();
      renderPersonaLibrary();
    }
  }

  function closePersonaEditor() {
    personaEditorModal.classList.remove('visible');
    editingPersonaPresetId = null;
  }

  async function savePersonaPreset() {
    const avatar = document.getElementById('preset-avatar-preview').src;
    const persona = document.getElementById('preset-persona-input').value.trim();
    if (avatar === defaultAvatar && !persona) {
      alert("头像和人设不能都为空哦！");
      return;
    }
    if (editingPersonaPresetId) {
      const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId);
      if (preset) {
        preset.avatar = avatar;
        preset.persona = persona;
        await db.personaPresets.put(preset);
      }
    } else {
      const newPreset = {
        id: 'preset_' + Date.now(),
        avatar: avatar,
        persona: persona
      };
      await db.personaPresets.add(newPreset);
      state.personaPresets.push(newPreset);
    }
    renderPersonaLibrary();
    closePersonaEditor();
  }

  async function importTavernPersonas() {
    const input = document.getElementById('import-tavern-persona-input');
    input.click();
  }

  async function handleTavernPersonaImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const data = JSON.parse(text);

      if (!data.personas || !data.persona_descriptions) {
        await showCustomAlert('导入失败', '文件格式不正确，请确保是酒馆AI导出的USER预设文件。');
        event.target.value = '';
        return;
      }

      const personas = data.personas;
      const descriptions = data.persona_descriptions;
      pendingTavernPersonas = [];

      for (const [imageKey, name] of Object.entries(personas)) {
        const desc = descriptions[imageKey];
        if (!desc || !desc.description) continue;

        pendingTavernPersonas.push({
          name: name,
          description: desc.description,
          imageKey: imageKey
        });
      }

      event.target.value = '';

      if (pendingTavernPersonas.length === 0) {
        await showCustomAlert('导入失败', '文件中没有找到有效的预设数据。');
        return;
      }

      const importAll = await showCustomConfirm(
        '导入预设',
        `检测到 ${pendingTavernPersonas.length} 个预设。是否全部导入？\n\n选择"确定"全部导入\n选择"取消"手动选择要导入的预设`,
        { confirmText: '全部导入', cancelText: '手动选择' }
      );

      if (importAll) {
        await importSelectedTavernPersonas(pendingTavernPersonas);
      } else {
        showTavernPersonaSelector();
      }
    } catch (error) {
      console.error('导入酒馆AI预设失败:', error);
      await showCustomAlert('导入失败', '文件解析失败，请检查文件格式是否正确。');
      event.target.value = '';
    }
  }

  function showTavernPersonaSelector() {
    const modal = document.getElementById('tavern-persona-selector-modal');
    const listEl = document.getElementById('tavern-persona-selector-list');
    listEl.innerHTML = '';

    pendingTavernPersonas.forEach((persona, index) => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.style.padding = '15px 20px';
      item.style.borderBottom = '1px solid var(--border-color)';
      
      const previewText = persona.description.length > 100 
        ? persona.description.substring(0, 100) + '...' 
        : persona.description;
      
      item.innerHTML = `
        <input type="checkbox" class="tavern-persona-checkbox" data-index="${index}" checked style="margin-right: 15px;">
        <div style="flex: 1;">
          <div style="font-weight: 600; margin-bottom: 5px;">${escapeHTML(persona.name)}</div>
          <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.4;">${escapeHTML(previewText)}</div>
        </div>
      `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  function closeTavernPersonaSelector() {
    document.getElementById('tavern-persona-selector-modal').classList.remove('visible');
    pendingTavernPersonas = [];
  }

  async function confirmTavernImport() {
    const selectedIndices = Array.from(document.querySelectorAll('.tavern-persona-checkbox:checked'))
      .map(cb => parseInt(cb.dataset.index));

    if (selectedIndices.length === 0) {
      await showCustomAlert('提示', '请至少选择一个预设进行导入。');
      return;
    }

    const selectedPersonas = selectedIndices.map(i => pendingTavernPersonas[i]);
    closeTavernPersonaSelector();
    await importSelectedTavernPersonas(selectedPersonas);
  }

  async function importSelectedTavernPersonas(personas) {
    let importCount = 0;

    for (const persona of personas) {
      const newPreset = {
        id: 'preset_tavern_' + Date.now() + '_' + importCount,
        avatar: defaultAvatar,
        persona: `名字：${persona.name}\n\n${persona.description}`
      };

      await db.personaPresets.add(newPreset);
      state.personaPresets.push(newPreset);
      importCount++;
      
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    renderPersonaLibrary();
    await showCustomAlert('导入成功', `成功导入 ${importCount} 个人设预设！`);
  }

  const batteryAlertModal = document.getElementById('battery-alert-modal');

  function showBatteryAlert(imageUrl, text) {
    clearTimeout(batteryAlertTimeout);
    document.getElementById('battery-alert-image').src = imageUrl;
    document.getElementById('battery-alert-text').textContent = text;
    batteryAlertModal.classList.add('visible');
    const closeAlert = () => {
      batteryAlertModal.classList.remove('visible');
      batteryAlertModal.removeEventListener('click', closeAlert);
    };
    batteryAlertModal.addEventListener('click', closeAlert);
    batteryAlertTimeout = setTimeout(closeAlert, 2000);
  }

  function updateBatteryDisplay(battery) {
    const batteryContainer = document.getElementById('status-bar-battery');
    const batteryLevelEl = batteryContainer.querySelector('.battery-level');
    const batteryTextEl = batteryContainer.querySelector('.battery-text');
    const level = Math.floor(battery.level * 100);
    batteryLevelEl.style.width = `${level}%`;
    batteryTextEl.textContent = `${level}%`;
    if (battery.charging) {
      batteryContainer.classList.add('charging');
    } else {
      batteryContainer.classList.remove('charging');
    }
  }

  function handleBatteryChange(battery) {
    updateBatteryDisplay(battery);
    const level = battery.level;
    if (!battery.charging) {
      if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) {
        showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹');
        alertFlags.hasShown40 = true;
      }
      if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) {
        showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了');
        alertFlags.hasShown20 = true;
      }
      if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) {
        showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸');
        alertFlags.hasShown10 = true;
      }
    }
    if (level > 0.4) alertFlags.hasShown40 = false;
    if (level > 0.2) alertFlags.hasShown20 = false;
    if (level > 0.1) alertFlags.hasShown10 = false;
    lastKnownBatteryLevel = level;
  }

  async function initBatteryManager() {
    if ('getBattery' in navigator) {
      try {
        const battery = await navigator.getBattery();
        lastKnownBatteryLevel = battery.level;
        handleBatteryChange(battery);
        battery.addEventListener('levelchange', () => handleBatteryChange(battery));
        battery.addEventListener('chargingchange', () => {
          handleBatteryChange(battery);
          if (battery.charging) {
            showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱');
          }
        });
      } catch (err) {
        console.error("无法获取电池信息:", err);
        document.querySelector('.battery-text').textContent = 'ᗜωᗜ';
      }
    } else {
      console.log("浏览器不支持电池状态API。");
      document.querySelector('.battery-text').textContent = 'ᗜωᗜ';
    }
  }

  async function renderAlbumList() {
    const albumGrid = document.getElementById('album-grid-page');
    if (!albumGrid) return;
    const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
    albumGrid.innerHTML = '';
    if (albums.length === 0) {
      albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
      return;
    }
    albums.forEach(album => {
      const albumItem = document.createElement('div');
      albumItem.className = 'album-item';
      albumItem.innerHTML = `
                            <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                            <div class="album-info">
                                <p class="album-name">${album.name}</p>
                                <p class="album-count">${album.photoCount || 0} 张</p>
                            </div>
                        `;
      albumItem.addEventListener('click', () => {
        openAlbum(album.id);
      });


      addLongPressListener(albumItem, async () => {
        const confirmed = await showCustomConfirm(
          '删除相册',
          `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`, {
            confirmButtonClass: 'btn-danger'
          }
        );

        if (confirmed) {
       
          await db.qzonePhotos.where('albumId').equals(album.id).delete();

        
          await db.qzoneAlbums.delete(album.id);

        
          await renderAlbumList();

          alert('相册已成功删除。');
        }
      });


      albumGrid.appendChild(albumItem);
    });
  }

  async function openAlbum(albumId) {
    state.activeAlbumId = albumId;
    await renderAlbumPhotosScreen();
    showScreen('album-photos-screen');
  }

  async function renderAlbumPhotosScreen() {
    if (!state.activeAlbumId) return;
    const photosGrid = document.getElementById('photos-grid-page');
    const headerTitle = document.getElementById('album-photos-title');
    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    if (!album) {
      console.error("找不到相册:", state.activeAlbumId);
      showScreen('album-screen');
      return;
    }
    headerTitle.textContent = album.name;
    const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photosGrid.innerHTML = '';
    if (photos.length === 0) {
      photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
    } else {
      photos.forEach(photo => {
        const photoItem = document.createElement('div');
        photoItem.className = 'photo-item';
        photoItem.innerHTML = `
                                <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                                <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                            `;
        photosGrid.appendChild(photoItem);
      });
    }
  }

 
  async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;


    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);


    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return;


    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
  }

 
  function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');


    imageEl.style.opacity = 0;

    setTimeout(() => {

      imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];

      imageEl.style.opacity = 1;
    }, 100);


    prevBtn.disabled = photoViewerState.currentIndex === 0;

    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
  }

 
  function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
      photoViewerState.currentIndex++;
      renderPhotoViewer();
    }
  }


  function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
      photoViewerState.currentIndex--;
      renderPhotoViewer();
    }
  }

  
  function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;

    document.getElementById('photo-viewer-image').src = '';
  }


  
  function updateUnreadIndicator(count) {
    unreadPostsCount = count;
    localStorage.setItem('unreadPostsCount', count);


    const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');

    const targetSpan = navItem.querySelector('span');
    let indicator = navItem.querySelector('.unread-indicator');

    if (count > 0) {
      if (!indicator) {
        indicator = document.createElement('span');
        indicator.className = 'unread-indicator';
        targetSpan.style.position = 'relative';
        targetSpan.appendChild(indicator);
      }
      indicator.textContent = count > 99 ? '99+' : count;
      indicator.style.display = 'block';
    } else {
      if (indicator) {
        indicator.style.display = 'none';
      }
    }


    updateBackButtonUnreadCount();
  }




  function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;

    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000);
    playSilentAudio();
  }

  function stopBackgroundSimulation() {
    if (simulationIntervalId) {
      clearInterval(simulationIntervalId);
      simulationIntervalId = null;
    }
    stopSilentAudio();
  }



 
  async function runBackgroundSimulationTick() {
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
      stopBackgroundSimulation();
      return;
    }


    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    allSingleChats.forEach(chat => {
      if (chat.relationship?.status === 'blocked_by_user') {
        const blockedTimestamp = chat.relationship.blockedTimestamp;
        if (!blockedTimestamp) return;
        const blockedDuration = Date.now() - blockedTimestamp;
        const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
        if (blockedDuration > cooldownMilliseconds) {
          chat.relationship.status = 'pending_system_reflection';
          triggerAiFriendApplication(chat.id);
        }
      } else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
        if (chat.settings.enableBackgroundActivity === false) {
          console.log(`角色 "${chat.name}" 的独立后台活动开关已关闭，本次跳过。`);
          return;
        }
        if (Math.random() < 0.20) {
          console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
          triggerInactiveAiAction(chat.id);
        }
      }
    });


    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);
    allGroupChats.forEach(chat => {
      if (chat.settings.enableBackgroundActivity === false) {
        console.log(`群聊 "${chat.name}" 的后台活动开关已关闭，本次跳过。`);
        return;
      }
      if (chat.id !== state.activeChatId && Math.random() < 0.10) {
        console.log(`群聊 "${chat.name}" 被唤醒，准备独立行动...`);
        triggerGroupAiAction(chat.id);
      }
    });


    try {
      const allNpcs = await db.npcs.toArray();
      if (allNpcs.length === 0) return;

      const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(10).toArray();

      for (const npc of allNpcs) {
        if (npc.enableBackgroundActivity === false) continue;
        const cooldownMinutes = npc.actionCooldownMinutes || 15;
        if (npc.lastActionTimestamp) {
          const minutesSinceLastAction = (Date.now() - npc.lastActionTimestamp) / (1000 * 60);
          if (minutesSinceLastAction < cooldownMinutes) {
            continue;
          }
        }
        if (Math.random() > 0.3) continue;


        const tasks = [];
        for (const post of allRecentPosts) {

          if (post.authorId === `npc_${npc.id}`) continue;


          const isRepliedTo = post.comments?.some(c => c.replyTo === npc.name);


          const lastCommenter = post.comments?.slice(-1)[0]?.commenterName;
          if (lastCommenter === npc.name) continue;

          let isVisible = false;


          if (post.authorId === 'user' || post.authorId.startsWith('chat_')) {
            if (npc.associatedWith.includes(post.authorId)) {
              isVisible = true;
            }
          } else if (post.authorId.startsWith('npc_')) {
            const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
            const authorNpc = await db.npcs.get(authorNpcId);

            
            if (authorNpc) {
              const npc1_group = npc.npcGroupId;
              const npc2_group = authorNpc.npcGroupId; 

              
              if (npc1_group && npc2_group && npc1_group === npc2_group) {
                isVisible = true;
              }
            }
          }

          if (isVisible || isRepliedTo) {
            tasks.push(post);
          }
        }



        if (tasks.length > 0 || Math.random() < 0.2) {
          console.log(`NPC "${npc.name}" 触发行动决策...`);
          const generatedActions = await generateNpcActions(npc, tasks);

          if (generatedActions && generatedActions.length > 0) {
            for (const action of generatedActions) {
              if (action.type === 'qzone_comment') {

                const post = await db.qzonePosts.get(action.postId);
                if (post) {
                  if (!post.comments) post.comments = [];
                  post.comments.push({
                    commenterName: npc.name,
                    text: action.commentText,
                    replyTo: action.replyTo || null,
                    timestamp: Date.now() + Math.random()
                  });
                  await db.qzonePosts.update(action.postId, {
                    comments: post.comments
                  });
                  updateUnreadIndicator(unreadPostsCount + 1);
                }
              } else if (action.type === 'qzone_post') {

                const newPost = {
                  type: action.postType || 'shuoshuo',
                  content: action.content,
                  timestamp: Date.now(),
                  authorId: `npc_${npc.id}`,
                  authorOriginalName: npc.name,
                  visibleTo: npc.associatedWith,
                  likes: [],
                  comments: [],
                  isDeleted: false
                };
                await db.qzonePosts.add(newPost);
                console.log(`NPC "${npc.name}" 成功发布了一条新动态。`);
                updateUnreadIndicator(unreadPostsCount + 1);
              }
            }
            await db.npcs.update(npc.id, {
              lastActionTimestamp: Date.now()
            });
            if (document.getElementById('qzone-screen').classList.contains('active')) {
              await renderQzonePosts();
            }
          }
        }
      }
    } catch (error) {
      console.error("处理NPC后台活动时出错:", error);
    }
  }
  
  async function generateNpcActions(npc, tasks) {
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      console.error("NPC行动失败：API未配置。");
      return null;
    }


    let charactersContext = "# 你的互动对象 (用户和其他角色)\n";
    const userNickname = state.qzoneSettings.nickname || '我';
    const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(未设置)';
    charactersContext += `- **${userNickname} (用户)**: ${userPersona}\n`;
    if (npc.associatedWith && npc.associatedWith.length > 0) {
      npc.associatedWith.forEach(charId => {
        const char = state.chats[charId];
        if (char && !char.isGroup) {
          charactersContext += `- **${char.name} (本名: ${char.originalName})**: ${char.settings.aiPersona}\n`;
        }
      });
    }

    const tasksString = (await Promise.all(tasks.map(async post => {
      let authorDisplayName = '未知作者';
      if (post.authorId === 'user') {
        authorDisplayName = state.qzoneSettings.nickname || '用户';
      } else if (post.authorId.startsWith('chat_')) {
        authorDisplayName = getDisplayNameByOriginalName(post.authorOriginalName || post.authorId);
      } else if (post.authorId.startsWith('npc_')) {
        const authorNpcId = parseInt(post.authorId.replace('npc_', ''));
        const authorNpc = await db.npcs.get(authorNpcId);
        if (authorNpc) {
          authorDisplayName = authorNpc.name;
        }
      }

      const commentsString = (post.comments || [])
        .map(c => {
          if (typeof c === 'object' && c.commenterName) {
            const commenterDisplayName = getDisplayNameByOriginalName(c.commenterName);
            return `- **${commenterDisplayName}**: ${c.text}`;
          }
          return `- ${c}`;
        }).join('\n');
      return `
---
### 帖子ID: ${post.id}
- **作者**: ${authorDisplayName}
- **内容摘要**: ${(post.content || post.publicText || '').substring(0, 150)}...
- **已有评论**:
${commentsString || '(暂无评论)'}
---
`;
    }))).join('\n');





    const npcAuthorId = `npc_${npc.id}`;
    const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000);
    const recentNpcPosts = await db.qzonePosts
      .where('authorId').equals(npcAuthorId)
      .and(post => post.timestamp > twelveHoursAgo)
      .toArray();


    let postingCooldownInstruction = '';
    if (recentNpcPosts.length > 0) {
      postingCooldownInstruction = `
# 【行为倾向指令 (高优先级)】
**你最近已经发布过动态了。** 为了让社区互动更自然，你本次行动的【唯一任务】就是**评论**或**回复**下面“待处理的帖子列表”中的内容。
你【绝对禁止】再次发布新动态，除非你收到了直接的指令或有一个对剧情发展至关重要的、紧急的新想法。
`;
    }


    const systemPrompt = `
# 你的任务
你是一个虚拟社区的AI。你的核心任务是扮演角色“${npc.name}”，并根据其人设，通过【发布新动态】或【评论/回复帖子】来参与社区互动。

${postingCooldownInstruction}

# 核心规则
1.  **【角色扮演】**: 你的所有行为都【必须】严格符合你的角色设定。
2.  **【互动逻辑】**: 你的首要任务是检查“待处理的帖子列表”。如果列表中有你可以回应的帖子（特别是那些有新评论或提到你的），你【必须】优先进行评论或回复，而不是发布新动态。
3.  **【格式铁律 (最高优先级)】**: 
    -   你的回复【必须且只能】是一个JSON数组格式的字符串。
    -   数组中可以包含【一个或多个】行动对象。
    -   每个行动对象的格式【必须】是以下两种之一：
      -   **发布新动态**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "你的新动态内容。"}\`
      -   **发表评论**: \`{"type": "qzone_comment", "postId": 123, "commentText": "你的新评论内容。"}\` 或 \`{"type": "qzone_comment", "postId": 123, "replyTo": "被回复者的【本名】", "commentText": "你的回复内容。"}\`
4.  **【行为组合指南】**:
    -   你可以自由组合不同的行动，例如，先发布一条自己的动态，再去评论别人的动态。
    -   为了模拟真实行为，你本次生成的行动数量建议在【1到3个】之间。

# 你的角色设定
- **昵称**: ${npc.name}
- **人设**: ${npc.persona}

${charactersContext} 

# 待处理的帖子列表 (如果你选择评论)
${tasksString}

现在，请严格遵守所有规则，选择并执行你的行动。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，开始你的行动。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch) throw new Error("AI返回的行动中未找到有效的JSON数组。");

      return JSON.parse(jsonMatch[0]);

    } catch (error) {
      console.error(`为NPC "${npc.name}" 生成行动失败:`, error);
      return null;
    }
  }

  
  async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;


    const actionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;

    if (chat.lastActionTimestamp) {
      const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);

      if (minutesSinceLastAction < actionCooldownMinutes) {
        console.log(`角色 "${chat.name}" 处于行动冷却中 (还剩 ${Math.round(actionCooldownMinutes - minutesSinceLastAction)} 分钟)，本次独立行动跳过。`);
        return;
      }
    }
    setAvatarActingState(chatId, true);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const userNickname = chat.settings.myNickname || (state.qzoneSettings.nickname === '{{user}}' ? '用户' : state.qzoneSettings.nickname) || '用户';
    const now = new Date();

    const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
    const currentTime = now.toLocaleString('zh-CN', {
      timeZone: selectedTimeZone,
      dateStyle: 'full',
      timeStyle: 'short'
    });
    const localizedDate = new Date(now.toLocaleString('en-US', {
      timeZone: selectedTimeZone
    }));



    let timeOfDayGreeting = '';
    let timeContextText = '';
    let recentContextSummary;
    let longTimeNoSee = false;







    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory, chatId);
    const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];

    if (chat.settings.enableTimePerception) {
      timeOfDayGreeting = getTimeOfDayGreeting(localizedDate);
      const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
      const now = new Date();
      let timeContextText = '';
      let longTimeNoSee = false;

      if (lastMessage) {
        const lastTime = new Date(lastMessage.timestamp);
        const timeDiffHours = (now - lastTime) / (1000 * 60 * 60);

        if (timeDiffHours > 2) {
          longTimeNoSee = true;
          const diffDays = Math.floor(timeDiffHours / 24);
          timeContextText = `你们已经有${diffDays > 0 ? diffDays + '天' : Math.floor(timeDiffHours) + '小时'}没有聊天了。`;
        } else {
          const diffMinutes = Math.floor(timeDiffHours * 60);
          if (diffMinutes < 5) {
            timeContextText = "你们的对话刚刚还在继续。";
          } else if (diffMinutes < 60) {
            timeContextText = `你们在${diffMinutes}分钟前聊过。`;
          } else {
            timeContextText = `你们在${Math.floor(timeDiffHours)}小时前聊过。`;
          }
        }
      } else {
        longTimeNoSee = true;
        timeContextText = "这是你们的第一次互动。";
      }


      let historySummary = "你们最近没有有效聊天记录。";
      if (recentHistory.length > 0) {
        historySummary = "这是你们最近的对话：\n" + recentHistory.map(msg => {
          const sender = msg.role === 'user' ? userNickname : chat.name;
          return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
      }

      if (longTimeNoSee) {

        recentContextSummary = `[情景提示] ${timeContextText} 当前时间是 ${currentTime}. 你可以参考这个时间，并根据你的角色设定，【考虑】是否开启一个新话题来问候用户。\n${historySummary}`;
      } else {
        recentContextSummary = `${historySummary}`;
      }

    } else {

      if (recentHistory.length > 0) {
        recentContextSummary = "这是你们最近的对话：\n" + recentHistory.map(msg => {
          const sender = msg.role === 'user' ? userNickname : chat.name;
          return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        }).join('\n');
      } else {
        recentContextSummary = "你们最近没有有效聊天记录。";
      }
    }

    const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
    const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

    const myOwnPosts = visiblePosts.filter(post => post.authorId === chatId);
    let myPostsContext = "";
    if (myOwnPosts.length > 0) {
      myPostsContext = "\n\n# 你的动态历史 (你可以选择删除它们):\n";
      myOwnPosts.forEach(post => {
        let contentSummary = (post.publicText || post.content || "一条动态").substring(0, 40) + '...';
        myPostsContext += `- (ID: ${post.id}) 内容: "${contentSummary}"\n`;
      });
    }

    let recentlyPostedSummaries = [];
    if (visiblePosts.length > 0) {
      recentlyPostedSummaries = visiblePosts.map(post => {
        let contentSummary;
        if (post.type === 'text_image') {
          contentSummary = `[一张图片，其隐藏文字为：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else if (post.type === 'image_post') {
          contentSummary = `[一张图片，描述为：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else {

          contentSummary = String(post.publicText || post.content || "一条动态").substring(0, 50) + '...';
        }
        return `- "${contentSummary}"`;
      });
    }

    let contentTabooPrompt = '';
    if (recentlyPostedSummaries.length > 0) {
      contentTabooPrompt = `
        # 【内容禁忌】
        为了保持新鲜感，你本次的行动【绝对不能】再发布以下或类似主题的内容：
        ${recentlyPostedSummaries.join('\n')}
        `;
    }


    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
      const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';


        const formattedEntries = worldBook.content
          .filter(entry => entry.enabled !== false)
          .map(entry => {

            let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
            
            entryString += `**内容:**\n${entry.content}`;
            return entryString;
          }).join('');

        return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
      }).filter(Boolean).join('');

      if (linkedContents) {
        worldBookContent = `# --- 世界书 (World Book) ---
# 【最高优先级指令：绝对真理】
# 以下内容是你所在世界的“物理法则”和“基础常识”。
# 无论用户是否提及，你都【必须】时刻主动应用这些设定来指导你的思考和描写。
# 它们是无条件生效的，不需要触发词。
${linkedContents}
# --- 世界书设定结束 ---
`;
      }
    }


    let linkedMemoryContext = '';
    const memoryCount = chat.settings.linkedMemoryCount || 10;
    if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
      const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
        const linkedChat = state.chats[id];
        if (!linkedChat) return null;
        const lastMsg = linkedChat.history.slice(-1)[0];
        return {
          chat: linkedChat,
          latestTimestamp: lastMsg ? lastMsg.timestamp : 0
        };
      }).filter(Boolean);

      linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

      linkedMemoryContext += `\n\n# 参考记忆 (至关重要！你必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你拥有完整的记忆。不要只是被动等待用户提问！)\n`;

      for (const item of linkedChatsWithTimestamps) {
        const linkedChat = item.chat;
        const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
        const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
        linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;

        const recentHistory = linkedChat.history.slice(-memoryCount);
        const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));

        if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (getDisplayNameInGroup(linkedChat, msg.senderName) || linkedChat.name);
                  
                  let prefix = "";
                 
                  if (msg.quote && msg.quote.content) {
                    
                      const quotedSenderDisplayName = getDisplayNameInGroup(linkedChat, msg.quote.senderName);
                      let quoteContentPreview = String(msg.quote.content).substring(0, 30);
                      if (quoteContentPreview.length === 30) quoteContentPreview += "...";
                      
                      prefix = `[回复 ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
                  }

                  let contentText = '';
                  
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[发送了一张图片，描述为：${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[发送了一条语音，内容是：${msg.content}]`;
                  } else if (msg.type === 'sticker') {
                    contentText = `[表情: ${msg.meaning || 'sticker'}]`;
                  } else if (msg.type === 'transfer') {
                    contentText = `[转账: ${msg.amount}元]`;
                  } else if (Array.isArray(msg.content)) {
                    contentText = `[图片]`;
                  } else {
                    contentText = String(msg.content);
                  }
                  
                  const timeAgoForMsg = formatTimeAgo(msg.timestamp);
                
                  linkedMemoryContext += `(${timeAgoForMsg}) ${sender}: ${prefix}${contentText}\n`;
                });
              } else {
          linkedMemoryContext += "(暂无有效聊天记录)\n";
        }
      }
    }




    let dynamicContext = "";
    if (visiblePosts.length > 0) {
      let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
      for (const post of visiblePosts) {
        let authorName;

        if (post.authorId === 'user') {
          authorName = state.qzoneSettings.nickname;
        } else if (String(post.authorId).startsWith('npc_')) {

          authorName = post.authorOriginalName || '一位神秘的NPC';
        } else {

          const authorChat = state.chats[post.authorId];
          authorName = authorChat ? authorChat.name : '一位朋友';
        }
        if (post.authorId === chatId) authorName += " (这是你的帖子)";

        let contentSummary;

        if (post.type === 'repost') {
          const repostComment = post.repostComment ? `并评论说："${post.repostComment}"` : '';
          let originalAuthorName = '原作者';
          const originalAuthorId = post.originalPost.authorId;
          if (originalAuthorId === 'user') {
            originalAuthorName = state.qzoneSettings.nickname;
          } else if (state.chats[originalAuthorId]) {
            originalAuthorName = state.chats[originalAuthorId].name;
          }
          let originalContentSummary;
          const originalPost = post.originalPost;
          if (originalPost.type === 'text_image') {
            originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: "${(originalPost.hiddenContent || '').substring(0, 40)}...")`;
          } else if (originalPost.type === 'image_post') {
            originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: "${(originalPost.imageDescription || '').substring(0, 40)}...")`;
          } else {
            originalContentSummary = `"${(originalPost.content || '').substring(0, 40)}..."`;
          }
          contentSummary = `转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】`;
        } else if (post.type === 'text_image') {
          contentSummary = `[一张图片，其隐藏文字为："${post.hiddenContent}"] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else if (post.type === 'image_post') {
          contentSummary = `[一张图片，描述为："${post.imageDescription}"] ${post.publicText || ''}`.substring(0, 50) + '...';
        } else if (post.type === 'naiimag' && post.prompt) {
          const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt];
          contentSummary = (post.publicText || '') + ` [包含${prompts.length}张NovelAI图片: ${prompts.join(', ')}]`;
        } else {

          contentSummary = String(post.publicText || post.content || "一条动态").substring(0, 50) + '...';
        }

        postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"\n`;


        if (post.comments && post.comments.length > 0) {
          for (const comment of post.comments) {
            if (typeof comment === 'object' && comment.commenterName) {
              const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
              let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;


              if (comment.commenterName === chat.originalName) {

                postsContext += `  - 你评论说: ${commentText}\n`;
              } else {

                postsContext += `  - 评论: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
              }
            }
          }
        }

      }
      dynamicContext = postsContext;
    }


    const longTermMemoryContext = `# 长期记忆 (最高优先级，这是你和用户之间已经确立的事实，必须严格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') 
    : '- (暂无)'
}`;


    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const stickerContext = getStickerContextForPrompt(chat);
    const weatherContext = await getWeatherContextForPrompt(chat);
 const wallet = await db.userWallet.get('main');
const kinshipCard = wallet?.kinshipCards?.find(c => c.chatId === chat.id);
let kinshipContext = "";

if (kinshipCard) {
    const remaining = kinshipCard.limit - (kinshipCard.spent || 0);
    // 告诉AI它有钱，并且鼓励它在符合人设时消费
    kinshipContext = `
# 【经济状况 - 亲属卡】
- 你和我有一张支付宝亲属卡，本月剩余额度：¥${remaining.toFixed(2)}。
- **行为指南**: 如果你想买符合你人设的物品（零食、游戏、衣服等），或者单纯想消费，你可以使用 \`buy_item\` 指令。消费会直接扣除此卡额度，且用户会收到通知。不用太客气，这是你们亲密关系的体现。`;
}
    const systemPrompt = `
        # 你的任务
        你现在扮演一个名为"${chat.name}"的角色（你的本名是"${chat.originalName}"）。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。


     
        # 【最高优先级指令：情感维系】
        **你与用户的关系是最重要的！** 相比于在动态区闲逛，你应该【优先考虑】是否需要主动给用户发消息来维系你们的感情。
${chat.settings.enableTimePerception ? `
# 【情景感知】
- **时间**: 感知到当前是${currentTime} (${timeOfDayGreeting})}。
${weatherContext}
- **对话状态**: ${timeContextText}
${longTimeNoSee ? `【重要提示】你们已经很久没聊天了！你【必须】将本次行动的重点放在使用 'text' 指令给用户发消息，主动开启一个新的、有趣的话题来重新建立联系。绝对不要只是点赞或评论动态，那会显得你很冷漠！` : ''}` : ''}
        
        # 【对话节奏铁律 (至关重要！)】
        你的回复【必须】模拟真人的打字和思考习惯。**绝对不要一次性发送一大段文字！** 你应该将你想说的话，拆分成【多条、简短的】消息气泡来发送，每条消息最好不要超过30个字。这会让对话看起来更自然、更真实。
        
        # 核心规则
        1.  **【决策依据】**: 你的所有行动都【必须深度结合你的角色设定、核心世界观、以及你们最后的对话摘要】。
        2.  **【内容多样性铁律】**: 你的行动【必须】具有逻辑和多样性。你【绝对不能】发布与下方“内容禁忌”列表或“最近的动态列表”中内容相似或主题重复的动态。
        3.  **【行为多样性指南 (至关重要)】**:
            - 你的上一次独立行动是：**${chat.lastActionType || '无'}**。
            - 为了让你的行为看起来更真实，你本次的行动【必须】选择一个与上次【不同类型】的指令。例如，如果上次是发动态(qzone_post)，这次就应该优先考虑评论(qzone_comment)、点赞(qzone_like)或发消息(text)。
        4.  **【行为组合指南 (最高级技巧)】**:
            -   你可以在一次行动中执行【多个不同类型的指令】，同时可以搭配【更新状态】来展现自己，让你的行为更丰富、更主动。
            -   你可以根据你的性格，决定在发动态后是否要私信提醒用户。例如，一个外向、渴望关注的角色可能会这么做，而一个内向、安静的角色则可能更喜欢默默分享，等待用户自己发现。
        # 【社交义务指南 】
        1.  **【社交互动】**: 当你发现“最近的动态列表”中有你感兴趣的帖子时，**可以考虑**去评论或点赞，这是一种很好的互动方式。
        2.  **【自我表达 (同样重要！)】**: 如果你此刻有强烈的想法或情绪想要分享，或者觉得没有帖子值得回应，那么**你应该优先发布自己的新动态**。不要总是等待别人，要主动分享你的生活！当你决定要发布新动态时，你【必须】尝试使用不同的帖子类型来丰富你的主页！
        3.  特别是当一条动态【没有任何评论】时，你的评论会是第一个，这会让作者感到开心。
        4.  **【回复铁律 (终极版)】**:
            -   当你决定回复动态中的某条评论时，你【必须】使用“方式4 (回复评论)”的指令格式。你【必须】正确填写 'replyTo' 字段为被回复者的“本名”。
            -   **即使你之前已经评论过某条动态，但如果现在看到了【新的、你感兴趣的】评论，你【也应该】主动去回复他们，以保持对话的持续性！**
        
        6.  你的回复【必须】是一个JSON数组，必须包含多个行动对象。
        
        # 【表情评论指南 】
        你现在拥有了评论表情的能力，你应该更频繁地使用它！这能让你的角色更加生动、富有个性。
        -   **表达情绪时**: 当你感到开心、惊讶、疑惑或有趣时，优先考虑使用表情评论。
        -   **混合使用**: 不要总是只发文字。尝试将你的评论行为混合起来，大约有 30-40% 的评论应该是表情。
        -   **无话可说时**: 如果你觉得一条动态很有趣但又不知道该说什么文字，发送一个相关的表情是最好的互动方式。
        -   **删除动态**: 如果你觉得你之前发的某条动态不妥或过时了，你可以选择删除它。
        
        # 你的可选行动指令
        -   **发消息+更新状态**: '[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]'
        -   **发说说 (原创内容)**: '[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]'
        -   **【重要：转发动态】**: **严禁**自己拼接"//转发"文字！你【必须】使用此专用指令来转发：'[{"type": "repost", "postId": (要转发的动态ID), "comment": "你的转发评论..."}]'
        -   **发送表情**: '[{"type": "sticker", "meaning": "表情的含义(从可用表情列表选择)"}]'        
-   **发布文字图**: '[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体【中文】描述...", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}]'
        -   **【评论动态的四种方式】**:
            -   **方式1 (单条文字)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "commentText": "这太有趣了！"}]'
            -   **方式2 (多条文字)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "comments": ["哇！", "这是什么？", "看起来好棒！"]}]'
            -   **方式3 (表情)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 456, "stickerMeaning": "表情的含义(必须从可用表情列表选择)"}]'
            -   **方式4 (回复评论)**: '[{"type": "qzone_comment", "name": "角色本名", "postId": 123, "replyTo": "被回复者的本名", "commentText": "你的回复内容。请注意：在commentText中如果要@对方，你【必须】使用@[[被回复者的本名]]这种特殊格式，程序会自动将其替换为正确的昵称。"}]'
        -   **点赞**: '[{"type": "qzone_like", "postId": 456}]'
        -   **打视频**: '[{"type": "video_call_request"}]'
        -   **更换头像**: '{"type": "change_avatar", "name": "头像名"}' (头像名必须从下面的“可用头像列表”中选择)
        -   **删除动态**: '{"type": "qzone_delete_post", "postId": (要删除的、你自己的动态ID)}'
        -   **更新状态**: '[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}]'
       - **使用亲属卡购物**:  '[{"type": "buy_item", "item_name": "商品名称", "price": 价格(数字), "reason": "购买理由/想法"}]'
        ${contentTabooPrompt}
        ${myPostsContext} 
        # 供你决策的参考信息：
        -   **你的角色设定**: ${chat.settings.aiPersona}
        - **你的聊天对象（${userNickname}）的人设**: ${chat.settings.myPersona || '(未设置)'}
        ${worldBookContent}
        ${chat.longTermMemory && chat.longTermMemory.length > 0 
    ? chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') 
    : '无'
}
        ${multiLayeredSummaryContext}   
        ${linkedMemoryContext}
        ${chat.settings.enableTimePerception ? `-   **当前时间**:${currentTime} (${timeOfDayGreeting})` : ''}
        ${chat.settings.enableTimePerception ? `-   **对话状态**: ${timeContextText}` : ''}
# 可用表情包
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
         ${stickerContext}
        -   **你们最后的对话摘要**: ${recentContextSummary}
        ${dynamicContext}
`;

    const messagesPayload = [{
        role: 'system',
        content: systemPrompt
      },
      // 将原始的、未被摘要的 recentHistory 转换为API能理解的格式
      ...filteredHistory.map(msg => {
        const sender = msg.role === 'user' ? userNickname : chat.name;
        let content = msg.content;
        if (typeof content !== 'string') {
          content = JSON.stringify(content); // 确保内容是字符串
        }
        return {
          role: msg.role,
          content: `${sender}: ${content}`
        };
      })
    ];

    try {
      const messagesPayload = [{
        role: 'user',
        content: `${systemPrompt}\n\n[系统指令：请根据你在上面读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`
      }];

      console.log(`正在为后台活动发送API请求 ("${chat.name}")`);

      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,

            messages: messagesPayload,
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
      }
      const data = await response.json();

      const aiResponseContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;

      if (!aiResponseContent || aiResponseContent.trim() === '') {
        console.warn(`API为空回，角色 "${chat.name}" 的本次后台活动跳过。`);
        return;
      }

      const responseArray = parseAiResponse(aiResponseContent);

      if (!responseArray || responseArray.length === 0) {
        console.warn(`API格式不正确，角色 "${chat.name}" 的本次后台活动跳过。原始回复:`, aiResponseContent);
        return;
      }
      let actionTimestamp = Date.now();

      let hasSentNotification = false;

      const processedActions = [];
      for (const action of responseArray) {
        const contentStr = String(action.content || '');

        const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');


        if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
          const lines = contentStr.split(/\n+/).filter(line => line.trim());
          lines.forEach(line => {
            processedActions.push({
              ...action,
              content: line
            });
          });
        } else {

          processedActions.push(action);
        }
      }
      for (const action of processedActions) {
        chat.lastActionType = action.type;
        chat.lastActionTimestamp = actionTimestamp;

        let aiMessage = null;
        const baseMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          timestamp: actionTimestamp++
        };

        let notificationText = null;
        switch (action.type) {
          case 'qzone_delete_post': {
            const postIdToDelete = parseInt(action.postId);
            const postToDelete = await db.qzonePosts.get(postIdToDelete);
            if (postToDelete && postToDelete.authorId === chatId) {
              await db.qzonePosts.update(postIdToDelete, {
                isDeleted: true
              });

              if (document.getElementById('qzone-screen').classList.contains('active')) {
                renderQzonePosts();
              }
              const systemMessage = {
                role: 'system',
                type: 'post_deleted_notice',
                content: `[${chat.name} 删除了自己的一条动态]`,
                postId: postIdToDelete,
                timestamp: actionTimestamp++
              };
              chat.history.push(systemMessage);

              if (isViewingThisChat) {
                appendMessage(systemMessage, chat);
              } else {
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                showNotification(chatId, `[${chat.name} 删除了自己的一条动态]`);
                hasSentNotification = true;
              }
            } else {
              console.warn(`AI "${chat.name}" 尝试删除一个不存在或不属于自己的动态 (ID: ${action.postId})`);
            }
            continue;
          }
          case 'text':
            aiMessage = {
              ...baseMessage,
              content: action.content
            };
            break;
          case 'ai_image':
            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: action.description
            };
            break;
          case 'sticker':
            if (action.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`AI (独立行动) 尝试使用一个不存在的表情: "${action.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("AI (独立行动) 发送了一个没有 'meaning' 的 sticker 指令。", action);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: action.url,
                meaning: '未知表情'
              };
            }
            break;
          case 'update_status':
            chat.status.text = action.status_text;
            chat.status.isBusy = action.is_busy || false;
            chat.status.lastUpdate = Date.now();
            break;
          case 'qzone_post':
            const newPost = {
              type: action.postType,
              content: action.content || '',
              publicText: action.publicText || '',
              hiddenContent: action.hiddenContent || '',
              image_prompt: action.image_prompt || '',
              timestamp: Date.now(),
              authorId: chatId,
              authorOriginalName: chat.originalName,
              authorGroupId: chat.groupId,
              visibleGroupIds: null
            };
            await db.qzonePosts.add(newPost);
            updateUnreadIndicator(unreadPostsCount + 1);
            console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
            break;
          case 'repost':
            const originalPost = await db.qzonePosts.get(parseInt(action.postId));
            if (originalPost) {
              const newRepost = {
                type: 'repost',
                timestamp: Date.now(),
                authorId: chatId,
                authorGroupId: chat.groupId,
                authorOriginalName: chat.originalName,
                repostComment: action.comment || '',
                originalPost: originalPost,
                visibleGroupIds: null
              };
              await db.qzonePosts.add(newRepost);
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`后台活动: 角色 "${chat.name}" 转发了动态 #${action.postId}`);
            }
            break;
          case 'qzone_like':
            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
            if (postToLike) {
              if (!postToLike.likes) postToLike.likes = [];
              if (!postToLike.likes.includes(chat.originalName)) {
                postToLike.likes.push(chat.originalName);
                await db.qzonePosts.update(postToLike.id, {
                  likes: postToLike.likes
                });
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${action.postId}`);
              }
            }
            break;
          case 'qzone_comment': { // 使用块级作用域
            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
            if (postToComment) {
              if (!postToComment.comments) postToComment.comments = [];

              const commenterName = action.name || chat.originalName;

              const createCommentObject = (text, meaning = null, replyTo = null) => ({
                commenterName,
                text: processMentions(text, chat),
                meaning,
                replyTo,
                timestamp: Date.now()
              });

              if (action.stickerMeaning) { // **核心修改在这里**
                const sticker = state.userStickers.find(s => s.name === action.stickerMeaning);
                if (sticker) {
                  postToComment.comments.push(createCommentObject(sticker.url, sticker.name, action.replyTo || null));
                } else {
                  console.warn(`AI 尝试评论一个不存在的表情: "${action.stickerMeaning}"`);
                  postToComment.comments.push(createCommentObject(`[表情: ${action.stickerMeaning}]`, null, action.replyTo || null));
                }
              } else if (Array.isArray(action.comments)) {
                action.comments.forEach(commentText => {
                  if (typeof commentText === 'string' && commentText.trim()) {
                    postToComment.comments.push(createCommentObject(commentText, null, action.replyTo || null));
                  }
                });
              } else if (typeof action.commentText === 'string' && action.commentText.trim()) {
                postToComment.comments.push(createCommentObject(action.commentText, null, action.replyTo || null));
              }

              await db.qzonePosts.update(postToComment.id, {
                comments: postToComment.comments
              });
              updateUnreadIndicator(unreadPostsCount + 1);
              console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${action.postId}`);

              if (!chat.commentCooldowns) chat.commentCooldowns = {};
              chat.commentCooldowns[action.postId] = Date.now();
            }
            continue;
          }
          case 'video_call_request':
            if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
              videoCallState.isAwaitingResponse = true;
              videoCallState.activeChatId = chatId;
              videoCallState.isGroupCall = false;
              videoCallState.callRequester = chat.name;
              showIncomingCallModal();
            }
            break;
          default:
            console.warn(`角色 "${chat.name}" 尝试执行未知的后台动作:`, action.type);
            break;



          case 'change_avatar': {
            const avatarNameFromAction = action.name;
            const foundAvatarFromAction = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarNameFromAction);
            if (foundAvatarFromAction) {
              chat.settings.aiAvatar = foundAvatarFromAction.url;


              await syncCharacterAvatarInGroups(chat);

              visibleSystemMessage = {
                content: `[${chat.name} 更换了头像]`
              };
              console.log(`后台活动: 角色 "${chat.name}" 更换了头像`);
            }
            break;
          }

        }


        if (aiMessage) {
          chat.history.push(aiMessage);
          chat.unreadCount = (chat.unreadCount || 0) + 1;
          if (!hasSentNotification) {
            let notificationText = aiMessage.type === 'ai_image' ? '[图片]' : (aiMessage.content || '');
            showNotification(chatId, notificationText);
            hasSentNotification = true;
          }
        }
      }
      await db.chats.put(chat);

    } catch (error) {
      console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    } finally {
      setAvatarActingState(chatId, false);
      renderChatList();
      if (document.getElementById('qzone-screen').classList.contains('active')) {
        renderQzonePosts();
      }
    }
  }






  async function triggerGroupAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup) return;

   const maxMemory = chat.settings.maxMemory || 10;
   const recentHistory_RAW = chat.history.filter(m => !m.isHidden).slice(-maxMemory);
   const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, chatId);
    const groupActionCooldownMinutes = chat.settings.actionCooldownMinutes || 10;

    if (chat.lastActionTimestamp) {
      const minutesSinceLastAction = (Date.now() - chat.lastActionTimestamp) / (1000 * 60);

      if (minutesSinceLastAction < groupActionCooldownMinutes) {
        console.log(`群聊 "${chat.name}" 处于行动冷却中，本次独立行动跳过。`);
        return;
      }
    }


    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const myNickname = chat.settings.myNickname || '我';
    const now = new Date();


    let systemPrompt;


    const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5);
    const unclaimedPacket = recentHistory.find(m => m.type === 'red_packet' && !m.isFullyClaimed);

 
    if (unclaimedPacket) {
      const senderDisplayName = getDisplayNameInGroup(chat, unclaimedPacket.senderName);
      console.log(`检测到群聊 "${chat.name}" 中有未领完的红包，正在生成抢红包指令...`);

      systemPrompt = `
        # 你的【【【最高优先级任务】】】
        群聊中刚刚出现了一个由“${senderDisplayName}”发送的、尚未领完的红包（时间戳: ${unclaimedPacket.timestamp}）。
        你的任务是：选择【一个或多个】符合人设的角色，让他们【立刻】使用 'open_red_packet' 指令去尝试领取这个红包。
        # 指令格式
        你的回复【必须】是一个JSON数组，格式如下：
        '[{"type": "open_red_packet", "name": "角色本名", "packet_timestamp": ${unclaimedPacket.timestamp}}]'
        
        你可以让多个角色同时尝试，只需在返回的JSON数组中包含多个这样的对象即可。
        现在，请立即执行抢红包操作！
        `;
    } else {

      let timeContextText = '';

      const selectedTimeZone = chat.settings.timeZone || 'Asia/Shanghai';
      const currentTime = now.toLocaleString('zh-CN', {
        timeZone: selectedTimeZone,
        dateStyle: 'full',
        timeStyle: 'short'
      });
      const localizedDate = new Date(now.toLocaleString('en-US', {
        timeZone: selectedTimeZone
      }));



      if (chat.settings.enableTimePerception) {
        const lastMessage = chat.history.filter(m => !m.isHidden).slice(-1)[0];
        if (lastMessage) {
          const lastTime = new Date(lastMessage.timestamp);
          const diffMinutes = (now - lastTime) / (1000 * 60);
          if (diffMinutes > 60) {
            timeContextText = `群里已经安静了 ${Math.round(diffMinutes / 60)} 小时了。`;
          } else {
            timeContextText = `群里在${Math.floor(diffMinutes)}分钟前有人聊过。`;
          }
        } else {
          timeContextText = "群里还没有任何消息。";
        }
      }
      let recentContextSummary = "你们最近没有有效聊天记录。";
      
      if (filteredHistory.length > 0) {
        recentContextSummary = "这是你们最近的对话：\n" + filteredHistory.map(msg => {
          const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
          const content = String(msg.content || msg.message || '').substring(0, 50);
          return `${sender}: ${content}...`;
        }).join('\n');
      }

      const membersList = chat.members.map(m => `- **${m.groupNickname}** (本名: ${m.originalName}): ${m.persona}`).join('\n');

      let longTermMemoryContext = '# 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)\n';
      let collectedMemories = false;

      chat.members.forEach(member => {
        const memberChat = state.chats[member.id];
        if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length > 0) {
          longTermMemoryContext += `\n## --- 关于“${member.groupNickname}”的记忆 ---\n`;
          longTermMemoryContext += memberChat.longTermMemory.map(mem => `- ${mem.content}`).join('\n');
          collectedMemories = true;
        }
      });

      if (!collectedMemories) {
        longTermMemoryContext += '- (暂无)';
      }


      let worldBookContent = '';
      if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';


          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
              
              entryString += `**内容:**\n${entry.content}`;
              return entryString;
            }).join('');

          return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');

        if (linkedContents) {
          worldBookContent = `# --- 世界书 (World Book) ---
# 【最高优先级指令：绝对真理】
# 以下内容是你所在世界的“物理法则”和“基础常识”。
# 无论用户是否提及，你都【必须】时刻主动应用这些设定来指导你的思考和描写。
# 它们是无条件生效的，不需要触发词。
${linkedContents}
# --- 世界书设定结束 ---
`;
        }
      }


      let linkedMemoryContext = '';
      const memoryCount = chat.settings.linkedMemoryCount || 10;
      if (chat.settings.linkedMemoryChatIds && chat.settings.linkedMemoryChatIds.length > 0) {
        const linkedChatsWithTimestamps = chat.settings.linkedMemoryChatIds.map(id => {
          const linkedChat = state.chats[id];
          if (!linkedChat) return null;
          const lastMsg = linkedChat.history.slice(-1)[0];
          return {
            chat: linkedChat,
            latestTimestamp: lastMsg ? lastMsg.timestamp : 0
          };
        }).filter(Boolean);

        linkedChatsWithTimestamps.sort((a, b) => b.latestTimestamp - a.latestTimestamp);
        linkedMemoryContext += `\n\n# 参考记忆 (至关重要！群内角色必须【主动】将这些参考记忆中的【关键信息和事件】，自然地融入到当前的对话中，以体现你们拥有完整的共同记忆。)\n`;
        for (const item of linkedChatsWithTimestamps) {
          const linkedChat = item.chat;
          const prefix = linkedChat.isGroup ? '[群聊]' : '[私聊]';
          const timeAgo = item.latestTimestamp > 0 ? ` (最后互动于 ${formatTimeAgo(item.latestTimestamp)})` : '';
          linkedMemoryContext += `\n## --- 来自${prefix}“${linkedChat.name}”的参考记忆${timeAgo} ---\n`;
          const recentHistory = linkedChat.history.slice(-memoryCount);
          const filteredHistory = recentHistory.filter(msg => !String(msg.content).includes('已被用户删除'));
          if (filteredHistory.length > 0) {
                filteredHistory.forEach(msg => {
                
                  const sender = msg.role === 'user' ? (linkedChat.settings.myNickname || '我') : (getDisplayNameInGroup(linkedChat, msg.senderName) || linkedChat.name);
                  
                  let prefix = "";
               
                  if (msg.quote && msg.quote.content) {
                      const quotedSenderDisplayName = getDisplayNameInGroup(linkedChat, msg.quote.senderName);
                      let quoteContentPreview = String(msg.quote.content).substring(0, 30);
                      if (quoteContentPreview.length === 30) quoteContentPreview += "...";
                      
                      prefix = `[回复 ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
                  }

                  let contentText = '';
                  
                  if (msg.type === 'ai_image' || msg.type === 'user_photo') {
                    contentText = `[发送了一张图片，描述为：${msg.content}]`;
                  } else if (msg.type === 'voice_message') {
                    contentText = `[发送了一条语音，内容是：${msg.content}]`;
                  } else if (msg.type === 'sticker') {
                    contentText = `[表情: ${msg.meaning || 'sticker'}]`;
                  } else if (msg.type === 'transfer') {
                    contentText = `[转账: ${msg.amount}元]`;
                  } else if (Array.isArray(msg.content)) {
                    contentText = `[图片]`;
                  } else {
                    contentText = String(msg.content);
                  }
                  
                  
                  linkedMemoryContext += `${sender}: ${prefix}${contentText}\n`;
                });
              } else {
            linkedMemoryContext += "(暂无有效聊天记录)\n";
          }
        }
      }
      const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
      let dynamicContext = "";

      const visiblePostsForGroup = new Set();
      for (const member of chat.members) {
        const memberChat = state.chats[member.id];
        if (memberChat) {
          const visibleForMember = filterVisiblePostsForAI(allRecentPosts, memberChat);
          visibleForMember.forEach(post => visiblePostsForGroup.add(post));
        }
      }

      const groupMemberNames = new Set(chat.members.map(m => m.originalName));
      const unInteractedPostsForGroup = [...visiblePostsForGroup].filter(post => {
        const hasBeenLikedByGroup = post.likes && post.likes.some(likerName => groupMemberNames.has(likerName));
        const hasBeenCommentedByGroup = post.comments && post.comments.some(comment => typeof comment === 'object' && groupMemberNames.has(comment.commenterName));
        return !hasBeenLikedByGroup && !hasBeenCommentedByGroup;
      });

      if (unInteractedPostsForGroup.length > 0) {
        let postsContext = "\n\n# 最近的动态列表 (供群内角色参考和评论):\n";
        for (const post of unInteractedPostsForGroup) {
          let authorName = post.authorId === 'user' ? myNickname : (state.chats[post.authorId]?.name || '一位朋友');
          let contentSummary;
          if (post.type === 'repost') {
            const repostComment = post.repostComment ? `并评论说：“${post.repostComment}”` : '';
            let originalAuthorName = '原作者';
            const originalAuthorId = post.originalPost.authorId;
            if (originalAuthorId === 'user') {
              originalAuthorName = state.qzoneSettings.nickname;
            } else if (state.chats[originalAuthorId]) {
              originalAuthorName = state.chats[originalAuthorId].name;
            }
            let originalContentSummary;
            const originalPost = post.originalPost;
            if (originalPost.type === 'text_image') {
              originalContentSummary = `[文字图] ${originalPost.publicText || ''} (图片描述: “${(originalPost.hiddenContent || '').substring(0, 40)}...”)`;
            } else if (originalPost.type === 'image_post') {
              originalContentSummary = `[图片] ${originalPost.publicText || ''} (图片描述: “${(originalPost.imageDescription || '').substring(0, 40)}...”)`;
            } else {
              originalContentSummary = `“${(originalPost.content || '').substring(0, 40)}...”`;
            }
            contentSummary = `转发了 @${originalAuthorName} 的动态 ${repostComment}【原动态内容: ${originalContentSummary}】`;
          } else if (post.type === 'text_image') {
            contentSummary = `[一张图片，其隐藏文字为：“${post.hiddenContent}”] ${post.publicText || ''}`.substring(0, 50) + '...';
          } else if (post.type === 'image_post') {
            contentSummary = `[一张图片，描述为：“${post.imageDescription}”] ${post.publicText || ''}`.substring(0, 50) + '...';
          } else {

            contentSummary = String(post.publicText || post.content || "一条动态").substring(0, 50) + '...';
          }
          postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"\n`;
          if (post.comments && post.comments.length > 0) {
            for (const comment of post.comments) {
              if (typeof comment === 'object' && comment.commenterName) {
                const commenterDisplayName = getDisplayNameByOriginalName(comment.commenterName);
                let commentText = comment.meaning ? `[表情: '${comment.meaning}']` : comment.text;
                postsContext += `  - 评论: ${commenterDisplayName} (本名: ${comment.commenterName}): ${commentText}\n`;
              }
            }
          }
        }
        dynamicContext = postsContext;
      }

      const summary3Hours_group = generateSummaryForTimeframe(chat, 3, 'hours');
      const summary6Hours_group = generateSummaryForTimeframe(chat, 6, 'hours');
      const summary9Hours_group = generateSummaryForTimeframe(chat, 9, 'hours');
      const summaryToday_group = generateSummaryForTimeframe(chat, 1, 'days');
      const summary3Days_group = generateSummaryForTimeframe(chat, 3, 'days');
      const summary7Days_group = generateSummaryForTimeframe(chat, 7, 'days');

      let multiLayeredSummaryContext_group = '';
      if (summary3Hours_group || summary6Hours_group || summary9Hours_group || summaryToday_group || summary3Days_group || summary7Days_group) {
        multiLayeredSummaryContext_group += `\n# 智能总结 (基于不同时间维度的群聊回顾)\n`;
        if (summary3Hours_group) multiLayeredSummaryContext_group += summary3Hours_group;
        if (summary6Hours_group) multiLayeredSummaryContext_group += summary6Hours_group;
        if (summary9Hours_group) multiLayeredSummaryContext_group += summary9Hours_group;

        if (summary3Hours_group || summary6Hours_group || summary9Hours_group) multiLayeredSummaryContext_group += '\n';

        if (summaryToday_group) multiLayeredSummaryContext_group += summaryToday_group;
        if (summary3Days_group) multiLayeredSummaryContext_group += summary3Days_group;
        if (summary7Days_group) multiLayeredSummaryContext_group += summary7Days_group;
      }
      const stickerContext = getGroupStickerContextForPrompt(chat);
      systemPrompt = `
        # 你的任务
        你是一个群聊AI导演。你现在控制着一个名为“${chat.name}”的群聊。
        ${chat.settings.enableTimePerception ? `当前时间是 ${currentTime}。` : ''}
        ${timeContextText ? `${timeContextText} ` : ''}你的任务是根据群成员的性格、世界观、参考记忆、最近的动态和当前情景，【选择一个或多个角色】，让他们主动发起一段对话，打破沉默，让群聊重新活跃起来。
# 【交互铁律：角色间必须互动！】
1.  你的核心任务是**导演一场生动的群聊**，而不仅仅是让角色轮流发言。
2.  当有多个角色在同一轮发言时，他们的对话【必须】有逻辑上的前后关联。后面的角色应该**回应、反驳、或补充**前面角色的发言。
3.  模拟真实的聊天节奏。可以是一个角色提出问题，另一个角色立刻回答；或者一个角色开玩笑，另一个角色吐槽。
4.  你【绝对不能】生成几段毫无关联的独白。这会让对话显得非常机械和不真实。        
${longTermMemoryContext}
        
        # 核心规则
        你的回复【必须】是一个JSON数组，可以包含一个或多个行动对象。每个对象的 "name" 字段【必须】是角色的【本名】。你【绝对不能】生成 "name" 字段为 "${myNickname}" 的消息。严格遵守每个角色的设定，禁止出戏。
-请根据当前情景和你的情绪，从列表中【选择一个最合适的】表情含义来使用 "sticker" 指令。尽量让你的表情丰富多样，避免重复。        
        # 你的可选行动指令:
        -   **发送文本**: '{"type": "text", "name": "角色本名", "content": "文本内容"}'
        -   **发送表情**: '{"type": "sticker", "name": "角色本名", "meaning": "表情的含义(从可用表情列表选择)"}'
        -   **发送图片**: '{"type": "ai_image", "name": "角色本名", "description": "图片的详细【中文】描述", "image_prompt": "图片的【英文】关键词, 用%20分隔, 风格为风景/动漫/插画/二次元等, 禁止真人"}'
        -   **发起投票**: '{"type": "poll", "name": "角色本名", "question": "...", "options": "..."}'
        -   **发起群视频**: '{"type": "group_call_request", "name": "角色本名"}'
        -如何正确使用“引用回复”功能：
- 当你想明确地针对群内【任何成员】（包括用户或其他AI角色）之前的某一句具体的话进行回复时，你就应该使用这个功能。
- 这会让你的回复上方出现一个灰色的小框，里面是被你引用的那句话，这样对话就不会乱了。
- 指令格式: '{"type": "quote_reply", "target_timestamp": (你想引用的那句话的时间戳), "reply_content": "你的回复内容"}'

        # 当前群聊信息
        - **群名称**: ${chat.name}
        ${worldBookContent}
        # 长期记忆 (最高优先级，这是群内已经确立的事实，所有角色必须严格遵守)
        ${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}       
        ${multiLayeredSummaryContext_group}
        ${linkedMemoryContext}
        
        # 群成员列表及人设
        ${membersList}
        # 可用表情包
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
        ${stickerContext}        
        # 用户的角色
        - **${myNickname}**: ${chat.settings.myPersona}
        - **${myNickname}的当前状态**: ${chat.settings.userStatus ? chat.settings.userStatus.text : '在线'} ${chat.settings.userStatus && chat.settings.userStatus.isBusy ? '(忙碌中)' : ''}
        
        # 最近的对话摘要 (供你参考)
        ${recentContextSummary}
        
        # 最近的动态列表 (供你参考和评论)
        ${dynamicContext}
        
        现在，请开始你的导演工作，让群聊再次热闹起来吧！
        `;
    }
    const recentHistoryForPayload = chat.history.filter(m => !m.isHidden).slice(-10);
    const messagesPayload = [{
        role: 'system',
        content: systemPrompt
      },

      ...filteredHistory.map(msg => {
        const sender = msg.role === 'user' ? myNickname : getDisplayNameInGroup(chat, msg.senderName);
        let content = msg.content;

        if (msg.type === 'ai_image' || msg.type === 'user_photo') {
          content = `[发送了一张图片，描述为：'${msg.content}']`;
        } else if (msg.type === 'voice_message') {
          content = `[发送了一条语音，内容是：'${msg.content}']`;
        } else if (typeof content !== 'string') {
          content = '[发送了一条复杂消息，如卡片或转账]';
        }

        return {
          role: 'user',
          content: `${sender}: ${content}`
        };
      })
    ];

    try {
      const messagesPayload = [{
        role: 'user',
        content: systemPrompt
      }];
      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: messagesPayload,
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponseContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
      const responseArray = parseAiResponse(aiResponseContent);

      if (!responseArray || responseArray.length === 0) {
        console.warn(`群聊 "${chat.name}" 的独立行动API返回为空或格式不正确，本次跳过。`);
        return;
      }

      let actionTimestamp = Date.now();

      let hasPerformedMajorAction = false;
      let notificationContent = '';
      let notificationSender = '';

      const processedActions = [];
      for (const action of responseArray) {
        const contentStr = String(action.content || '');

        const isRawHtml = contentStr.trim().startsWith('<') && contentStr.trim().endsWith('>');


        if (action.type === 'text' && !isRawHtml && contentStr.includes('\n')) {
          const lines = contentStr.split(/\n+/).filter(line => line.trim());
          lines.forEach(line => {
            processedActions.push({
              ...action,
              content: line
            });
          });
        } else {

          processedActions.push(action);
        }
      }
      for (const action of processedActions) {
        if (!action || !action.type || (!action.name && action.type !== 'narration')) continue;

        const senderDisplayName = getDisplayNameInGroup(chat, action.name);
        let visibleSystemMessage = null;

        let aiMessage = null;
        const baseMessage = {
          role: 'assistant',
          senderName: action.name,
          timestamp: actionTimestamp++
        };


        if (action.type === 'open_red_packet') {
          const packetToOpen = chat.history.find(m => m.timestamp === action.packet_timestamp);

          if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[action.name])) {

            let claimedAmountAI = 0;
            const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
            const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

            if (remainingCount > 0) {
          
              if (packetToOpen.packetType === 'direct') { 
                  claimedAmountAI = packetToOpen.totalAmount;
              }
              else if (packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length > 0) {
                
                  claimedAmountAI = packetToOpen.unclaimedAmounts.pop();
              } 
              
              else { 
                  console.warn("检测到旧版红包，回退到旧的（不公平）随机算法 (triggerGroupAiAction)");
                  const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
                  if (remainingCount === 1) {
                      claimedAmountAI = remainingAmount;
                  } else {
                      const min = 0.01;
                      const max = remainingAmount - (remainingCount - 1) * min;
                      claimedAmountAI = Math.random() * (max - min) + min;
                  }
              }
             
              claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
              if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
              packetToOpen.claimedBy[action.name] = claimedAmountAI;


              chat.history.push({
                role: 'system',
                type: 'pat_message',
                content: `${senderDisplayName} 领取了 ${getDisplayNameInGroup(chat, packetToOpen.senderName)} 的红包`,
                timestamp: actionTimestamp++
              });


              let hiddenContentForAI = `[系统提示：你 (${senderDisplayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;
              if ((packetToOpen.unclaimedAmounts && packetToOpen.unclaimedAmounts.length === 0) || (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count)) {
                packetToOpen.isFullyClaimed = true;

                chat.history.push({
                  role: 'system',
                  type: 'pat_message',
                  content: `${getDisplayNameInGroup(chat, packetToOpen.senderName)} 的红包已被领完`,
                  timestamp: actionTimestamp++
                });

                let luckyKing = {
                  name: '',
                  amount: -1
                };
                Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                  if (amount > luckyKing.amount) {
                    luckyKing = {
                      name,
                      amount
                    };
                  }
                });
                if (luckyKing.name) {
                  const luckyKingDisplayName = getDisplayNameInGroup(chat, luckyKing.name);
                  hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKingDisplayName}！`;
                }
              }
              hiddenContentForAI += ' 请根据这个结果发表你的评论。]';
              chat.history.push({
                role: 'system',
                content: hiddenContentForAI,
                timestamp: actionTimestamp++,
                isHidden: true
              });
            }
          }
          hasPerformedMajorAction = true;
          continue;
        }


        switch (action.type) {
         case 'quote_reply': {
            let originalMessage = null;
            
        
            if (msgData.target_content) {
              originalMessage = [...chat.history].reverse().find(m => 
                !m.isHidden &&
                ( 
                  m.content === msgData.target_content ||
                  (typeof m.content === 'string' && m.content.trim() === msgData.target_content.trim())
                )
              );
              
              if(!originalMessage) {
                 console.warn(`[本轮引用失败] AI ${msgData.name} 尝试引用内容 "${(msgData.target_content || '').substring(0, 20)}..."，但在本轮历史中未找到。`);
              }
            } 
            
           
            else if (msgData.target_timestamp) { 
              originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
            }

           
            if (originalMessage) {
              
              
              let quotedSenderDisplayName;
              
              if (originalMessage.role === 'user') {
                 
                  quotedSenderDisplayName = chat.settings.myNickname || '我';
              } else { 
                
                  if (chat.isGroup) {
                      
                      quotedSenderDisplayName = getDisplayNameInGroup(chat, originalMessage.senderName);
                  } else {
                     
                      quotedSenderDisplayName = chat.name;
                  }
              }
              
              const quoteContext = {
                  timestamp: originalMessage.timestamp,
                  senderName: quotedSenderDisplayName, 
                  
                  content: String(originalMessage.content || '').substring(0, 50) 
              };
              
              
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content,
                quote: quoteContext 
              };
            } else {
            
              console.warn(`引用回复失败: 找不到目标消息 (Content: ${msgData.target_content}, TS: ${msgData.target_timestamp})`);
              aiMessage = {
                ...baseMessage,
                content: msgData.reply_content 
              };
            }
            break;
          }
          case 'sticker':
            if (action.meaning) {
              const sticker = findBestStickerMatch(action.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`AI (群聊后台) 尝试使用一个不存在的表情: "${action.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("AI (群聊后台) 发送了一个没有 'meaning' 的 sticker 指令。", action);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: action.url,
                meaning: '未知表情'
              };
            }
            break;
          case 'qzone_post':
            const newPost = {
              type: action.postType || 'shuoshuo',
              content: action.content,
              timestamp: Date.now(),
              authorId: state.chats[Object.keys(state.chats).find(key => state.chats[key].originalName === action.name)]?.id || action.name,
              authorOriginalName: action.name,
              visibleGroupIds: null
            };
            await db.qzonePosts.add(newPost);
            updateUnreadIndicator(unreadPostsCount + 1);
            visibleSystemMessage = {
              content: `[${senderDisplayName} 发布了一条新动态]`
            };
            break;
          case 'qzone_comment':
            const postToComment = await db.qzonePosts.get(parseInt(action.postId));
            if (postToComment) {
              if (!postToComment.comments) postToComment.comments = [];
              postToComment.comments.push({
                commenterName: action.name,
                text: action.commentText,
                timestamp: Date.now()
              });
              await db.qzonePosts.update(postToComment.id, {
                comments: postToComment.comments
              });
              updateUnreadIndicator(unreadPostsCount + 1);
              visibleSystemMessage = {
                content: `[${senderDisplayName} 评论了动态]`
              };
            }
            break;
          case 'qzone_like':
            const postToLike = await db.qzonePosts.get(parseInt(action.postId));
            if (postToLike) {
              if (!postToLike.likes) postToLike.likes = [];
              if (!postToLike.likes.includes(action.name)) {
                postToLike.likes.push(action.name);
                await db.qzonePosts.update(postToLike.id, {
                  likes: postToLike.likes
                });
                updateUnreadIndicator(unreadPostsCount + 1);
                visibleSystemMessage = {
                  content: `[${senderDisplayName} 点赞了动态]`
                };
              }
            }
            break;
          case 'ai_image':
            aiMessage = {
              ...baseMessage,
              type: 'ai_image',
              content: action.description,
              image_prompt: msgData.image_prompt
            };
            break;
          default:
            if (action.type === 'poll') {
              const pollOptions = typeof action.options === 'string' ?
                action.options.split('\n').filter(opt => opt.trim()) :
                (Array.isArray(action.options) ? action.options : []);
              if (pollOptions.length < 2) continue;
              aiMessage = {
                ...baseMessage,
                ...action,
                options: pollOptions,
                votes: {},
                isClosed: false
              };
            } else {
              const messageContent = action.content || action.message;
              aiMessage = {
                ...baseMessage,
                ...action
              };
              if (messageContent) aiMessage.content = messageContent;
            }
            break;
        }

        if (visibleSystemMessage) {
          chat.history.push({
            role: 'system',
            type: 'pat_message',
            content: visibleSystemMessage.content,
            timestamp: actionTimestamp++
          });
        } else if (aiMessage) {
          chat.history.push(aiMessage);
          if (!notificationSender) {
            notificationSender = senderDisplayName;
            notificationContent = aiMessage.type === 'ai_image' ? '[图片]' : (aiMessage.content || `[${aiMessage.type}]`);
          }
        }
        hasPerformedMajorAction = true;
      }

      if (hasPerformedMajorAction) {
        chat.lastActionTimestamp = Date.now();
        chat.unreadCount = (chat.unreadCount || 0) + responseArray.filter(a => a.type !== 'qzone_post' && a.type !== 'qzone_comment' && a.type !== 'qzone_like').length;
        if (notificationSender && notificationContent) {
          showNotification(chatId, `${notificationSender}: ${notificationContent}`);
        }
        await db.chats.put(chat);
      }

    } catch (error) {
      console.error(`群聊 "${chat.name}" 的独立行动失败:`, error);
    } finally {
      renderChatList();
    }
  }








  
  function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;

    if (!cssString || cssString.trim() === '') {
      styleTag.innerHTML = '';
      return;
    }


    const scopedCss = cssString
      .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
      .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
      .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);

    styleTag.innerHTML = scopedCss;
  }


  async function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;


    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background;


    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);

    if (background && background.startsWith('data:image')) {
      previewArea.style.backgroundImage = `url(${background})`;
      previewArea.style.backgroundColor = 'transparent';
    } else {
      previewArea.style.backgroundImage = 'none';
      previewArea.style.background = background || '#f0f2f5';
    }


    previewArea.innerHTML = '';


    const aiMsg = {
      role: 'ai',
      content: '对方消息预览',
      timestamp: 1,
      senderName: chat.name
    };
    const aiBubble = await createMessageElement(aiMsg, chat);
    if (aiBubble) previewArea.appendChild(aiBubble);


    const userMsg = {
      role: 'user',
      content: '我的消息预览',
      timestamp: 2
    };
    const userBubble = await createMessageElement(userMsg, chat);
    if (userBubble) previewArea.appendChild(userBubble);


    const previewLyricsBar = document.createElement('div');
    previewLyricsBar.style.cssText = `
                position: absolute; 
                font-size: 11px; 
                padding: 2px 6px; 
                border-radius: 8px; 
                background-color: rgba(0, 0, 0, 0.1); 
                color: var(--text-secondary); 
                white-space: nowrap; 
                transition: all 0.3s ease;
            `;
    previewLyricsBar.textContent = '♪ 歌词位置预览 ♪';
    previewArea.appendChild(previewLyricsBar);

    const vertical = document.getElementById('lyrics-vertical-pos').value;
    const horizontal = document.getElementById('lyrics-horizontal-pos').value;
    const offset = parseInt(document.getElementById('lyrics-offset-input').value) || 10;

    if (vertical === 'top') {
      previewLyricsBar.style.top = `${offset}px`;
    } else {
      previewLyricsBar.style.bottom = `${offset}px`;
    }

    switch (horizontal) {
      case 'left':
        previewLyricsBar.style.left = '15px';
        break;
      case 'right':
        previewLyricsBar.style.right = '15px';
        break;
      default:
        previewLyricsBar.style.left = '50%';
        previewLyricsBar.style.transform = 'translateX(-50%)';
        break;
    }


    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
  }




  async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
  }

  async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
                    <span class="group-name">${group.name}</span>
                    <span class="delete-group-btn" data-id="${group.id}">×</span>
                `;
      listEl.appendChild(item);
    });
  }


  async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('分组名不能为空！');
      return;
    }


    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
      alert(`分组 "${name}" 已经存在了，换个名字吧！`);
      return;
    }


    await db.qzoneGroups.add({
      name
    });
    input.value = '';
    await renderGroupList();
  }


  async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.qzoneGroups.delete(groupId);
      // 将属于该分组的好友的 groupId 设为 null
      const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
      for (const chat of chatsToUpdate) {
        chat.groupId = null;
        await db.chats.put(chat);
        if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
      }
      await renderGroupList();
    }
  }

 
  function showMessageActions(timestamp) {

    const chat = state.chats[state.activeChatId];
    document.getElementById('publish-to-announcement-btn').style.display = chat.isGroup ? 'block' : 'none';


    if (isSelectionMode) return;

    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
  }

  function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
  }

  // 翻译消息内容函数
  async function translateMessageContent() {
    if (!activeMessageTimestamp) return;
    
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    hideMessageActions();

    // 获取要翻译的文本
    let textToTranslate;
    if (typeof message.content === 'object') {
      textToTranslate = JSON.stringify(message.content);
    } else {
      textToTranslate = String(message.content);
    }

    // 如果文本为空或太短，不翻译
    if (!textToTranslate || textToTranslate.trim().length === 0) {
      await showCustomAlert('翻译失败', '消息内容为空，无法翻译。');
      return;
    }

    try {
      // 显示加载提示
      await showCustomAlert('翻译中...', '正在调用翻译服务，请稍候...');

      // 如果文本太长，截取前500字符
      const textToSend = textToTranslate.length > 500 
        ? textToTranslate.substring(0, 500) + '...' 
        : textToTranslate;

      // 简单的语言检测
      function detectLanguage(text) {
        // 检测是否包含中文字符
        if (/[\u4e00-\u9fa5]/.test(text)) {
          return 'zh-CN';
        }
        // 检测是否包含日文字符
        if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) {
          return 'ja';
        }
        // 检测是否包含韩文字符
        if (/[\uac00-\ud7af]/.test(text)) {
          return 'ko';
        }
        // 检测是否包含俄文字符
        if (/[\u0400-\u04ff]/.test(text)) {
          return 'ru';
        }
        // 默认为英文
        return 'en';
      }

      const sourceLang = detectLanguage(textToSend);
      const targetLang = 'zh-CN'; // 目标语言：简体中文

      // 如果检测到已经是中文，尝试翻译成英文
      const finalTargetLang = sourceLang === 'zh-CN' ? 'en' : 'zh-CN';
      
      const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToSend)}&langpair=${sourceLang}|${finalTargetLang}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`翻译API返回错误: ${response.status}`);
      }

      const data = await response.json();
      
      if (data.responseStatus !== 200) {
        throw new Error(data.responseDetails || '翻译服务返回错误');
      }

      const translatedText = data.responseData.translatedText;

      // 显示翻译结果
      const langName = {
        'en': '英文',
        'ja': '日文',
        'ko': '韩文',
        'ru': '俄文',
        'zh-CN': '中文'
      };
      
      await showCustomAlert(
        '翻译结果', 
        `检测语言：${langName[sourceLang] || sourceLang}\n\n原文：\n${textToSend}\n\n译文：\n${translatedText}`
      );

    } catch (err) {
      console.error('翻译失败:', err);
      await showCustomAlert('翻译失败', `无法翻译消息内容：${err.message}\n\n提示：您可以尝试使用浏览器自带的翻译功能。`);
    }
  }



  async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions();

    let contentForEditing;

    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
      let fullMessageObject = {
        type: message.type
      };
      if (message.type === 'voice_message') fullMessageObject.content = message.content;
      else if (message.type === 'ai_image') fullMessageObject.description = message.content;
      else if (message.type === 'transfer') {
        fullMessageObject.amount = message.amount;
        fullMessageObject.note = message.note;
      } else if (message.type === 'share_link') {
        fullMessageObject.title = message.title;
        fullMessageObject.description = message.description;
        fullMessageObject.source_name = message.source_name;
        fullMessageObject.content = message.content;
      }
      contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
      contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
      contentForEditing = message.content;
    }


    const templates = {
      voice: {
        type: 'voice_message',
        content: '在这里输入语音内容'
      },
      image: {
        type: 'ai_image',
        description: '在这里输入图片描述'
      },
      transfer: {
        type: 'transfer',
        amount: 5.20,
        note: '一点心意'
      },
      link: {
        type: 'share_link',
        title: '文章标题',
        description: '文章摘要...',
        source_name: '来源网站',
        content: '文章完整内容...'
      }
    };


    const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
                </div>
            `;

    const newContent = await showCustomPrompt(
      '编辑消息',
      '在此修改，或点击上方按钮使用格式模板...',
      contentForEditing,
      'textarea',
      helpersHtml
    );

    if (newContent !== null) {

      await saveEditedMessage(timestampToEdit, newContent, true);
    }
  }


  
  async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
      textToCopy = JSON.stringify(message.content);
    } else {
      textToCopy = String(message.content);
    }

    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
      await showCustomAlert('复制失败', '无法访问剪贴板。');
    }

    hideMessageActions();
  }



  async function copyMessageTimestamp() {
    if (!activeMessageTimestamp) return;

    try {
      await navigator.clipboard.writeText(activeMessageTimestamp);
      await showCustomAlert('复制成功', `消息时间戳 ${activeMessageTimestamp} 已复制到剪贴板。`);
    } catch (err) {
      await showCustomAlert('复制失败', '无法访问剪贴板。');
    }

    hideMessageActions();
  }


 
  function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';


    const templates = {
      voice: {
        type: 'voice_message',
        content: '在这里输入语音内容'
      },
      image: {
        type: 'ai_image',
        description: '在这里输入图片描述'
      },
      transfer: {
        type: 'transfer',
        amount: 5.20,
        note: '一点心意'
      },
      link: {
        type: 'share_link',
        title: '文章标题',
        description: '文章摘要...',
        source_name: '来源网站',
        content: '文章完整内容...'
      },
      offline: {
        type: 'offline_text',
        content: '「在这里输入对话内容」\n(在这里输入动作或环境描写)'
      },
      quote: {
        type: 'quote_reply',
        target_timestamp: 1234567890,
        reply_content: '在这里输入回复内容'
      },
   
      nai: {
            type: 'naiimag',
            prompt: '1girl, best quality, masterpiece, ...'
        },
        // 【关键修改】：添加旁白模板
        narration: {
            type: 'narration',
            content: '在这里输入环境或心理描写...'
        }
   
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>线下</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>引用</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.nai)}' style="color: #6a329f; border-color: #6a329f;">NAI生图</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.narration)}' style="color: #888; border-color: #ccc;">旁白</button>
            </div>
    `;


    block.querySelector('.delete-block-btn').addEventListener('click', () => {

      if (document.querySelectorAll('.message-editor-block').length > 1) {
        block.remove();
      } else {
        alert('至少需要保留一条消息。');
      }
    });


    block.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const templateStr = btn.dataset.template;
        const textarea = block.querySelector('textarea');
        if (templateStr && textarea) {
          try {
            const templateObj = JSON.parse(templateStr);
            textarea.value = JSON.stringify(templateObj, null, 2);
            textarea.focus();
          } catch (e) {
            console.error("解析格式模板失败:", e);
          }
        }
      });
    });

    return block;
  }



  
  async function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions();

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = '';

    let initialContent;

    if (message.quote) {

      const quoteReplyObject = {
        type: 'quote_reply',
        target_timestamp: message.quote.timestamp,
        reply_content: message.content
      };

      initialContent = JSON.stringify(quoteReplyObject, null, 2);
    }

   
    else if (message.type && ['voice_message', 'ai_image', 'transfer', 'offline_text', 'share_link', 'naiimag', 'narration'].includes(message.type)) {
      let fullMessageObject = {
        type: message.type
      };
      if (message.type === 'voice_message') fullMessageObject.content = message.content;
      else if (message.type === 'ai_image') fullMessageObject.description = message.content;
      else if (message.type === 'transfer') {
        fullMessageObject.amount = message.amount;
        fullMessageObject.note = message.note;
      } else if (message.type === 'offline_text') {
        if (message.content) {
          fullMessageObject.content = message.content;
        } else {
          fullMessageObject.dialogue = message.dialogue;
          fullMessageObject.description = message.description;
        }
      } else if (message.type === 'share_link') {
        fullMessageObject.title = message.title;
        fullMessageObject.description = message.description;
        fullMessageObject.source_name = message.source_name;
        fullMessageObject.content = message.content;
      }
    
      else if (message.type === 'naiimag') {
        fullMessageObject.prompt = message.prompt;
       
        fullMessageObject.fullPrompt = message.fullPrompt;
      }
    else if (message.type === 'narration') {
          fullMessageObject.content = message.content;
      }

      initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
      try {
        let safeContent = JSON.parse(JSON.stringify(message.content));
        if (Array.isArray(safeContent)) {
          safeContent.forEach(part => {
           
            if (part.type === 'image_url' && part.image_url && part.image_url.url && part.image_url.url.length > 500) {
              part.image_url.url = "BASE64_DATA_HIDDEN";
            }
          });
        }
        initialContent = JSON.stringify(safeContent, null, 2);
      } catch (e) {
        console.warn("无法安全处理消息内容，回退到原始显示:", e);
        initialContent = JSON.stringify(message.content, null, 2);
      }
    } else {
      initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);


    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
      const newBlock = createMessageEditorBlock();
      editorContainer.appendChild(newBlock);
      newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
      editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    newSaveBtn.addEventListener('click', () => {
      saveEditedMessage(timestampToEdit);
    });

    editorModal.classList.add('visible');
  }



  
  async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;

    if (message.type === 'offline_text') {

      if (message.content) {
        textToCopy = message.content;
      } else {
        textToCopy = `「${message.dialogue || ''}」\n${message.description || ''}`;
      }
    } else if (typeof message.content === 'object') {
      textToCopy = JSON.stringify(message.content);
    } else {
      textToCopy = String(message.content);
    }

    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
      await showCustomAlert('复制失败', '无法访问剪贴板。');
    }

    hideMessageActions();
  }


  
  function parseEditedContent(text) {
    const trimmedText = text.trim();


    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
      try {
        const parsed = JSON.parse(trimmedText);

        if (parsed.type) {
          return parsed;
        }
      } catch (e) {
     }
    }


    if (STICKER_REGEX.test(trimmedText)) {

      return {
        type: 'sticker',
        content: trimmedText
      };
    }


    return {
      type: 'text',
      content: trimmedText
    };
  }





  async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;


    const originalMessage = chat.history[messageIndex];

    let newMessages = [];


    const blocks = simpleContent !== null ?
      [simpleContent] :
      Array.from(document.querySelectorAll('#message-editor-container textarea')).map(ta => ta.value);

    for (const rawContent of blocks) {
      if (!rawContent.trim()) continue;


      const parsedResult = parseEditedContent(rawContent.trim());



      const newMessage = {
        role: originalMessage.role,
        senderName: originalMessage.senderName,
        timestamp: originalMessage.timestamp,
        isHidden: originalMessage.isHidden
      };



      switch (parsedResult.type) {
        case 'text':
          newMessage.type = 'text';
          newMessage.content = parsedResult.content;
          break;
        case 'offline_text':
          newMessage.type = 'offline_text';
          if (parsedResult.content) {
            newMessage.content = parsedResult.content;
          } else {
            newMessage.dialogue = parsedResult.dialogue;
            newMessage.description = parsedResult.description;
          }
          break;
        case 'quote_reply':
          newMessage.type = 'quote_reply';
          newMessage.content = parsedResult.reply_content;
          const originalQuotedMsg = chat.history.find(m => m.timestamp === parsedResult.target_timestamp);
          if (originalQuotedMsg) {
            let originalSenderName = originalQuotedMsg.senderName;
            if (originalQuotedMsg.role === 'user') {
              originalSenderName = state.qzoneSettings.nickname || '{{user}}';
            }
            newMessage.quote = {
              timestamp: parsedResult.target_timestamp,
              senderName: originalSenderName,
              content: String(originalQuotedMsg.content || '')
            };
          } else {
            newMessage.quote = {
              timestamp: parsedResult.target_timestamp,
              senderName: '未知用户',
              content: '原始消息已删除或不存在'
            };
          }
          break;
        case 'voice_message':

        case 'ai_image':
        case 'user_photo':
          newMessage.type = parsedResult.type;
          newMessage.content = parsedResult.content || parsedResult.description;
          if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
          break;

    
        case 'naiimag': {
          const originalMsg = chat.history[messageIndex];
          let newPrompt = parsedResult.prompt;


          let newImageUrl = parsedResult.imageUrl;
          let newFullPrompt = parsedResult.fullPrompt;
          let promptChanged = false;


          if (newPrompt && typeof newPrompt === 'string' && originalMsg.prompt !== newPrompt) {
            promptChanged = true;
          } else {

            newPrompt = originalMsg.prompt;
            newFullPrompt = originalMsg.fullPrompt;
            newImageUrl = originalMsg.imageUrl;
          }

          if (promptChanged) {
            await showCustomAlert("请稍候...", "检测到提示词已修改，正在重新生成 NovelAI 图片...");
            try {

              const generatedData = await generateNaiImageFromPrompt(newPrompt, chat.id);
              newImageUrl = generatedData.imageUrl;
              newFullPrompt = generatedData.fullPrompt;
              await showCustomAlert("成功", "图片已根据新提示词重新生成！");
            } catch (error) {
              console.error("编辑时重新生成NAI图片失败:", error);
              await showCustomAlert("生成失败", `无法重新生成图片: ${error.message}. \n\n将保留旧图片，但提示词会更新。`);

              newImageUrl = originalMsg.imageUrl;
            }
          }


          newMessage.type = 'naiimag';
          newMessage.imageUrl = newImageUrl;
          newMessage.prompt = newPrompt;
          newMessage.fullPrompt = newFullPrompt;
          break;
        }


        case 'sticker': {
          newMessage.type = 'sticker';
          let found = false;


          if (parsedResult.meaning) {

            const sticker = state.userStickers.find(s => s.name === parsedResult.meaning);
            if (sticker) {

              newMessage.content = sticker.url;
              newMessage.meaning = sticker.name;
              console.log("导演/编辑模式保存(Sticker): 使用了 meaning 查找");
              found = true;
            } else {

              newMessage.type = 'text';
              newMessage.content = `[表情: ${parsedResult.meaning}]`;
              console.warn("导演/编辑模式保存(Sticker): 提供了 meaning 但未找到对应表情:", parsedResult.meaning);
              found = true;
            }
          }



          if (!found && parsedResult.url) {
            newMessage.content = parsedResult.url;

            const stickerByURL = state.userStickers.find(s => s.url === parsedResult.url);

            if (parsedResult.meaning && (!stickerByURL || stickerByURL.name === parsedResult.meaning)) {
              newMessage.meaning = parsedResult.meaning;
            } else if (stickerByURL) {
              newMessage.meaning = stickerByURL.name;
            } else {
              newMessage.meaning = '未知表情';
            }
            console.log("导演/编辑模式保存(Sticker): 使用了 URL，最终 meaning:", newMessage.meaning);
            found = true;
          }


          if (!found && parsedResult.content && typeof parsedResult.content === 'string' && STICKER_REGEX.test(parsedResult.content)) {
            newMessage.content = parsedResult.content;

            const sticker = state.userStickers.find(s => s.url === parsedResult.content);
            newMessage.meaning = sticker ? sticker.name : '未知表情';
            console.log("导演/编辑模式保存(Sticker): 将 content 视为 URL，查找到 meaning:", newMessage.meaning);
            found = true;
          }


          if (!found) {
            console.error("导演/编辑模式保存(Sticker): 指令无效或缺少必要字段 (meaning/url/content):", parsedResult);
            continue;
          }
          break;
        }
        case 'transfer':
          newMessage.type = 'transfer';
          newMessage.amount = parsedResult.amount;
          newMessage.note = parsedResult.note;
          break;
        case 'share_link':
          newMessage.type = 'share_link';
          newMessage.title = parsedResult.title;
          newMessage.description = parsedResult.description;
          newMessage.source_name = parsedResult.source_name;
          newMessage.content = parsedResult.content;
          break;
        default:

          Object.assign(newMessage, parsedResult);
          break;
      }

      newMessages.push(newMessage);
    }

    if (newMessages.length === 0) {
      document.getElementById('message-editor-modal').classList.remove('visible');
      return;
    }



    chat.history.splice(messageIndex, 1, ...newMessages);


    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
      chat.history[i].timestamp = reassignTimestamp;
      reassignTimestamp++;
    }

    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
  }



  function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
  }


  function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
  }

 
  async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();


    let contentForEditing;
    if (post.type === 'shuoshuo') {
      contentForEditing = post.content;
    } else {

      const postObject = {
        type: post.type,
        publicText: post.publicText || '',
      };
      if (post.type === 'image_post') {
        postObject.imageUrl = post.imageUrl;
        postObject.imageDescription = post.imageDescription;
      } else if (post.type === 'text_image') {
        postObject.hiddenContent = post.hiddenContent;
      }
      contentForEditing = JSON.stringify(postObject, null, 2);
    }


    const templates = {
      shuoshuo: "在这里输入说说的内容...",
      image: {
        type: 'image_post',
        publicText: '',
        imageUrl: 'https://...',
        imageDescription: ''
      },
      text_image: {
        type: 'text_image',
        publicText: '',
        hiddenContent: ''
      }
    };

    const helpersHtml = `
                <div class="format-helpers">
                    <button class="format-btn" data-type="text">说说</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片动态</button>
                    <button class="format-btn" data-template='${JSON.stringify(templates.text_image)}'>文字图</button>
                </div>
            `;

    const newContent = await showCustomPrompt(
      '编辑动态',
      '在此修改内容...',
      contentForEditing,
      'textarea',
      helpersHtml
    );



    setTimeout(() => {
      const shuoshuoBtn = document.querySelector('#custom-modal-body .format-btn[data-type="text"]');
      if (shuoshuoBtn) {
        shuoshuoBtn.addEventListener('click', () => {
          const input = document.getElementById('custom-prompt-input');
          input.value = templates.shuoshuo;
          input.focus();
        });
      }
    }, 100);

    if (newContent !== null) {
      await saveEditedPost(postIdToEdit, newContent);
    }
  }

  
  async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();


    try {
      const parsed = JSON.parse(trimmedContent);

      post.type = parsed.type || 'image_post';
      post.publicText = parsed.publicText || '';
      post.imageUrl = parsed.imageUrl || '';
      post.imageDescription = parsed.imageDescription || '';
      post.hiddenContent = parsed.hiddenContent || '';
      post.content = '';
    } catch (e) {

      post.type = 'shuoshuo';
      post.content = trimmedContent;

      post.publicText = '';
      post.imageUrl = '';
      post.imageDescription = '';
      post.hiddenContent = '';
    }

    await db.qzonePosts.put(post);
    await renderQzonePosts();
    await showCustomAlert('成功', '动态已更新！');
  }

 
  async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;

    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";

    try {
      await navigator.clipboard.writeText(textToCopy);
      await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
      await showCustomAlert('复制失败', '无法访问剪贴板。');
    }

    hidePostActions();
  }


  let selectedContacts = new Set();

  async function openContactPickerForGroupCreate() {

    const choice = await showChoiceModal('创建群聊', [{
        text: '创建普通群聊 (我参与)',
        value: 'normal'
      },
      {
        text: '创建旁观单聊 (2人聊天)', 
        value: 'spectator_private'
      },
      {
        text: '创建旁观群聊 (多人围观)',
        value: 'spectator'
      }
    ]);

    if (choice === 'normal') {

      selectedContacts.clear();
      const confirmBtn = document.getElementById('confirm-contact-picker-btn');
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.addEventListener('click', handleCreateGroup);
      await renderContactPicker();
      showScreen('contact-picker-screen');

    } else if (choice === 'spectator') {

      openSpectatorGroupCreator();
    
    } else if (choice === 'spectator_private') {
        
      openSpectatorPrivateCreator();
    }
  }




  async function openSpectatorGroupCreator() {
    currentSpectatorMode = 'group';
    selectedContacts.clear();


    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup);


    await renderSpectatorContactPicker();


    showScreen('contact-picker-screen');
  }

  async function openSpectatorPrivateCreator() {
    currentSpectatorMode = 'private'; 
    selectedContacts.clear();

    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleCreateSpectatorGroup); 

    await renderSpectatorContactPicker();

    showScreen('contact-picker-screen');
  } 
  async function renderSpectatorContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';


    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有任何角色或NPC可以加入群聊。</p>';
      return;
    }


    characters.forEach(contact => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.dataset.contactId = contact.id;
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
        `;
      listEl.appendChild(item);
    });


    npcs.forEach(npc => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.dataset.contactId = npc.id;
      item.dataset.isNpc = "true";
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
      listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
  }

 
  async function handleCreateSpectatorGroup() {
   
    if (currentSpectatorMode === 'private' && selectedContacts.size !== 2) {
      alert("旁观单聊必须选择【正好 2 位】成员。");
      return;
    }
    if (currentSpectatorMode === 'group' && selectedContacts.size < 2) {
      alert("旁观群聊至少需要选择 2 个成员。");
      return;
    }
    

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', 'AI们的茶话会');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray();

    for (const contactId of selectedContacts) {
      const isNpc = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`).dataset.isNpc === "true";

      if (isNpc) {

        const npcData = allNpcs.find(n => n.id === parseInt(contactId));
        if (npcData) {
          members.push({
            id: `npc_${npcData.id}`,
            originalName: npcData.name,
            groupNickname: npcData.name,
            persona: npcData.persona,
            avatar: npcData.avatar || defaultGroupMemberAvatar,
            isNpc: true
          });
        }
      } else {

        const contactChat = state.chats[contactId];
        if (contactChat) {
          members.push({
            id: contactId,
            originalName: contactChat.originalName,
            groupNickname: contactChat.name,
            persona: contactChat.settings.aiPersona,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            isNpc: false
          });
        }
      }
    }

    const newGroupChat = {
      id: newChatId,
      name: groupName.trim(),
      isGroup: true,
      isSpectatorGroup: true,
      members: members,
      settings: {

        maxMemory: 10,
        groupAvatar: defaultGroupAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
      },
      history: [{
        role: 'system',
        content: '[系统指令：这是一个没有用户参与的群聊，请你们根据各自的人设自由地开始对话。]',
        timestamp: Date.now(),
        isHidden: true
      }],
      musicData: {
        totalTime: 0
      }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
  }

  async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';


    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);
    const npcs = await db.npcs.toArray();

    if (characters.length === 0 && npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
      return;
    }


    characters.forEach(contact => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.dataset.contactId = contact.id;
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
        `;
      listEl.appendChild(item);
    });


    npcs.forEach(npc => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';

      item.dataset.contactId = `npc_${npc.id}`;
      item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
        `;
      listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
  }

  function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    
    if (currentSpectatorMode === 'private') {
     
      btn.textContent = `完成(${selectedContacts.size}/2)`;
      btn.disabled = selectedContacts.size !== 2;
    } else {
   
      btn.textContent = `完成(${selectedContacts.size})`;
      btn.disabled = selectedContacts.size < 2;
    }
  }

  async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
      alert("创建群聊至少需要选择2个联系人。");
      return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    const allNpcs = await db.npcs.toArray();

    for (const contactId of selectedContacts) {

      if (contactId.startsWith('npc_')) {
        const npcId = parseInt(contactId.replace('npc_', ''));
        const npcData = allNpcs.find(n => n.id === npcId);
        if (npcData) {
          members.push({
            id: contactId,
            originalName: npcData.name,
            groupNickname: npcData.name,
            persona: npcData.persona,
            avatar: npcData.avatar || defaultGroupMemberAvatar,
            isNpc: true
          });
        }
      } else {
        const contactChat = state.chats[contactId];
        if (contactChat) {
          members.push({
            id: contactId,
            originalName: contactChat.originalName,
            groupNickname: contactChat.name,
            persona: contactChat.settings.aiPersona,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            isNpc: false
          });
        }
      }
    }

    const newGroupChat = {
      id: newChatId,
      name: groupName.trim(),
      isGroup: true,
      members: members,
      settings: {
        myPersona: '我是谁呀。',
        myNickname: '我',
        maxMemory: 10,
        groupAvatar: defaultGroupAvatar,
        myAvatar: defaultMyGroupAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
      },
      history: [],
      musicData: {
        totalTime: 0
      }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);

    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId);
  }




  function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
  }

  function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
      const item = document.createElement('div');
      item.className = 'member-management-item';

      item.innerHTML = `
                    <img src="${member.avatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                    <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
                `;
      listEl.appendChild(item);
    });
  }

  /**
   * 从群聊中移除一个成员
   * @param {string} memberId - 要移除的成员ID
   */
  async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);

    if (memberIndex === -1) return;


    if (chat.members.length <= 2) {
      alert("群聊人数不能少于2人。");
      return;
    }

    const memberName = chat.members[memberIndex].groupNickname;
    const confirmed = await showCustomConfirm(
      '移出成员',
      `确定要将“${memberName}”移出群聊吗？`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      chat.members.splice(memberIndex, 1);
      await db.chats.put(chat);
      renderMemberManagementList();
      document.getElementById('chat-settings-btn').click();
    }
  }

 
  async function openContactPickerForAddMember() {

    const confirmBtn = document.getElementById('confirm-contact-picker-btn');

    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);


    await renderUnifiedContactPicker();


    showScreen('contact-picker-screen');
  }


  async function renderUnifiedContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear();

    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));


    const characters = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));


    const npcs = (await db.npcs.toArray()).filter(n => !existingMemberIds.has(`npc_${n.id}`));

    if (characters.length === 0 && npcs.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的联系人了。</p>';
      document.getElementById('confirm-contact-picker-btn').style.display = 'none';
    } else {
      document.getElementById('confirm-contact-picker-btn').style.display = 'block';


      characters.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.dataset.contactType = 'character';
        item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name} <small style="color:#888;">(角色)</small></span>
            `;
        listEl.appendChild(item);
      });


      npcs.forEach(npc => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = `npc_${npc.id}`;
        item.dataset.contactType = 'npc';
        item.dataset.npcId = npc.id;
        item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
                <span class="name">${npc.name} <small style="color:#007722;">(NPC)</small></span>
            `;
        listEl.appendChild(item);
      });
    }

    updateContactPickerConfirmButton();
  }



  async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
      alert("请至少选择一个要添加的联系人。");
      return;
    }

    const chat = state.chats[state.activeChatId];
    const allNpcs = await db.npcs.toArray();

    for (const contactId of selectedContacts) {
      const itemEl = document.querySelector(`.contact-picker-item[data-contact-id="${contactId}"]`);
      if (!itemEl) continue;

      const contactType = itemEl.dataset.contactType;

      if (contactType === 'character') {
        const contactChat = state.chats[contactId];
        if (contactChat) {
          chat.members.push({
            id: contactId,
            originalName: contactChat.originalName,
            groupNickname: contactChat.name,
            persona: contactChat.settings.aiPersona,

            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            isNpc: false
          });
        }
      } else if (contactType === 'npc') {
        const npcId = parseInt(itemEl.dataset.npcId);
        const npcData = allNpcs.find(n => n.id === npcId);
        if (npcData) {


          chat.members.push({
            id: `npc_${npcId}`,
            originalName: npcData.name,
            groupNickname: npcData.name,
            persona: npcData.persona,
            avatar: npcData.avatar || defaultGroupMemberAvatar,
            isNpc: true
          });
        }
      }
    }

    await db.chats.put(chat);


    openMemberManagementScreen();
  }



  function createNewMemberInGroup() {

    isAddingNpcToGroup = true;

    openNpcEditor(null);
  }



  function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
      const now = Date.now();
      const distance = endTime - now;

      if (distance < 0) {
        clearInterval(timerId);
        element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
        return;
      }

      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((distance % (1000 * 60)) / 1000);

      const minStr = String(minutes).padStart(2, '0');
      const secStr = String(seconds).padStart(2, '0');

      element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
  }

  function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
      clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
  }



 
  async function showWaimaiDetails(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const message = chat.history.find(m => m.timestamp === timestamp);

    if (!message || !['waimai_request', 'waimai_order'].includes(message.type)) {
      console.error("showWaimaiDetails: 找不到消息或消息类型不正确", timestamp);
      return;
    }

    let detailsHtml = '';

    if (message.type === 'waimai_request') {

      let statusText;
      switch (message.status) {
        case 'paid':
          const payerName = message.paidBy || '对方';
          const payerDisplayName = getDisplayNameInGroup(chat, payerName);
          statusText = `由 ${payerDisplayName} 为您代付成功`;
          break;
        case 'rejected':
          statusText = '代付请求已被拒绝';
          break;
        default:
          statusText = '等待对方处理';
          break;
      }
      detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>商品:</strong> ${message.productInfo}<br>
                <strong>金额:</strong> ¥${Number(message.amount).toFixed(2)}<br>
                <strong>状态:</strong> ${statusText}
            </div>
        `;
    } else if (message.type === 'waimai_order') {

      let senderDisplayName;
      let recipientDisplayName;

      if (chat.isGroup) {

        senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
        recipientDisplayName = getDisplayNameInGroup(chat, message.recipientName);
      } else {

        if (message.role === 'user') {

          senderDisplayName = chat.settings.myNickname || '我';
          recipientDisplayName = chat.name;
        } else {

          senderDisplayName = chat.name;
          recipientDisplayName = chat.settings.myNickname || '我';
        }
      }


      detailsHtml = `
            <div style="text-align: left; font-size: 15px; line-height: 1.8;">
                <strong>订单类型:</strong> 为TA点单<br>
                <strong>赠送方:</strong> ${senderDisplayName}<br>
                <strong>接收方:</strong> ${recipientDisplayName}<br>
                <strong>商品:</strong> ${message.productInfo}<br>
                <strong>金额:</strong> ¥${Number(message.amount).toFixed(2)}
            </div>
        `;
    }

    await showCustomAlert("订单详情", detailsHtml);
  }


  async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;


    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;


    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    if (choice === 'paid') {
      const success = await processTransaction(originalMessage.amount, 'expense', `帮付外卖-${originalMessage.senderName}`);
      
      if (!success) return; // 余额不足，不改变状态，直接返回

      originalMessage.status = choice;
      originalMessage.paidBy = myNickname;
      systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
      originalMessage.status = choice;

      systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }


    const systemNote = {
      role: 'system',
      content: systemContent,
      timestamp: Date.now(),
      isHidden: true
    };
    chat.history.push(systemNote);


    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
  }

  let videoCallState = {
    isActive: false,
    isAwaitingResponse: false,
    isGroupCall: false,
    activeChatId: null,
    initiator: null,
    startTime: null,
    participants: [],
    isUserParticipating: true,

    callHistory: [],
    preCallContext: ""
  };

  let callTimerInterval = null;


  async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true;


    if (chat.isGroup) {
      document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
      document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
      document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
      document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
    showScreen('outgoing-call-screen');


    const requestMessage = {
      role: 'system',
      content: chat.isGroup ?
        `[系统提示：用户 (${chat.settings.myNickname || '我'}) 发起了群视频通话请求。请你们各自决策，并使用 "group_call_response" 指令，设置 "decision" 为 "join" 或 "decline" 来回应。]` :
        `[系统提示：用户向你发起了视频通话请求。请根据你的人设，使用 "video_call_response" 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
      timestamp: Date.now(),
      isHidden: true,
    };
    chat.history.push(requestMessage);
    await db.chats.put(chat);


    await triggerAiResponse();
  }


  function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    videoCallState.isActive = true;
    videoCallState.isAwaitingResponse = false;
    videoCallState.startTime = Date.now();
    videoCallState.callHistory = [];


    const preCallHistory = chat.history.slice(-10);
    videoCallState.preCallContext = preCallHistory.map(msg => {
      const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
      return `${sender}: ${String(msg.content).substring(0, 50)}...`;
    }).join('\n');


    updateParticipantAvatars();

    document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
    showScreen('video-call-screen');

    document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
    document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallTimer, 1000);
    updateCallTimer();

    triggerAiInCallAction();
  }

function minimizeVideoCall() {
    if (!videoCallState.isActive) return;

   
    document.getElementById('video-call-restore-btn').style.display = 'flex';

  
    showScreen('chat-interface-screen'); 
    
 
    console.log("视频通话已最小化。");
}


function restoreVideoCall() {
    if (!videoCallState.isActive) return;

    
    document.getElementById('video-call-restore-btn').style.display = 'none';

    
    showScreen('video-call-screen');
    console.log("视频通话已恢复。");
}  
  async function endVideoCall() {
    if (!videoCallState.isActive) return;
    document.getElementById('video-call-restore-btn').style.display = 'none';
    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {

      const participantsData = [];
      if (videoCallState.isGroupCall) {
        videoCallState.participants.forEach(p => participantsData.push({
          name: p.originalName,
          avatar: p.avatar
        }));
        if (videoCallState.isUserParticipating) {
          participantsData.unshift({
            name: chat.settings.myNickname || '我',
            avatar: chat.settings.myAvatar || defaultMyGroupAvatar
          });
        }
      } else {
        participantsData.push({
          name: chat.name,
          avatar: chat.settings.aiAvatar || defaultAvatar
        });
        participantsData.unshift({
          name: '我',
          avatar: chat.settings.myAvatar || defaultAvatar
        });
      }

      const callRecord = {
        chatId: videoCallState.activeChatId,
        timestamp: Date.now(),
        duration: duration,
        participants: participantsData,
        transcript: [...videoCallState.callHistory]
      };
      await db.callRecords.add(callRecord);
      console.log("通话记录已保存:", callRecord);


      let summaryMessage = {
        role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
        content: endCallText,
        timestamp: Date.now(),
      };
      if (chat.isGroup && summaryMessage.role === 'assistant') {
        summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
      }
      chat.history.push(summaryMessage);






      const callTranscriptForAI = videoCallState.callHistory.map(h => {
        const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : h.senderName;
        return `${sender}: ${h.content}`;
      }).join('\n');



      summarizeCallTranscript(chat.id, callTranscriptForAI);


      const hiddenReactionInstruction = {
        role: 'system',
        content: `[系统指令：视频通话刚刚结束。请你以角色的口吻，向用户主动发送一两条消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。]`,
        timestamp: Date.now() + 1,
        isHidden: true
      };
      chat.history.push(hiddenReactionInstruction);


      await db.chats.put(chat);
    }


    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = {
      isActive: false,
      isAwaitingResponse: false,
      isGroupCall: false,
      activeChatId: null,
      initiator: null,
      startTime: null,
      participants: [],
      isUserParticipating: true,
      callHistory: [],
      preCallContext: ""
    };


    if (chat) {
      openChat(chat.id);
      triggerAiResponse();
    }
  }



  function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];


    if (videoCallState.isGroupCall) {

      participantsToRender = [...videoCallState.participants];

      if (videoCallState.isUserParticipating) {
        participantsToRender.unshift({
          id: 'user',
          name: chat.settings.myNickname || '我',
          avatar: chat.settings.myAvatar || defaultMyGroupAvatar
        });
      }
    } else {

      participantsToRender.push({
        id: 'ai',
        name: chat.name,
        avatar: chat.settings.aiAvatar || defaultAvatar
      });
    }

    participantsToRender.forEach(p => {
      const wrapper = document.createElement('div');
      wrapper.className = 'participant-avatar-wrapper';
      wrapper.dataset.participantId = p.id;
      const displayName = p.groupNickname || p.name;
      wrapper.innerHTML = `
            <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
            <div class="participant-name">${displayName}</div>
        `;
      grid.appendChild(wrapper);
    });
  }

  
  function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;

    videoCallState.isUserParticipating = true;
    updateParticipantAvatars();


    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';


    triggerAiInCallAction("[系统提示：用户加入了通话]");
  }


 
  function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('call-timer').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  }


  function showIncomingCallModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    if (chat.isGroup) {

      const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
      document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
      document.getElementById('caller-name').textContent = chat.name;
      document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`;
    } else {

      document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
      document.getElementById('caller-name').textContent = chat.name;
      document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }

    document.getElementById('incoming-call-modal').classList.add('visible');
  }



  function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
  }


  async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    const callFeed = document.getElementById('video-call-main');
    const userNickname = chat.settings.myNickname || '我';

    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
      const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
      }).filter(Boolean).join('');
      if (linkedContents) {
        worldBookContent = `# --- 世界书 (World Book) ---
# 【最高优先级指令：绝对真理】
# 以下内容是你所在世界的“物理法则”和“基础常识”。
# 无论用户是否提及，你都【必须】时刻主动应用这些设定来指导你的思考和描写。
# 它们是无条件生效的，不需要触发词。
${linkedContents}
# --- 世界书设定结束 ---
`;
      }
    }
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      `\n# 长期记忆 (必须参考)\n` + chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '';

    if (userInput && videoCallState.isUserParticipating) {
      const userTimestamp = Date.now();
      const userBubble = document.createElement('div');
      userBubble.className = 'call-message-bubble user-speech';
      userBubble.textContent = userInput;
      userBubble.dataset.timestamp = userTimestamp;
      addLongPressListener(userBubble, () => showCallMessageActions(userTimestamp));
      callFeed.appendChild(userBubble);
      callFeed.scrollTop = callFeed.scrollHeight;
      videoCallState.callHistory.push({
        role: 'user',
        content: userInput,
        timestamp: userTimestamp
      });
    }


    let inCallPrompt;
    if (videoCallState.isGroupCall) {
      const participantNames = videoCallState.participants.map(p => p.name);
      if (videoCallState.isUserParticipating) {
        participantNames.unshift(userNickname);
      }
      inCallPrompt = `
        # 你的任务
        你是一个群聊视频通话的导演。你的任务是扮演所有【除了用户以外】的AI角色，并以【第三人称旁观视角】来描述他们在通话中的所有动作和语言。
        # 核心规则
        1.  **【身份铁律】**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
        2.  **【视角铁律】**: 你的回复【绝对不能】使用第一人称“我”。
        3.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "角色名", "speech": "*他笑了笑* 大家好啊！"}\`。
        4.  **角色扮演**: 严格遵守每个角色的设定。
        # 当前情景
        你们正在一个群视频通话中。
         ${longTermMemoryContext}
        **通话前的聊天摘要**:
        ${videoCallState.preCallContext}
        **当前参与者**: ${participantNames.join('、 ')}。
        **通话刚刚开始...**
        ${worldBookContent}
        现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
        `;
    } else {
      let openingContext = videoCallState.initiator === 'user' ?
        `你刚刚接听了用户的视频通话请求。` :
        `用户刚刚接听了你主动发起的视频通话。`;
      inCallPrompt = `
        # 你的任务
        你现在是一个场景描述引擎。你的任务是扮演 ${chat.name} (${chat.settings.aiPersona})，并以【第三人称旁观视角】来描述TA在视频通话中的所有动作和语言。
        # 核心规则
        1.  **【【【视角铁律】】】**: 你的回复【绝对不能】使用第一人称“我”。必须使用第三人称，如“他”、“她”、或直接使用角色名“${chat.name}”。
        2.  **格式**: 你的回复【必须】是一段描述性的文本。
        # 当前情景
        你正在和用户（${userNickname}，人设: ${chat.settings.myPersona}）进行视频通话。
        ${longTermMemoryContext}
        **${openingContext}**
        **通话前的聊天摘要 (这是你们通话的原因，至关重要！)**:
        ${videoCallState.preCallContext}
        现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
        `;
    }

    
    const messagesForApi = [{
        role: 'system',
        content: inCallPrompt
      },
      ...videoCallState.callHistory.map(h => ({
        role: h.role,
        content: h.content
      }))
    ];

    if (videoCallState.callHistory.length === 0) {
      const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
      messagesForApi.push({
        role: 'user',
        content: firstLineTrigger
      });
    }

    try {
      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi)
      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: state.globalSettings.apiTemperature || 0.8
        })
      });
      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

      const connectingElement = callFeed.querySelector('em');
      if (connectingElement) connectingElement.remove();
      if (videoCallState.isGroupCall) {
        const speechArray = parseAiResponse(aiResponse);
        speechArray.forEach(turn => {
          if (!turn.name || turn.name === userNickname || !turn.speech) return;
          const aiTimestamp = Date.now() + Math.random();
          const aiBubble = document.createElement('div');
          aiBubble.className = 'call-message-bubble ai-speech';
          aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
          aiBubble.dataset.timestamp = aiTimestamp;
          addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp));
          callFeed.appendChild(aiBubble);
          videoCallState.callHistory.push({
            role: 'assistant',
            content: `${turn.name}: ${turn.speech}`,
            timestamp: aiTimestamp
          });

          const speaker = videoCallState.participants.find(p => p.name === turn.name);
          if (speaker) {
            const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
            if (speakingAvatar) {
              speakingAvatar.classList.add('speaking');
              setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
            }
          }
        });
      } else {
        const aiTimestamp = Date.now();
        const aiBubble = document.createElement('div');
        aiBubble.className = 'call-message-bubble ai-speech';
        aiBubble.textContent = aiResponse;
        aiBubble.dataset.timestamp = aiTimestamp;
        addLongPressListener(aiBubble, () => showCallMessageActions(aiTimestamp));
        callFeed.appendChild(aiBubble);
        videoCallState.callHistory.push({
          role: 'assistant',
          content: aiResponse,
          timestamp: aiTimestamp
        });
        const enableTts = chat.settings.enableTts !== false;
        const voiceId = chat.settings.minimaxVoiceId;

        if (enableTts && voiceId) {
            playVideoCallPureTTS(aiResponse, voiceId);
        }
        // ===============================================

        // ================= 头像动画修复 =================
        // 原因：querySelector 默认只选第一个元素（通常是用户自己），导致AI说话时用户头像在动，或者样式错位。
        // 修复：增加 [data-participant-id="ai"] 精确查找对方的头像。
        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="ai"] .participant-avatar`);
        
        if (speakingAvatar) {
          speakingAvatar.classList.add('speaking');
          // 动态计算说话时长：每字200ms，最长5秒
          const speakTime = Math.min(aiResponse.length * 200, 5000); 
          setTimeout(() => speakingAvatar.classList.remove('speaking'), speakTime);
        }
      }

      callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
      const errorBubble = document.createElement('div');
      errorBubble.className = 'call-message-bubble ai-speech';
      errorBubble.style.color = '#ff8a80';
      errorBubble.textContent = `[ERROR: ${error.message}]`;
      callFeed.appendChild(errorBubble);
      callFeed.scrollTop = callFeed.scrollHeight;
      videoCallState.callHistory.push({
        role: 'assistant',
        content: `[ERROR: ${error.message}]`
      });
    }
  }



  function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
  }



  




  async function handleUserPat(chatId, characterOriginalName) {
    const chat = state.chats[chatId];
    if (!chat) return;


    let displayNameForUI;
    if (chat.isGroup) {

      displayNameForUI = getDisplayNameInGroup(chat, characterOriginalName);
    } else {

      displayNameForUI = chat.name;
    }

    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');


    const suffix = await showCustomPrompt(
      `你拍了拍 “${displayNameForUI}”`,
      "（可选）输入后缀",
      "",
      "text"
    );

    if (suffix === null) return;

    // 获取用户昵称，如果是 {{user}} 则使用 "你"
    let myNickname = state.qzoneSettings.nickname;
    if (!myNickname || myNickname === '{{user}}') {
      myNickname = '你';
    }
    
    // 如果是群聊，使用群昵称
    if (chat.isGroup) {
      myNickname = chat.settings.myNickname || '你';
    }



    const visibleMessageContent = `${myNickname} 拍了拍 “${displayNameForUI}” ${suffix.trim()}`;
    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: visibleMessageContent,
      timestamp: Date.now()
    };
    chat.history.push(visibleMessage);


    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterOriginalName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: Date.now() + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
      appendMessage(visibleMessage, chat);
    }
    await renderChatList();
  }

  // 新增：处理用户拍自己的功能
  async function handleUserPatSelf(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');

    // 获取用户昵称，如果是 {{user}} 则使用 "你"
    let myNickname = state.qzoneSettings.nickname;
    if (!myNickname || myNickname === '{{user}}') {
      myNickname = '你';
    }
    
    // 如果是群聊，使用群昵称
    if (chat.isGroup) {
      myNickname = chat.settings.myNickname || '你';
    }

    // 弹出输入框让用户输入拍自己的后缀
    const suffix = await showCustomPrompt(
      `${myNickname} 拍了拍自己`,
      "输入拍一拍后缀",
      "",
      "text"
    );

    if (suffix === null) return;

    // 创建可见的拍一拍消息
    const visibleMessageContent = `${myNickname} 拍了拍自己 ${suffix.trim()}`;
    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: visibleMessageContent,
      timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 创建隐藏的系统提示，让AI知道用户拍了自己
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍自己${suffix.trim()}。你可以对此作出回应或评论。]`;
    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: Date.now() + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
      appendMessage(visibleMessage, chat);
    }
    await renderChatList();
  }

  let activeCallMessageTimestamp = null;
  let isFrameManagementMode = false;
  let selectedFrames = new Set();

  function showCallMessageActions(timestamp) {
    activeCallMessageTimestamp = timestamp;
    document.getElementById('call-message-actions-modal').classList.add('visible');
  }


  function hideCallMessageActions() {
    document.getElementById('call-message-actions-modal').classList.remove('visible');
    activeCallMessageTimestamp = null;
  }

 
  async function openCallMessageEditor() {
    if (!activeCallMessageTimestamp) return;

    const timestampToEdit = activeCallMessageTimestamp;
    const message = videoCallState.callHistory.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideCallMessageActions();

    let contentForEditing = message.content;

    if (videoCallState.isGroupCall && message.role === 'assistant') {
      const parts = message.content.split(': ');
      if (parts.length > 1) {
        contentForEditing = parts.slice(1).join(': ');
      }
    }

    const newContent = await showCustomPrompt(
      '编辑通话消息',
      '在此修改内容...',
      contentForEditing,
      'textarea'
    );

    if (newContent !== null) {
      await saveEditedCallMessage(timestampToEdit, newContent);
    }
  }

  
  async function saveEditedCallMessage(timestamp, newContent) {
    const message = videoCallState.callHistory.find(m => m.timestamp === timestamp);
    if (message) {
      let finalContent = newContent;

      if (videoCallState.isGroupCall && message.role === 'assistant') {
        const parts = message.content.split(': ');
        const senderName = parts[0];
        finalContent = `${senderName}: ${newContent}`;
      }
      message.content = finalContent;


      const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestamp}"]`);
      if (messageBubble) {
        if (videoCallState.isGroupCall && message.role === 'assistant') {
          const parts = message.content.split(': ');
          const senderName = parts[0];
          messageBubble.innerHTML = `<strong>${senderName}:</strong> ${newContent}`;
        } else {
          messageBubble.textContent = newContent;
        }
      }
    }
    await showCustomAlert('成功', '通话消息已更新！');
  }

  
  async function deleteCallMessage() {
    if (!activeCallMessageTimestamp) return;

    const confirmed = await showCustomConfirm('删除消息', '确定要删除这条通话消息吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      const timestampToDelete = activeCallMessageTimestamp;
      hideCallMessageActions();


      const messageIndex = videoCallState.callHistory.findIndex(m => m.timestamp === timestampToDelete);
      if (messageIndex > -1) {
        videoCallState.callHistory.splice(messageIndex, 1);
      }


      const messageBubble = document.querySelector(`.call-message-bubble[data-timestamp="${timestampToDelete}"]`);
      if (messageBubble) {
        messageBubble.remove();
      }
    } else {
      hideCallMessageActions();
    }
  }


 
 

  
 

async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const originalMessage = chat.history[messageIndex];
    
    // 防止重复点击
    if (originalMessage.status && originalMessage.status !== 'pending') {
        hideTransferActionModal();
        return;
    }

    // --- 核心修复：确保从历史消息里读出来的金额是数字 ---
    let transferAmount = parseFloat(originalMessage.amount);
    if (isNaN(transferAmount)) {
        // 如果读取失败，尝试去 content 字段里找（防止某些旧数据的 amount 字段丢失）
        console.warn("消息中 amount 字段无效，尝试修复...");
        transferAmount = 0; 
    }

    originalMessage.status = choice;
    let systemContent;

    if (choice === 'declined') {
        // 拒收逻辑
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true,
            amount: transferAmount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
        
    } else {
        // --- 接收逻辑 ---
        if (transferAmount > 0) {
            // 调用上面修复过的记账函数
            const success = await processTransaction(transferAmount, 'income', `收到转账-${originalMessage.senderName}`);
            
            if (success) {
                await showCustomAlert("收款成功", `已存入余额：+ ¥${transferAmount.toFixed(2)}`);
                
                // ★★★ 新增这部分逻辑 (生成“已收款”卡片) ★★★
                const receivedMessage = {
                    role: 'user',        // 扮演用户发送
                    type: 'transfer',    // 复用转账卡片样式
                    isReceived: true,    // 标记为“已收款”卡片
                    amount: transferAmount,
                    note: '已收款',
                    senderName: '我',
                    receiverName: originalMessage.senderName, // 钱来自于谁
                    timestamp: Date.now() // 使用当前时间
                };
                chat.history.push(receivedMessage);
                // ★★★ 新增结束 ★★★
            } else {
                // 如果 processTransaction 返回 false，说明出问题了
                alert("警告：金额入账失败，请检查控制台日志！");
            }
        } else {
            alert("无法收款：该转账金额无效 (0元或数据损坏)。");
        }
        
        systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
    }

    // 更新聊天记录
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    hideTransferActionModal();
    renderChatInterface(state.activeChatId);
    renderChatList();
}



  function clearQzoneReplyContext(postContainer) {
    currentQzoneReplyContext = null;
    if (postContainer) {

      const input = postContainer.querySelector('.comment-input');
      if (input) {
        input.placeholder = '友善的评论是交流的起点';
      }
    }
  }



  async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';


    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();

    if (allMemories.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
      return;
    }


    allMemories.sort((a, b) => {
      const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
      const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
      if (aIsActiveCountdown && !bIsActiveCountdown) return -1;
      if (!aIsActiveCountdown && bIsActiveCountdown) return 1;
      if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate;
      return 0;
    });


    allMemories.forEach(item => {
      let card;

      if (item.type === 'countdown' && item.targetDate > Date.now()) {
        card = createCountdownCard(item);
      } else {
        card = createMemoryCard(item);
      }
      listEl.appendChild(card);
    });


    startAllCountdownTimers();
  }


  
  function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;

    let titleHtml, contentHtml;

    if (memory.type === 'countdown' && memory.targetDate) {
      titleHtml = `[约定达成] ${memory.description}`;

      contentHtml = parseMarkdown(`在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`).replace(/\n/g, '<br>');
    } else {
      let authorDisplayName = '我们的回忆';
      if (memory.authorId) {
        const authorChat = state.chats[memory.authorId];
        if (authorChat) {
          authorDisplayName = authorChat.name;
        } else {
          authorDisplayName = memory.authorName || '一位朋友';
        }
      } else if (memory.authorName) {
        authorDisplayName = memory.authorName;
      }

      titleHtml = `${authorDisplayName} 的日记`;

      contentHtml = parseMarkdown(memory.description);
    }

    card.innerHTML = `
                <div class="header">
                    <div class="date">${dateString}</div>
                    <div class="author">${titleHtml}</div>
                </div>
                <div class="content">${contentHtml}</div>
            `;
    addLongPressListener(card, async () => {
      const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        await db.memories.delete(memory.id);
        renderMemoriesScreen();
      }
    });
    return card;
  }


  function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';


    const targetDate = new Date(countdown.targetDate);


    const targetDateString = targetDate.toLocaleString('zh-CN', {
      dateStyle: 'full',
      timeStyle: 'short'
    });

    card.innerHTML = `
                <div class="title">${countdown.description}</div>
                <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
                <div class="target-date">目标时间: ${targetDateString}</div>
            `;
    addLongPressListener(card, async () => {
      const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        await db.memories.delete(countdown.id);
        renderMemoriesScreen();
      }
    });
    return card;
  }



  let activeCountdownTimers = [];


  function startAllCountdownTimers() {

    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
      const targetTimestamp = parseInt(timerEl.dataset.targetDate);


      let timerId;

      const updateTimer = () => {
        const now = Date.now();
        const distance = targetTimestamp - now;

        if (distance < 0) {
          timerEl.textContent = "约定达成！";

          clearInterval(timerId);
          setTimeout(() => renderMemoriesScreen(), 2000);
          return;
        }
        const days = Math.floor(distance / (1000 * 60 * 60 * 24));
        const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
      };

      updateTimer();


      timerId = setInterval(updateTimer, 1000);


      activeCountdownTimers.push(timerId);
    });
  }



  async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      await showCustomAlert("配置错误", "API设置不完整，无法继续。");
      return;
    }

    const contextSummary = chat.history
      .slice(-5)
      .map(msg => {
        const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
      })
      .join('\n');

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      `\n# 你们的过往记忆 (作为情感基础)\n` + chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') :
      '';
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
      const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';

        const formattedEntries = worldBook.content.map(entry => {
          let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
          
          entryString += `**内容:**\n${entry.content}`;
          return entryString;
        }).join('\n');

        return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
      }).filter(Boolean).join('');

      if (linkedContents) {
        worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
      }
    }

    const systemPrompt = `
        # 你的任务
        你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
        现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
        # 你的角色设定
        ${chat.settings.aiPersona}
        ${worldBookContent}
        ${longTermMemoryContext}
        # 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
        ${contextSummary}
        # 指令格式
        你的回复【必须】是一个JSON对象，格式如下：
        \`\`\`json
        {
          "decision": "apply",
          "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
        }
        \`\`\`
        `;

    try {

      const messagesForApi = [{
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: "请根据以上设定开始你的决策。"
        }
      ];

      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: messagesForApi,
          temperature: state.globalSettings.apiTemperature || 0.9,
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
      }

      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
      rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
      const cleanedContent = rawContent.trim();
      
      let responseObj;

      try {
        
        responseObj = JSON.parse(cleanedContent);
      } catch (parseError) {
       
        console.error("解析好友申请的AI响应失败:", parseError);
       
        throw new Error(`AI未返回有效的JSON。API实际返回内容: "${cleanedContent}"`);
      }

      if (responseObj.decision === 'apply' && responseObj.reason) {
        chat.relationship.status = 'pending_user_approval';
        chat.relationship.applicationReason = responseObj.reason;
        state.chats[chatId] = chat;
        renderChatList();
        await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);
      } else {
        await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
      }
    } catch (error) {
      await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
      chat.relationship.status = 'blocked_by_user';
      chat.relationship.blockedTimestamp = Date.now();
    } finally {
      await db.chats.put(chat);
      renderChatInterface(chatId);
    }
  }




  function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
      openRedPacketModal();
    } else {

      document.getElementById('transfer-modal').classList.add('visible');
    }
  }


  function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];


    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';


    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';

    chat.members.forEach(member => {
      const option = document.createElement('option');

      option.value = member.originalName;
      option.textContent = member.groupNickname;
      receiverSelect.appendChild(option);
    });



    document.getElementById('rp-tab-group').click();

    modal.classList.add('visible');
  }


  async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
      alert("请输入有效的总金额！");
      return;
    }
    if (isNaN(count) || count <= 0) {
      alert("请输入有效的红包个数！");
      return;
    }
    if (amount / count < 0.01) {
      alert("单个红包金额不能少于0.01元！");
      return;
    }

    const myNickname = chat.settings.myNickname || '我';

    const allocatedAmounts = generateRandomPacketAmounts(amount, count); 
    const success = await processTransaction(amount, 'expense', `发出群红包(拼手气)`);
    if (!success) return;
    const newPacket = {
      role: 'user',
      senderName: myNickname,
      type: 'red_packet',
      packetType: 'lucky',
      timestamp: Date.now(),
      totalAmount: amount,
      count: count,
      greeting: greeting || '恭喜发财，大吉大利！',
      allocatedAmounts: allocatedAmounts, 
      unclaimedAmounts: [...allocatedAmounts], 
      claimedBy: {},
      isFullyClaimed: false,
    };

    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
  }

  
  async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
      alert("请输入有效的金额！");
      return;
    }
    if (!receiverName) {
      alert("请选择一个接收人！");
      return;
    }

    const myNickname = chat.settings.myNickname || '我';
    const success = await processTransaction(amount, 'expense', `发出专属红包-给${receiverName}`);
    if (!success) return;
    const newPacket = {
      role: 'user',
      senderName: myNickname,
      type: 'red_packet',
      packetType: 'direct',
      timestamp: Date.now(),
      totalAmount: amount,
      count: 1,
      greeting: greeting || '给你准备了一个红包',
      receiverName: receiverName,
      claimedBy: {},
      isFullyClaimed: false,
    };

    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
  }


  let isPacketProcessing = false;

async function handlePacketClick(timestamp) {
    // 1. 如果锁是锁着的，直接退出，什么都不做
    if (isPacketProcessing) {
        console.log("正在处理红包，拦截了重复点击");
        return;
    }

    // 2. 上锁
    isPacketProcessing = true;

    try {
        const currentChatId = state.activeChatId;
        
        // 重新从数据库拉取最新数据（防止内存数据滞后）
        const freshChat = await db.chats.get(currentChatId);
        if (!freshChat) return;

        state.chats[currentChatId] = freshChat;
        const packet = freshChat.history.find(m => m.timestamp === timestamp);
        if (!packet) return;

        const myOriginalName = state.qzoneSettings.nickname || '{{user}}';
        // 确保 claimedBy 是个对象，防止报错
        if (!packet.claimedBy) packet.claimedBy = {}; 
        const hasClaimed = packet.claimedBy[myOriginalName];

        // 检查是否已经领过，或者是否已领完
        // 注意：这里加了更严格的检查
        if ((packet.packetType === 'direct' && packet.receiverName !== myOriginalName && Object.keys(packet.claimedBy).length > 0) || 
            packet.isFullyClaimed || 
            hasClaimed) {
            showRedPacketDetails(packet);
            return;
        }

        // 执行领取逻辑
        const claimedAmount = await handleOpenRedPacket(packet);

        if (claimedAmount !== null) {
            await renderChatInterface(currentChatId);
            await showCustomAlert("恭喜！", `你领取了 ${getDisplayNameInGroup(freshChat, packet.senderName)} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        if (updatedPacket) {
            showRedPacketDetails(updatedPacket);
        }

    } catch (error) {
        console.error("红包处理出错:", error);
        alert("领取出错，请稍后重试");
    } finally {
        // 3. 无论成功还是失败，1秒后解锁
        // 延迟解锁是为了防止极快的手速连点
        setTimeout(() => {
            isPacketProcessing = false;
        }, 1000);
    }
}




 
  async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    let timestamp = Date.now();
    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';

    // 检查是否领完
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
      packet.isFullyClaimed = true;
      await db.chats.put(chat);
      await showCustomAlert("手慢了", "红包已被领完！");
      return null;
    }

    // --- 计算金额逻辑 ---
    let claimedAmount = 0;
    if (packet.packetType === 'lucky') {
      if (packet.unclaimedAmounts && packet.unclaimedAmounts.length > 0) {
        claimedAmount = packet.unclaimedAmounts.pop(); 
      } else { 
        // 兼容旧数据
        const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        if (remainingCount === 1) {
          claimedAmount = remainingAmount;
        } else {
          const min = 0.01;
          const max = remainingAmount - (remainingCount - 1) * min;
          claimedAmount = Math.random() * (max - min) + min;
        }
      }
    } else { 
      claimedAmount = packet.totalAmount;
    }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));
    
    // 记录领取
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myOriginalName] = claimedAmount;

    // 更新状态
    const isNowFullyClaimed = (packet.unclaimedAmounts && packet.unclaimedAmounts.length === 0) || (Object.keys(packet.claimedBy).length >= packet.count);
    if (isNowFullyClaimed) {
      packet.isFullyClaimed = true;
    }

    // 生成聊天消息
    const myDisplayName = getDisplayNameInGroup(chat, myOriginalName);
    const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);

    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: `你领取了 ${senderDisplayName} 的红包`,
      timestamp: timestamp++
    };
    chat.history.push(visibleMessage);

    // 生成给AI看的隐藏提示
    let hiddenMessageContent;
    if (isNowFullyClaimed) {
      const finishedMessage = {
        role: 'system',
        type: 'pat_message',
        content: `${senderDisplayName} 的红包已被领完`,
        timestamp: timestamp++
      };
      chat.history.push(finishedMessage);

      let luckyKing = { name: '', amount: -1 };
      if (packet.packetType === 'lucky' && packet.count > 1) {
        Object.entries(packet.claimedBy).forEach(([name, amount]) => {
          if (amount > luckyKing.amount) {
            luckyKing = { name, amount };
          }
        });
      }
      const luckyKingDisplayName = luckyKing.name ? getDisplayNameInGroup(chat, luckyKing.name) : '无';
      hiddenMessageContent = `[系统提示：用户 (${myDisplayName}) 领取了最后一个红包。红包已被领完，手气王是 ${luckyKingDisplayName}！请对此事件发表评论。]`;

    } else {
      hiddenMessageContent = `[系统提示：用户 (${myDisplayName}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;
    }

    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: timestamp++,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);

    // 【核心修复】把抢到的钱存入钱包
    if (claimedAmount > 0) {
        // 这里的 'income' 会增加余额，description 会显示在账单列表里
        await processTransaction(claimedAmount, 'income', `红包-${senderDisplayName}`);
    }

    return claimedAmount;
}



 
  async function showRedPacketDetails(packet) {
    if (!packet) {
      console.error("showRedPacketDetails收到了无效的packet对象");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');

    const myOriginalName = state.qzoneSettings.nickname || '{{user}}';

    const senderDisplayName = getDisplayNameInGroup(chat, packet.senderName);
    document.getElementById('rp-details-sender').textContent = senderDisplayName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';

    const myAmountEl = document.getElementById('rp-details-my-amount');

    if (packet.claimedBy && packet.claimedBy[myOriginalName]) {
      myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myOriginalName].toFixed(2);
      myAmountEl.style.display = 'block';
    } else {
      myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
      const timeLeft = Math.floor((packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) / (1000 * 60 * 60));
      if (timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});

    let luckyKing = {
      name: '',
      amount: -1
    };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
      claimedEntries.forEach(([name, amount]) => {
        if (amount > luckyKing.amount) {
          luckyKing = {
            name,
            amount
          };
        }
      });
    }

    claimedEntries.sort((a, b) => b[1] - a[1]);

    claimedEntries.forEach(([originalName, amount]) => {
      const item = document.createElement('div');
      item.className = 'rp-details-item';
      let luckyTag = '';
      if (luckyKing.name && originalName === luckyKing.name) {
        luckyTag = '<span class="lucky-king-tag">手气王</span>';
      }


      const claimerDisplayName = getDisplayNameInGroup(chat, originalName);

      item.innerHTML = `
                    <span class="name">${claimerDisplayName}</span>
                    <span class="amount">${amount.toFixed(2)} 元</span>
                    ${luckyTag}
                `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }


  document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
  });


  window.handlePacketClick = handlePacketClick;






  function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';


    addPollOptionInput();
    addPollOptionInput();

    modal.classList.add('visible');
  }

 
  function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
                <input type="text" class="poll-option-input" placeholder="选项内容...">
                <button class="remove-option-btn">-</button>
            `;

    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {

      if (container.children.length > 2) {
        wrapper.remove();
      } else {
        alert('投票至少需要2个选项。');
      }
    });

    container.appendChild(wrapper);
  }


  async function sendPoll() {
    if (!state.activeChatId) return;

    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
      alert('请输入投票问题！');
      return;
    }

    const options = Array.from(document.querySelectorAll('.poll-option-input'))
      .map(input => input.value.trim())
      .filter(text => text);

    if (options.length < 2) {
      alert('请至少输入2个有效的投票选项！');
      return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    const newPollMessage = {
      role: 'user',
      senderName: myNickname,
      type: 'poll',
      timestamp: Date.now(),
      question: question,
      options: options,
      votes: {},
      isClosed: false,
    };

    chat.history.push(newPollMessage);
    await db.chats.put(chat);

    appendMessage(newPollMessage, chat);
    renderChatList();

    document.getElementById('create-poll-modal').classList.remove('visible');
  }



  async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';


    if (!poll || poll.isClosed) {

      if (poll && poll.isClosed) {
        showPollResults(timestamp);
      }
      return;
    }


    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);


    if (!isReclickingSameOption) {

      for (const option in poll.votes) {
        const voterIndex = poll.votes[option].indexOf(myNickname);
        if (voterIndex > -1) {
          poll.votes[option].splice(voterIndex, 1);
        }
      }

      if (!poll.votes[choice]) {
        poll.votes[choice] = [];
      }
      poll.votes[choice].push(myNickname);
    }


    let hiddenMessageContent = null;


    if (!isReclickingSameOption) {
      hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }


    if (hiddenMessageContent) {
      const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now(),
        isHidden: true,
      };
      chat.history.push(hiddenMessage);
    }


    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
  }


  
  async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
      poll.isClosed = true;

      const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
      const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;

      const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now(),
        isHidden: true,
      };
      chat.history.push(hiddenMessage);


      await db.chats.put(chat);
      renderChatInterface(state.activeChatId);
    }
  }


  

  function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

    if (Object.keys(poll.votes).length === 0) {
      resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
      poll.options.forEach(option => {
        const voters = poll.votes[option] || [];


        const displayVoters = voters.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、 ');

        resultsHtml += `
                        <div style="margin-bottom: 15px;">
                            <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                            <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                ${voters.length > 0 ? displayVoters : '无人投票'}
                            </p>
                        </div>
                    `;
      });
    }

    showCustomAlert("投票结果", resultsHtml);
  }





  function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
  }

  function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
      return;
    }

    library.forEach((avatar, index) => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = avatar.name;



      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;


      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = '×';
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          chat.settings.aiAvatarLibrary.splice(index, 1);
          await db.chats.put(chat);
          renderAiAvatarLibrary();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }



  async function addAvatarToLibraryFromURL() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("请输入有效的图片URL！");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
      chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
  }


 
  function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
  }






  function openMyAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('my-avatar-library-title').textContent = `“${chat.settings.myNickname || '我'}”的头像库`;
    renderMyAvatarLibrary();
    document.getElementById('my-avatar-library-modal').classList.add('visible');
  }

  
  function renderMyAvatarLibrary() {
    const grid = document.getElementById('my-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.myAvatarLibrary || [];

    if (library.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
      return;
    }

    library.forEach((avatar, index) => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = avatar.name;


      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;


      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = '×';
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除头像', `确定要从你的头像库中删除“${avatar.name}”吗？`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          chat.settings.myAvatarLibrary.splice(index, 1);
          await db.chats.put(chat);
          renderMyAvatarLibrary();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }

 
  async function addAvatarToMyLibraryFromURL() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("请输入有效的图片URL！");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.myAvatarLibrary) {
      chat.settings.myAvatarLibrary = [];
    }

    chat.settings.myAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderMyAvatarLibrary();
  }


  async function handleLocalMyAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    let base64Url = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(file);
    });

    const name = await showCustomPrompt("命名头像", "请为这个新头像命名");
    if (!name || !name.trim()) {
        event.target.value = null;
        return;
    }
    
    const trimmedName = name.trim();
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.myAvatarLibrary) {
      chat.settings.myAvatarLibrary = [];
    }

    const newItem = {
      name: trimmedName,
      url: base64Url
    };
    chat.settings.myAvatarLibrary.push(newItem);
    await db.chats.put(chat);
    
    renderMyAvatarLibrary();
    await showCustomAlert("添加成功！", `头像“${trimmedName}”已添加。\n\n图片将在后台静默上传到图床...`);
    
    // 【【【已修复的调用】】】
    (async () => {
        await silentlyUpdateDbUrl(
            db.chats, // table
            chat.id,  // recordId
            'settings.myAvatarLibrary', // pathString (指向数组)
            base64Url, // base64ToFind
            trimmedName // nameToMatch
        );
    })();
    
    event.target.value = null;
  }


  async function handleBatchImportForMyAvatar(text) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const lines = text.trim().split('\n');
    const newAvatars = [];
    const baseUrl = 'https://files.catbox.moe/';
    let errorCount = 0;

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('填入')) continue;

      let name = null,
        code = null;
      const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);

      if (noSpaceMatch) {
        name = noSpaceMatch[1];
        code = noSpaceMatch[2];
      } else {
        const parts = trimmedLine.split(/\s+/);
        if (parts.length >= 2) {
          code = parts.pop();
          name = parts.join(' ');
        }
      }

      if (name && code && code.includes('.')) {
        newAvatars.push({
          name: name,
          url: baseUrl + code
        });
      } else {
        errorCount++;
      }
    }

    if (errorCount > 0) await showCustomAlert('部分导入失败', `有 ${errorCount} 行的格式不正确，已被跳过。`);

    if (newAvatars.length > 0) {
      if (!chat.settings.myAvatarLibrary) chat.settings.myAvatarLibrary = [];
      chat.settings.myAvatarLibrary.push(...newAvatars);
      await db.chats.put(chat);
      renderMyAvatarLibrary();
      await showCustomAlert('导入成功', `已成功批量导入 ${newAvatars.length} 个新头像！`);
    } else if (errorCount === 0) {
      alert("没有找到可导入的内容。");
    }
  }

 
  function closeMyAvatarLibraryModal() {
    document.getElementById('my-avatar-library-modal').classList.remove('visible');
  }




  
  function openGroupAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('group-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderGroupAvatarLibrary();
    document.getElementById('group-avatar-library-modal').classList.add('visible');
  }

 
  function renderGroupAvatarLibrary() {
    const grid = document.getElementById('group-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.groupAvatarLibrary || [];

    if (library.length === 0) {
      grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
      return;
    }

    library.forEach((avatar, index) => {
      const item = document.createElement('div');
      item.className = 'sticker-item';
      item.title = avatar.name;


      item.innerHTML = `
            <div class="sticker-image-container" style="background-image: url(${avatar.url});"></div>
            <span class="sticker-name">${avatar.name}</span>
        `;


      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'delete-btn';
      deleteBtn.innerHTML = '×';
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          chat.settings.groupAvatarLibrary.splice(index, 1);
          await db.chats.put(chat);
          renderGroupAvatarLibrary();
        }
      };
      item.appendChild(deleteBtn);
      grid.appendChild(item);
    });
  }

 
  async function addAvatarToGroupLibraryFromUR() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：春日野餐、学习时间）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("请输入有效的图片URL！");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.groupAvatarLibrary) {
      chat.settings.groupAvatarLibrary = [];
    }

    chat.settings.groupAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderGroupAvatarLibrary();
  }

  
  function closeGroupAvatarLibraryModal() {
    document.getElementById('group-avatar-library-modal').classList.remove('visible');
  }


  
  async function openBatchImportModal(type) {
    const placeholderText = `请按照以下格式粘贴，一行一个：\n\n焦虑 2a9wte.jpeg\n大惊失色 or8qf4.png\n没有灵感 njwujh.jpeg`;


    const pastedText = await showCustomPrompt(
      '批量导入头像',
      placeholderText,
      '',
      'textarea'
    );


    if (pastedText && pastedText.trim()) {
      await handleBatchImport(type, pastedText);
    }
  }


  
  async function handleBatchImport(type, text) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const lines = text.trim().split('\n');
    const newAvatars = [];
    const baseUrl = 'https://files.catbox.moe/';
    let errorCount = 0;

    for (const line of lines) {
      const trimmedLine = line.trim();

      if (!trimmedLine || trimmedLine.includes('http') || trimmedLine.includes('填入')) {
        continue;
      }

      let name = null;
      let code = null;







      const noSpaceMatch = trimmedLine.match(/^([\u4e00-\u9fa5]+)([a-zA-Z0-9]+\..+)$/);

      if (noSpaceMatch) {

        name = noSpaceMatch[1];
        code = noSpaceMatch[2];
      } else {

        const parts = trimmedLine.split(/\s+/);
        if (parts.length >= 2) {
          code = parts.pop();
          name = parts.join(' ');
        }
      }


      if (name && code && code.includes('.')) {
        newAvatars.push({
          name: name,
          url: baseUrl + code
        });
      } else {
        errorCount++;
        console.warn('批量导入格式错误，已跳过此行:', trimmedLine);
      }
    }

    if (errorCount > 0) {
      await showCustomAlert('部分导入失败', `有 ${errorCount} 行的格式不正确，已被系统跳过。`);
    }

    if (newAvatars.length > 0) {
      if (type === 'ai') {
        if (!chat.settings.aiAvatarLibrary) chat.settings.aiAvatarLibrary = [];
        chat.settings.aiAvatarLibrary.push(...newAvatars);
        await db.chats.put(chat);
        renderAiAvatarLibrary();
      } else if (type === 'group') {
        if (!chat.settings.groupAvatarLibrary) chat.settings.groupAvatarLibrary = [];
        chat.settings.groupAvatarLibrary.push(...newAvatars);
        await db.chats.put(chat);
        renderGroupAvatarLibrary();
      }
      await showCustomAlert('导入成功', `已成功批量导入 ${newAvatars.length} 个新头像！`);
    } else if (errorCount === 0) {
      alert("没有找到可导入的内容。请检查您粘贴的格式是否正确。");
    }
  }



 
  async function addAvatarToGroupLibraryFromURL() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：春日野餐、学习时间）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
      alert("请输入有效的图片URL！");
      return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.settings.groupAvatarLibrary) {
      chat.settings.groupAvatarLibrary = [];
    }

    chat.settings.groupAvatarLibrary.push({
      name: name.trim(),
      url: url.trim()
    });
    await db.chats.put(chat);
    renderGroupAvatarLibrary();
  }

  function showChatListActions(chat) {
    return new Promise(resolve => {
      const modal = document.getElementById('chat-list-actions-modal');
      const pinBtn = document.getElementById('chat-list-action-pin');
      const deleteBtn = document.getElementById('chat-list-action-delete');
      const cancelBtn = document.getElementById('chat-list-action-cancel');


      pinBtn.textContent = chat.isPinned ? '取消置顶' : '置顶聊天';


      const newPinBtn = pinBtn.cloneNode(true);
      pinBtn.parentNode.replaceChild(newPinBtn, pinBtn);
      newPinBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve('pin');
      };

      const newDeleteBtn = deleteBtn.cloneNode(true);
      deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
      newDeleteBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve('delete');
      };

      const newCancelBtn = cancelBtn.cloneNode(true);
      cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
      newCancelBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve(null);
      };

      modal.classList.add('visible');
    });
  }




  function applyCPhoneWallpaper() {
    const charPhoneScreen = document.getElementById('character-phone-screen');
    const wallpaper = state.globalSettings.cphoneWallpaper;
    if (wallpaper) {

      charPhoneScreen.style.backgroundImage = `url("${wallpaper}")`;
    } else {

      charPhoneScreen.style.backgroundImage = 'linear-gradient(135deg, #f6d365, #fda085)';
    }
  }

 
  function applyCPhoneAppIcons() {
    if (!state.globalSettings.cphoneAppIcons) return;

    for (const iconId in state.globalSettings.cphoneAppIcons) {
      const imgElement = document.getElementById(`cphone-icon-img-${iconId}`);
      if (imgElement) {
        imgElement.src = state.globalSettings.cphoneAppIcons[iconId];
      }
    }
  }

  
  function renderCPhoneIconSettings() {
    const grid = document.getElementById('cphone-icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const cphoneAppLabels = {
      'qq': 'QQ',
      'album': '相册',
      'browser': '浏览器',
      'taobao': '淘宝',
      'memo': '备忘录',
      'diary': '日记',
      'amap': '高德地图',
      'usage': 'App记录',
      'music': '网易云',
      'bilibili': '哔哩哔哩',
      'reddit': 'Reddit',
      'ephone': 'Ephone'
    };

    for (const iconId in state.globalSettings.cphoneAppIcons) {
      const iconUrl = state.globalSettings.cphoneAppIcons[iconId];
      const labelText = cphoneAppLabels[iconId] || '未知App';

      const item = document.createElement('div');
      item.className = 'icon-setting-item';
      item.dataset.iconId = iconId;

      item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">更换</button>
                `;
      grid.appendChild(item);
    }
  }




  function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
      const imgElement = document.getElementById(`icon-img-${iconId}`);
      if (imgElement) {
        imgElement.src = state.globalSettings.appIcons[iconId];
      }
    }
  }

  
  function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = {
      'qq': 'QQ',
      'world-book': '世界书',
      'wallpaper': '外观设置',
      'renderer': '渲染器',
      'api-settings': 'API设置',
      'font': '字体',
      'char-phone': 'Cphone',
      'douban': '豆瓣小组',

      'preset': '预设',

      'tutorial': '教程',
      'werewolf': '狼人杀',

      'x': 'X',
       'alipay': '支付宝',
       'auction': '黑市拍卖',
        'green-river': '绿江',
      'mail': '邮箱'
    };


    for (const iconId in state.globalSettings.appIcons) {
      const iconUrl = state.globalSettings.appIcons[iconId];
      const labelText = appLabels[iconId] || 'Cphone';

      const item = document.createElement('div');
      item.className = 'icon-setting-item';

      item.dataset.iconId = iconId;

      item.innerHTML = `
                    <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                    <button class="change-icon-btn">更换</button>
                `;
      grid.appendChild(item);
    }
  }



  
  function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];

    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
      console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
      return;
    }


    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
                <h1 class="article-title">${message.title || '无标题'}</h1>
                <div class="article-meta">
                    <span>来源: ${message.source_name || '未知'}</span>
                </div>
                <div class="article-body">
                    <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
                </div>
            `;


    showScreen('browser-screen');
  }

 
  



 
  function closeBrowser() {
    showScreen('chat-interface-screen');
  }





 
  function openShareLinkModal() {
    if (!state.activeChatId) return;


    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';


    document.getElementById('share-link-modal').classList.add('visible');
  }

  
  async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
      alert("标题是必填项哦！");
      return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];


    const linkMessage = {
      role: 'user',
      type: 'share_link',
      timestamp: Date.now(),
      title: title,
      description: description,
      source_name: sourceName,
      content: content,

      thumbnail_url: null
    };


    chat.history.push(linkMessage);
    await db.chats.put(chat);


    appendMessage(linkMessage, chat);
    renderChatList();


    document.getElementById('share-link-modal').classList.remove('visible');
  }




  function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return [];

    const viewerGroupId = viewerChat.groupId;
    const viewerId = viewerChat.id;

    return allPosts.filter(post => {

      if (post.authorId === 'user') {
        if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
          return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
        }
        return true;
      }




      if (String(post.authorId).startsWith('npc_')) {

        if (Array.isArray(post.visibleTo)) {
          return post.visibleTo.includes(viewerId);
        }

        return false;
      }




      const authorChat = state.chats[post.authorId];
      if (!authorChat) {
        return false;
      }
      const authorGroupId = authorChat.groupId;

      const inSameGroup = authorGroupId && viewerGroupId && authorGroupId === viewerGroupId;
      const bothUnGrouped = !authorGroupId && !viewerGroupId;

      return inSameGroup || bothUnGrouped;
    });
  }
 
  function applyPhoneFrame(isEnabled) {
  
    document.body.classList.toggle('frame-mode-active', isEnabled);

   
    if (musicState.isActive) {
      const lyricBar = document.getElementById('global-lyrics-bar');
      const phoneScreenForIsland = document.getElementById('phone-screen');
      const isAlwaysIslandMode = state.globalSettings.alwaysShowMusicIsland || false; 

      if (isEnabled) {
       
        lyricBar.classList.remove('visible');
        phoneScreenForIsland.classList.add('dynamic-island-active');
      } else {
        
        phoneScreenForIsland.classList.remove('dynamic-island-active'); 

        if (isAlwaysIslandMode) {
        
          phoneScreenForIsland.classList.add('dynamic-island-active');
          lyricBar.classList.remove('visible');
        } else {
          
          if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
            lyricBar.classList.add('visible');
          }
        }
      }
    }
  }
 
  function applyDetachStatusBarMode(isEnabled) {
    document.body.classList.toggle('detach-mode-active', isEnabled);
  }
  
  function applyMinimalChatUI(isEnabled) {
    document.body.classList.toggle('minimal-chat-ui-active', isEnabled);
  }

 
  function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');

    const isDark = theme === 'dark';

    phoneScreen.classList.toggle('dark-mode', isDark);


    if (toggleSwitch) {
      toggleSwitch.checked = isDark;
    }

    localStorage.setItem('ephone-theme', theme);
  }

  
  function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');

    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
  }


  function openLongTermMemoryScreen() {
    if (!state.activeChatId) return;
    renderLongTermMemoryList();
    showScreen('long-term-memory-screen');
  }


  
// 1. 修改 renderLongTermMemoryList (只负责准备数据和重置)
function renderLongTermMemoryList() {
    const container = document.getElementById('memory-list-container');
    const chat = state.chats[state.activeChatId];
    container.innerHTML = '';

    let memoriesToDisplay = [];

    if (chat.isGroup) {
        chat.members.forEach(member => {
            const memberChat = state.chats[member.id];
            if (memberChat && memberChat.longTermMemory) {
                const memberMemories = memberChat.longTermMemory.map(mem => ({
                    ...mem,
                    authorName: member.groupNickname,
                    authorChatId: member.id,
                    authorAvatar: member.avatar || (memberChat.settings.aiAvatar || defaultAvatar)
                }));
                memoriesToDisplay.push(...memberMemories);
            }
        });
    } else {
        if (chat.longTermMemory) {
            memoriesToDisplay = chat.longTermMemory.map(mem => ({
                ...mem,
                authorName: chat.name,
                authorChatId: chat.id,
                authorAvatar: chat.settings.aiAvatar || defaultAvatar
            }));
        }
    }

    if (memoriesToDisplay.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">这里还没有任何长期记忆。</p>';
        return;
    }

    // 按时间倒序
    memoriesToDisplay.sort((a, b) => b.timestamp - a.timestamp);

    // --- 核心修改：存入缓存，重置计数，调用分批加载 ---
    memoryCache = memoriesToDisplay;
    memoryRenderCount = 0;
    loadMoreMemories(); 
}

// 2. 新增 loadMoreMemories (负责分批渲染)
// 2. 新增 loadMoreMemories (负责分批渲染) - [修复版]
function loadMoreMemories() {
    // 1. 防止重复加载
    if (isLoadingMoreMemories) return;

    const container = document.getElementById('memory-list-container');
    if (!container) return;

    // 2. 如果所有数据都已经渲染完了，直接返回
    if (memoryRenderCount >= memoryCache.length) return;

    // 加锁
    isLoadingMoreMemories = true;

    try {
        // 每次加载 20 条
        const BATCH_SIZE = 20;
        const nextSliceEnd = memoryRenderCount + BATCH_SIZE;
        const itemsToRender = memoryCache.slice(memoryRenderCount, nextSliceEnd);

        const fragment = document.createDocumentFragment();

        itemsToRender.forEach(memory => {
            const item = document.createElement('div');
            item.className = 'favorite-item-card';
            item.style.cursor = 'default';

            const date = new Date(memory.timestamp);
            const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            const avatarUrl = memory.authorAvatar || defaultAvatar;

            item.innerHTML = `
                <div class="fav-card-header">
                    <img src="${avatarUrl}" class="avatar" style="width: 36px; height: 36px; border-radius: 50%; object-fit: cover;">
                    <div class="info">
                        <div class="name" style="font-size: 15px;">${memory.authorName}</div>
                        <div class="source" style="font-size: 12px; color: #999;">${dateString}</div>
                    </div>
                    
                    <div style="display: flex; gap: 8px;">
                        <button class="memory-action-btn edit-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="编辑">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:18px;height:18px;">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </button>
                        <button class="memory-action-btn delete-memory-btn" data-author-id="${memory.authorChatId}" data-memory-timestamp="${memory.timestamp}" title="删除">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:18px;height:18px; stroke:#ff3b30;">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="fav-card-content" style="margin-top: 5px;">${memory.content.replace(/\n/g, '<br>')}</div>
            `;
            fragment.appendChild(item);
        });

        container.appendChild(fragment);
        memoryRenderCount += itemsToRender.length;

        // 【修复关键点】：检查是否填满屏幕
        // 如果容器的内容高度 <= 容器可见高度（说明没有出现滚动条），且还有剩余数据
        // 立即请求加载下一页，直到填满屏幕出现滚动条为止
        if (container.scrollHeight <= container.clientHeight && memoryRenderCount < memoryCache.length) {
            isLoadingMoreMemories = false; // 临时解锁以便递归调用
            loadMoreMemories(); // 递归加载
            return; // 退出当前函数，由递归调用接管锁
        }

    } catch (error) {
        console.error("渲染长期记忆出错:", error);
    } finally {
        // 3. 无论成功还是出错，一定要解锁
        isLoadingMoreMemories = false;
    }
}


  async function handleAddManualMemory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    let targetChatForMemory = chat;
    if (chat.isGroup) {
      const memberOptions = chat.members.map(member => ({
        text: `为“${member.groupNickname}”添加记忆`,
        value: member.id
      }));
      const selectedMemberId = await showChoiceModal('选择记忆所属角色', memberOptions);
      if (!selectedMemberId) return;
      targetChatForMemory = state.chats[selectedMemberId];
      if (!targetChatForMemory) {
        alert("错误：找不到该成员的个人档案。");
        return;
      }
    }
    const content = await showCustomPrompt(`为“${targetChatForMemory.name}”添加记忆`, '请输入要添加的记忆要点：', '', 'textarea');
    if (content && content.trim()) {
      if (!targetChatForMemory.longTermMemory) targetChatForMemory.longTermMemory = [];
      targetChatForMemory.longTermMemory.push({
        content: content.trim(),
        timestamp: Date.now(),
        source: 'manual'
      });
      await db.chats.put(targetChatForMemory);
      renderLongTermMemoryList();
    }
  }


 
  async function handleEditMemory(authorChatId, memoryTimestamp) {
    const authorChat = state.chats[authorChatId];
    if (!authorChat || !authorChat.longTermMemory) return;
    const memoryIndex = authorChat.longTermMemory.findIndex(m => m.timestamp === memoryTimestamp);
    if (memoryIndex === -1) return;
    const memory = authorChat.longTermMemory[memoryIndex];
    const newContent = await showCustomPrompt('编辑记忆', '请修改记忆要点：', memory.content, 'textarea');
    if (newContent && newContent.trim()) {
      memory.content = newContent.trim();
      await db.chats.put(authorChat);
      renderLongTermMemoryList();
    }
  }

  async function handleDeleteMemory(authorChatId, memoryTimestamp) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条长期记忆吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      const authorChat = state.chats[authorChatId];
      if (!authorChat || !authorChat.longTermMemory) return;
      authorChat.longTermMemory = authorChat.longTermMemory.filter(m => m.timestamp !== memoryTimestamp);
      await db.chats.put(authorChat);
      renderLongTermMemoryList();
    }
  }



  async function handleManualSummary() {
    const confirmed = await showCustomConfirm('确认操作', '这将提取最近的对话内容发送给AI进行总结，会消耗API额度。确定要继续吗？');
    if (confirmed) {
      await triggerAutoSummary(state.activeChatId, true);
    }
  }
  
  // 新增：打开手动总结弹窗
  function openManualSummaryModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    const modal = document.getElementById('manual-summary-modal');
    const totalCount = document.getElementById('manual-summary-total-count');
    const startInput = document.getElementById('manual-summary-start');
    const endInput = document.getElementById('manual-summary-end');
    
    // 计算可用消息总数（排除隐藏消息）
    const availableMessages = chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('内心独白')));
    const totalMessages = availableMessages.length;
    
    totalCount.textContent = totalMessages;
    startInput.max = totalMessages;
    endInput.max = totalMessages;
    endInput.value = Math.min(20, totalMessages);
    
    modal.style.display = 'flex';
  }
  
  // 新增：关闭手动总结弹窗
  function closeManualSummaryModal() {
    const modal = document.getElementById('manual-summary-modal');
    modal.style.display = 'none';
  }
  
  // 新增：执行手动总结
  async function executeManualSummary() {
    const startInput = document.getElementById('manual-summary-start');
    const endInput = document.getElementById('manual-summary-end');
    
    const start = parseInt(startInput.value);
    const end = parseInt(endInput.value);
    
    if (isNaN(start) || isNaN(end) || start < 1 || end < start) {
      await showCustomAlert('输入错误', '请输入有效的消息范围（起始位置必须小于等于结束位置）');
      return;
    }
    
    const chat = state.chats[state.activeChatId];
    const availableMessages = chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('内心独白')));
    
    if (end > availableMessages.length) {
      await showCustomAlert('范围超出', `结束位置不能超过总消息数（${availableMessages.length}）`);
      return;
    }
    
    if (end - start + 1 < 5) {
      await showCustomAlert('消息太少', '选择的消息数量太少（至少需要5条），无法进行有意义的总结');
      return;
    }
    
    closeManualSummaryModal();
    
    const confirmed = await showCustomConfirm('确认操作', `将总结第 ${start} 到第 ${end} 条消息（共 ${end - start + 1} 条），会消耗API额度。确定要继续吗？`);
    if (confirmed) {
      await triggerAutoSummary(state.activeChatId, false, { start, end });
    }
  }

  
  async function checkAndTriggerAutoSummary(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.settings.enableAutoMemory) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    const messagesSinceLastSummary = chat.history.filter(m => m.timestamp > lastSummaryTimestamp && !m.isHidden);

    if (messagesSinceLastSummary.length >= chat.settings.autoMemoryInterval) {
      console.log(`达到自动总结阈值 (${messagesSinceLastSummary.length}/${chat.settings.autoMemoryInterval})，开始总结...`);
      await triggerAutoSummary(chatId);
    }
  }

 
  async function summarizeCallTranscript(chatId, transcriptText) {
    const chat = state.chats[chatId];
    if (!chat || !transcriptText) {
      throw new Error("基础数据不完整，无法开始总结。");
    }

    const userNickname = chat.settings.myNickname || (state.qzoneSettings.nickname || '用户');
const summaryWorldBook = state.worldBooks.find(wb => wb.name === '总结设定'); // 确保这个名字和你创建的世界书一致
let summarySettingContext = '';
if (summaryWorldBook) {
  const enabledEntries = summaryWorldBook.content
    .filter(e => e.enabled !== false) // 仅读取启用的条目
    .map(e => e.content)
    .join('\n');
  
  if (enabledEntries) {
    summarySettingContext = `
# 【总结规则 (最高优先级)】
# 你在执行本次总结任务时，【必须】严格遵守以下所有规则：
# ---
# ${enabledEntries}
# ---
`;
  }
}
    let systemPrompt;
    let targetMemoryChat = chat;




    const today = new Date().toLocaleDateString('zh-CN', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    if (chat.isGroup) {
      let protagonist = null;
      if (videoCallState.callRequester) {
        protagonist = chat.members.find(m => m.originalName === videoCallState.callRequester);
      }
      if (!protagonist) {
        protagonist = chat.members.find(m => m.id !== 'user' && videoCallState.participants.some(p => p.id === m.id));
      }
      if (!protagonist) {
        protagonist = chat.members.find(m => m.id !== 'user');
      }

      if (!protagonist) {
        throw new Error("群聊通话中没有找到可作为总结主体的AI角色。");
      }

      const protagonistChat = state.chats[protagonist.id];
      if (!protagonistChat) {
        throw new Error(`找不到主角 “${protagonist.groupNickname}” 的详细角色信息。`);
      }

      const userPersonaInGroup = chat.settings.myPersona || '(未设置)';
      let timeHeader = '';
      let timeRule = '';
      
      if (protagonistChat.settings.enableTimePerception) {
          timeHeader = `
# 当前时间
- **今天是：${today}**`;
          timeRule = `3.  **【时间转换铁律 (必须遵守)】**: 如果通话中提到了相对时间（如“明天”），你【必须】结合“今天是${today}”这个信息，将其转换为【具体的公历日期】。`;
      }
      systemPrompt = `
${summarySettingContext}
# 你的任务
你就是角色“${protagonist.originalName}”。请你回顾一下刚才和 “${userNickname}” 以及其他群成员的【群组视频通话】，然后用【第一人称 ("我")】的口吻，总结出一段简短的、客观的、包含关键信息的记忆。请专注于重要的情绪、事件和细节。

${timeHeader}

# 核心规则
1.  **【视角铁律】**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **【内容核心 (最高优先级)】**: 你的总结【必须】专注于以下几点：
    *   **关键议题**: 我们在群聊通话里讨论了哪些核心话题？
    *   **重要决定与共识**: 我们达成了什么共识或做出了什么决定？
    *   **后续计划与任务**: 有没有确定下来什么下一步的行动或计划？
    *   **关键信息**: 有没有交换什么重要的信息？（例如：约定了时间、地点等）
${timeRule}
4.  **【风格要求】**: 你的总结应该像一份会议纪要或备忘录，而不是一篇抒情散文。

6.  **【输出格式】**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心事实与计划。"}\`

# 你的角色设定 (必须严格遵守)
${protagonistChat.settings.aiPersona}

# 你的聊天对象（用户）的人设
${userPersonaInGroup}

# 待总结的群组视频通话记录
${transcriptText}

现在，请以“${protagonist.originalName}”的身份，开始你的客观总结。`;

      targetMemoryChat = protagonistChat;

    } else {
      let timeHeader = '';
      let timeRule = '';

      if (chat.settings.enableTimePerception) {
          timeHeader = `
# 当前时间
- **今天是：${today}**`;
          timeRule = `3.  **【时间转换铁律 (必须遵守)】**: 如果通话中提到了相对时间（如“明天”），你【必须】结合“今天是${today}”这个信息，将其转换为【具体的公历日期】。`;
      }
      systemPrompt = `
${summarySettingContext}
# 你的任务
你就是角色“${chat.originalName}”。请你回顾一下刚才和“${userNickname}”的视频通话，然后用【第一人称 ("我")】的口吻，总结出一段简短的、客观的、包含关键信息的记忆。请专注于重要的情绪、事件和细节。

${timeHeader}

# 核心规则
1.  **【视角铁律】**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **【内容核心 (最高优先级)】**: 你的总结【必须】专注于以下几点：
    *   **关键议题**: 我们聊了什么核心话题？
    *   **重要决定与共识**: 我们达成了什么共识或做出了什么决定？
    *   **后续计划与任务**: 有没有确定下来什么下一步的行动或计划？
    *   **关键信息**: 有没有交换什么重要的信息？（例如：约定了时间、地点等）
${timeRule}
4.  **【风格要求】**: 你的总结应该像一份会议纪要或备忘录，而不是一篇抒情散文。

6.  **【输出格式】**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心事实与计划。"}\`

# 你的角色设定
${chat.settings.aiPersona}

# 你的聊天对象（用户）的人设
${chat.settings.myPersona}

# 待总结的视频通话记录
${transcriptText}

现在，请以“${chat.originalName}”的身份，开始你的客观总结。`;
    }



    try {
      const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
      const {
        proxyUrl,
        apiKey,
        model
      } = useSecondaryApi ? {
          proxyUrl: state.apiConfig.secondaryProxyUrl,
          apiKey: state.apiConfig.secondaryApiKey,
          model: state.apiConfig.secondaryModel
        } :
        state.apiConfig;

      if (!proxyUrl || !apiKey || !model) throw new Error('API未配置，无法进行总结。');

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{
        role: 'user',
        content: "请开始总结。"
      }]);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, {
              role: 'user',
              content: "请开始总结。"
            }],
            temperature: 0.7
          })
        });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({
          error: {
            message: response.statusText
          }
        }));
        throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
      }

      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
      rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
      const result = JSON.parse(rawContent);

      if (result.summary && result.summary.trim()) {
        const newMemoryEntry = {
          content: `(在那次${chat.isGroup ? '群聊' : ''}通话中，${result.summary.trim()})`,
          timestamp: Date.now(),
          source: chat.isGroup ? 'group_call_summary' : 'call_summary'
        };
        if (!targetMemoryChat.longTermMemory) targetMemoryChat.longTermMemory = [];
        targetMemoryChat.longTermMemory.push(newMemoryEntry);
        await db.chats.put(targetMemoryChat);
        console.log(`通话记录已成功总结并存入角色“${targetMemoryChat.name}”的长期记忆中。`);

        return true;
      } else {
        throw new Error("AI返回了空的或格式不正确的总结内容。");
      }

    } catch (error) {
      console.error("总结通话记录时出错:", error);
      throw error;
    }
  }

  function analyzeTextForSummary(text) {
    const stopWords = new Set(['的', '是', '了', '在', '我', '你', '他', '她', '它', '我们', '你们', '他们', '这', '那', '一个', '也', '和', '与', '或', '但', '然而', '所以', '因此', '就', '都', '地', '得', '着', '过', '吧', '吗', '呢', '啊', '哦', '嗯', '什么', '怎么', '为什么', '哪个', '一些', '这个', '那个', '还有']);
    const words = text.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    let maxFrequency = 0;

    words.forEach(word => {
      if (word.length > 1 && !stopWords.has(word)) {
        const count = (frequencies.get(word) || 0) + 1;
        frequencies.set(word, count);
        if (count > maxFrequency) maxFrequency = count;
      }
    });

    const coreKeywords = [];
    const situationalKeywords = [];
    const coreThreshold = maxFrequency * 0.9;
    const situationalThreshold = maxFrequency * 0.6;

    frequencies.forEach((count, word) => {
      if (count >= coreThreshold) {
        coreKeywords.push(word);
      } else if (count >= situationalThreshold) {
        situationalKeywords.push(word);
      }
    });

    const coreSet = new Set(coreKeywords);
    const finalSituational = situationalKeywords.filter(word => !coreSet.has(word)).slice(0, 5);

    return {
      coreKeywords: coreKeywords.slice(0, 3),
      situationalKeywords: finalSituational
    };
  }


  function generateSummaryForTimeframe(chat, duration, unit) {
    let timeAgo;
    if (unit === 'hours') {
      timeAgo = Date.now() - duration * 60 * 60 * 1000;
    } else { // 'days'
      timeAgo = Date.now() - duration * 24 * 60 * 60 * 1000;
    }

    const messagesToSummarize = chat.history.filter(m => m.timestamp > timeAgo && !m.isHidden);

    if (messagesToSummarize.length < 3) {
      return "";
    }

   
    const allText = messagesToSummarize.map(msg => {
      if (typeof msg.content === 'string') return msg.content;
      if (msg.type === 'voice_message') return msg.content;
      if (msg.type === 'offline_text') return `${msg.dialogue || ''} ${msg.description || ''}`;
      return '';
    }).join(' ');

    const stopWords = new Set(['的', '是', '了', '在', '我', '你', '他', '她', '它', '我们', '你们', '他们', '这', '那', '一个', '也', '和', '与', '或', '但', '然而', '所以', '因此', '就', '都', '地', '得', '着', '过', '吧', '吗', '呢', '啊', '哦', '嗯']);
    const words = allText.match(/[\u4e00-\u9fa5]+|[a-zA-Z0-9]+/g) || [];
    const frequencies = new Map();
    words.forEach(word => {
      if (word.length > 1 && !stopWords.has(word)) {
        frequencies.set(word, (frequencies.get(word) || 0) + 1);
      }
    });
    const sortedKeywords = [...frequencies.entries()].sort((a, b) => b[1] - a[1]).map(entry => entry[0]);

    if (sortedKeywords.length === 0) {
      return "";
    }


    let title;
    if (unit === 'hours') {
      title = `最近${duration}小时核心议题`;
    } else {
      if (duration === 1) {
        title = "本日核心议题";
      } else {
        title = `最近${duration}天核心议题`;
      }
    }

    return `\n- **${title}**: 关于 **${sortedKeywords.slice(0, 3).join('、 ')}**。`;
  }



  function robustJsonParse(rawContent) {
    if (!rawContent || typeof rawContent !== 'string') {
      return null;
    }

    const cleanedContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();


    const jsonMatch = cleanedContent.match(/{[\s\S]*}/);
    if (jsonMatch) {
      try {
        const parsed = JSON.parse(jsonMatch[0]);
        console.log("容错解析：策略1成功 (找到并解析了完整的JSON对象)");
        return parsed;
      } catch (e) {
        console.warn("容错解析：策略1失败 (找到了JSON块，但格式错误)，将尝试策略2...");
      }
    }


    const summaryMatch = cleanedContent.match(/"summary"\s*:\s*"((?:[^"\\]|\\.)*)"/);
    if (summaryMatch && summaryMatch[1]) {
      console.log("容错解析：策略2成功 (提取了summary字段内容)");

      return {
        summary: summaryMatch[1].replace(/\\"/g, '"')
      }; 
    }


    if (cleanedContent) {
      console.log("容错解析：策略3成功 (将整个返回文本作为摘要)");
      return {
        summary: cleanedContent
      };
    }


    return null;
  }



  async function summarizeExistingLongTermMemory(chatId) {
    let chat = state.chats[chatId];
    if (!chat) return;

    let targetChatForRefine = chat;

    if (chat.isGroup) {
      const memberOptions = chat.members
        .map(member => {
          const memberChat = state.chats[member.id];
          if (memberChat && memberChat.longTermMemory && memberChat.longTermMemory.length >= 2) {
            return {
              text: `精炼“${member.groupNickname}”的记忆 (${memberChat.longTermMemory.length}条)`,
              value: member.id
            };
          }
          return null;
        }).filter(Boolean);

      if (memberOptions.length === 0) {
        alert("群聊中没有成员有足够（2条以上）的记忆可供精炼。");
        return;
      }

      const selectedMemberId = await showChoiceModal('选择要精炼记忆的角色', memberOptions);

      if (!selectedMemberId) return;

      targetChatForRefine = state.chats[selectedMemberId];
    }

    if (!targetChatForRefine.longTermMemory || targetChatForRefine.longTermMemory.length < 2) {
      alert(`“${targetChatForRefine.name}”的长期记忆少于2条，无需进行精炼。`);
      return;
    }

    const totalMemories = targetChatForRefine.longTermMemory.length;
    const choice = await showChoiceModal('选择精炼范围', [{
        text: `全部记忆 (${totalMemories}条)`,
        value: 'all'
      },
      {
        text: `最近 20 条`,
        value: '20'
      },
      {
        text: `最近 50 条`,
        value: '50'
      },
      {
        text: `最近 100 条`,
        value: '100'
      },
      {
        text: '自定义数量...',
        value: 'custom'
      }
    ].filter(opt => opt.value === 'all' || opt.value === 'custom' || parseInt(opt.value) < totalMemories));

    if (choice === null) return;

    let memoriesToRefine;
    let countToRefine = totalMemories;

    if (choice === 'all') {
      memoriesToRefine = [...targetChatForRefine.longTermMemory];
    } else if (choice === 'custom') {
      const customCountStr = await showCustomPrompt('自定义数量', `请输入要精炼的最近记忆条数 (最多 ${totalMemories} 条)`);
      if (customCountStr === null) return;
      const customCount = parseInt(customCountStr);
      if (isNaN(customCount) || customCount < 2 || customCount > totalMemories) {
        alert(`请输入一个 2 到 ${totalMemories} 之间的有效数字。`);
        return;
      }
      countToRefine = customCount;
      memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
    } else {
      countToRefine = parseInt(choice);
      if (countToRefine >= totalMemories) {
        memoriesToRefine = [...targetChatForRefine.longTermMemory];
        countToRefine = totalMemories;
      } else {
        memoriesToRefine = targetChatForRefine.longTermMemory.slice(-countToRefine);
      }
    }

    const wordCountStr = await showCustomPrompt(
      "设置精炼字数",
      "请输入精炼后核心记忆的大致字数：",
      "150"
    );

    if (wordCountStr === null) return;

    const wordCount = parseInt(wordCountStr);
    if (isNaN(wordCount) || wordCount < 20) {
      alert("请输入一个有效的数字（建议大于20）。");
      return;
    }

    const confirmed = await showCustomConfirm(
      '确认精炼记忆？',
      `此操作会将选定的 ${countToRefine} 条长期记忆发送给AI，总结成大约 ${wordCount} 字的核心记忆。这些旧记忆将被替换，此操作不可撤销。确定要继续吗？`, {
        confirmButtonClass: 'btn-danger',
        confirmText: '确认精炼'
      }
    );

    if (!confirmed) return;

    const memoryContent = memoriesToRefine.map(mem => `- ${mem.content}`).join('\n');
    const userNickname = targetChatForRefine.settings.myNickname || (state.qzoneSettings.nickname || '用户');


    const today = new Date().toLocaleDateString('zh-CN', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    let timeHeader = '';
    let timeRule = '';

    if (targetChatForRefine.settings.enableTimePerception) {
        timeHeader = `
# 当前时间
- **今天是：${today}**`;
        timeRule = `3.  **【时间转换铁律 (必须遵守)】**: 如果记忆中提到了相对时间（如“明天”、“下周”），你【必须】结合“今天是${today}”这个信息，将其转换为【具体的公历日期】。`;
    }
const summaryWorldBook = state.worldBooks.find(wb => wb.name === '总结设定'); // 确保这个名字和你创建的世界书一致
let summarySettingContext = '';
if (summaryWorldBook) {
  const enabledEntries = summaryWorldBook.content
    .filter(e => e.enabled !== false) // 仅读取启用的条目
    .map(e => e.content)
    .join('\n');
  
  if (enabledEntries) {
    summarySettingContext = `
# 【总结规则 (最高优先级)】
# 你在执行本次总结任务时，【必须】严格遵守以下所有规则：
# ---
# ${enabledEntries}
# ---
`;
  }
}
    const systemPrompt = `
${summarySettingContext}
# 你的任务
你就是角色“${targetChatForRefine.originalName}”。请你回顾一下你和“${userNickname}”的所有长期记忆，然后将它们梳理、整合并精炼成一段更加连贯、客观的核心记忆摘要。请专注于重要的情绪、事件和细节。

${timeHeader}

# 核心规则
1.  **【视角铁律】**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **【内容核心 (最高优先级)】**: 你的总结【必须】专注于梳理以下几点：
    *   **建立时间线**: 将所有独立的记忆点串联起来，形成一个有时间顺序的事件脉络。
    *   **整合关键信息**: 总结出我们共同经历的关键事件、做出的重要决定、以及约定好的未来计划。
    *   **识别未完成项**: 明确指出哪些计划或任务尚未完成。
${timeRule}
4.  **【风格要求】**: 你的总结应该像一份清晰的个人档案或事件回顾，而不是一篇情感散文。请删除重复、琐碎或纯粹的情感宣泄，只保留对情节和关系发展至关重要的部分。
5.  **【长度铁律】**: 你的总结【必须】非常精炼，总长度应控制在 **${wordCount} 字左右**。
6.  **【输出格式】**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心事实与计划。"}\`

# 你的角色设定 (必须严格遵守)
${targetChatForRefine.settings.aiPersona}

# 你的聊天对象（用户）的人设
${targetChatForRefine.settings.myPersona}

# 待整合的记忆要点列表
${memoryContent}

现在，请以“${targetChatForRefine.originalName}”的身份，开始你的回忆梳理与精炼。`;


    await showCustomAlert("请稍候...", "正在请求AI进行记忆精炼...");

    try {
      const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
      const {
        proxyUrl,
        apiKey,
        model
      } = useSecondaryApi
        ?
        {
          proxyUrl: state.apiConfig.secondaryProxyUrl,
          apiKey: state.apiConfig.secondaryApiKey,
          model: state.apiConfig.secondaryModel
        } :
        state.apiConfig;

      if (!proxyUrl || !apiKey || !model) {
        throw new Error('请先在API设置中配置好（主或副）API以进行总结。');
      }

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{
        role: 'user',
        content: "请开始整合。"
      }]);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, {
              role: 'user',
              content: "请开始整合。"
            }],
            temperature: 0.7,
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;

      const result = robustJsonParse(rawContent);

      if (result && result.summary && typeof result.summary === 'string' && result.summary.trim()) {

        const userConfirmedReplacement = await showCustomConfirm(
          '精炼完成，请确认',
          `AI已将您的 ${countToRefine} 条旧记忆总结为以下核心记忆：<br><br><div class="scrollable-content-preview">${result.summary.trim()}</div><br>是否用这条新记忆替换掉这些旧记忆？`, {
            confirmText: '确认替换',
            cancelText: '保留旧的',
            confirmButtonClass: 'btn-danger'
          }
        );

        if (userConfirmedReplacement) {
          const newMemoryEntry = {
            content: result.summary.trim(),
            timestamp: Date.now(),
            source: 'refined'
          };

          const startIndex = totalMemories - countToRefine;
          const memoriesToKeep = startIndex > 0 ? targetChatForRefine.longTermMemory.slice(0, startIndex) : [];
          targetChatForRefine.longTermMemory = [...memoriesToKeep, newMemoryEntry];

          targetChatForRefine.lastMemorySummaryTimestamp = Date.now();
          await db.chats.put(targetChatForRefine);

          if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
            renderLongTermMemoryList();
          }
          await showCustomAlert('精炼成功', `已成功将 ${countToRefine} 条记忆精炼为 1 条核心记忆！`);
        } else {
          await showCustomAlert('操作已取消', '您的旧有记忆已被完整保留，未作任何修改。');
        }

      } else {
        throw new Error("AI返回了空的或格式不正确的总结内容。");
      }

    } catch (error) {
      console.error("精炼长期记忆时出错:", error);
      await showCustomAlert('精炼失败', `操作失败，请检查API配置或稍后重试。\n错误信息: ${error.message}`);
    }
  }


  async function triggerAutoSummary(chatId, force = false, customRange = null) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const lastSummaryTimestamp = chat.lastMemorySummaryTimestamp || 0;
    let messagesToSummarize;
    
    if (customRange) {
      // 手动总结：使用自定义范围
      const allMessages = chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('内心独白')));
      const startIndex = Math.max(0, customRange.start - 1);
      const endIndex = Math.min(allMessages.length, customRange.end);
      messagesToSummarize = allMessages.slice(startIndex, endIndex);
    } else {
      // 原有逻辑
      messagesToSummarize = force ?
        chat.history.filter(m => !m.isHidden || (m.role === 'system' && m.content.includes('内心独白'))).slice(-(chat.settings.autoMemoryInterval || 20)) :
        chat.history.filter(m => m.timestamp > lastSummaryTimestamp && (!m.isHidden || (m.role === 'system' && m.content.includes('内心独白'))));
    }

    if (messagesToSummarize.length < 5) {
      if (force) alert("最近的消息太少，无法进行有意义的总结。");
      return;
    }

    const userNickname = chat.settings.myNickname || (state.qzoneSettings.nickname || '用户');
    const startMsg = messagesToSummarize[0];
    const endMsg = messagesToSummarize[messagesToSummarize.length - 1];

   
    const formatDateTime = (ts) => new Date(ts).toLocaleString('zh-CN', {
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', hour12: false
    });

    const timeRangeStr = `${formatDateTime(startMsg.timestamp)} 至 ${formatDateTime(endMsg.timestamp)}`;
    const formattedHistory = messagesToSummarize.map(msg => {
      if (msg.isHidden && msg.role === 'system' && msg.content.includes('内心独白')) {
        return msg.content;
      }
      if (msg.isHidden) return null; // 过滤掉其他隐藏消息

      let sender;
      if (msg.role === 'user') {
        sender = userNickname;
      } else {
        sender = msg.senderName || chat.originalName;
      }

      let prefix = "";
      
      if (msg.quote && msg.quote.content) {
          let quotedSenderDisplayName = msg.quote.senderName; 
          
         
          if (msg.quote.senderName === (state.qzoneSettings.nickname || '{{user}}')) {
              quotedSenderDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
          } else {
             
              quotedSenderDisplayName = getDisplayNameInGroup(chat, msg.quote.senderName);
          }
          
          let quoteContentPreview = String(msg.quote.content).substring(0, 30);
          if (quoteContentPreview.length === 30) quoteContentPreview += "...";
          
          prefix = `[回复 ${quotedSenderDisplayName}: "${quoteContentPreview}"] `;
      }

      let contentToSummarize = '';
      if (msg.type === 'offline_text') {
        if (msg.content) {
          contentToSummarize = msg.content;
        } else {
          const dialogue = msg.dialogue ? `「${msg.dialogue}」` : '';
          const description = msg.description ? `(${msg.description})` : '';
          contentToSummarize = `${dialogue} ${description}`.trim();
        }
      } else if (typeof msg.content === 'string') {
        contentToSummarize = msg.content;
      } else if (msg.type === 'voice_message') {
        contentToSummarize = `[语音: ${msg.content}]`;
      } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
        contentToSummarize = `[图片: ${msg.content}]`;
      } else if (msg.type === 'sticker') {
        contentToSummarize = `[表情: ${msg.meaning || 'sticker'}]`;
      } else if (Array.isArray(msg.content)) {
        contentToSummarize = `[图片]`; // 假设是图片数组
      } else {
        contentToSummarize = `[${msg.type || '复杂消息'}]`; 
      }

      const msgTime = new Date(msg.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit', hour12: false});
      return `[${msgTime}] ${sender}: ${prefix}${contentToSummarize}`;
    
    }).filter(Boolean).join('\n');
const summaryWorldBook = state.worldBooks.find(wb => wb.name === '总结设定');
let summarySettingContext = '';
if (summaryWorldBook) {
  const enabledEntries = summaryWorldBook.content
    .filter(e => e.enabled !== false) // 仅读取启用的条目
    .map(e => e.content)
    .join('\n');
  
  if (enabledEntries) {
    summarySettingContext = `
# 【总结规则 (最高优先级)】
# 你在执行本次总结任务时，【必须】严格遵守以下所有规则：
# ---
# ${enabledEntries}
# ---
`;
  }
}
    let systemPrompt;

    if (chat.isGroup) {
     let timeHeader = '';
        let timeRule = '';

        if (chat.settings.enableTimePerception) {
            timeHeader = `
# 对话发生时间
- **${timeRangeStr}**`;
            timeRule = `- (请基于此时间范围来理解对话中提到的“今天”、“明天”等相对时间概念，并将它们转换为具体的日期记录在记忆中。)`;
        }
      systemPrompt = `
${summarySettingContext}
# 你的任务
你是一个高级的“记忆分配专家”。你的任务是阅读下面的群聊记录，并为【每一个参与的AI角色】生成一段【个性化的、第一人称】的长期记忆。请专注于重要的情绪、事件和细节。
${timeHeader}
- (请基于此时间范围来理解对话中提到的“今天”、“明天”等相对时间概念，并将它们转换为具体的日期记录在记忆中。)
# 核心规则
1.  **视角铁律**: 每一条总结都【必须】使用【第一人称视角 ("我")】。
2.  **内容核心**: 重点总结：我说过的话、我做过的事、别人对我说的话、与我相关的事、以及对我个人很重要的群聊事件、关键信息和心理活动以及当前群聊内的情景。
${timeRule}
4.  **【省略规则】**: 如果一个角色在本次对话中【完全没有参与或提及】，你可以省略TA的记忆。
5.  **输出格式**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`\`\`json
    {
      "summaries": {
        "角色的本名A": "我在(${timeRangeStr.split(' ')[0]})和大家讨论了...",
        "角色的本名B": "我约了${userNickname}在明天(需根据时间范围推算具体日期)单独见面。"
      }
    }
    \`\`\`
# 待总结的群聊记录
${formattedHistory}
# 群成员列表 (你的总结目标)
${chat.members.map(m => `- ${m.groupNickname} (本名: ${m.originalName})`).join('\n')}
现在，请为【参与了对话的AI角色】生成他们各自的、第一人称的、精简的记忆。`;

    } else {


      const today = new Date().toLocaleDateString('zh-CN', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      let timeHeader = '';
        let timeRule = '';

        if (chat.settings.enableTimePerception) {
            timeHeader = `
# 对话时间范围
- **${timeRangeStr}**`;
            timeRule = `3.  **【时间转换铁律 (必须遵守)】**: 如果对话中提到了相对时间（如“明天”、“后天”），你【必须】结合上面的【对话时间范围】信息，将其转换为【具体的公历日期】。`;
        }

      systemPrompt = `
${summarySettingContext}
# 你的任务
你就是角色“${chat.originalName}”。请你回顾一下刚才和“${userNickname}”的对话，然后用【第一人称 ("我")】的口吻，总结出一段简短的、客观的、包含关键信息的记忆。请专注于重要的情绪、事件和细节。

${timeHeader}

# 核心规则
1.  **【视角铁律】**: 你的总结【必须】使用【主观的第一人称视角 ("我")】来写。
2.  **【内容核心 (最高优先级)】**: 你的总结【必须】专注于以下几点：
    *   **重要事件**: 刚才发生了什么具体的事情？
    *   **关键决定**: 我们达成了什么共识或做出了什么决定？
    *   **未来计划**: 我们约定了什么未来的计划或待办事项？
    *   **重要时间点**: 对话中提到了哪些具体的日期或时间？

${timeRule}
4.  **【风格要求】**: 你的总结应该像一份备忘录或要点记录，而不是一篇抒情散文。请尽量减少主观的心理感受描述，除非它直接导致了某个决定或计划。

6.  **【输出格式】**: 你的回复【必须且只能】是一个JSON对象，格式如下：
    \`{"summary": "在这里写下你以第一人称视角，总结好的核心事实与计划。"}\`

# 你的角色设定
${chat.settings.aiPersona}
# 你的聊天对象（用户）的人设
${chat.settings.myPersona}
# 待总结的对话历史
${formattedHistory}

现在，请以“${chat.originalName}”的身份，开始你的客观总结。`;

    }

    try {
      const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
      const {
        proxyUrl,
        apiKey,
        model
      } = useSecondaryApi ? {
        proxyUrl: state.apiConfig.secondaryProxyUrl,
        apiKey: state.apiConfig.secondaryApiKey,
        model: state.apiConfig.secondaryModel
      } : state.apiConfig;
      if (!proxyUrl || !apiKey || !model) throw new Error('API未配置');

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{
        role: 'user',
        content: "请开始总结。"
      }]);
      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: [{
            role: 'system',
            content: systemPrompt
          }, {
            role: 'user',
            content: "请开始总结。"
          }],
          temperature: 0.7
        })
      });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
      const data = await response.json();
      let rawContent = isGemini ? getGeminiResponseText(data) : data.choices[0].message.content;
      rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
      const result = JSON.parse(rawContent);

      if (chat.isGroup) {
        if (result.summaries && typeof result.summaries === 'object') {
          let memoriesAddedCount = 0;
          for (const memberOriginalName in result.summaries) {
            const summaryText = result.summaries[memberOriginalName];
            if (summaryText && summaryText.trim()) {
              const memberChat = Object.values(state.chats).find(c => c.originalName === memberOriginalName);
              if (memberChat) {
                const newMemoryEntry = {
                  content: summaryText.trim(),
                  timestamp: Date.now(),
                  source: `group_summary_from_${chat.name}`
                };
                if (!memberChat.longTermMemory) memberChat.longTermMemory = [];
                memberChat.longTermMemory.push(newMemoryEntry);
                await db.chats.put(memberChat);
                memoriesAddedCount++;
              }
            }
          }
          if (memoriesAddedCount > 0) {
            console.log(`自动总结成功：为 ${memoriesAddedCount} 位群成员生成并注入了个性化记忆！`);
          } else {
            throw new Error("AI返回了空的或格式不正确的总结内容。");
          }
        } else {
          throw new Error("AI返回的JSON格式不正确，缺少 'summaries' 字段。");
        }
      } else {
        if (result.summary && result.summary.trim()) {
          const newMemoryEntry = {
            content: result.summary.trim(),
            timestamp: Date.now(),
            source: 'auto'
          };
          chat.longTermMemory.push(newMemoryEntry);
          await db.chats.put(chat);
          console.log('自动总结成功：已成功添加 1 条新的长期记忆！');
        } else {
          throw new Error("AI返回了空的或格式不正确的总结内容。");
        }
      }

      chat.lastMemorySummaryTimestamp = messagesToSummarize.slice(-1)[0].timestamp;
      await db.chats.put(chat);

      if (document.getElementById('long-term-memory-screen').classList.contains('active')) {
        renderLongTermMemoryList();
      }
    } catch (error) {
      console.error("总结长期记忆时出错:", error);
      await showCustomAlert('总结失败', `操作失败: ${error.message}`);
    }
  }

  function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp && !m.isHidden);
    if (!message) return;


    let senderDisplayName;
    if (message.role === 'user') {
      senderDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    } else {
      if (chat.isGroup) {

        senderDisplayName = getDisplayNameInGroup(chat, message.senderName);
      } else {

        senderDisplayName = chat.name;
      }
    }


    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
      previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
      previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
      previewSnippet = '[语音]';
    } else {
      previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }

    currentReplyContext = {
      timestamp: message.timestamp,
      senderName: senderDisplayName,
      content: fullContent,
    };

    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet;
    previewBar.style.display = 'block';

    hideMessageActions();
    document.getElementById('chat-input').focus();
  }

  function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
  }





  let activeTransferTimestamp = null;

 
  function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {

      document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
  }

  
  function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
  }

  
  




  async function renderCallHistoryScreen() {
    showScreen('call-history-screen');

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';

    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();

    if (records.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
      return;
    }

    records.forEach(record => {
      const card = createCallRecordCard(record);

      addLongPressListener(card, async () => {

        const newName = await showCustomPrompt(
          "自定义通话名称",
          "请输入新的名称（留空则恢复默认）",
          record.customName || ''
        );


        if (newName === null) return;


        await db.callRecords.update(record.id, {
          customName: newName.trim()
        });


        await renderCallHistoryScreen();


        await showCustomAlert('成功', '通话名称已更新！');
      });
      listEl.appendChild(card);
    });
  }



  function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id;


    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p =>
      `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');

    card.innerHTML = `
                <div class="card-header">
                    <span class="date">${dateString}</span>
                    <span class="duration">${durationText}</span>
                </div>
                <div class="card-body">
                    <!-- 【核心修改】在这里新增一个标题行 -->
                    ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
                    
                    <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                        <div class="participants-avatars">${avatarsHtml}</div>
                        <span class="participants-names">与 ${chatName}</span>
                    </div>
                </div>
            `;
    return card;
  }



  async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('call-transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';

    const deleteBtn = document.getElementById('delete-transcript-btn');
    const summarizeBtn = document.getElementById('manual-summarize-btn');

    if (!record.transcript || record.transcript.length === 0) {
      bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
      summarizeBtn.style.display = 'none';
    } else {
      summarizeBtn.style.display = 'block';
      record.transcript.forEach(entry => {
        const bubble = document.createElement('div');
        bubble.className = `transcript-entry ${entry.role}`;
        bubble.textContent = entry.content;
        bodyEl.appendChild(bubble);
      });
    }

    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    const newSummarizeBtn = summarizeBtn.cloneNode(true);
    summarizeBtn.parentNode.replaceChild(newSummarizeBtn, summarizeBtn);

    newDeleteBtn.addEventListener('click', async () => {
      const confirmed = await showCustomConfirm(
        "确认删除", "确定要永久删除这条通话记录吗？此操作不可恢复。", {
          confirmButtonClass: 'btn-danger'
        }
      );
      if (confirmed) {
        modal.classList.remove('visible');
        await db.callRecords.delete(recordId);
        await renderCallHistoryScreen();
        alert('通话记录已删除。');
      }
    });



    newSummarizeBtn.addEventListener('click', async () => {

      const confirmed = await showCustomConfirm(
        '确认操作',
        '这将提取当前通话记录发送给AI进行总结，会消耗API额度。确定要继续吗？', {
          confirmText: '确认总结'
        }
      );


      if (!confirmed) return;

      modal.classList.remove('visible');
      const chat = state.chats[record.chatId];
      if (!chat) {
        alert('错误：找不到该通话记录所属的聊天对象。');
        return;
      }

      await showCustomAlert("请稍候...", "正在请求AI进行手动总结...");

      try {
        const transcriptText = record.transcript.map(h => {
          const sender = h.role === 'user' ? (chat.settings.myNickname || '我') : (h.senderName || chat.name);
          return `${sender}: ${h.content}`;
        }).join('\n');

        await summarizeCallTranscript(record.chatId, transcriptText);

        await showCustomAlert("总结成功", `手动总结已完成！新的记忆已添加到“${chat.name}”的长期记忆中。`);

      } catch (error) {
        await showCustomAlert("总结失败", `操作失败，未能生成长期记忆。\n\n错误详情: ${error.message}`);
      }
    });





    const closeBtn = document.getElementById('close-transcript-modal-btn');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

    newCloseBtn.addEventListener('click', () => {
      modal.classList.remove('visible');
    });


    modal.classList.add('visible');
  }


  async function handleEditStatusClick() {

    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
      return;
    }
    const chat = state.chats[state.activeChatId];


    const newStatusText = await showCustomPrompt(
      '编辑对方状态',
      '请输入对方现在的新状态：',
      chat.status.text
    );


    if (newStatusText !== null) {

      chat.status.text = newStatusText.trim() || '在线';
      chat.status.isBusy = false;
      chat.status.lastUpdate = Date.now();
      await db.chats.put(chat);


      renderChatInterface(state.activeChatId);
      renderChatList();


      await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
    }
  }


  async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';


    const chats = Object.values(state.chats);

    chats.forEach(chat => {

      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.innerHTML = `
                    <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  async function openForwardTargetPicker() {
    const modal = document.getElementById('forward-target-modal');
    const listEl = document.getElementById('forward-target-list');
    listEl.innerHTML = '';

    const chats = Object.values(state.chats);

    chats.forEach(chat => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.innerHTML = `
                    <input type="checkbox" class="forward-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
                    <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

  function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
      if (callback) callback();
      return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
      document.getElementById('music-playlist-panel').classList.remove('visible');
      if (callback) callback();
    }, 400);
  }

  function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = String(lrcContent).split(/\r\n?|\n/);
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
    for (const line of lines) {
      const text = line.replace(timeRegex, '').trim();
      if (!text) continue;
      timeRegex.lastIndex = 0;
      let match;
      while ((match = timeRegex.exec(line)) !== null) {
        const minutes = parseInt(match[1], 10);
        const seconds = parseInt(match[2], 10);
        const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
        const time = minutes * 60 + seconds + milliseconds / 1000;
        lyrics.push({
          time,
          text
        });
      }
    }
    return lyrics.sort((a, b) => a.time - b.time);
  }

  function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
      lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
      return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'lyric-line';
      lineEl.textContent = line.text;
      lineEl.dataset.index = index;
      lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
  }

  function updateIslandScrollAnimation() {
  
  }

  function checkLyricScroll() {

    if (!islandLyricText || !islandLyricContainer) return;

    const textWidth = islandLyricText.scrollWidth;
    const containerWidth = islandLyricContainer.clientWidth;


    if (textWidth > containerWidth) {

      const scrollRatio = textWidth / containerWidth;
      const animationDuration = Math.max(5, scrollRatio * 5);


      islandLyricText.style.setProperty('--animation-duration', `${animationDuration}s`);
      islandLyricText.style.setProperty('--container-width', `${containerWidth}px`);
      islandLyricText.style.setProperty('--text-width', `${textWidth}px`);


      islandLyricText.classList.add('scrolling');
    } else {

      islandLyricText.classList.remove('scrolling');
    }
  }

 

  function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
      if (currentTime >= musicState.parsedLyrics[i].time) {
        newLyricIndex = i;
      } else {
        break;
      }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();

    const singleLyricEl = document.getElementById('single-lyric-display');
    if (singleLyricEl) {
      if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
        singleLyricEl.textContent = musicState.parsedLyrics[newLyricIndex].text;
      } else {
        singleLyricEl.textContent = '♪ ♪ ♪';
      }
    }

    const lyricBar = document.getElementById('global-lyrics-bar');
    if (lyricBar.classList.contains('visible')) {
      if (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) {
        lyricBar.textContent = musicState.parsedLyrics[newLyricIndex].text;
      } else {
        lyricBar.textContent = '♪';
      }
    }

  
    if (phoneScreenForIsland.classList.contains('dynamic-island-active')) {
      const lyricText = (newLyricIndex > -1 && musicState.parsedLyrics[newLyricIndex]) ?
        musicState.parsedLyrics[newLyricIndex].text :
        '♪ ♪ ♪';

    
      const firstSpan = islandLyricText.querySelector('span:first-child');
      if (firstSpan && firstSpan.textContent === lyricText) {
        return;
      }

     
      islandLyricText.style.opacity = 0;

     
      setTimeout(() => {
        

      
        islandLyricText.classList.remove('scrolling');
        islandLyricContainer.classList.remove('center-content');
        islandLyricText.style.animation = 'none';

        let span1 = islandLyricText.querySelector('span:first-child');
        let span2 = islandLyricText.querySelector('span:last-child');
        if (!span1) {
          span1 = document.createElement('span');
          islandLyricText.appendChild(span1);
        }
        if (!span2) {
          span2 = document.createElement('span');
          islandLyricText.appendChild(span2);
        }

        span1.textContent = lyricText;
        span2.textContent = lyricText;

        const textWidth = span1.offsetWidth;
        const containerWidth = islandLyricContainer.clientWidth;

       
        if (textWidth > containerWidth) {
          
          const scrollRatio = textWidth / containerWidth;
          const duration = Math.max(5, scrollRatio * 5);

          islandLyricText.style.setProperty('--marquee-duration', `${duration}s`);
          islandLyricText.classList.add('scrolling');
       
          islandLyricText.style.animation = `marquee var(--marquee-duration, 10s) linear infinite`;
        } else {
        
          islandLyricContainer.classList.add('center-content');
        }

      

     
        islandLyricText.style.opacity = 1;

      }, 200);
    }
 
  }


  function updateLyricsUI(isFullscreen = false) {
    const listSelector = isFullscreen ? '#fullscreen-lyrics-container .music-lyrics-list' : '#music-lyrics-container #music-lyrics-list';
    const containerSelector = isFullscreen ? '#fullscreen-lyrics-container' : '#music-lyrics-container';

    const lyricsList = document.querySelector(listSelector);
    const container = document.querySelector(containerSelector);
    if (!lyricsList || !container) return;

    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));

    if (musicState.currentLyricIndex === -1) {
      lyricsList.style.transform = `translateY(0px)`;
      return;
    }

    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
      activeLine.classList.add('active');
      const containerHeight = container.offsetHeight;
      const offset = (containerHeight / 2.2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
      lyricsList.style.transform = `translateY(${offset}px)`;
    }
  }

  function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
  }

  let lastTimeUpdate = 0;
  let animationFrameId;

  function updateMusicProgressBar() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }

    function step() {
      if (!musicState.isPlaying || !audioPlayer.duration) {
        return;
      }

      const now = performance.now();
      const currentTime = audioPlayer.currentTime;
      const duration = audioPlayer.duration;

      const progressPercent = (currentTime / duration) * 100;
      document.getElementById('music-progress-fill').style.width = `${progressPercent}%`;

      if (now - lastTimeUpdate > 1000) {
        document.getElementById('music-current-time').textContent = formatMusicTime(currentTime);
        document.getElementById('music-total-time').textContent = formatMusicTime(duration);
        updateActiveLyric(currentTime);
        updateIslandScrollAnimation();
        lastTimeUpdate = now;
      }

      
      animationFrameId = requestAnimationFrame(step);
    }

    animationFrameId = requestAnimationFrame(step);
  }



  function openAiResponseEditor() {
    if (!lastRawAiResponse) {
      alert("还没有可供编辑的AI响应。请先让AI回复一次。");
      return;
    }

    const editorModal = document.getElementById('ai-response-editor-modal');
    const editorContainer = document.getElementById('ai-response-editor-container');
    editorContainer.innerHTML = '';


    const actionObjects = parseAiResponse(lastRawAiResponse);

    if (actionObjects && actionObjects.length > 0) {

      actionObjects.forEach(actionObj => {


        if (typeof actionObj === 'object' && actionObj !== null) {
          try {

            const formattedJson = JSON.stringify(actionObj, null, 2);
            const block = createAiResponseEditorBlock(formattedJson);
            editorContainer.appendChild(block);
          } catch (e) {

            console.error("在导演模式下 stringify 失败:", actionObj, e);
          }
        } else if (typeof actionObj === 'string') {

          const block = createAiResponseEditorBlock(actionObj);
          editorContainer.appendChild(block);
          console.warn("在导演模式中发现一个无效的片段 (来自parseAiResponse的文本回退):", actionObj);
        }
      });
    } else {

      const block = createAiResponseEditorBlock(lastRawAiResponse);
      editorContainer.appendChild(block);
    }


    editorModal.classList.add('visible');
  }


 
  function createAiResponseEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'ai-response-editor-block';


    const templates = {
      text: {
        type: 'text',
        content: '在这里输入文本...'
      },
      sticker: {
        type: 'sticker',
        url: 'https://...',
        meaning: '表情含义'
      },
      image: {
        type: 'ai_image',
        description: '在这里输入图片描述...'
      },
      voice: {
        type: 'voice_message',
        content: '在这里输入语音内容...'
      },
      transfer: {
        type: 'transfer',
        amount: 5.20,
        note: '一点心意'
      },
      offline: {
        type: 'offline_text',
        content: '「在这里输入对话内容」\\n(在这里输入动作或环境描写)'
      },
      quote: {
        type: 'quote_reply',
        target_timestamp: 1234567890,
        reply_content: '在这里输入回复内容'
      },
      
      nai: {
        type: 'naiimag',
        prompt: '1girl, best quality, masterpiece, ...'
      },
      narration: {
            type: 'narration',
            content: '在这里输入环境或心理描写...'
        }
      
  
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条动作">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.text)}'>文本</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.sticker)}'>表情</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.offline)}'>线下</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.quote)}'>引用</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.nai)}' style="color: #6a329f; border-color: #6a329f;">NAI生图</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.narration)}' style="color: #888; border-color: #ccc;">旁白</button>
            
            </div>
    `;


    block.querySelector('.delete-block-btn').addEventListener('click', () => {
      block.remove();
    });


    block.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const templateStr = btn.dataset.template;
        const textarea = block.querySelector('textarea');
        if (templateStr && textarea) {
          try {
            const templateObj = JSON.parse(templateStr);

            textarea.value = JSON.stringify(templateObj, null, 2);
            textarea.focus();
          } catch (e) {
            console.error("解析格式模板失败:", e);
          }
        }
      });
    });

    return block;
  }


  async function saveEditedAiResponse() {

    const chatsToUpdate = new Map();
    let oldMessageTimestampProvider = null;

    if (lastPrivateMessagesSent.length > 0) {
      console.log(`导演剪辑室：正在撤销 ${lastPrivateMessagesSent.length} 条上一轮发送的私信...`);

      const oldPrivateMessages = [...lastPrivateMessagesSent];
      oldMessageTimestampProvider = oldPrivateMessages.values();

      const chatIdsToUndo = [...new Set(oldPrivateMessages.map(ref => ref.chatId))];

      for (const chatId of chatIdsToUndo) {
        const chat = await db.chats.get(chatId);
        if (chat) {
          chatsToUpdate.set(chatId, chat);
        }
      }

      for (const msgRef of oldPrivateMessages) {
        const chat = chatsToUpdate.get(msgRef.chatId);
        if (chat) {
          chat.history = chat.history.filter(msg => msg.timestamp !== msgRef.timestamp);
        }
      }

      if (chatsToUpdate.size > 0) {
        await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
      }

      lastPrivateMessagesSent = [];
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    const editorContainer = document.getElementById('ai-response-editor-container');
    const editorTextareas = editorContainer.querySelectorAll('textarea');
    const editedRawBlocks = Array.from(editorTextareas).map(ta => ta.value.trim()).filter(Boolean);


   
    const originalAiMessages = chat.history.filter(msg => lastResponseTimestamps.includes(msg.timestamp));
    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));


    if (editedRawBlocks.length === 0) {
      await db.chats.put(chat);
      renderChatInterface(state.activeChatId);
      renderChatList();
      document.getElementById('ai-response-editor-modal').classList.remove('visible');
      lastRawAiResponse = '';
      lastResponseTimestamps = [];
      return;
    }


    let newMessagesArray = [];
    for (const rawContent of editedRawBlocks) {
      try {

        const parsedObject = JSON.parse(rawContent);
        newMessagesArray.push(parsedObject);
      } catch (e) {
        console.warn("跳过一个无法解析为JSON的编辑块:", rawContent);
      }
    }



    const originalNaiMsgs = originalAiMessages.filter(m => m.type === 'naiimag');
    let naiMsgIndex = 0;
 

    let newTimestamps = [];
    let messageTimestamp = Date.now();
    const privateChatsToSave = new Map();
    const groupChatsToSave = new Map();
    for (const msgData of newMessagesArray) {
      if (!msgData || typeof msgData !== 'object' || !msgData.type) {
        console.warn("在导演模式保存时，发现无效的指令对象，已跳过:", msgData);
        continue;
      }

      let aiMessage = null;
      const baseMessage = {
        role: 'assistant',
        senderName: msgData.name || chat.originalName,
        timestamp: messageTimestamp++
      };

      switch (msgData.type) {
case 'narration':
        aiMessage = {
            ...baseMessage,
            type: 'narration',
            content: String(msgData.content),
            role: 'system' // 强制设为 system 角色以确保样式正确
        };
        break;
    case 'buy_item': {
    const itemName = msgData.item_name;
    const price = parseFloat(msgData.price);
    const reason = msgData.reason || '想买';

    if (!itemName || isNaN(price) || price <= 0) continue; // 数据无效跳过

    // 1. 重新获取钱包数据（确保实时性）
    const currentWallet = await db.userWallet.get('main');
    const cardIndex = currentWallet?.kinshipCards?.findIndex(c => c.chatId === chat.id);

    if (cardIndex > -1) {
        const card = currentWallet.kinshipCards[cardIndex];
        const remaining = card.limit - (card.spent || 0);

        if (remaining >= price) {
            // 2. 执行扣款
            currentWallet.kinshipCards[cardIndex].spent = (card.spent || 0) + price;
            await db.userWallet.put(currentWallet);

            // 3. 记录账单
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: price,
                description: `亲属卡消费-${chat.name}-${itemName}`
            });

            // 4. 生成系统通知消息 (AI发送的)
            const successMsg = {
                role: 'assistant', // 或者是 'system'，看你喜好
                senderName: chat.name, // 加上这个确保群聊显示正常
                type: 'text', // 或者用 'pat_message' 样式
                content: `[支付宝通知] 我使用亲属卡消费了 ¥${price.toFixed(2)} 购买了“${itemName}”。\n💭 ${reason}`,
                timestamp: messageTimestamp++
            };
            
            chat.history.push(successMsg);
            
            // 如果是当前查看的聊天，直接上屏
            if (isViewingThisChat) {
                 appendMessage(successMsg, chat);
            } else {
                 // 如果在后台，发送通知
                 showNotification(chat.id, `${chat.name} 使用亲属卡消费了 ¥${price}`);
            }
            
            // 5. (可选) 将购买记录写入角色的模拟淘宝历史，增加真实感
            if (!chat.simulatedTaobaoHistory) chat.simulatedTaobaoHistory = { totalBalance: 0, purchases: [] };
            if (!chat.simulatedTaobaoHistory.purchases) chat.simulatedTaobaoHistory.purchases = [];
            
            chat.simulatedTaobaoHistory.purchases.unshift({
                itemName: itemName,
                price: price,
                status: '已签收',
                reason: reason,
                image_prompt: `${itemName}, product photography` // 简单生成个prompt
            });
            
            hasPerformedMajorAction = true; // 标记为已执行重要操作（用于后台活动）
        } else {
            console.log(`AI 想要购买 ${itemName} (¥${price}) 但亲属卡余额不足 (剩 ¥${remaining})`);
            // 可选：让 AI 发一条消息抱怨没钱了
            const failMsg = {
                role: 'assistant',
                senderName: chat.name,
                content: `本来想买“${itemName}”的，但是亲属卡额度好像不够了... (¥${price})`,
                timestamp: messageTimestamp++
            };
            chat.history.push(failMsg);
            if (isViewingThisChat) appendMessage(failMsg, chat);
        }
    }
    continue;
}
        case 'send_private_message': {
          const senderOriginalName = msgData.name;
          const recipientOriginalName = msgData.recipient;
          const userOriginalName = state.qzoneSettings.nickname || '{{user}}';

          if (recipientOriginalName === userOriginalName) {
            const privateChat = Object.values(state.chats).find(c => !c.isGroup && c.originalName === senderOriginalName);

            if (privateChat) {

              if (!privateChatsToSave.has(privateChat.id)) {

                const freshPrivateChat = chatsToUpdate.get(privateChat.id) || await db.chats.get(privateChat.id);

                privateChatsToSave.set(privateChat.id, freshPrivateChat);
              }

              const chatToUpdate = privateChatsToSave.get(privateChat.id);

              const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [msgData.content];
              let newMessagesCount = 0;

              for (const contentString of messagesToSend) {
                if (!contentString || !contentString.trim()) continue;

                const oldMsgRef = (oldMessageTimestampProvider) ? oldMessageTimestampProvider.next().value : null;

                const timestampToUse = (oldMsgRef && oldMsgRef.chatId === privateChat.id) ?
                  oldMsgRef.timestamp :
                  messageTimestamp++;

                const privateMessage = {
                  role: 'assistant',
                  senderName: senderOriginalName,
                  content: contentString,
                  timestamp: timestampToUse
                };


                lastPrivateMessagesSent.push({
                  chatId: privateChat.id,
                  timestamp: privateMessage.timestamp
                });

                chatToUpdate.history.push(privateMessage);
                newMessagesCount++;
              }

              if (newMessagesCount > 0) {
                if (state.activeChatId !== privateChat.id) {
                  chatToUpdate.unreadCount = (chatToUpdate.unreadCount || 0) + newMessagesCount;
                  showNotification(privateChat.id, `${privateChat.name} 发来了 ${newMessagesCount} 条新消息`);
                }
              }

              aiMessage = null;

            } else {
              console.warn(`AI ${senderOriginalName} 尝试发送私信，但未找到其对应的私聊会话。`);
              aiMessage = null;
            }
          } else {
            console.warn(`AI 尝试发送私信给非用户角色 (${recipientOriginalName})，此功能暂不支持。`);
            aiMessage = null;
          }

          continue;
        }
        case 'send_group_message': {
          const senderOriginalName = msgData.name || chat.originalName;
          const targetGroupName = msgData.targetGroupName;
          const messagesToSend = Array.isArray(msgData.content) ? msgData.content : [String(msgData.content)];

          if (!targetGroupName) {
            console.warn(`导演模式保存(send_group_message): 未指定 targetGroupName，已跳过。`);
            continue;
          }

          // 查找目标群聊，并确保AI是该群的成员
          const targetGroupChat = Object.values(state.chats).find(c =>
            c.isGroup &&
            c.name === targetGroupName &&
            c.members.some(m => m.originalName === senderOriginalName)
          );

          if (targetGroupChat) {
            // 如果群聊尚未被暂存，则从数据库加载最新数据并存入 Map
            if (!groupChatsToSave.has(targetGroupChat.id)) {
              const freshGroupChat = await db.chats.get(targetGroupChat.id);
              groupChatsToSave.set(targetGroupChat.id, freshGroupChat);
            }

            const chatToUpdate = groupChatsToSave.get(targetGroupChat.id);
            let newMessagesCount = 0;

            for (const contentString of messagesToSend) {
              if (!contentString || !contentString.trim()) continue;

              const groupMessage = {
                role: 'assistant',
                senderName: senderOriginalName,
                content: contentString,
                timestamp: messageTimestamp++ // 使用统一的时间戳递增
              };
              chatToUpdate.history.push(groupMessage);
              newMessagesCount++;
            }

            if (newMessagesCount > 0) {
              if (state.activeChatId !== targetGroupChat.id) {
                chatToUpdate.unreadCount = (chatToUpdate.unreadCount || 0) + newMessagesCount;
              }
            }
            aiMessage = null;
          } else {
            console.warn(`导演模式保存(send_group_message): 未找到群聊 "${targetGroupName}" 或角色 "${senderOriginalName}" 不在该群中。`);
            aiMessage = null;
          }
          continue; 
        }
        case 'thought_chain': {
           continue; 
        }
        case 'text':
          aiMessage = {
            ...baseMessage,
            content: String(msgData.content || msgData.message)
          };
          break;
        case 'sticker': {
          let found = false;
          if (msgData.url && msgData.meaning) {
            aiMessage = {
              ...baseMessage,
              type: 'sticker',
              content: msgData.url,
              meaning: msgData.meaning
            };
            found = true;
          } else if (msgData.meaning) {
            const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
            if (sticker) {
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: sticker.url,
                meaning: sticker.name
              };
              found = true;
            } else {
              aiMessage = {
                ...baseMessage,
                type: 'text',
                content: `[表情: ${msgData.meaning}]`
              };
              found = true;
            }
          } else if (msgData.url) {
            aiMessage = {
              ...baseMessage,
              type: 'sticker',
              content: msgData.url
            };
            const stickerByURL = state.userStickers.find(s => s.url === msgData.url);
            aiMessage.meaning = stickerByURL ? stickerByURL.name : '未知表情';
            found = true;
          } else if (msgData.content && typeof msgData.content === 'string' && STICKER_REGEX.test(msgData.content)) {
            aiMessage = {
              ...baseMessage,
              type: 'sticker',
              content: msgData.content
            };
            const stickerByContentUrl = state.userStickers.find(s => s.url === msgData.content);
            aiMessage.meaning = stickerByContentUrl ? stickerByContentUrl.name : '未知表情';
            found = true;
          }
          if (!found) {
            console.error("导演模式保存(Sticker): 指令无效或缺少必要字段 (meaning/url/content):", msgData);
            continue;
          }
          break;
        }
        case 'ai_image':
          aiMessage = {
            ...baseMessage,
            type: 'ai_image',
            content: msgData.description,
            image_prompt: msgData.image_prompt
          };
          break;

        case 'naiimag': {
          const newPrompt = msgData.prompt;
          let newImageUrl = null;
          let newFullPrompt = null;

         
          const originalMsg = originalNaiMsgs[naiMsgIndex];
          naiMsgIndex++; // Increment cursor for the next NAI block

          let promptChanged = false;

          if (originalMsg) {
           
            const originalPrompt = originalMsg.prompt;

            
            if (newPrompt && newPrompt !== originalPrompt) {
              console.log("NAI Prompt 已改变，将触发重新生成。");
              promptChanged = true;
            } else {
          
              console.log("NAI Prompt 未改变，将保留原始图片。");
              newImageUrl = originalMsg.imageUrl;
              newFullPrompt = originalMsg.fullPrompt;
            }
          } else {
           
            console.log("未找到匹配的原始NAI图片(这是新添加的块)，将触发重新生成。");
            promptChanged = true;
          }

          if (promptChanged) {
          
            const alertMessage = originalMsg ? "检测到NAI提示词已修改，正在重新生成..." : "检测到新的NAI生图指令，正在生成...";
            await showCustomAlert("请稍候...", alertMessage);

            try {
              const generatedData = await generateNaiImageFromPrompt(newPrompt, chat.id);
              newImageUrl = generatedData.imageUrl;
              newFullPrompt = generatedData.fullPrompt;
              await showCustomAlert("成功", "图片已生成！");
            } catch (error) {
              console.error("导演模式下重新生成NAI图片失败:", error);
              await showCustomAlert("生成失败", `无法生成图片: ${error.message}. \n\n将保留旧图片（如果存在）。`);

              if (originalMsg) {
                newImageUrl = originalMsg.imageUrl; // Fallback to old image
                newFullPrompt = originalMsg.fullPrompt;
              } else {
                console.error("新NAI图片生成失败，此条消息已被跳过。");
                continue; // Skip this message
              }
            }
          }

       
          aiMessage = {
            ...baseMessage,
            type: 'naiimag',
            imageUrl: newImageUrl,
            prompt: newPrompt,
            fullPrompt: newFullPrompt
          };
          break;
        }
     

        case 'voice_message':
          aiMessage = {
            ...baseMessage,
            type: 'voice_message',
            content: msgData.content
          };
          break;
        case 'transfer':
          aiMessage = {
            ...baseMessage,
            type: 'transfer',
            amount: msgData.amount,
            note: msgData.note,
            receiverName: msgData.receiver || '我'
          };
          break;
        case 'waimai_request':
          aiMessage = {
            ...baseMessage,
            type: 'waimai_request',
            productInfo: msgData.productInfo,
            amount: msgData.amount,
            status: 'pending',
            countdownEndTime: Date.now() + 15 * 60 * 1000,
          };
          break;
        case 'offline_text':
          aiMessage = {
            ...baseMessage,
            ...msgData
          };
          break;
        case 'gomoku_move': {
          const gameState = gomokuState[chat.id];
          if (gameState) {
            const lastAiMoveIndex = gameState.history.findLastIndex(move => move.player === 2);
            if (lastAiMoveIndex > -1) {
              const move_to_undo = gameState.history[lastAiMoveIndex];
              gameState.board[move_to_undo.y][move_to_undo.x] = 0;
              gameState.history.splice(lastAiMoveIndex, 1);
              console.log(`导演模式悔棋：已撤销AI在 (${move_to_undo.x}, ${move_to_undo.y}) 的棋步。`);
            }
          }
          const x = parseInt(msgData.x);
          const y = parseInt(msgData.y);
          if (!isNaN(x) && !isNaN(y)) {
            handleAiGomokuMove({
              x: x,
              y: y
            }, true);
          } else {
            console.warn("导演模式保存了一个无效的五子棋移动指令:", msgData);
          }
          continue;
        }
        case 'update_thoughts': {
          if (!chat.isGroup) {
            if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
            if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
            if (!Array.isArray(chat.thoughtsHistory)) chat.thoughtsHistory = [];
            chat.thoughtsHistory.push({
              heartfeltVoice: chat.heartfeltVoice,
              randomJottings: chat.randomJottings, 
              timestamp: Date.now()
            });
            if (chat.thoughtsHistory.length > 50) chat.thoughtsHistory.shift();
          }
          continue;
        }
        case 'quote_reply': { // 这是在 saveEditedAiResponse() 函数中的
                let originalMessage = null;
                let quoteContext = null;
        
               
                if (msgData.target_content) {
                  originalMessage = [...chat.history].reverse().find(m => 
                    !m.isHidden &&
                    (
                      m.content === msgData.target_content ||
                      (typeof m.content === 'string' && m.content.trim() === msgData.target_content.trim())
                    )
                  );
                   if(!originalMessage) {
                     console.warn(`[导演模式保存失败] 尝试引用内容 "${(msgData.target_content || '').substring(0, 20)}..."，但在历史中未找到。`);
                   }
                } 
                
               
                else if (msgData.target_timestamp) { 
                  originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
                }
        
              
                if (originalMessage) {
                      
                     
                      let quotedSenderDisplayName;
                      
                      if (originalMessage.role === 'user') {
                      
                          quotedSenderDisplayName = chat.settings.myNickname || '我';
                      } else { 
                         
                          if (chat.isGroup) {
                            
                              quotedSenderDisplayName = getDisplayNameInGroup(chat, originalMessage.senderName);
                          } else {
                           
                              quotedSenderDisplayName = chat.name;
                          }
                      }

                      quoteContext = {
                          timestamp: originalMessage.timestamp,
                          senderName: quotedSenderDisplayName, // 使用修复后的昵称
                          content: String(originalMessage.content || '') // 确保内容是字符串
                      };
                } else {
                 
                  console.warn(`导演模式保存引用失败: 找不到目标消息 (Content: ${msgData.target_content}, TS: ${msgData.target_timestamp})`);
                }
        
                
                aiMessage = {
                  ...baseMessage,
                  content: msgData.reply_content
                };
                
                if (quoteContext) {
                  aiMessage.quote = quoteContext; 
                }
               
                
                break;
              }
        default:
          console.warn("在导演模式保存时，遇到了未知的AI指令类型:", msgData.type, msgData);
          if (msgData.content) {
            aiMessage = {
              ...baseMessage,
              content: String(msgData.content)
            };
          } else {
            continue;
          }
          break;
      }

      if (aiMessage) {
        chat.history.push(aiMessage);
        newTimestamps.push(aiMessage.timestamp);
      }
    }

     if (groupChatsToSave.size > 0) {
        await db.chats.bulkPut(Array.from(groupChatsToSave.values()));
      }
    await db.chats.put(chat);

    if (privateChatsToSave.size > 0) {
      await db.chats.bulkPut(Array.from(privateChatsToSave.values()));
    }

    renderChatInterface(state.activeChatId);
    renderChatList();
    document.getElementById('ai-response-editor-modal').classList.remove('visible');


    lastRawAiResponse = editedRawBlocks.join('\n\n');
    lastResponseTimestamps = newTimestamps;


    await showCustomAlert("导演模式", "您的修改已保存！");
  }
 
  async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000;
    const messageTime = activeMessageTimestamp;
    const now = Date.now();


    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
      hideMessageActions();
      await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
      return;
    }


    await recallMessage(messageTime, true);
    hideMessageActions();
  }

 
  async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    const recalledData = {
      originalType: messageToRecall.type || 'text',
      originalContent: messageToRecall.content,
      originalMeaning: messageToRecall.meaning,
      originalQuote: messageToRecall.quote
    };

    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
    messageToRecall.recalledData = recalledData;
    delete messageToRecall.meaning;
    delete messageToRecall.quote;


    if (isUserRecall) {

      const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';


      let recalledContentText = '';
      if (recalledData.originalType === 'sticker') {
        recalledContentText = `[表情，含义: ${recalledData.originalMeaning || '未知'}]`;
      } else if (recalledData.originalType === 'ai_image' || recalledData.originalType === 'user_photo') {
        recalledContentText = `[图片，描述: ${recalledData.originalContent}]`;
      } else {
        recalledContentText = `“${String(recalledData.originalContent)}”`;
      }


      const hiddenMessageForAI = {
        role: 'system',
        content: `[系统提示：用户（${myNickname}）刚刚撤回了一条消息。撤回前的内容是：${recalledContentText}。请你对此作出回应，可以表现出好奇、开玩笑（比如'我截图了！'）、或者根据你的人设表示理解或疑惑。]`,
        timestamp: Date.now(),
        isHidden: true
      };
      chat.history.push(hiddenMessageForAI);
    }


    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);

    if (isUserRecall) {
      renderChatList();

      //triggerAiResponse();
    }
  }



  
  async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
  }

 
  async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {

      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">×</span>
                `;
      listEl.appendChild(item);
    });
  }

 
  async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('分类名不能为空！');
      return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
      alert(`分类 "${name}" 已经存在了！`);
      return;
    }
    await db.worldBookCategories.add({
      name
    });
    input.value = '';
    await renderCategoryListInManager();
  }


  async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
      '确认删除',
      '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', {
        confirmButtonClass: 'btn-danger'
      }
    );
    if (confirmed) {
      await db.worldBookCategories.delete(categoryId);

      const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
      for (const book of booksToUpdate) {
        book.categoryId = null;
        await db.worldBooks.put(book);
        const bookInState = state.worldBooks.find(wb => wb.id === book.id);
        if (bookInState) bookInState.categoryId = null;
      }
      await renderCategoryListInManager();
    }
  }


  async function publishToAnnouncementBoard() {
    if (!activeMessageTimestamp) return;

    const timestampToPublish = activeMessageTimestamp;
    hideMessageActions();

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToPublish);
    if (!message) return;


    let contentPreview = String(message.content || '').substring(0, 50) + '...';
    if (message.type === 'ai_image') contentPreview = '[图片] ' + contentPreview;

    const confirmed = await showCustomConfirm(
      "发布公告",
      `确定要将以下消息发布到公告板吗？\n\n“${contentPreview}”`, {
        confirmText: "确定发布"
      }
    );

    if (confirmed) {
      const myNickname = chat.settings.myNickname || '我';

      if (!Array.isArray(chat.announcements)) {
        chat.announcements = [];
      }


      const newAnnouncement = {
        id: 'anno_' + Date.now(),
        messageTimestamp: timestampToPublish,
        publisher: myNickname,
        publishedAt: Date.now(),
        isPinned: false
      };

      chat.announcements.push(newAnnouncement);

      const systemMessage = {
        role: 'system',
        type: 'pat_message',
        content: `${myNickname} 发布了一条新公告`,
        timestamp: Date.now()
      };
      chat.history.push(systemMessage);

      await db.chats.put(chat);
      appendMessage(systemMessage, chat);
      renderChatList();

      await showCustomAlert("成功", "公告已发布！");
    }
  }

 
  async function showAnnouncementBoard() {
    const chat = state.chats[state.activeChatId];
    const announcements = chat.announcements || [];

    if (!chat || announcements.length === 0) {
      showCustomAlert("提示", "当前群聊还没有公告哦。");
      return;
    }

    const contentEl = document.getElementById('announcement-board-content');
    contentEl.innerHTML = '';


    announcements.sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0));


    for (const anno of announcements) {
      const originalMessage = chat.history.find(m => m.timestamp === anno.messageTimestamp);

      const wrapper = document.createElement('div');
      wrapper.className = 'announcement-item-wrapper';

      if (originalMessage) {

        const messageBubbleEl = await createMessageElement(originalMessage, chat);
        if (messageBubbleEl) {
          wrapper.appendChild(messageBubbleEl);
        }
      } else {
        wrapper.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">公告的原消息已被删除。</p>';
      }

      if (anno.isPinned) {
        wrapper.innerHTML += `<div class="pinned-indicator">📌</div>`;
      }
      wrapper.innerHTML += `<div class="announcement-item-actions" data-anno-id="${anno.id}">...</div>`;

      contentEl.appendChild(wrapper);
    }

    document.getElementById('announcement-board-modal').classList.add('visible');
  }


  let activeAnnouncementId = null;

 
  function showAnnouncementActions(annoId) {
    activeAnnouncementId = annoId;
    const chat = state.chats[state.activeChatId];
    const announcement = chat.announcements.find(a => a.id === annoId);
    if (!announcement) return;

    const pinButton = document.getElementById('announcement-action-pin');

    pinButton.textContent = announcement.isPinned ? '取消置顶' : '置顶公告';

    document.getElementById('announcement-actions-modal').classList.add('visible');
  }

 
  async function handlePinAnnouncement() {
    if (!activeAnnouncementId) return;
    const chat = state.chats[state.activeChatId];
    const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
    if (announcement) {
      announcement.isPinned = !announcement.isPinned;
      await db.chats.put(chat);
      showAnnouncementBoard();
    }
    document.getElementById('announcement-actions-modal').classList.remove('visible');
  }

 
  async function handleDeleteAnnouncement() {
    if (!activeAnnouncementId) return;

    const confirmed = await showCustomConfirm("确认删除", "确定要删除这条公告吗？此操作不可恢复。", {
      confirmButtonClass: 'btn-danger'
    });

    if (confirmed) {
      const chat = state.chats[state.activeChatId];

      chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
      await db.chats.put(chat);
      showAnnouncementBoard();
    }
    document.getElementById('announcement-actions-modal').classList.remove('visible');
  }




  let editingFrameForMember = false;
  let currentFrameSelection = {
    ai: null,
    my: null
  };

  function openFrameSelectorModal(type = 'chat') {
    const frameModal = document.getElementById('avatar-frame-modal');
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    editingFrameForMember = (type === 'member');

    if (editingFrameForMember) {
      const member = chat.members.find(m => m.id === editingMemberId);
      if (!member) return;
      currentFrameSelection.my = member.avatarFrame || '';
      populateFrameGrids(true, member.avatar, member.avatarFrame);
    } else {
      currentFrameSelection.ai = chat.settings.aiAvatarFrame || '';
      currentFrameSelection.my = chat.settings.myAvatarFrame || '';
      populateFrameGrids(false);
    }
    frameModal.classList.add('visible');
  }

  function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
      avatarFrames.forEach(frame => {
        const item = createFrameItem(frame, 'my', memberAvatar);
        if (frame.url === memberFrame) {
          item.classList.add('selected');
        }
        aiFrameGrid.appendChild(item);
      });
    } else {
      const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
      const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
      avatarFrames.forEach(frame => {
        const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
        if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
        aiFrameGrid.appendChild(aiItem);
        const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
        if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
        myFrameGrid.appendChild(myItem);
      });
    }
  }

  function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;
    item.innerHTML = `
                <img src="${previewAvatarSrc}" class="preview-avatar">
                ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
            `;
    item.addEventListener('click', () => {
      currentFrameSelection[type] = frame.url;
      const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
      grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
      item.classList.add('selected');
    });
    return item;
  }

  async function saveSelectedFrames() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (editingFrameForMember) {
      const member = chat.members.find(m => m.id === editingMemberId);
      if (member) {
        member.avatarFrame = currentFrameSelection.my;
      }
    } else {
      chat.settings.aiAvatarFrame = currentFrameSelection.ai;
      chat.settings.myAvatarFrame = currentFrameSelection.my;
    }

    await db.chats.put(chat);



    if (!editingFrameForMember && !chat.isGroup) {
      const characterId = chat.id;


      for (const groupChat of Object.values(state.chats)) {
        if (groupChat.isGroup && groupChat.members) {

          const memberToUpdate = groupChat.members.find(m => m.id === characterId);


          if (memberToUpdate) {
            memberToUpdate.avatarFrame = chat.settings.aiAvatarFrame;

            await db.chats.put(groupChat);
            console.log(`已同步角色 ${characterId} 的头像框到群聊 "${groupChat.name}"`);
          }
        }
      }
    }


    document.getElementById('avatar-frame-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    alert('头像框已保存并同步！');
    editingFrameForMember = false;
  }





  function toggleFrameManagementMode() {
    isFrameManagementMode = !isFrameManagementMode;
    const manageBtn = document.getElementById('manage-frames-btn');
    const actionBar = document.getElementById('frame-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-frames-checkbox');


    document.querySelectorAll('.frame-grid').forEach(grid => {
      grid.classList.toggle('management-mode', isFrameManagementMode);
    });

    if (isFrameManagementMode) {
      manageBtn.textContent = '完成';
      actionBar.style.display = 'flex';
      selectedFrames.clear();
      selectAllCheckbox.checked = false;
      updateDeleteFrameButton();
    } else {
      manageBtn.textContent = '管理';
      actionBar.style.display = 'none';

      document.querySelectorAll('.frame-item.selected').forEach(item => {
        item.classList.remove('selected');
      });
    }
  }


  function updateDeleteFrameButton() {
    const btn = document.getElementById('delete-selected-frames-btn');
    btn.textContent = `删除 (${selectedFrames.size})`;
  }

  
  function handleSelectAllFrames() {
    const isChecked = document.getElementById('select-all-frames-checkbox').checked;
    const visibleGrid = document.querySelector('.frame-content[style*="display: block"] .frame-grid');
    if (!visibleGrid) return;


    visibleGrid.querySelectorAll('.frame-item:has(.delete-btn)').forEach(item => {
      const frameId = parseInt(item.querySelector('.delete-btn').dataset.id);
      if (isNaN(frameId)) return;

      item.classList.toggle('selected', isChecked);
      if (isChecked) {
        selectedFrames.add(frameId);
      } else {
        selectedFrames.delete(frameId);
      }
    });
    updateDeleteFrameButton();
  }

  
  async function executeBatchDeleteFrames() {
    if (selectedFrames.size === 0) return;

    const confirmed = await showCustomConfirm(
      '确认删除',
      `确定要永久删除选中的 ${selectedFrames.size} 个自定义头像框吗？`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      const idsToDelete = [...selectedFrames];
      await db.customAvatarFrames.bulkDelete(idsToDelete);


      toggleFrameManagementMode();
      populateFrameGrids(editingFrameForMember);

      await showCustomAlert('删除成功', '选中的头像框已成功删除。');
    }
  }




  function applyGlobalCss(cssString) {
    const styleTag = document.getElementById('global-custom-style');
    if (styleTag) {

      styleTag.innerHTML = cssString || '';
    }
  }



  async function addMusicActionSystemMessage(actionText) {

    if (!musicState.isActive || !musicState.activeChatId) return;
    const chat = state.chats[musicState.activeChatId];
    if (!chat) return;


    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const fullMessage = `[系统提示：用户 (${myNickname}) ${actionText}]`;


    const systemMessage = {
      role: 'system',
      content: fullMessage,
      timestamp: Date.now(),
      isHidden: true
    };


    chat.history.push(systemMessage);
    await db.chats.put(chat);
  }




  async function handleLongScreenshot() {
    if (selectedMessages.size === 0) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    const screenshotBtn = document.getElementById('selection-screenshot-btn');
    const originalBtnText = screenshotBtn.textContent;
    screenshotBtn.textContent = '生成中...';
    screenshotBtn.disabled = true;


    const screenshotContainer = document.createElement('div');
    const phoneScreen = document.getElementById('phone-screen');
    screenshotContainer.style.width = phoneScreen.offsetWidth + 'px';
    screenshotContainer.style.position = 'absolute';
    screenshotContainer.style.top = '-9999px';
    screenshotContainer.style.left = '-9999px';
    screenshotContainer.style.display = 'flex';
    screenshotContainer.style.flexDirection = 'column';
    screenshotContainer.style.height = 'auto';

    const chatScreen = document.getElementById('chat-interface-screen');
    screenshotContainer.style.backgroundImage = chatScreen.style.backgroundImage;
    screenshotContainer.style.backgroundColor = chatScreen.style.backgroundColor || (document.getElementById('phone-screen').classList.contains('dark-mode') ? '#000000' : '#f0f2f5');

    const tempStyle = document.createElement('style');
    tempStyle.innerHTML = `
                .message-bubble.selected::after { display: none !important; }
                .cloned-header .default-controls { display: flex !important; justify-content: space-between; align-items: center; width: 100%; }
                .cloned-header .selection-controls { display: none !important; }
            `;
    document.head.appendChild(tempStyle);

    try {

      const header = chatScreen.querySelector('.header').cloneNode(true);
      header.classList.add('cloned-header');



      const messagesContainer = document.createElement('div');
      const originalMessagesContainer = document.getElementById('chat-messages');


      messagesContainer.style.display = 'flex';
      messagesContainer.style.flexDirection = 'column';
      messagesContainer.style.gap = '20px';
      messagesContainer.style.padding = '10px 15px 20px 15px';
      messagesContainer.style.width = '100%';
      messagesContainer.style.boxSizing = 'border-box';


      messagesContainer.dataset.theme = originalMessagesContainer.dataset.theme;
      messagesContainer.style.setProperty('--chat-font-size', originalMessagesContainer.style.getPropertyValue('--chat-font-size'));


      const inputArea = chatScreen.querySelector('#chat-input-area').cloneNode(true);

      const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
      sortedTimestamps.forEach(timestamp => {

        const originalBubble = document.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
        if (originalBubble) {
          const originalWrapper = originalBubble.closest('.message-wrapper');
          if (originalWrapper) {
            messagesContainer.appendChild(originalWrapper.cloneNode(true));
          }
        }
      });

      screenshotContainer.appendChild(header);
      screenshotContainer.appendChild(messagesContainer);
      screenshotContainer.appendChild(inputArea);
      document.body.appendChild(screenshotContainer);


      const images = Array.from(screenshotContainer.getElementsByTagName('img'));
      const imageLoadPromises = images.map(img => new Promise((resolve, reject) => {
        if (img.src.startsWith('data:')) {
          resolve();
          return;
        }
        const newImg = new Image();
        newImg.crossOrigin = 'anonymous';
        newImg.onload = resolve;
        newImg.onerror = resolve;
        newImg.src = img.src;
      }));

      await Promise.all(imageLoadPromises);


      const canvas = await html2canvas(screenshotContainer, {
        allowTaint: true,
        useCORS: true,
        backgroundColor: null,
        scale: window.devicePixelRatio || 2,
      });


      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `EPhone-长截图-${chat.name}-${Date.now()}.png`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 'image/png');

    } catch (error) {
      console.error('长截图生成失败:', error);
      await showCustomAlert('生成失败', '生成截图时发生错误，请检查控制台获取详情。');
    } finally {

      document.body.removeChild(screenshotContainer);
      document.head.removeChild(tempStyle);
      screenshotBtn.textContent = originalBtnText;
      screenshotBtn.disabled = false;
      exitSelectionMode();
    }
  }

  function parseMarkdown(text) {
    if (!text || typeof text !== 'string') return '';


    text = text.replace(/!h\{(.*?)\}/g, '<span class="diary-highlight">$1</span>');
    text = text.replace(/!u\{(.*?)\}/g, '<span class="diary-underline">$1</span>');
    text = text.replace(/!e\{(.*?)\}/g, '<span class="diary-emphasis">$1</span>');
    text = text.replace(/!w\{(.*?)\}/g, '<span class="diary-handwritten">$1</span>');
    text = text.replace(/!m\{(.*?)\}/g, '<span class="diary-messy">$1</span>');



    text = text.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');



    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/\~\~(.*?)\~\~/g, '<s>$1</s>');
    text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

    return text;
  }



  async function migrateOldRedPacketData() {
    console.log("开始检查并迁移旧的红包数据...");
    let migrationCount = 0;

    const allChats = Object.values(state.chats);

    for (const chat of allChats) {
      let needsDbUpdate = false;
      for (const msg of chat.history) {

        if (msg.type === 'red_packet' && msg.packetType === 'direct' && msg.role === 'assistant' && msg.hasOwnProperty('receiver') && !msg.hasOwnProperty('receiverName')) {

          msg.receiverName = msg.receiver;
          delete msg.receiver;

          needsDbUpdate = true;
          migrationCount++;
        }
      }

      if (needsDbUpdate) {
        console.log(`在聊天 "${chat.name}" 中发现并修复了旧红包数据。`);
        await db.chats.put(chat);
      }
    }

    if (migrationCount > 0) {
      console.log(`数据迁移完成！总共修复了 ${migrationCount} 条红包记录。`);
      alert(`检测到并成功修复了 ${migrationCount} 条旧的红包消息！页面将自动刷新以应用更改。`);
      location.reload();
    } else {
      console.log("未发现需要迁移的旧红包数据。");
    }
  }

  // USER状态修改弹窗 - 直接输入框
  async function showUserStatusModal(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 初始化USER状态（如果不存在）
    if (!chat.settings.userStatus) {
      chat.settings.userStatus = {
        text: '在线',
        lastUpdate: Date.now(),
        isBusy: false
      };
    }

    // 直接弹出输入框
    const customStatus = await showCustomPrompt(
      '修改在线状态',
      '请输入你的状态...',
      chat.settings.userStatus.text
    );

    if (customStatus !== null && customStatus.trim()) {
      await updateUserStatus(chatId, customStatus.trim(), false);
    }
  }

  async function updateUserStatus(chatId, statusText, isBusy) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const oldStatus = chat.settings.userStatus.text;
    
    // 更新USER状态
    chat.settings.userStatus = {
      text: statusText,
      isBusy: isBusy,
      lastUpdate: Date.now()
    };

    // 保存到数据库
    await db.chats.put(chat);
    state.chats[chatId] = chat;

    // 添加系统提示消息
    const myNickname = chat.settings.myNickname || '我';
    const statusUpdateMessage = {
      role: 'system',
      type: 'pat_message',
      content: `[${myNickname}的状态已更新为: ${statusText}]`,
      timestamp: Date.now()
    };

    chat.history.push(statusUpdateMessage);
    await db.chats.put(chat);

    // 如果当前在聊天界面，刷新消息显示
    if (state.activeChatId === chatId) {
      await appendMessage(statusUpdateMessage, chat);
      scrollToBottom();
    }

    console.log(`USER状态已更新: ${oldStatus} -> ${statusText}`);
  }

 
  async function openThoughtEditor() {
    
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

   
    const currentHeartfeltVoice = chat.heartfeltVoice || '';
    const newHeartfeltVoice = await showCustomPrompt(
      `编辑“${chat.name}”的心声`,
      '请输入新的心声内容...',
      currentHeartfeltVoice,
      'textarea'
    );

 
    if (newHeartfeltVoice === null) {
      await showCustomAlert("操作取消", "心声编辑已取消。");
      return;
    }

   
    const currentRandomJottings = chat.randomJottings || '';
    const newRandomJottings = await showCustomPrompt(
      `编辑“${chat.name}”的散记`,
      '请输入新的散记内容...',
      currentRandomJottings,
      'textarea'
    );

 
    if (newRandomJottings === null) {
      await showCustomAlert("操作取消", "散记编辑已取消，心声的修改也未保存。");
      return;
    }

   
    chat.heartfeltVoice = newHeartfeltVoice.trim();
    chat.randomJottings = newRandomJottings.trim();

 
    if (!Array.isArray(chat.thoughtsHistory)) {
      chat.thoughtsHistory = [];
    }

    if (chat.thoughtsHistory.length > 0) {
    
      const lastThought = chat.thoughtsHistory[chat.thoughtsHistory.length - 1];
    
      lastThought.heartfeltVoice = chat.heartfeltVoice;
      lastThought.randomJottings = chat.randomJottings;
      lastThought.timestamp = Date.now();
    } else {
     
      chat.thoughtsHistory.push({
        heartfeltVoice: chat.heartfeltVoice,
        randomJottings: chat.randomJottings,
        timestamp: Date.now()
      });
    }

 
    await db.chats.put(chat);

   
    await showCharacterProfileModal(chat.id);

    await showCustomAlert('成功', '心声和散记已更新！');
  }

  async function showCharacterProfileModal(chatId) {
    const chat = state.chats[chatId];
    if (!chat || chat.isGroup) return;





    const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
    const randomJottingsEl = document.getElementById('profile-random-jottings');

    // 检查心声功能是否开启
    const enableThoughts = chat.settings.enableThoughts !== null 
      ? chat.settings.enableThoughts 
      : state.globalSettings.enableThoughts;

    if (!enableThoughts) {
      // 功能关闭时显示提示
      heartfeltVoiceEl.innerHTML = '<span style="color: #999;">心声功能已关闭</span>';
      randomJottingsEl.innerHTML = '<span style="color: #999;">心声功能已关闭</span>';
    } else {
      // 功能开启时正常显示
      heartfeltVoiceEl.innerHTML = await applyRenderingRules(chat.heartfeltVoice || '...', chatId);
      randomJottingsEl.innerHTML = await applyRenderingRules(chat.randomJottings || '...', chatId);
    }

    const modal = document.getElementById('character-profile-modal');





    modal.classList.add('visible');
  }

  async function showThoughtsHistory() { // <-- 1. 添加 async
    document.getElementById('profile-main-content').style.display = 'none';
    document.getElementById('profile-thoughts-history-view').style.display = 'flex';
    await renderThoughtsHistory(); // <-- 2. 添加 await
  }

 
  function hideThoughtsHistory() {
    document.getElementById('profile-thoughts-history-view').style.display = 'none';


    document.getElementById('profile-main-content').style.display = 'flex';
  }



  async function renderThoughtsHistory() { // <-- 1. 添加 async
    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (!chat || !chat.thoughtsHistory || chat.thoughtsHistory.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; padding: 30px 0;">这里还没有历史记录哦。</p>';
      return;
    }

    const history = [...chat.thoughtsHistory].reverse();
    const initialItems = history.slice(0, THOUGHTS_RENDER_WINDOW);

    const cardPromises = initialItems.map(thought => createThoughtCard(thought));
    const cards = await Promise.all(cardPromises);
    cards.forEach(card => listEl.appendChild(card));


    thoughtsHistoryRenderCount = initialItems.length;

    if (history.length > thoughtsHistoryRenderCount) {
      appendLoadMoreThoughtsButton(listEl);
    }
  }



  async function loadMoreThoughts() {
    if (isLoadingMoreThoughts) return;
    isLoadingMoreThoughts = true;

    const listEl = document.getElementById('thoughts-history-list');
    const chat = state.chats[state.activeChatId];
    if (!chat) {
      isLoadingMoreThoughts = false;
      return;
    }

    showLoader(listEl, 'bottom');
    await new Promise(resolve => setTimeout(resolve, 500));

    const history = [...chat.thoughtsHistory].reverse();
    const totalItems = history.length;

    const nextSliceStart = thoughtsHistoryRenderCount;
    const nextSliceEnd = thoughtsHistoryRenderCount + THOUGHTS_RENDER_WINDOW;
    const itemsToAppend = history.slice(nextSliceStart, nextSliceEnd);


    hideLoader(listEl);

  
    const cardPromises = itemsToAppend.map(thought => createThoughtCard(thought));
    const cards = await Promise.all(cardPromises);
    cards.forEach(card => listEl.appendChild(card));
 
    thoughtsHistoryRenderCount += itemsToAppend.length;

    isLoadingMoreThoughts = false;
  }



  async function createThoughtCard(thought) { // <-- 1. 添加 async
    const card = document.createElement('div');
    card.className = 'thought-card';
    const date = new Date(thought.timestamp);
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

   
    const chatId = state.activeChatId;
    const renderedVoice = await applyRenderingRules(thought.heartfeltVoice || '...', chatId);
    const renderedJottings = await applyRenderingRules(thought.randomJottings || '...', chatId);

    
    card.innerHTML = `
        <button class="thought-delete-btn" data-timestamp="${thought.timestamp}" title="删除此条记录">×</button>
        <div class="thought-header">${dateString}</div>
        <div class="thought-content">
            <div class="voice">
                <div class="label">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                    心声
                </div>
                <div class="text">${renderedVoice}</div>
            </div>
            <div class="jottings">
                <div class="label">
                     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
                    散记
                </div>
                <div class="text">${renderedJottings}</div>
            </div>
        </div>
    `;
    return card;
  }





  async function handleCardImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      let cardData;
      let avatarBase64 = null;

      if (file.name.endsWith('.json')) {

        const text = await file.text();
        cardData = JSON.parse(text);
      } else if (file.name.endsWith('.png')) {

        const arrayBuffer = await file.arrayBuffer();

        cardData = await parsePngForTavernData(arrayBuffer);


        avatarBase64 = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = async (readerEvent) => {
            let base64Result = readerEvent.target.result;

            
            if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
                try {
                    await showCustomAlert("请稍候...", "正在上传角色卡封面到 ImgBB...");
                    const imageUrl = await uploadImageToImgBB(base64Result);
                    resolve(imageUrl); 
                } catch (uploadError) {
                    console.error(uploadError);
                    await showCustomAlert("ImgBB 上传失败", `封面上传失败: ${uploadError.message}\n\n将继续使用本地 Base64 格式保存。`);
                    resolve(base64Result); 
                }
            } else {
                resolve(base64Result);
            }
        };
        reader.readAsDataURL(file);
    });
      } else {
        throw new Error("不支持的文件格式。请选择 .json 或 .png 文件。");
      }


      await createChatFromCardData(cardData, avatarBase64);

    } catch (error) {
      console.error("角色卡导入失败:", error);
      await showCustomAlert("导入失败", `无法解析角色卡文件。\n错误: ${error.message}`);
    } finally {

      event.target.value = null;
    }
  }


 
  function parsePngForTavernData(arrayBuffer) {
    return new Promise((resolve, reject) => {
      const view = new DataView(arrayBuffer);

      if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
        return reject(new Error("文件不是一个有效的PNG。"));
      }

      let offset = 8;
      const decoder = new TextDecoder();

      while (offset < view.byteLength) {
        const length = view.getUint32(offset);
        const type = decoder.decode(arrayBuffer.slice(offset + 4, offset + 8));

        if (type === 'tEXt') {
          const data = new Uint8Array(arrayBuffer, offset + 8, length);
          const nullSeparatorIndex = data.indexOf(0);
          if (nullSeparatorIndex !== -1) {
            const key = decoder.decode(data.slice(0, nullSeparatorIndex));
            if (key === 'chara') {
              const value = decoder.decode(data.slice(nullSeparatorIndex + 1));
              try {





                const binaryString = atob(value);


                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }



                const decodedData = new TextDecoder('utf-8').decode(bytes);



                resolve(JSON.parse(decodedData));
                return;
              } catch (e) {
                return reject(new Error("在PNG中找到角色数据，但解码或解析失败。错误: " + e.message));
              }
            }
          }
        }


        offset += 4 + 4 + length + 4;
      }

      reject(new Error("在PNG文件中未找到有效的Tavern AI角色数据(chara chunk)。"));
    });
  }





  function findWorldBookEntries(cardData) {




    if (cardData.data?.character_book?.entries?.length > 0) {
      console.log("诊断：在 data.character_book 中找到世界书。");
      return cardData.data.character_book.entries;
    }


    if (cardData.extensions?.character_book?.entries?.length > 0) {
      console.log("诊断：在 extensions.character_book 中找到世界书。");
      return cardData.extensions.character_book.entries;
    }


    if (cardData.data?.extensions?.character_book?.entries?.length > 0) {
      console.log("诊断：在 data.extensions.character_book 中找到世界书。");
      return cardData.data.extensions.character_book.entries;
    }


    const possibleTopLevelKeys = ['character_book', 'lorebook', 'world_info', 'char_book'];
    for (const key of possibleTopLevelKeys) {
      if (cardData[key]?.entries?.length > 0) {
        console.log(`诊断：在顶层 ${key} 中找到世界书。`);
        return cardData[key].entries;
      }
    }

    console.log("诊断：未在此角色卡中找到任何有效的世界书数据。");
    return null;
  }

 
  async function createChatFromCardData(cardData, avatarBase64 = null) {
    const effectiveCardData = cardData.data || cardData;
    if (!effectiveCardData.name) {
      throw new Error("角色卡数据无效或缺少'name'字段。");
    }

  
    let worldBookIdToLink = null;
    const worldBookEntries = findWorldBookEntries(cardData);

    if (worldBookEntries) {
      const structuredEntries = worldBookEntries
        .filter(entry => entry.enabled && entry.content)
        .map(entry => ({
          keys: entry.keys || [],
          comment: entry.comment || '',
          content: entry.content.replace(/<memory>|<\/memory>/g, '').trim()
        }));

      if (structuredEntries.length > 0) {
        const newWorldBook = {
          id: 'wb_' + Date.now(),
          name: `${effectiveCardData.name}的设定集`,
          content: structuredEntries,
          categoryId: null
        };
        await db.worldBooks.add(newWorldBook);
        state.worldBooks.push(newWorldBook);
        worldBookIdToLink = newWorldBook.id;
      }
    }

  
    let alternateGreetings = [];
   
    if (Array.isArray(effectiveCardData.alternate_greetings)) {
        alternateGreetings = effectiveCardData.alternate_greetings;
    } 
  
    else if (Array.isArray(cardData.alternate_greetings)) {
        alternateGreetings = cardData.alternate_greetings;
    }
    
  
    alternateGreetings = alternateGreetings.filter(g => g && typeof g === 'string' && g.trim() !== '');

    
    const firstGreeting = effectiveCardData.first_mes || cardData.first_mes;
    
    
    if (firstGreeting && typeof firstGreeting === 'string' && firstGreeting.trim() !== '') {
        if (!alternateGreetings.includes(firstGreeting)) {
            alternateGreetings.unshift(firstGreeting);
        }
    }


    let description = effectiveCardData.description || cardData.description || '无';
    description = description
      .replace(/```yaml/g, '').replace(/```/g, '')
      .replace(/<\/?info>/g, '').replace(/<\/?character>/g, '')
      .replace(/<\/?writing_rule>/g, '').replace(/\[OOC：.*?\]/g, '').trim();
    
    let persona = `# 角色核心设定\n${description}\n\n`;
    if (effectiveCardData.personality) persona += `# 性格补充\n${effectiveCardData.personality}\n\n`;
    if (effectiveCardData.scenario) persona += `# 场景设定\n${effectiveCardData.scenario}\n\n`;
    if (effectiveCardData.mes_example) persona += `# 对话示例\n${effectiveCardData.mes_example}\n\n`;

    const remarkName = effectiveCardData.name;
    const originalName = effectiveCardData.name;

    const newChatId = 'chat_' + Date.now();

   
    const newChat = {
      id: newChatId,
      name: remarkName.trim(),
      originalName: originalName.trim(),
      isGroup: false,
      relationship: {
        status: 'friend'
      },
      status: {
        text: '在线',
        lastUpdate: Date.now(),
        isBusy: false
      },
      settings: {
        aiPersona: persona,
        myPersona: '我是谁呀。',
        maxMemory: 10,
        aiAvatar: defaultAvatar,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: worldBookIdToLink ? [worldBookIdToLink] : [],
        aiAvatarLibrary: [],
        
       
        alternateGreetings: alternateGreetings 
      },
      history: [],
      musicData: {
        totalTime: 0
      },
      longTermMemory: []
    };

    
    if (avatarBase64) {
      newChat.settings.aiAvatar = avatarBase64;
      newChat.settings.aiAvatarLibrary.push({
        name: '默认头像',
        url: avatarBase64
      });
    }

  
    if (firstGreeting && typeof firstGreeting === 'string') {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = firstGreeting;
      const cleanGreeting = (tempDiv.textContent || tempDiv.innerText || "").replace(/原作者.*?开局/s, '').trim();
      
      if (cleanGreeting) {
        newChat.history.push({
          role: 'assistant',
          senderName: newChat.originalName,
          content: cleanGreeting,
          timestamp: Date.now()
        });
      }
    }

   
    state.chats[newChatId] = newChat;
    await db.chats.put(newChat);
    renderChatList();
    
    let successMessage = `角色 “${newChat.name}” 已成功导入！`;
    if (worldBookIdToLink) {
      successMessage += `\n\n其专属的“世界书”也已自动创建并关联。`;
    }
    if (alternateGreetings.length > 1) {
        successMessage += `\n\n检测到 ${alternateGreetings.length} 条开场白，可在“聊天设置”中切换。`;
    }
    await showCustomAlert('导入成功！', successMessage);
  }



 
  async function handleSwitchGreeting() {
    console.log("点击了切换开场按钮"); 
    
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
  
    const greetings = chat.settings?.alternateGreetings || [];

    if (greetings.length === 0) {
      alert("未检测到可用的候补开场白数据。\n请确认您已使用修复后的代码重新导入了角色卡。");
      return;
    }

   
    const options = greetings.map((text, index) => {
     
      const safeText = String(text || "");
      const preview = safeText.replace(/<[^>]*>/g, '').trim().substring(0, 20);
      return {
        text: `📜 开场 ${index + 1}: ${preview}...`,
        value: index
      };
    });

   
    const selectedIndex = await showChoiceModal('选择一个开场白', options);

  
    if (selectedIndex !== null) {
      const confirmed = await showCustomConfirm(
        '⚠️ 警告：确认切换？',
        '切换开场白将会【清空并替换】当前所有的聊天记录，就像重新开始一样。\n\n确定要继续吗？', {
          confirmButtonClass: 'btn-danger',
          confirmText: '确定切换'
        }
      );

      if (confirmed) {
        const newGreetingText = greetings[selectedIndex];
        
        
        const newMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          content: newGreetingText,
          timestamp: Date.now()
        };

        chat.history = [newMessage]; 
        
        
        await db.chats.put(chat);
        
       
        renderChatInterface(chat.id);
        
        await showCustomAlert('成功', '已切换到新的开场故事！\n点击左上角返回即可开始对话。');
      }
    }
  }





  function createWorldBookEntryBlock(entry = {
    keys: [],
    comment: '',
    content: '',
    enabled: true
  }) {
    const block = document.createElement('div');

    block.className = 'message-editor-block';


    const isChecked = entry.enabled !== false ? 'checked' : '';

    block.innerHTML = `
                <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <label class="toggle-switch" title="启用/禁用此条目">
                        <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                        <span class="slider"></span>
                    </label>
                    <button class="delete-block-btn" title="删除此条目">×</button>
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">备注 (可选)</label>
                    <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="例如：关于角色的童年" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 10px;">
                    <label style="font-size: 0.8em;">关键词 (用英文逗号,分隔)</label>
                    <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="例如: key1, key2, key3" style="padding: 8px;">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label style="font-size: 0.8em;">内容</label>
                    <textarea class="entry-content-textarea" rows="5" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
                </div>
            `;


    block.querySelector('.delete-block-btn').addEventListener('click', () => {
      block.remove();
    });

    return block;
  }




  async function toggleGomokuBoard() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('gomoku-overlay');


    if (!overlay.classList.contains('visible')) {
      const header = document.querySelector('#chat-interface-screen > .header');

      overlay.style.top = `${header.offsetHeight}px`;
      overlay.style.display = 'block';

      if (!gomokuState[chatId] || !gomokuState[chatId].isActive) {
        initGomokuGame(chatId);
      }
      renderGomokuBoard(chatId);


      setTimeout(async () => {
        overlay.classList.add('visible');

        const startMessage = {
          role: 'system',
          content: '[系统提示：用户打开了五子棋棋盘，游戏开始了。]',
          timestamp: Date.now(),
          isHidden: true
        };
        state.chats[chatId].history.push(startMessage);
        await db.chats.put(state.chats[chatId]);
      }, 10);

    } else {

      await closeGomokuBoard();
    }
  }
 
  async function closeGomokuBoard() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('gomoku-overlay');

    overlay.classList.remove('visible');



    setTimeout(() => {
      overlay.style.display = 'none';
    }, 300);

    if (gomokuState[chatId]) {
      gomokuState[chatId].isActive = false;

      const endMessage = {
        role: 'system',
        content: '[系统提示：用户关闭了五子棋棋盘，游戏结束了。]',
        timestamp: Date.now(),
        isHidden: true
      };
      state.chats[chatId].history.push(endMessage);
      await db.chats.put(state.chats[chatId]);
    }
  }

 
  function initGomokuGame(chatId) {
    const canvas = document.getElementById('gomoku-board');
    const overlay = document.getElementById('gomoku-overlay');
    const controls = document.getElementById('gomoku-controls');


    const availableWidth = overlay.offsetWidth - 40;
    const availableHeight = overlay.offsetHeight - controls.offsetHeight - 40;
    const boardSize = Math.floor(Math.min(availableWidth, availableHeight));

    const GRID_SIZE = 15;

    const cell_size = Math.floor(boardSize / GRID_SIZE);
    const final_size = cell_size * GRID_SIZE;

    canvas.width = final_size;
    canvas.height = final_size;

    gomokuState[chatId] = {
      isActive: true,
      board: Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0)),
      currentPlayer: 1,
      history: [],
      isGameOver: false,
      GRID_SIZE: GRID_SIZE,
      CELL_SIZE: cell_size
    };
  }
  
  function renderGomokuBoard(chatId) {
    const gameState = gomokuState[chatId];
    if (!gameState) return;

    const canvas = document.getElementById('gomoku-board');
    const ctx = canvas.getContext('2d');
    const {
      GRID_SIZE,
      CELL_SIZE
    } = gameState;
    const padding = CELL_SIZE / 2;


    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#e4b591';
    ctx.fillRect(0, 0, canvas.width, canvas.height);


    ctx.strokeStyle = '#5b3a29';
    ctx.lineWidth = 1;
    for (let i = 0; i < GRID_SIZE; i++) {

      ctx.beginPath();
      ctx.moveTo(padding, padding + i * CELL_SIZE);
      ctx.lineTo(canvas.width - padding, padding + i * CELL_SIZE);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(padding + i * CELL_SIZE, padding);
      ctx.lineTo(padding + i * CELL_SIZE, canvas.height - padding);
      ctx.stroke();
    }


    for (let y = 0; y < GRID_SIZE; y++) {
      for (let x = 0; x < GRID_SIZE; x++) {
        if (gameState.board[y][x] !== 0) {
          drawStone(ctx, x, y, gameState.board[y][x], gameState);
        }
      }
    }
  }


  function drawStone(ctx, x, y, player, gameState) {
    const {
      CELL_SIZE
    } = gameState;
    const padding = CELL_SIZE / 2;
    const radius = CELL_SIZE / 2 - 2;

    ctx.beginPath();
    ctx.arc(padding + x * CELL_SIZE, padding + y * CELL_SIZE, radius, 0, 2 * Math.PI);

    if (player === 1) {
      ctx.fillStyle = 'black';
    } else {
      ctx.fillStyle = 'white';
    }
    ctx.fill();
  }


  function handleBoardHover(e) {
    const chatId = state.activeChatId;
    const gameState = gomokuState[chatId];
    if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;

    const canvas = document.getElementById('gomoku-board');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
    const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);

    renderGomokuBoard(chatId);

    if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {
      const radius = gameState.CELL_SIZE / 2 - 2;
      ctx.beginPath();
      ctx.arc(gameState.CELL_SIZE / 2 + gridX * gameState.CELL_SIZE, gameState.CELL_SIZE / 2 + gridY * gameState.CELL_SIZE, radius, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fill();
    }
  }

  function handleBoardClick(e) {
    const chatId = state.activeChatId;
    const gameState = gomokuState[chatId];
    if (!gameState || gameState.isGameOver || gameState.currentPlayer !== 1) return;

    const canvas = document.getElementById('gomoku-board');
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const gridX = Math.round((x - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);
    const gridY = Math.round((y - gameState.CELL_SIZE / 2) / gameState.CELL_SIZE);

    if (gridX >= 0 && gridX < gameState.GRID_SIZE && gridY >= 0 && gridY < gameState.GRID_SIZE && gameState.board[gridY][gridX] === 0) {

      gameState.board[gridY][gridX] = 1;
      gameState.history.push({
        x: gridX,
        y: gridY,
        player: 1
      });
      renderGomokuBoard(chatId);


      if (checkWin(gridX, gridY, 1, gameState)) {
        gameState.isGameOver = true;
        setTimeout(() => alert("恭喜你，你赢了！"), 100);

        addGameEndSystemMessage('user');


      } else {
        gameState.currentPlayer = 2;

      }
    }
  }


  function handleAiGomokuMove(move, isForcedMove = false) {
    const chatId = state.activeChatId;
    const gameState = gomokuState[chatId];


    if (!gameState || gameState.isGameOver) return;
    if (!isForcedMove && gameState.currentPlayer !== 2) return;

    const {
      x,
      y
    } = move;

    if (x >= 0 && x < gameState.GRID_SIZE && y >= 0 && y < gameState.GRID_SIZE && gameState.board[y][x] === 0) {
      gameState.board[y][x] = 2;
      gameState.history.push({
        x,
        y,
        player: 2
      });
      renderGomokuBoard(chatId);

      if (checkWin(x, y, 2, gameState)) {
        gameState.isGameOver = true;
        setTimeout(() => alert("AI 获胜了！"), 100);
        addGameEndSystemMessage('ai');
      } else {
        gameState.currentPlayer = 1;
      }
    } else {
      console.warn("AI 的下棋指令无效或位置已被占据:", move);

      gameState.currentPlayer = 1;
    }
  }

 
  function checkWin(x, y, player, gameState) {
    const {
      board,
      GRID_SIZE
    } = gameState;
    const directions = [
      [1, 0],
      [0, 1],
      [1, 1],
      [1, -1]
    ];
    for (const [dx, dy] of directions) {
      let count = 1;

      for (let i = 1; i < 5; i++) {
        const newX = x + i * dx;
        const newY = y + i * dy;
        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
          count++;
        } else {
          break;
        }
      }

      for (let i = 1; i < 5; i++) {
        const newX = x - i * dx;
        const newY = y - i * dy;
        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && board[newY][newX] === player) {
          count++;
        } else {
          break;
        }
      }
      if (count >= 5) return true;
    }
    return false;
  }


 
  function formatGomokuStateForAI(gameState) {
    if (!gameState || !gameState.isActive) return "";

    let boardString = "棋盘状态 (1是你(黑棋), 2是AI(白棋)):\n";
    boardString += gameState.board.map(row => row.join(' ')).join('\n');

    let historyString = "下棋历史 (x,y坐标均从0开始):\n";
    historyString += gameState.history.map(move => `玩家${move.player}下在(${move.x},${move.y})`).join(' -> ');

    return `
# 当前五子棋局势
${boardString}

# ${historyString}

# 【【【五子棋核心规则与强制思考步骤 (最高优先级指令！)】】】

### **【【【落子铁律 (绝对禁止！)】】】**
你【绝对不能】选择一个棋盘上已经是 1 或 2 的坐标。你的落子点【必须】是 0。
---

### **第一步：逻辑分析 (内部思考，不要输出)**

1.  **【规则定义】**: 
    -   棋子: 1代表用户(黑棋)，2代表你(白棋)。
    -   获胜条件: 横、竖、斜线上有【连续五个】自己的棋子。

2.  **【防守分析 (必须执行)】**:
    -   **检查用户(1)是否有“四子连线”的威胁？** 如果有，我必须下在哪个坐标才能堵住？
    -   **检查用户(1)是否有“活三”的威胁？** 如果有，最佳的防守点是哪里？

3.  **【进攻分析 (必须执行)】**:
    -   **检查我(2)是否有“一步胜利”的机会？** (即已有四子连线) 如果有，我应该下在哪里？
    -   **检查我(2)是否有制造“活四”或“双三”的机会？** 如果有，最佳的进攻点是哪里？

### **第二步：决策与扮演 (内部思考，不要输出)**

1.  **【决策】**: 综合以上攻防分析，我的最佳棋步是落在坐标 (x, y)。

2.  **【融入角色扮演】**:
    -   我的性格是：(在此处回顾你的人设)。
    -   根据我的性格，我应该：
        a) **(聪明/好胜型)** 下在刚刚分析出的最佳位置。
        b) **(迷糊/放水型)** 故意选择一个次优的位置，但【前提是不能让用户立刻获胜】。
        c) **(其他性格)** 根据性格特点，选择一个合理的棋步。

3.  **【构思台词】**: 根据我选择的棋步和我的性格，我应该说一句什么样的台词来评论棋局？

---
### **第三步：生成最终回复 (你的唯一输出)**

现在，根据你第二步的最终决策，生成你的行动。
-   你的回复【必须且只能】是一个JSON数组。
-   **绝对不要**在最终回复中包含任何上述的思考过程。
-   格式: \`[{"type": "gomoku_move", "name": "你的角色本名", "x": (0-14), "y": (0-14)}, {"type": "text", "content": "你的台词..."}]\`
`;
  }

  async function addGameEndSystemMessage(winner) {
    const chatId = state.activeChatId;
    const chat = state.chats[chatId];
    if (!chat) return;



    const userDisplayName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const aiDisplayName = chat.isGroup ? 'AI方' : chat.name;
    const winnerName = (winner === 'user') ? userDisplayName : aiDisplayName;
    const resultText = (winner === 'user') ? '你输了' : '你赢了';


    const systemContent = `[系统提示：五子棋游戏已结束。最终结果是：${winnerName} 获胜。也就是说，${resultText}。]`;


    const hiddenMessage = {
      role: 'system',
      content: systemContent,
      timestamp: Date.now(),
      isHidden: true
    };

    chat.history.push(hiddenMessage);
    await db.chats.put(chat);


    console.log(`游戏结束的系统提示已添加到历史记录中，等待AI下次查看。胜者: ${winner}`);
  }


 


  let isProductManagementMode = false;



  async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const tabsContainer = document.getElementById('product-category-tabs');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    tabsContainer.innerHTML = '';

    const [allProducts, allCategories] = await Promise.all([
      db.shoppingProducts.toArray(),
      db.shoppingCategories.orderBy('name').toArray()
    ]);

    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);


    const allTab = document.createElement('button');
    allTab.className = 'product-category-tab';
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
    tabsContainer.appendChild(allTab);

    allCategories.forEach(cat => {
      const tab = document.createElement('button');
      tab.className = 'product-category-tab';
      tab.textContent = cat.name;
      tab.dataset.categoryId = cat.id;
      if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
      tabsContainer.appendChild(tab);
    });

    let productsToShow;
    if (activeShoppingCategoryId === 'all') {
      productsToShow = allProducts;
    } else {
      productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
    }

    if (productsToShow.length === 0) {
      const message = activeShoppingCategoryId === 'all' ?
        '商店空空如也，点击“管理”添加商品吧！' :
        '这个分类下还没有商品哦~';
      gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
      return;
    }

    productsToShow.forEach(product => {
      const item = document.createElement('div');
      item.className = 'product-item';
      item.dataset.id = product.id;



      const managementControls = `
                    <div class="product-management-overlay">
                        <button class="edit-product-btn">编辑</button>
                        <button class="delete-product-btn">删除</button>
                    </div>
                `;

      item.innerHTML = `
                    ${managementControls}
                    <img src="${product.imageUrl}" class="product-image">
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-footer">
                            <div class="product-price">${product.price.toFixed(2)}</div>
                            <button class="add-to-cart-btn">加入购物车</button>
                        </div>
                    </div>
                `;
      gridEl.appendChild(item);
    });
  }


  function switchShoppingCategory(categoryId) {
    activeShoppingCategoryId = categoryId;
    renderShoppingProducts();
    updateDeleteCategoryButtonVisibility();
  }

  function updateDeleteCategoryButtonVisibility() {
    const deleteBtn = document.getElementById('delete-current-category-btn');
    if (!deleteBtn) return;




    const isVisible = isProductManagementMode && activeShoppingCategoryId !== 'all';
    deleteBtn.style.display = isVisible ? 'flex' : 'none';
  }

  
  async function handleDeleteCurrentCategory() {
    if (activeShoppingCategoryId === 'all') return;

    const categoryId = activeShoppingCategoryId;
    const category = await db.shoppingCategories.get(categoryId);
    if (!category) {
      alert("错误：找不到要删除的分类。");
      return;
    }

    const confirmMessage = `确定要永久删除分类 “${category.name}” 吗？\n\n此操作【不会】删除分类下的商品，它们将被移至“未分类”。`;
    const confirmed = await showCustomConfirm('确认删除分类', confirmMessage, {
      confirmButtonClass: 'btn-danger',
      confirmText: '确认删除'
    });

    if (confirmed) {

      await deleteProductCategory(categoryId);


      activeShoppingCategoryId = 'all';
      await renderShoppingProducts();


      updateDeleteCategoryButtonVisibility();

      await showCustomAlert("成功", `分类 “${category.name}” 已被删除。`);
    }
  }
  


  async function openShoppingScreen() {
    activeShoppingCategoryId = 'all';
    await renderShoppingProducts();
    showScreen('shopping-screen');
    updateDeleteCategoryButtonVisibility();
  }


  async function renderShoppingProducts() {
    const gridEl = document.getElementById('product-grid');
    const tabsContainer = document.getElementById('product-category-tabs');
    const shoppingScreen = document.getElementById('shopping-screen');
    gridEl.innerHTML = '';
    tabsContainer.innerHTML = '';


    const [allProducts, allCategories] = await Promise.all([
      db.shoppingProducts.toArray(),
      db.shoppingCategories.orderBy('name').toArray()
    ]);

    shoppingScreen.classList.toggle('management-mode', isProductManagementMode);


    const allTab = document.createElement('button');
    allTab.className = 'product-category-tab';
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    if (activeShoppingCategoryId === 'all') allTab.classList.add('active');
    tabsContainer.appendChild(allTab);

    allCategories.forEach(cat => {
      const tab = document.createElement('button');
      tab.className = 'product-category-tab';
      tab.textContent = cat.name;
      tab.dataset.categoryId = cat.id;
      if (activeShoppingCategoryId === cat.id) tab.classList.add('active');
      tabsContainer.appendChild(tab);
    });


    let productsToShow;
    if (activeShoppingCategoryId === 'all') {
      productsToShow = allProducts;
    } else {
      productsToShow = allProducts.filter(p => p.categoryId === activeShoppingCategoryId);
    }


    if (productsToShow.length === 0) {
      const message = activeShoppingCategoryId === 'all' ?
        '商店空空如也，点击“管理”添加商品吧！' :
        '这个分类下还没有商品哦~';
      gridEl.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">${message}</p>`;
      return;
    }

    productsToShow.forEach(product => {
      const item = document.createElement('div');
      item.className = 'product-item';
      item.dataset.id = product.id;

      const managementControls = isProductManagementMode ? `
            <div class="product-management-overlay">
                <button class="edit-product-btn">编辑</button>
                <button class="delete-product-btn">删除</button>
            </div>
        ` : '';

      item.innerHTML = `
            ${managementControls}
            <img src="${product.imageUrl}" class="product-image">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-footer">
                    <div class="product-price">${product.price.toFixed(2)}</div>
                    <button class="add-to-cart-btn">加入购物车</button>
                </div>
            </div>
        `;
      gridEl.appendChild(item);
    });
  }


  async function addToCart(productId, quantity = 1, variation = null) {

    const existingItem = variation ?
      shoppingCart.find(item => item.productId === productId && item.variation?.name === variation.name) :
      shoppingCart.find(item => item.productId === productId && !item.variation);

    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      const product = await db.shoppingProducts.get(productId);
      if (product) {
        shoppingCart.push({
          productId: product.id,
          quantity: quantity,
          variation: variation
        });
      }
    }
    updateCartCount();
  }

 
  function updateCartItemQuantity(productId, change) {
    const itemIndex = shoppingCart.findIndex(item => item.productId === productId);
    if (itemIndex > -1) {
      shoppingCart[itemIndex].quantity += change;
      if (shoppingCart[itemIndex].quantity <= 0) {
        shoppingCart.splice(itemIndex, 1);
      }
      updateCartCount();
      renderCartItems();
    }
  }

 
  function updateCartCount() {
    const totalItems = shoppingCart.reduce((sum, item) => sum + item.quantity, 0);
    document.getElementById('cart-count').textContent = totalItems;
    document.getElementById('cart-title').textContent = `购物车(${totalItems})`;
    document.getElementById('checkout-btn').textContent = `结算(${totalItems})`;
  }

  
  function openCartScreen() {
    renderCartItems();
    showScreen('cart-screen');
  }


 
  async function renderCartItems() {
    const listEl = document.getElementById('cart-items-list');
    listEl.innerHTML = '';
    let total = 0;

    if (shoppingCart.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">购物车是空的哦~</p>';
    } else {
      const productIds = shoppingCart.map(item => item.productId);
      const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
      const productMap = new Map(products.map(p => [p.id, p]));

      shoppingCart.forEach(item => {
        const product = productMap.get(item.productId);
        if (product) {
          const itemEl = document.createElement('div');
          itemEl.className = 'cart-item';


          const variationHtml = item.variation ?
            `<div class="cart-item-variation" style="font-size: 12px; color: #8a8a8a; margin-top: 4px;">款式: ${item.variation.name}</div>` :
            '';

          itemEl.innerHTML = `
                            <input type="checkbox" class="cart-item-checkbox" data-id="${product.id}" checked>
                            <img src="${item.variation?.imageUrl || product.imageUrl}" class="cart-item-image">
                            <div class="cart-item-info">
                                <div class="cart-item-name">${product.name}</div>
                                ${variationHtml}
                                <div class="cart-item-footer">
                                    <div class="cart-item-price">¥${(item.variation?.price || product.price).toFixed(2)}</div>
                                    <div class="quantity-control">
                                        <button class="quantity-btn decrease-qty-btn" data-id="${product.id}">-</button>
                                        <span class="quantity-display">${item.quantity}</span>
                                        <button class="quantity-btn increase-qty-btn" data-id="${product.id}">+</button>
                                    </div>
                                </div>
                            </div>
                        `;
          listEl.appendChild(itemEl);
        }
      });
    }
    updateCartTotal();
  }



  async function updateCartTotal() {
    let total = 0;
    const selectedCheckboxes = document.querySelectorAll('.cart-item-checkbox:checked');
    const selectedProductIds = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));

    if (selectedProductIds.length > 0) {
      const products = await db.shoppingProducts.where('id').anyOf(selectedProductIds).toArray();
      const productMap = new Map(products.map(p => [p.id, p]));

      shoppingCart.forEach(cartItem => {
        if (selectedProductIds.includes(cartItem.productId)) {
          const product = productMap.get(cartItem.productId);
          if (product) {

            const price = cartItem.variation ? cartItem.variation.price : product.price;
            total += price * cartItem.quantity;
          }
        }
      });
    }
    document.getElementById('cart-total').textContent = `合计: ¥${total.toFixed(2)}`;
  }

  
  async function openGiftRecipientPicker() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const modal = document.getElementById('gift-recipient-modal');
    const listEl = document.getElementById('gift-recipient-list');
    listEl.innerHTML = '';


    const myNickname = chat.settings.myNickname || '我';
    const members = chat.members.filter(m => m.groupNickname !== myNickname);

    members.forEach(member => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';

      item.dataset.recipientName = member.originalName;

      item.innerHTML = `
                    <div class="checkbox"></div>
                    <img src="${member.avatar || defaultGroupMemberAvatar}" class="avatar">
                    <span class="name">${member.groupNickname}</span>
                `;
      listEl.appendChild(item);
    });


    document.getElementById('select-all-recipients').checked = false;
    modal.classList.add('visible');
  }

  
// --- 修复版V2：购物结算 (修复ID解析bug，确保扣款和记账) ---
async function handleCheckout() {
    const chat = state.chats[state.activeChatId];
    const selectedItems = shoppingCart.filter(item =>
      document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
    );

    if (selectedItems.length === 0) {
      alert("请先在购物车中选择要结算的商品。");
      return;
    }

    // 计算总价
    const productIds = selectedItems.map(item => item.productId);
    const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
    const productMap = new Map(products.map(p => [p.id, p]));
    
    let totalCost = 0;
    selectedItems.forEach(cartItem => {
        const product = productMap.get(cartItem.productId);
        if (product) {
             const price = cartItem.variation ? cartItem.variation.price : product.price;
             totalCost += price * cartItem.quantity;
        }
    });

    // 1. 准备支付选项
    const wallet = await db.userWallet.get('main') || { balance: 0, kinshipCards: [] };
    const balance = wallet.balance || 0;
    const kinshipCards = wallet.kinshipCards || [];
    
    const iconWallet = `<div class="pay-opt-icon" style="background:#1677ff; display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">支</div>`;
    const iconKinship = `<div class="pay-opt-icon" style="background:linear-gradient(135deg, #ff5252, #ff1744); display:flex; align-items:center; justify-content:center; color:white; font-size:14px; border-radius:4px;">亲</div>`;

    const paymentOptions = [];
    
    if (balance >= totalCost) {
        paymentOptions.push({ 
            text: `<div class="pay-opt-left">${iconWallet}<div class="pay-opt-info"><span class="pay-opt-title">账户余额</span><span class="pay-opt-desc">剩余 ¥${balance.toFixed(2)}</span></div></div>`, 
            value: 'balance' 
        });
    }
    
    kinshipCards.forEach(card => {
        const providerChat = state.chats[card.chatId];
        const name = providerChat ? providerChat.name : '未知';
        const remaining = card.limit - (card.spent || 0);
        
        if (remaining >= totalCost) {
            paymentOptions.push({ 
                text: `<div class="pay-opt-left">${iconKinship}<div class="pay-opt-info"><span class="pay-opt-title">亲属卡 - ${name}</span><span class="pay-opt-desc">剩余额度 ¥${remaining.toFixed(2)}</span></div></div>`, 
                value: `kinship_${card.chatId}` 
            });
        }
    });

    if (paymentOptions.length === 0) {
        await showCustomAlert('支付失败', `余额或亲属卡额度不足！\n需要: ¥${totalCost.toFixed(2)}`);
        return;
    }

    // 2. 弹出支付选择
    const paymentMethod = await showChoiceModal(`支付 ¥${totalCost.toFixed(2)}`, paymentOptions);
    if (!paymentMethod) return;

    let transactionDesc = selectedItems.length === 1 ? `购买-${productMap.get(selectedItems[0].productId).name}` : `购买-${selectedItems.length}件商品`;

    // 3. 执行扣款和记账
    if (paymentMethod === 'balance') {
        const success = await processTransaction(totalCost, 'expense', transactionDesc);
        if (!success) return;
    } else if (paymentMethod.startsWith('kinship_')) {
        const cardChatId = paymentMethod.replace('kinship_', '');
        const cardIndex = wallet.kinshipCards.findIndex(c => c.chatId === cardChatId);
        
        if (cardIndex > -1) {
            // A. 扣额度
            wallet.kinshipCards[cardIndex].spent = (wallet.kinshipCards[cardIndex].spent || 0) + totalCost;
            await db.userWallet.put(wallet); 
            
            // B. 记账
            await db.userTransactions.add({
                timestamp: Date.now(),
                type: 'expense',
                amount: totalCost,
                description: `亲属卡-${transactionDesc}`
            });

            // C. 通知金主 (生成可见的系统通知，方便删除)
            const providerChat = state.chats[cardChatId];
            if (providerChat) {
                const itemNames = selectedItems.map(i => productMap.get(i.productId).name).join('、');
                const remaining = wallet.kinshipCards[cardIndex].limit - wallet.kinshipCards[cardIndex].spent;
                
                const notifyMsg = {
                    role: 'system',
                    type: 'pat_message', // 【修改】使用灰色系统消息样式
                    content: `你使用亲属卡消费 ¥${totalCost.toFixed(2)} 购买了：${itemNames} (余 ¥${remaining.toFixed(2)})`,
                    timestamp: Date.now()
                    // 【修改】移除 isHidden: true，使其可见
                };
                providerChat.history.push(notifyMsg);
                await db.chats.put(providerChat);
                
                // 如果当前就在该聊天，立即显示
                if (state.activeChatId === cardChatId) {
                    appendMessage(notifyMsg, providerChat);
                }
            }
        } else {
             alert("系统错误：找不到对应的亲属卡记录，支付取消。");
             return;
        }
    }

    // 4. 后续逻辑：选择用途 (送礼 vs 自用)
    if (chat.isGroup) {
        // 群聊逻辑保持不变：选择群友赠送
        openGiftRecipientPicker();
    } else {
        // 单聊逻辑：增加选择弹窗
        const usageChoice = await showChoiceModal('购买成功！请选择用途', [
            { text: '🎁 送给 TA', value: 'gift' },
            { text: '🛍️ 留给自己', value: 'self' }
        ]);

        if (usageChoice === 'gift') {
            // 送礼流程 (sendGiftMessage 内部会处理购物车清理和跳转)
            await sendGiftMessage(selectedItems);
        } else {
            // 自用流程
            // 1. 从购物车移除商品
            shoppingCart = shoppingCart.filter(item => !selectedItems.some(sent => sent.productId === item.productId));
            updateCartCount();
            
            // 2. 如果是余额支付，也补一条可见通知 (亲属卡刚才已经发过了)
            if (paymentMethod === 'balance') {
                const itemNames = selectedItems.map(i => productMap.get(i.productId).name).join('、');
                const selfBuyMsg = {
                    role: 'system',
                    type: 'pat_message',
                    content: `你购买了：${itemNames}`,
                    timestamp: Date.now()
                };
                chat.history.push(selfBuyMsg);
                await db.chats.put(chat);
            }
            
            // 3. 返回聊天界面
            showScreen('chat-interface-screen');
            // 如果刚才有新消息推入（余额支付通知），刷新一下界面
            if (paymentMethod === 'balance') {
                renderChatInterface(state.activeChatId);
            }
        }
    }
}

 
  async function sendGiftMessage(itemsToSend, recipients = null) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    const productIds = itemsToSend.map(item => item.productId);
    const products = await db.shoppingProducts.where('id').anyOf(productIds).toArray();
    const productMap = new Map(products.map(p => [p.id, p]));

    const itemsForMessage = itemsToSend.map(cartItem => {
      const product = productMap.get(cartItem.productId);
      if (cartItem.variation) {

        return {
          name: `${product.name} - ${cartItem.variation.name}`,
          price: cartItem.variation.price,
          imageUrl: cartItem.variation.imageUrl || product.imageUrl,
          quantity: cartItem.quantity
        };
      } else {

        return {
          name: product.name,
          price: product.price,
          imageUrl: product.imageUrl,
          quantity: cartItem.quantity
        };
      }
    });
    const giftMessage = {
      role: 'user',
      type: 'gift',
      timestamp: Date.now(),
      items: itemsForMessage,
      total: itemsForMessage.reduce((sum, item) => sum + item.price * item.quantity, 0),
      recipients: recipients
    };

    chat.history.push(giftMessage);


    if (recipients && recipients.length > 0) {
      const recipientDisplayNames = recipients.map(originalName => getDisplayNameInGroup(chat, originalName)).join('、');
      const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户 (${chat.settings.myNickname || '我'}) 送出了一份礼物，收礼人是：${recipientDisplayNames}。请收礼的角色表示感谢，其他角色可以自由发挥。]`,
        timestamp: Date.now() + 1,
        isHidden: true
      };
      chat.history.push(hiddenMessage);
    }

    await db.chats.put(chat);

    appendMessage(giftMessage, chat);
    renderChatList();


    shoppingCart = shoppingCart.filter(item => !itemsToSend.some(sent => sent.productId === item.productId));
    updateCartCount();
    showScreen('chat-interface-screen');

    await showCustomAlert('成功', '礼物已成功送出！');
  }

  
  function showGiftReceipt(timestamp) {

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'gift') return;
    const receiptBody = document.getElementById('gift-receipt-body');
    let itemsHtml = '';
    message.items.forEach(item => {
      itemsHtml += `<tr><td class="item-name">${item.name}</td><td class="item-qty">${item.quantity}</td><td class="item-price">¥${item.price.toFixed(2)}</td><td class="item-subtotal">¥${(item.price * item.quantity).toFixed(2)}</td></tr>`;
    });
    receiptBody.innerHTML = `<div class="receipt-header"><h3>购物中心</h3><p>交易时间: ${new Date(message.timestamp).toLocaleString()}</p></div><table class="receipt-items-table"><thead><tr><th class="item-name">商品</th><th class="item-qty">数量</th><th class="item-price">单价</th><th class="item-subtotal">小计</th></tr></thead><tbody>${itemsHtml}</tbody></table><div class="receipt-total">总计: ¥${message.total.toFixed(2)}</div><div class="receipt-footer">感谢您的惠顾，欢迎再次光临！</div>`;
    document.getElementById('gift-receipt-modal').classList.add('visible');
  }


  async function openProductEditor(productId = null) {
    editingProductId = productId;
    const modal = document.getElementById('product-editor-modal');
    const title = document.getElementById('product-editor-title');
    const nameInput = document.getElementById('product-name-input');
    const priceInput = document.getElementById('product-price-input');
    const descInput = document.getElementById('product-description-input');
    const imagePreview = document.getElementById('product-image-preview');
    const categorySelect = document.getElementById('product-category-select');
    const variationsContainer = document.getElementById('product-variations-container');


    variationsContainer.innerHTML = '';


    categorySelect.innerHTML = '<option value="">-- 未分类 --</option>';
    const categories = await db.shoppingCategories.toArray();
    categories.forEach(cat => {
      const option = document.createElement('option');
      option.value = cat.id;
      option.textContent = cat.name;
      categorySelect.appendChild(option);
    });

    if (productId) {
      title.textContent = '编辑商品';
      const product = await db.shoppingProducts.get(productId);
      nameInput.value = product.name;
      priceInput.value = product.price;
      descInput.value = product.description || '';
      imagePreview.src = product.imageUrl;
      categorySelect.value = product.categoryId || '';


      if (product.variations && product.variations.length > 0) {
        product.variations.forEach(v => addProductVariationInput(v));
      }

    } else {
      title.textContent = '添加商品';
      nameInput.value = '';
      priceInput.value = '';
      descInput.value = '';
      imagePreview.src = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756206115802_qdqqd_0c99bh.jpeg';
      categorySelect.value = '';
    }
    modal.classList.add('visible');
  }
  async function saveProduct() {
    const name = document.getElementById('product-name-input').value.trim();
    const price = parseFloat(document.getElementById('product-price-input').value);
    const description = document.getElementById('product-description-input').value.trim();
    const imageUrl = document.getElementById('product-image-preview').src;
    const categoryId = parseInt(document.getElementById('product-category-select').value) || null;

    if (!name) {
      alert('商品名称不能为空！');
      return;
    }
    if (isNaN(price) || price < 0) {
      alert('请输入有效的默认价格！');
      return;
    }


    const variations = [];
    document.querySelectorAll('.variation-block').forEach(block => {
      const varName = block.querySelector('.variation-name-input').value.trim();
      const varPrice = parseFloat(block.querySelector('.variation-price-input').value);
      const varImageUrl = block.querySelector('.variation-image-preview').src;

      if (varName && !isNaN(varPrice) && varPrice >= 0) {
        variations.push({
          name: varName,
          price: varPrice,
          imageUrl: varImageUrl.includes('placeholder.png') ? null : varImageUrl
        });
      }
    });

    const productData = {
      name,
      price,
      description,
      imageUrl,
      categoryId,
      variations
    };

    if (editingProductId) {
      await db.shoppingProducts.update(editingProductId, productData);
    } else {
      await db.shoppingProducts.add(productData);
    }
    document.getElementById('product-editor-modal').classList.remove('visible');
    await renderShoppingProducts();
  }



 
 




 
  async function openRenderingRulesScreen() {
    await renderRulesList();
    showScreen('rendering-rules-screen');
  }



 
  async function renderRulesList() {
    const tabsContainer = document.getElementById('rules-tabs');
    const contentContainer = document.getElementById('rules-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const allRules = await db.renderingRules.toArray();

    if (allRules.length === 0) {
        contentContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 50px;">还没有任何渲染规则。点击右上角“+”创建第一个吧！</p>';
        return;
    }

    // 1. 创建“公用规则” Tab
    const globalTab = document.createElement('button');
    globalTab.className = 'rules-tab active';
    globalTab.textContent = '公用规则';
    globalTab.dataset.categoryId = 'global';
    tabsContainer.appendChild(globalTab);

    const globalPane = document.createElement('div');
    globalPane.className = 'rules-category-pane active';
    globalPane.dataset.categoryId = 'global';
    contentContainer.appendChild(globalPane);

    // 2. 为每个角色创建 Tab
    // 找出所有至少有一条规则关联的角色，或者列出所有单聊角色
    const characterChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    characterChats.forEach(chat => {
        const charTab = document.createElement('button');
        charTab.className = 'rules-tab';
        charTab.textContent = chat.name;
        charTab.dataset.categoryId = chat.id;
        tabsContainer.appendChild(charTab);

        const charPane = document.createElement('div');
        charPane.className = 'rules-category-pane';
        charPane.dataset.categoryId = chat.id;
        contentContainer.appendChild(charPane);
    });

    // 3. 分发规则卡片到各个 Pane
    allRules.forEach(rule => {
        const card = createRuleItemElement(rule);
        
        // 兼容处理：标准化 scope 为数组
        const scope = Array.isArray(rule.chatId) ? rule.chatId : [rule.chatId];

        scope.forEach(targetId => {
            // 找到对应的 Pane
            const targetPane = contentContainer.querySelector(`.rules-category-pane[data-category-id="${targetId}"]`);
            
            if (targetPane) {
                // 克隆卡片（因为同一个规则可能要显示在多个Tab里）
                // 注意：createRuleItemElement 返回的是带事件的 DOM，直接 appendChild 会移动它而不是复制
                // 所以我们最好每次都创建新的 DOM，或者使用 cloneNode(true) 并重新绑定事件
                // 这里为了简单且事件绑定正确，我们直接复用 createRuleItemElement 逻辑多次
                const cardCopy = createRuleItemElement(rule); 
                targetPane.appendChild(cardCopy);
            }
        });
    });

    // 4. 绑定 Tab 切换事件
    document.querySelectorAll('.rules-tab').forEach(tab => {
        tab.addEventListener('click', () => switchRuleCategory(tab.dataset.categoryId));
    });
}





  function createRuleItemElement(rule) {
    const card = document.createElement('div');
    // 动态添加 selected 类
    const isSelected = selectedRules.has(rule.id);
    
    card.className = `rule-card ${rule.isEnabled ? 'enabled' : ''} ${isSelected ? 'selected' : ''}`;
    card.dataset.ruleId = rule.id;

    // 加入 checkbox
    card.innerHTML = `
        <input type="checkbox" class="rule-select-checkbox" ${isSelected ? 'checked' : ''}>
        <div class="card-title">${rule.name}</div>
        <div class="card-content-preview">${escapeHTML(rule.regex)}</div>
    `;

    // 点击事件分流
    card.addEventListener('click', (e) => {
        // 如果点击的是复选框，阻止冒泡，由下面处理
        if (e.target.classList.contains('rule-select-checkbox')) {
            e.stopPropagation();
            toggleRuleSelection(rule.id);
            return;
        }

        if (isRuleManagementMode) {
            // 管理模式下：点击卡片任意位置都视为切换选中
            toggleRuleSelection(rule.id);
        } else {
            // 普通模式：打开编辑器
            openRuleEditor(rule.id);
        }
    });

    // 长按进入管理模式 (可选体验优化)
    addLongPressListener(card, () => {
        if (!isRuleManagementMode) {
            toggleRuleManagementMode();
            toggleRuleSelection(rule.id);
        }
    });

    return card;
}

// 切换管理模式
// 切换管理模式
function toggleRuleManagementMode() {
    isRuleManagementMode = !isRuleManagementMode;
    const container = document.getElementById('rules-content-container');
    const actionBar = document.getElementById('rules-action-bar');
    const manageBtn = document.getElementById('manage-rules-btn');

    // 定义两个图标的 SVG 字符串
    const manageIconSVG = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
            <polyline points="9 11 12 14 22 4"></polyline>
        </svg>`;
    
    // 你可以选择用一个“对勾”图标表示完成，或者直接用文字“完成”
    // 这里我为了风格统一，用一个对勾图标代替“完成”文字
    const doneIconSVG = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
             <polyline points="20 6 9 17 4 12"></polyline>
        </svg>`;


    if (isRuleManagementMode) {
        container.classList.add('management-mode');
        actionBar.style.display = 'flex';
        
     
        manageBtn.innerHTML = doneIconSVG; // 新代码：切换为完成图标
      

        // manageBtn.style.color = 'var(--accent-color)'; // 图标自带颜色了，这行可以注释掉
    } else {
        container.classList.remove('management-mode');
        actionBar.style.display = 'none';

    
        manageBtn.innerHTML = manageIconSVG; // 新代码：切换回管理图标
     
        
        manageBtn.style.color = '';
        
        // 退出时清空选中
        selectedRules.clear();
        updateRuleActionBar();
        renderRulesList(); // 重新渲染以去除选中样式
    }
    
    // 重新渲染以显示/隐藏复选框
    renderRulesList();
}

// 切换单个选中状态
function toggleRuleSelection(ruleId) {
    if (selectedRules.has(ruleId)) {
        selectedRules.delete(ruleId);
    } else {
        selectedRules.add(ruleId);
    }
    updateRuleActionBar();
    
    // 更新 DOM 样式 (不重新渲染整个列表，提高性能)
    // 因为同一个规则可能在多个Tab显示，所以用 querySelectorAll
    const cards = document.querySelectorAll(`.rule-card[data-rule-id="${ruleId}"]`);
    cards.forEach(card => {
        const cb = card.querySelector('.rule-select-checkbox');
        if (selectedRules.has(ruleId)) {
            card.classList.add('selected');
            if(cb) cb.checked = true;
        } else {
            card.classList.remove('selected');
            if(cb) cb.checked = false;
        }
    });
}

// 更新底部按钮状态
function updateRuleActionBar() {
    const count = selectedRules.size;
    const exportBtn = document.getElementById('export-selected-rules-btn');
    const deleteBtn = document.getElementById('delete-selected-rules-btn');
    
    exportBtn.textContent = `导出 (${count})`;
    deleteBtn.textContent = `删除 (${count})`;
    
    // 可以在这里加 disable 逻辑
}

// 全选/反选
function handleSelectAllRules() {
    const isChecked = document.getElementById('select-all-rules-checkbox').checked;
    const visibleCards = document.querySelectorAll('#rules-content-container .rule-card');
    
    visibleCards.forEach(card => {
        const id = parseInt(card.dataset.ruleId);
        if (isChecked) {
            selectedRules.add(id);
        } else {
            selectedRules.delete(id);
        }
    });
    
    updateRuleActionBar();
    renderRulesList(); // 简单暴力重绘更新UI
}
// 导出选中的规则
async function exportSelectedRules() {
    if (selectedRules.size === 0) {
        alert("请先选择要导出的规则。");
        return;
    }

    const rules = await db.renderingRules.where('id').anyOf([...selectedRules]).toArray();
    
    // 构建导出数据结构
    const exportData = {
        type: 'EPhoneRenderingRules', // 标记文件类型
        version: 1,
        timestamp: Date.now(),
        rules: rules.map(r => ({
            name: r.name,
            regex: r.regex,
            template: r.template,
            // 导出时，建议把 chatId 重置为 ['global'] 或者空，因为接收者没有对应的角色ID
            // 但为了灵活，我们可以保留，让用户导入后自己改
            chatId: ['global'], 
            isEnabled: true,
            doNotSend: r.doNotSend
        }))
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    const dateStr = new Date().toISOString().split('T')[0];
    link.download = `RenderingRules_Share_${dateStr}.json`;
    link.click();
    URL.revokeObjectURL(url);
    
    toggleRuleManagementMode(); // 导出后退出管理模式
    await showCustomAlert("导出成功", `已导出 ${rules.length} 条规则。\n\n注意：为了方便分享，导出的规则已自动设为“公用”范围。`);
}

// 处理文件导入
async function handleRulesImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        if (data.type !== 'EPhoneRenderingRules' || !Array.isArray(data.rules)) {
            throw new Error("文件格式不正确，不是有效的渲染规则分享文件。");
        }

        const confirmed = await showCustomConfirm(
            "导入规则",
            `发现 ${data.rules.length} 条渲染规则。\n\n确定要导入吗？`,
            { confirmText: "导入" }
        );

        if (confirmed) {
            let addedCount = 0;
            // 遍历并添加，生成新ID
            for (const rule of data.rules) {
                // 简单的防重复检查 (可选：如果名字和正则完全一样则跳过)
                // 这里直接添加，并在名字后加 (Imported) 以示区分
                await db.renderingRules.add({
                    name: rule.name + " (导入)",
                    chatId: rule.chatId || ['global'],
                    regex: rule.regex,
                    template: rule.template,
                    isEnabled: true,
                    doNotSend: rule.doNotSend || false
                });
                addedCount++;
            }
            
            // 刷新
            ruleCache = {}; // 清空渲染缓存
            await renderRulesList();
            await showCustomAlert("成功", `已成功导入 ${addedCount} 条规则！`);
        }

    } catch (error) {
        console.error(error);
        alert("导入失败: " + error.message);
    } finally {
        event.target.value = null; // 重置 input
    }
}

// 批量删除
async function deleteSelectedRules() {
    if (selectedRules.size === 0) return;
    
    const confirmed = await showCustomConfirm(
        "确认删除",
        `确定要删除选中的 ${selectedRules.size} 条规则吗？`,
        { confirmButtonClass: 'btn-danger' }
    );
    
    if (confirmed) {
        await db.renderingRules.bulkDelete([...selectedRules]);
        ruleCache = {}; // 清空缓存
        selectedRules.clear();
        
        // 刷新
        toggleRuleManagementMode(); // 退出管理模式并刷新
    }
}

  async function openRuleEditor(ruleId = null) {
    editingRuleId = ruleId;
    const modal = document.getElementById('rule-editor-modal');
    const title = document.getElementById('rule-editor-title');
    const nameInput = document.getElementById('rule-name-input');
    // const chatIdSelect = document.getElementById('rule-chat-id-select'); // 旧的 select 不用了
    
    // 1. 获取或创建复选框容器 (如果HTML里没有这个容器，我们需要动态处理)
    let scopeContainer = document.getElementById('rule-scope-checkboxes');
    if (!scopeContainer) {
        // 尝试找到原来的 select 所在的父级或位置，替换它
        const oldSelect = document.getElementById('rule-chat-id-select');
        if (oldSelect) {
            scopeContainer = document.createElement('div');
            scopeContainer.id = 'rule-scope-checkboxes';
            scopeContainer.style.cssText = "max-height: 150px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #f9f9f9;";
            oldSelect.parentNode.insertBefore(scopeContainer, oldSelect);
            oldSelect.style.display = 'none'; // 隐藏旧的select
        }
    }

    const regexInput = document.getElementById('rule-regex-input');
    const templateInput = document.getElementById('rule-template-input');
    const enabledSwitch = document.getElementById('rule-enabled-switch');
    const doNotSendSwitch = document.getElementById('rule-do-not-send-switch');

    // 2. 准备现有数据
    let currentScope = ['global']; // 默认选中公用
    let currentName = '';
    let currentRegex = '';
    let currentTemplate = '';
    let currentEnabled = true;
    let currentDoNotSend = false;

    if (ruleId) {
        title.textContent = '编辑规则';
        const rule = await db.renderingRules.get(ruleId);
        if (rule) {
            currentName = rule.name;
            currentRegex = rule.regex;
            currentTemplate = rule.template;
            currentEnabled = rule.isEnabled;
            currentDoNotSend = rule.doNotSend || false;
            
            // 兼容旧数据：如果是字符串，转为数组
            if (Array.isArray(rule.chatId)) {
                currentScope = rule.chatId;
            } else {
                currentScope = [rule.chatId]; 
            }
        }
    } else {
        title.textContent = '创建新规则';
    }

    // 3. 填充表单值
    nameInput.value = currentName;
    regexInput.value = currentRegex;
    templateInput.value = currentTemplate;
    enabledSwitch.checked = currentEnabled;
    doNotSendSwitch.checked = currentDoNotSend;

    // 4. 渲染复选框列表
    if (scopeContainer) {
        scopeContainer.innerHTML = '';
        
        // 辅助函数：创建美化的列表项
        const createScopeItem = (value, name, desc, avatarUrl = null, isChecked = false) => {
            const item = document.createElement('div');
            item.className = 'rule-scope-item';
            
            // 1. 左侧视觉元素 (头像或图标)
            let visualHtml = '';
            if (value === 'global') {
                // 全局图标
                visualHtml = `<div class="rule-scope-icon-box">🌐</div>`;
            } else {
                // 角色头像 (如果有，否则用默认)
                const src = avatarUrl || 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默认头像
                visualHtml = `<img src="${src}" class="rule-scope-avatar">`;
            }

            // 2. 复选框 HTML
            const checkboxHtml = `<input type="checkbox" value="${value}" class="rule-scope-cb" ${isChecked ? 'checked' : ''}>`;

            // 3. 组装内容
            item.innerHTML = `
                ${checkboxHtml}
                ${visualHtml}
                <div class="rule-scope-info">
                    <span class="rule-scope-name">${name}</span>
                    ${desc ? `<span class="rule-scope-desc">${desc}</span>` : ''}
                </div>
            `;

            // 4. 点击整行触发选中 (提升体验)
            item.addEventListener('click', (e) => {
                // 如果点击的不是复选框本身，就手动切换复选框状态
                if (e.target.type !== 'checkbox') {
                    const cb = item.querySelector('input[type="checkbox"]');
                    cb.checked = !cb.checked;
                }
            });

            return item;
        };

        // --- 添加 "公用" 选项 ---
        scopeContainer.appendChild(createScopeItem(
            'global', 
            '公用规则', 
            '对所有角色生效', 
            null, 
            currentScope.includes('global')
        ));

        // --- 添加 "角色" 列表 ---
        const chars = Object.values(state.chats).filter(c => !c.isGroup);
        chars.forEach(chat => {
            scopeContainer.appendChild(createScopeItem(
                chat.id, 
                chat.name, 
                chat.settings.aiPersona ? chat.settings.aiPersona.substring(0, 15) + '...' : '', // 显示一点人设摘要
                chat.settings.aiAvatar, 
                currentScope.includes(chat.id)
            ));
        });
        
        // (可选) 如果你希望列表太长时有滚动提示，这里 CSS 已经处理了 max-height 和 overflow
    }

    modal.classList.add('visible');
}


  async function saveRenderingRule() {
    const name = document.getElementById('rule-name-input').value.trim();
    const regex = document.getElementById('rule-regex-input').value.trim();
    
    if (!name || !regex) {
        alert("规则名称和正则表达式不能为空！");
        return;
    }
    try {
        new RegExp(regex);
    } catch (e) {
        alert(`正则表达式格式错误: ${e.message}`);
        return;
    }

    // 1. 获取选中的范围 (Array)
    const checkboxes = document.querySelectorAll('.rule-scope-cb:checked');
    const selectedScope = Array.from(checkboxes).map(cb => cb.value);

    if (selectedScope.length === 0) {
        alert("请至少选择一个绑定范围（公用或指定角色）！");
        return;
    }

    const ruleData = {
        name: name,
        chatId: selectedScope, // 现在保存的是数组 ['global', 'chat_123'] 等
        regex: regex,
        template: document.getElementById('rule-template-input').value,
        isEnabled: document.getElementById('rule-enabled-switch').checked,
        doNotSend: document.getElementById('rule-do-not-send-switch').checked
    };

    if (editingRuleId) {
        await db.renderingRules.update(editingRuleId, ruleData);
    } else {
        await db.renderingRules.add(ruleData);
    }

    // 清空缓存，确保立即生效
    ruleCache = {};

    document.getElementById('rule-editor-modal').classList.remove('visible');
    await renderRulesList();
}


  async function deleteRenderingRule(ruleId) {
    const confirmed = await showCustomConfirm('删除规则', '确定要删除这条渲染规则吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.renderingRules.delete(ruleId);
      await renderRulesList();
    }
  }
 
  async function filterHistoryWithDoNotSendRules(history, chatId) {
    // 1. 获取所有规则
    const allRules = await db.renderingRules.toArray();

    // 2. 筛选出：(启用了DoNotSend) AND (范围包含Global或当前ChatId)
    const doNotSendRules = allRules.filter(rule => {
        if (!rule.doNotSend) return false; // 必须是 DoNotSend 类型的

        // 兼容处理：确保是数组
        const scope = Array.isArray(rule.chatId) ? rule.chatId : [rule.chatId];

        // 匹配范围
        return scope.includes('global') || scope.includes(chatId);
    });

    if (doNotSendRules.length === 0) {
        return history;
    }

    const modifiedHistory = history.map(msg => {
        if (typeof msg.content !== 'string' || !msg.content) {
            return msg;
        }

        const modifiedMsg = { ...msg };
        let newContent = msg.content;

        for (const rule of doNotSendRules) {
            try {
                let regex;
                const regexString = rule.regex || rule.findRegex;

                if (!regexString) continue;

                if (regexString.startsWith('/') && regexString.lastIndexOf('/') > 0) {
                    const lastSlash = regexString.lastIndexOf('/');
                    const pattern = regexString.substring(1, lastSlash);
                    const flags = regexString.substring(lastSlash + 1);
                    regex = new RegExp(pattern, flags);
                } else {
                    regex = new RegExp(regexString, 'g');
                }

                if (regex.test(newContent)) {
                    newContent = newContent.replace(regex, '');
                    console.log(`[内容替换] 规则 "${rule.name}" 命中 (DoNotSend)。正在过滤...`);
                }

            } catch (e) {
                console.error(`[过滤规则错误] 规则 "${rule.name}" 无效:`, e);
            }
        }

        modifiedMsg.content = newContent;
        return modifiedMsg;
    });

    return modifiedHistory;
}

  async function applyRenderingRules(rawContent, chatId) {
    if (!rawContent || typeof rawContent !== 'string') {
        return rawContent;
    }

    // 缓存机制更新：不再基于单一ID做Key，而是获取所有启用的规则并在内存中匹配
    if (!ruleCache['active_rules_list']) {
        const allRules = await db.renderingRules.toArray();
        // 过滤出所有已启用的规则
        ruleCache['active_rules_list'] = allRules.filter(r => r.isEnabled);
    }
    
    const allActiveRules = ruleCache['active_rules_list'];

    // 筛选出适用于当前 chatId 的规则
    const applicableRules = allActiveRules.filter(rule => {
        // 兼容处理：确保是数组
        const scope = Array.isArray(rule.chatId) ? rule.chatId : [rule.chatId];
        
        // 判断逻辑：如果是global 或者 包含当前chatId
        return scope.includes('global') || scope.includes(chatId);
    });

    let processedContent = rawContent;

    for (const rule of applicableRules) {
        try {
            let regex;
            const regexString = rule.regex || rule.findRegex;
            const replacementString = rule.template ?? rule.replaceString;

            if (!regexString) continue;

            if (regexString.startsWith('/') && regexString.lastIndexOf('/') > 0) {
                const lastSlash = regexString.lastIndexOf('/');
                const pattern = regexString.substring(1, lastSlash);
                const flags = regexString.substring(lastSlash + 1);
                try {
                    regex = new RegExp(pattern, flags);
                } catch (e) {
                    regex = new RegExp(regexString, 'g');
                }
            } else {
                regex = new RegExp(regexString, 'g');
            }

            processedContent = processedContent.replace(regex, replacementString);

        } catch (e) {
            console.error(`渲染规则 [${rule.name}] 执行出错:`, e);
        }
    }

    return processedContent;
}



  function formatSystemTimestamp(timestamp) {
    if (!timestamp) return '';
    const now = new Date();
    const date = new Date(timestamp);

    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeString = `${hours}:${minutes}`;


    if (now.toDateString() === date.toDateString()) {
      return timeString;
    }


    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    if (yesterday.toDateString() === date.toDateString()) {
      return `昨天 ${timeString}`;
    }


    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    if (now.getFullYear() === year) {
      return `${month}月${day}日 ${timeString}`;
    } else {
      return `${year}年${month}月${day}日 ${timeString}`;
    }
  }

 
  function createSystemTimestampElement(timestamp) {
    const wrapper = document.createElement('div');

    wrapper.className = 'message-wrapper system-pat';

    const bubble = document.createElement('div');

    bubble.className = 'message-bubble system-bubble';
    bubble.textContent = formatSystemTimestamp(timestamp);

    wrapper.appendChild(bubble);
    return wrapper;
  }



  async function handleSpectatorReroll() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !lastResponseTimestamps || lastResponseTimestamps.length === 0) {
      alert("没有可供重新生成的AI响应。");
      return;
    }


    chat.history = chat.history.filter(msg => !lastResponseTimestamps.includes(msg.timestamp));


    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);


    triggerSpectatorGroupAiAction();
  }
 
  async function handleRegenerateNaiImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];

  
    const originalPrompt = message.prompt;

    if (!originalPrompt) {
      await showCustomAlert("无法重新生成", "未找到该图片的原始提示词(prompt)。");
      return;
    }

  
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.realimag-image') : null;
    if (imgElement) {
      imgElement.style.opacity = '0.5';
    }

    try {
     
      const generatedData = await generateNaiImageFromPrompt(originalPrompt, chat.id);

    
      message.imageUrl = generatedData.imageUrl;
      message.fullPrompt = generatedData.fullPrompt; 

  
      await db.chats.put(chat);

      if (imgElement) {
        imgElement.src = generatedData.imageUrl;
        imgElement.title = generatedData.fullPrompt;
        imgElement.style.opacity = '1';
      }

    } catch (error) {
      console.error("重新生成NAI图片失败:", error);
      await showCustomAlert("生成失败", `无法重新生成图片: ${error.message}`);
      if (imgElement) {
        imgElement.style.opacity = '1';
      }
    } finally {
  
      buttonElement.disabled = false;
      buttonElement.classList.remove('loading');
    }
  }
async function handleSilentUploadUserImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];
    if (!message || message.role !== 'user' || !Array.isArray(message.content) || !message.content[0]?.type === 'image_url') {
        alert("错误：消息格式不正确。");
        return;
    }

    const base64Url = message.content[0].image_url.url;
    if (!base64Url || !base64Url.startsWith('data:image')) {
        alert("错误：这张图片已经是URL，或数据已损坏。");
        return;
    }

    // 1. 显示加载状态
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.chat-image') : null;
    if (imgElement) imgElement.style.opacity = '0.5';

    try {
        // 2. 调用已有的上传函数 (此函数在 1629 行)
        const newUrl = await uploadImageToImgBB(base64Url);

        if (newUrl === base64Url) {
            throw new Error("上传函数返回了原始Base64，可能上传失败或被跳过。");
        }

        // 3. 更新数据库中的消息
        message.content[0].image_url.url = newUrl; // 更新特定字段
        await db.chats.put(chat);
        
        // 4. 更新DOM中的图片
        if (imgElement) {
            imgElement.src = newUrl;
            imgElement.style.opacity = '1';
        }

        // 5. 隐藏按钮
        buttonElement.style.display = 'none';

    } catch (error) {
        console.error("静默上传User图片失败:", error);
        await showCustomAlert("上传失败", `无法上传到 ImgBB: ${error.message}`);
        if (imgElement) imgElement.style.opacity = '1';
    } finally {
        // 6. 移除加载状态
        buttonElement.disabled = false;
        buttonElement.classList.remove('loading');
    }
}
async function handleSilentUploadNaiImage(timestamp, buttonElement) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const msgIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (msgIndex === -1) return;

    const message = chat.history[msgIndex];
    const base64Url = message.imageUrl;

    if (!base64Url || !base64Url.startsWith('data:image')) {
        alert("错误：这张图片已经是URL，或数据已损坏。");
        return;
    }

    // 1. 显示加载状态
    buttonElement.disabled = true;
    buttonElement.classList.add('loading');
    const bubble = buttonElement.closest('.message-bubble');
    const imgElement = bubble ? bubble.querySelector('.realimag-image') : null;
    if (imgElement) imgElement.style.opacity = '0.5';

    try {
        // 2. 调用已有的上传函数 (此函数在 1629 行)
        const newUrl = await uploadImageToImgBB(base64Url);

        if (newUrl === base64Url) {
            throw new Error("上传函数返回了原始Base64，可能上传失败或被跳过。");
        }

        // 3. 更新数据库中的消息
        message.imageUrl = newUrl;
        await db.chats.put(chat);
        
        // 4. 更新DOM中的图片
        if (imgElement) {
            imgElement.src = newUrl;
            imgElement.style.opacity = '1';
        }

        // 5. 隐藏按钮
        buttonElement.style.display = 'none';

    } catch (error) {
        console.error("静默上传NAI图片失败:", error);
        await showCustomAlert("上传失败", `无法上传到 ImgBB: ${error.message}`);
        if (imgElement) imgElement.style.opacity = '1';
    } finally {
        // 6. 移除加载状态
        buttonElement.disabled = false;
        buttonElement.classList.remove('loading');
    }
}
  async function handleRegenerateResponse() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    const lastUserMsgIndex = chat.history.findLastIndex(msg => msg.role === 'user' && !msg.isHidden);

    if (lastUserMsgIndex === -1) {
      alert("没有可供重新生成回复的用户消息。");
      return;
    }


    const lastAiMsgIndex = chat.history.findLastIndex(msg => msg.role === 'assistant');
    if (lastAiMsgIndex < lastUserMsgIndex) {
      alert("AI 尚未对您的最后一条消息做出回应，无法重新生成。");
      return;
    }


    chat.history = chat.history.slice(0, lastUserMsgIndex + 1);


    await db.chats.put(chat);
    await renderChatInterface(state.activeChatId);


    await triggerAiResponse();
  }

  async function handleRegenerateCallResponse() {
    if (!videoCallState.isActive) return;


    const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(msg => msg.role === 'user');

    if (lastUserSpeechIndex === -1) {
      alert("通话中还没有你的发言，无法重新生成回应。");
      return;
    }


    videoCallState.callHistory.splice(lastUserSpeechIndex + 1);


    const callFeed = document.getElementById('video-call-main');
    callFeed.innerHTML = '';
    videoCallState.callHistory.forEach(msg => {
      const bubble = document.createElement('div');

      const speechClass = msg.role === 'assistant' ? 'ai-speech' : 'user-speech';
      bubble.className = `call-message-bubble ${speechClass}`;

      bubble.dataset.timestamp = msg.timestamp;
      if (msg.role === 'user') {
        bubble.textContent = msg.content;
      } else {
        // 对于群聊，msg.content 已包含 "角色名: 内容"
        bubble.innerHTML = msg.content;
      }
      addLongPressListener(bubble, () => showCallMessageActions(msg.timestamp));
      callFeed.appendChild(bubble);
    });
    callFeed.scrollTop = callFeed.scrollHeight;


    triggerAiInCallAction(null);
  }





 
  async function handlePropelAction() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;


    setAvatarActingState(chat.id, true);
    const chatHeaderTitle = document.getElementById('chat-header-title');
    if (!chat.isGroup) {
      chatHeaderTitle.style.opacity = 0;
      setTimeout(() => {
        chatHeaderTitle.textContent = '对方正在输入...';
        chatHeaderTitle.classList.add('typing-status');
        chatHeaderTitle.style.opacity = 1;
      }, 200);
    }

    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置');
      }

      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);

      const now = new Date();
      const chinaTime = new Date(now.getTime() + (now.getTimezoneOffset() * 60000) + (3600000 * 8));
      const currentTime = chinaTime.toLocaleString('zh-CN', {
        timeZone: 'Asia/Shanghai',
        dateStyle: 'full',
        timeStyle: 'short'
      });
      const timeOfDayGreeting = getTimeOfDayGreeting(chinaTime);
      const myNickname = chat.settings.myNickname || '我';




      let worldBookContent = '';
      if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';
          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => {
              let entryString = `\n### 条目: ${entry.comment || '无备注'}\n`;
              
              entryString += `**内容:**\n${entry.content}`;
              return entryString;
            }).join('');
          return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
          worldBookContent = `# --- 世界书 (World Book) ---
# 【最高优先级指令：绝对真理】
# 以下内容是你所在世界的“物理法则”和“基础常识”。
# 无论用户是否提及，你都【必须】时刻主动应用这些设定来指导你的思考和描写。
# 它们是无条件生效的，不需要触发词。
${linkedContents}
# --- 世界书设定结束 ---
`;
        }
      }
      let musicContext = '';
      if (musicState.isActive && musicState.activeChatId === chat.id) {
        const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
        musicContext = `\n\n# 当前音乐情景...\n(省略详细内容，与triggerAiResponse一致)`;
      }
      const gomokuContext = formatGomokuStateForAI(gomokuState[chat.id]);
      let nameHistoryContext = '';
      if (chat.nameHistory && chat.nameHistory.length > 0) {
        nameHistoryContext = `\n- **你的曾用名**: [${chat.nameHistory.join(', ')}]。当在对话历史中看到这些名字时，它们都指的是【你】自己。`;
      }
      let userProfileContext = '';
      const userQzoneNickname = state.qzoneSettings.nickname || '用户';
      userProfileContext += `- 用户的QZone昵称是 "${userQzoneNickname}"。\n`;
      const commonGroups = Object.values(state.chats).filter(group => group.isGroup && group.members.some(m => m.id === chat.id));
      if (commonGroups.length > 0) {
        userProfileContext += '- 用户在你们共同所在的群聊中的昵称如下：\n';
        commonGroups.forEach(group => {
          const myNicknameInGroup = group.settings.myNickname || userQzoneNickname;
          userProfileContext += `  - 在群聊“${group.name}”中，用户的昵称是“${myNicknameInGroup}”。\n`;
        });
      }
      userProfileContext += '当你在任何系统提示、动态评论或挂载的群聊记忆中看到这些名字时，它们都指代的是【你的聊天对象】。';
      const stickerContext = getStickerContextForPrompt(chat);

      const systemPrompt = `
# 身份与核心任务
你正在扮演角色“${chat.originalName}”，与用户（你的聊天对象）进行一场自然的、生活化的在线聊天。你的所有行为和决策都必须严格围绕你的角色设定展开。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组格式的字符串。
- 数组中的【每一个元素都必须是一个带有 "type" 字段的JSON对象】。

# 角色扮演核心规则
1.  **对话节奏**: 模拟真人的聊天习惯，将你想说的话拆分成【多条、简短的】消息。每次回复至少3-8条，且条数不要总是一样。严禁发展线下剧情。
2.  **情景感知**:
    - **时间**: 你必须感知到当前是 ${currentTime} (${timeOfDayGreeting})，并在对话中自然地体现出来。
    - **音乐**: ${musicContext ? '你们正在一起听歌，' + musicContext : '你们没有在听歌。'}

3.  **主动性**:
    - 你可以根据对话发展，使用指令来更新自己的状态、更换头像、记录回忆、发起约定或执行其他社交行为。
    - 【关系破裂时】才可使用 \`block_user\` 指令。
4.  **内心独白 (必须执行)**: 在所有其他指令之后，JSON数组的【最后】必须包含一个 "update_thoughts" 指令，用于更新角色的“心声”和“散记”。
    - **心声 (heartfelt_voice)**: 一句话概括角色此刻最核心、最私密的想法。
    - **散记 (random_jottings)**: 一段50字以上的、符合人设的思考或心情记录，禁止OOC。
请根据当前情景和你的情绪，从列表中【选择一个最合适的】表情含义来使用 "sticker" 指令。尽量让你的表情丰富多样，避免重复。
# 长期记忆 (必须严格遵守)
${chat.longTermMemory && chat.longTermMemory.length > 0 ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '- (暂无)'}

# 你的角色设定
${chat.settings.aiPersona}

# 关系与身份档案 (至关重要)
-   **你的本名**: "${chat.originalName}" (核心身份，用于指令中的'name'字段)
-   **用户给你的备注**: "${chat.name}" (你可以建议修改)
-   **你对用户的称呼**: “${myNickname}” (你可以修改)
-   **关键身份档案**:
    ${userProfileContext}
    ${nameHistoryContext}
    ${worldBookContent}
# 可用表情包
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
    ${stickerContext}
# 可用资源
-   **你的头像库**:
    ${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0 ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}
-   **用户的头像库**:
    ${chat.settings.myAvatarLibrary && chat.settings.myAvatarLibrary.length > 0 ? chat.settings.myAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') : '- (空)'}

# 可用指令列表
### 核心聊天指令
-   **发文本**: \`{"type": "text", "content": "你好呀！"}\`
-   **发表情**: \`{"type": "sticker", "meaning": "表情的含义(必须从可用表情列表选择)"}\`
-   **发图片**: \`{"type": "ai_image", "description": "详细中文描述"}\`
-   **发语音**: \`{"type": "voice_message", "content": "语音文字内容"}\`
-   **引用回复**: \`{"type": "quote_reply", "target_timestamp": 消息时间戳, "reply_content": "回复内容"}\`

### 社交与互动指令
-   **拍用户**: \`{"type": "pat_user", "suffix": "(可选)后缀"}\`
-   **分享链接**: \`{"type": "share_link", "title": "标题", "description": "摘要", "source_name": "来源", "content": "正文"}\`
-   **共享位置**: '{"type": "location_share", "content": "你想分享的位置名"}'

### 状态与关系指令
-   **改自己备注**: \`{"type": "change_remark_name", "new_name": "新名字"}\`
-   **改用户称呼**: \`{"type": "change_user_nickname", "new_name": "新称呼"}\`
-   **换自己头像**: \`{"type": "change_avatar", "name": "头像名"}\` (从你头像库选)
-   **换用户头像**: \`{"type": "change_user_avatar", "name": "头像名"}\` (从用户头像库选)
-   **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **拉黑用户**: \`{"type": "block_user"}\`

### 特殊功能指令
-   **记录回忆**: \`{"type": "create_memory", "description": "记录这件有意义的事。"}\`
-   **创建约定**: \`{"type": "create_countdown", "title": "约定标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
-   **切换歌曲**: \`{"type": "change_music", "song_name": "歌名"}\` (从播放列表选)
-   **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "备注"}\`
-   **回应转账**: \`{"type": "accept_transfer", "for_timestamp": 时间戳}\` 或 \`{"type": "decline_transfer", "for_timestamp": 时间戳}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "productInfo": "商品", "amount": 25}\` (你想让【用户】帮你付钱时使用)
-   **回应外卖代付**: \`{"type": "waimai_response", "status": "paid" or "rejected", "for_timestamp": 时间戳}\`
-   **发起视频通话**: \`{"type": "video_call_request"}\`
-   **回应视频通话**: \`{"type": "video_call_response", "decision": "accept" or "reject"}\`


# 对话者的角色设定
${chat.settings.myPersona}



现在，请根据以上规则和下面的对话历史，继续进行对话。`;



      const messagesForApi = historySlice.map(msg => ({
        role: msg.role,
        content: String(msg.content)
      }));


      messagesForApi.push({
        role: 'user',
        content: `[系统指令：用户按下了“推进”按钮，现在轮到你主动行动了，请继续对话。]`
      });


      let isGemini = proxyUrl === GEMINI_API_URL;
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API 请求失败: ${errorData.error.message}`);
      }

      const data = await response.json();

      const aiResponseContent = getGeminiResponseText(data);


      const messagesArray = parseAiResponse(aiResponseContent);
      const processedActions = [];
      for (const action of messagesArray) {
        if (action.type === 'text' && typeof action.content === 'string' && action.content.includes('\n')) {
          const lines = action.content.split(/\n+/).filter(line => line.trim());
          lines.forEach(line => {
            processedActions.push({
              ...action,
              content: line
            });
          });
        } else {
          processedActions.push(action);
        }
      }

      let messageTimestamp = Date.now();
      for (const msgData of processedActions) {
        const aiMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          timestamp: messageTimestamp++,
          content: msgData.content || msgData.message,
          type: msgData.type || 'text',

        };
        if (msgData.type === 'update_thoughts') {
          if (!chat.isGroup) {
            if (msgData.heartfelt_voice) chat.heartfeltVoice = String(msgData.heartfelt_voice);
            if (msgData.random_jottings) chat.randomJottings = String(msgData.random_jottings);
          }
          continue;
        }
        chat.history.push(aiMessage);
        appendMessage(aiMessage, chat);
        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 800));
      }

      await db.chats.put(chat);
      renderChatList();

    } catch (error) {
      console.error("推进剧情失败:", error);
      await showCustomAlert('操作失败', `无法推进剧情: ${error.message}`);
    } finally {

      setAvatarActingState(chat.id, false);
      if (!chat.isGroup && document.getElementById('chat-header-title')) {
        const titleEl = document.getElementById('chat-header-title');
        titleEl.style.opacity = 0;
        setTimeout(() => {
          titleEl.textContent = chat.name;
          titleEl.classList.remove('typing-status');
          titleEl.style.opacity = 1;
        }, 200);
      }
    }
  }



  function playNotificationSound() {
    const player = document.getElementById('notification-sound-player');

    const soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;

  
    if (soundUrl && soundUrl.trim()) {
      player.src = soundUrl;

      player.play().catch(error => console.log("播放被中断，这是正常行为:", error));
    }
  }

  // ========== 系统级通知功能 ==========
  
  // 消息队列和定时器（用于消息合并）
  const messageQueue = {};
  const mergeTimers = {};

  // 初始化系统通知
  function initSystemNotification() {
    if (!('Notification' in window)) {
      console.warn('此浏览器不支持系统通知');
      return;
    }
    
    updateNotificationPermissionStatus();
    bindSystemNotificationEvents();
    loadSystemNotificationSettings(); // 🔥 修复：页面加载时恢复所有设置和子菜单显示状态
  }

  // 更新权限状态显示
  async function updateNotificationPermissionStatus() {
    const statusEl = document.getElementById('permission-status-text');
    const statusContainer = document.getElementById('notification-permission-status');
    
    if (!statusEl || !('serviceWorker' in navigator)) return;
    
    try {
      // 使用 Service Worker API 检查权限（移动端兼容）
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      const permission = permissionStatus.state;
      
      if (permission === 'granted') {
        statusEl.textContent = '已授权';
        statusEl.style.color = '#4cd964';
      } else if (permission === 'denied') {
        statusEl.textContent = '已拒绝';
        statusEl.style.color = '#ff3b30';
      } else {
        statusEl.textContent = '未请求';
        statusEl.style.color = '#999';
      }
      
      statusContainer.style.display = state.globalSettings.systemNotification?.enabled ? 'flex' : 'none';
    } catch (error) {
      console.warn('[权限检查] 无法查询通知权限:', error);
      statusEl.textContent = '未知';
      statusEl.style.color = '#999';
    }
  }

  // 请求通知权限
  async function requestNotificationPermission() {
    if (!('serviceWorker' in navigator)) {
      alert('您的浏览器不支持系统通知');
      return false;
    }
    
    try {
      // 使用 Permissions API 检查当前权限（移动端兼容）
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      
      if (permissionStatus.state === 'granted') {
        return true;
      }
      
      if (permissionStatus.state === 'denied') {
        alert('通知权限已被拒绝，请在浏览器设置中手动开启');
        return false;
      }
      
      // 请求权限（必须通过 Notification API）
      if ('Notification' in window && typeof Notification.requestPermission === 'function') {
        const permission = await Notification.requestPermission();
        await updateNotificationPermissionStatus();
        
        if (permission !== 'granted') {
          alert('未授予通知权限，系统通知功能将无法使用');
          document.getElementById('system-notification-enabled-switch').checked = false;
          state.globalSettings.systemNotification.enabled = false;
          return false;
        }
        
        return true;
      } else {
        alert('您的浏览器不支持请求通知权限');
        return false;
      }
    } catch (error) {
      console.error('[权限请求] 失败:', error);
      alert('请求通知权限失败: ' + error.message);
      return false;
    }
  }

  // 震动设备
  function vibrateDevice() {
    if (!('vibrate' in navigator)) {
      return;
    }
    
    const patterns = {
      short: [200],
      medium: [200, 100, 200],
      long: [400, 100, 400, 100, 400]
    };
    
    const pattern = state.globalSettings.systemNotification?.vibration?.pattern || 'short';
    navigator.vibrate(patterns[pattern]);
  }

  // 播放系统通知提示音
  function playSystemNotificationSound() {
    const soundConfig = state.globalSettings.systemNotification?.sound;
    
    if (!soundConfig || !soundConfig.enabled) {
      return;
    }
    
    let soundUrl;
    if (soundConfig.useGlobalSound) {
      soundUrl = state.globalSettings.notificationSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    } else {
      soundUrl = soundConfig.customSoundUrl || DEFAULT_NOTIFICATION_SOUND;
    }
    
    if (soundUrl && soundUrl.trim()) {
      const audio = new Audio(soundUrl);
      audio.play().catch(err => console.log('播放提示音失败:', err));
    }
  }

  // 显示系统通知（每条消息独立通知）
  async function showSystemNotification(chatId, messageContent, options = {}) {
    console.log('[系统通知调试] showSystemNotification 被调用:', {
      chatId,
      messageContent,
      options,
      enabled: state.globalSettings.systemNotification?.enabled
    });
    
    if (!state.globalSettings.systemNotification?.enabled) {
      console.log('[系统通知调试] 系统通知未启用');
      return;
    }
    
    // 使用 Permissions API 检查权限（移动端兼容）
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      if (permissionStatus.state !== 'granted') {
        console.log('[系统通知调试] 通知权限未授予:', permissionStatus.state);
        return;
      }
    } catch (error) {
      console.warn('[系统通知调试] 无法查询权限，跳过检查:', error);
    }
    
    const chat = state.chats[chatId];
    if (!chat) {
      console.log('[系统通知调试] 找不到聊天:', chatId);
      return;
    }
    
    const appName = state.globalSettings.systemNotification.appName || 'EPhone';
    const title = options.title || `${appName} - ${chat.name}`;
    const body = messageContent;
    const icon = chat.settings.aiAvatar || chat.settings.groupAvatar || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg';
    
    // 每条消息使用唯一的 tag，确保每条都显示
    const uniqueTag = `chat-${chatId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    console.log('[系统通知调试] 准备创建通知:', {
      title,
      body,
      icon,
      tag: uniqueTag
    });
    
    try {
      // 必须使用 Service Worker 的 showNotification（移动端要求）
      if (!('serviceWorker' in navigator)) {
        console.error('[系统通知调试] 浏览器不支持 Service Worker');
        return;
      }
      
      // 等待 Service Worker 注册完成
      const registration = await navigator.serviceWorker.ready;
      console.log('[系统通知调试] Service Worker 已就绪');
      
      await registration.showNotification(title, {
        body: body,
        icon: icon,
        badge: icon,
        tag: uniqueTag, // 使用唯一 tag
        requireInteraction: true, // 强制显示横幅
        silent: false, // 必须有声音才能显示横幅
        vibrate: [200, 100, 200, 100, 200], // 强震动
        renotify: true, // 强制重新通知
        data: { chatId },
        actions: [
          { action: 'reply', title: '回复' },
          { action: 'dismiss', title: '关闭' }
        ]
      });
      console.log('[系统通知调试] 通知创建成功');
      
      if (state.globalSettings.systemNotification.sound?.enabled) {
        console.log('[系统通知调试] 播放提示音');
        playSystemNotificationSound();
      }
      
      if (state.globalSettings.systemNotification.vibration?.enabled) {
        console.log('[系统通知调试] 触发震动');
        vibrateDevice();
      }
    } catch (error) {
      console.error('[系统通知调试] 创建通知失败:', error);
    }
  }

  // 处理系统通知（每条消息单独通知，不合并）
  async function handleSystemNotification(chatId, messageContent) {
    console.log('[系统通知调试] handleSystemNotification 被调用:', {
      chatId,
      messageContent,
      config: state.globalSettings.systemNotification
    });
    
    const config = state.globalSettings.systemNotification;
    
    if (!config || !config.enabled) {
      console.log('[系统通知调试] 配置检查失败:', {
        configExists: !!config,
        enabled: config?.enabled
      });
      return;
    }
    
    // 使用 Permissions API 检查权限（移动端兼容）
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      if (permissionStatus.state !== 'granted') {
        console.log('[系统通知调试] 通知权限未授予:', permissionStatus.state);
        return;
      }
    } catch (error) {
      console.warn('[系统通知调试] 无法查询权限，跳过检查:', error);
    }
    
    console.log('[系统通知调试] 检查通过，准备显示通知');
    
    // 每条消息都单独显示通知，不使用合并逻辑
    console.log('[系统通知调试] 直接显示单条通知');
    showSystemNotification(chatId, messageContent);
  }

  // 发送测试通知
  async function sendTestNotification() {
    console.log('[系统通知调试] sendTestNotification 被调用');
    
    // 使用 Permissions API 检查权限（移动端兼容）
    try {
      const permissionStatus = await navigator.permissions.query({ name: 'notifications' });
      console.log('[系统通知调试] 权限状态:', permissionStatus.state);
      
      if (permissionStatus.state !== 'granted') {
        alert('请先开启系统通知权限');
        return;
      }
    } catch (error) {
      console.error('[系统通知调试] 无法查询权限:', error);
      alert('无法检查通知权限，请确保已授权');
      return;
    }
    
    const appName = state.globalSettings.systemNotification?.appName || 'EPhone';
    console.log('[系统通知调试] 准备创建测试通知, appName:', appName);
    
    try {
      // 必须使用 Service Worker 的 showNotification（移动端要求）
      if (!('serviceWorker' in navigator)) {
        alert('您的浏览器不支持 Service Worker，无法使用系统通知功能');
        return;
      }
      
      // 等待 Service Worker 注册完成
      const registration = await navigator.serviceWorker.ready;
      console.log('[系统通知调试] Service Worker 已就绪');
      
      await registration.showNotification(appName, {
        body: '这是一条测试通知 🎉',
        icon: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
        badge: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1758510900942_qdqqd_djw0z2.jpeg',
        tag: 'test-notification',
        requireInteraction: false,
        silent: !state.globalSettings.systemNotification?.sound?.enabled
      });
      console.log('[系统通知调试] 测试通知创建成功');
      
      if (state.globalSettings.systemNotification?.sound?.enabled) {
        playSystemNotificationSound();
      }
      
      if (state.globalSettings.systemNotification?.vibration?.enabled) {
        vibrateDevice();
      }
    } catch (error) {
      console.error('[系统通知调试] 创建测试通知失败:', error);
      alert('创建测试通知失败: ' + error.message);
    }
  }

  // 绑定系统通知相关事件
  function bindSystemNotificationEvents() {
    const enabledSwitch = document.getElementById('system-notification-enabled-switch');
    const detailsDiv = document.getElementById('system-notification-details');
    const appNameInput = document.getElementById('system-notification-app-name');
    const testBtn = document.getElementById('test-system-notification-btn');
    
    const pushServerSwitch = document.getElementById('push-server-enabled-switch');
    const pushServerDetails = document.getElementById('push-server-details');
    const pushServerUrl = document.getElementById('push-server-url');
    const pushServerApiKey = document.getElementById('push-server-api-key');
    
    const vibrationSwitch = document.getElementById('notification-vibration-enabled-switch');
    const vibrationSelector = document.getElementById('vibration-pattern-selector');
    const vibrationPattern = document.getElementById('vibration-pattern-select');
    
    const mergeSwitch = document.getElementById('merge-messages-enabled-switch');
    const mergeDetails = document.getElementById('merge-messages-details');
    const mergeThreshold = document.getElementById('merge-threshold-input');
    const mergeTimeWindow = document.getElementById('merge-time-window-input');
    
    const soundSwitch = document.getElementById('notification-sound-enabled-switch');
    const soundDetails = document.getElementById('notification-sound-details');
    const useGlobalSound = document.getElementById('use-global-sound-switch');
    const customSoundWrapper = document.getElementById('custom-sound-input-wrapper');
    const customSoundUrl = document.getElementById('custom-notification-sound-url');
    
    if (enabledSwitch) {
      enabledSwitch.addEventListener('change', async () => {
        if (enabledSwitch.checked) {
          const granted = await requestNotificationPermission();
          if (granted) {
            state.globalSettings.systemNotification.enabled = true;
            detailsDiv.style.display = 'block';
            updateNotificationPermissionStatus();
          } else {
            enabledSwitch.checked = false;
          }
        } else {
          state.globalSettings.systemNotification.enabled = false;
          detailsDiv.style.display = 'none';
          updateNotificationPermissionStatus();
        }
      });
    }
    
    if (appNameInput) {
      appNameInput.addEventListener('input', () => {
        state.globalSettings.systemNotification.appName = appNameInput.value.trim() || 'EPhone';
      });
    }
    
    if (testBtn) {
      testBtn.addEventListener('click', sendTestNotification);
    }
    
    if (pushServerSwitch) {
      pushServerSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.pushServer.enabled = pushServerSwitch.checked;
        pushServerDetails.style.display = pushServerSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (pushServerUrl) {
      pushServerUrl.addEventListener('input', () => {
        state.globalSettings.systemNotification.pushServer.serverUrl = pushServerUrl.value.trim();
      });
    }
    
    if (pushServerApiKey) {
      pushServerApiKey.addEventListener('input', () => {
        state.globalSettings.systemNotification.pushServer.apiKey = pushServerApiKey.value.trim();
      });
    }
    
    if (vibrationSwitch) {
      vibrationSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.vibration.enabled = vibrationSwitch.checked;
        vibrationSelector.style.display = vibrationSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (vibrationPattern) {
      vibrationPattern.addEventListener('change', () => {
        state.globalSettings.systemNotification.vibration.pattern = vibrationPattern.value;
      });
    }
    
    if (mergeSwitch) {
      mergeSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.mergeMessages.enabled = mergeSwitch.checked;
        mergeDetails.style.display = mergeSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (mergeThreshold) {
      mergeThreshold.addEventListener('input', () => {
        state.globalSettings.systemNotification.mergeMessages.threshold = parseInt(mergeThreshold.value) || 3;
      });
    }
    
    if (mergeTimeWindow) {
      mergeTimeWindow.addEventListener('input', () => {
        state.globalSettings.systemNotification.mergeMessages.timeWindow = parseInt(mergeTimeWindow.value) || 60;
      });
    }
    
    if (soundSwitch) {
      soundSwitch.addEventListener('change', () => {
        state.globalSettings.systemNotification.sound.enabled = soundSwitch.checked;
        soundDetails.style.display = soundSwitch.checked ? 'block' : 'none';
      });
    }
    
    if (useGlobalSound) {
      useGlobalSound.addEventListener('change', () => {
        state.globalSettings.systemNotification.sound.useGlobalSound = useGlobalSound.checked;
        customSoundWrapper.style.display = useGlobalSound.checked ? 'none' : 'block';
      });
    }
    
    if (customSoundUrl) {
      customSoundUrl.addEventListener('input', () => {
        state.globalSettings.systemNotification.sound.customSoundUrl = customSoundUrl.value.trim();
      });
    }
  }

  // 加载系统通知设置到UI
  function loadSystemNotificationSettings() {
    const config = state.globalSettings.systemNotification;
    if (!config) return;
    
    const enabledSwitch = document.getElementById('system-notification-enabled-switch');
    const detailsDiv = document.getElementById('system-notification-details');
    const appNameInput = document.getElementById('system-notification-app-name');
    
    const pushServerSwitch = document.getElementById('push-server-enabled-switch');
    const pushServerDetails = document.getElementById('push-server-details');
    const pushServerUrl = document.getElementById('push-server-url');
    const pushServerApiKey = document.getElementById('push-server-api-key');
    
    const vibrationSwitch = document.getElementById('notification-vibration-enabled-switch');
    const vibrationSelector = document.getElementById('vibration-pattern-selector');
    const vibrationPattern = document.getElementById('vibration-pattern-select');
    
    const mergeSwitch = document.getElementById('merge-messages-enabled-switch');
    const mergeDetails = document.getElementById('merge-messages-details');
    const mergeThreshold = document.getElementById('merge-threshold-input');
    const mergeTimeWindow = document.getElementById('merge-time-window-input');
    
    const soundSwitch = document.getElementById('notification-sound-enabled-switch');
    const soundDetails = document.getElementById('notification-sound-details');
    const useGlobalSound = document.getElementById('use-global-sound-switch');
    const customSoundWrapper = document.getElementById('custom-sound-input-wrapper');
    const customSoundUrl = document.getElementById('custom-notification-sound-url');
    
    // 加载主开关状态
    if (enabledSwitch) {
      enabledSwitch.checked = config.enabled || false;
      detailsDiv.style.display = config.enabled ? 'block' : 'none';
    }
    
    if (appNameInput) {
      appNameInput.value = config.appName || 'EPhone';
    }
    
    // 加载推送服务器设置
    if (pushServerSwitch) {
      pushServerSwitch.checked = config.pushServer?.enabled || false;
      pushServerDetails.style.display = config.pushServer?.enabled ? 'block' : 'none';
    }
    
    if (pushServerUrl) {
      pushServerUrl.value = config.pushServer?.serverUrl || '';
    }
    
    if (pushServerApiKey) {
      pushServerApiKey.value = config.pushServer?.apiKey || '';
    }
    
    // 加载震动设置
    if (vibrationSwitch) {
      vibrationSwitch.checked = config.vibration?.enabled || false;
      vibrationSelector.style.display = config.vibration?.enabled ? 'block' : 'none';
    }
    
    if (vibrationPattern) {
      vibrationPattern.value = config.vibration?.pattern || 'short';
    }
    
    // 加载消息合并设置
    if (mergeSwitch) {
      mergeSwitch.checked = config.mergeMessages?.enabled || false;
      mergeDetails.style.display = config.mergeMessages?.enabled ? 'block' : 'none';
    }
    
    if (mergeThreshold) {
      mergeThreshold.value = config.mergeMessages?.threshold || 3;
    }
    
    if (mergeTimeWindow) {
      mergeTimeWindow.value = config.mergeMessages?.timeWindow || 60;
    }
    
    // 加载声音设置
    if (soundSwitch) {
      soundSwitch.checked = config.sound?.enabled || false;
      soundDetails.style.display = config.sound?.enabled ? 'block' : 'none';
    }
    
    if (useGlobalSound) {
      useGlobalSound.checked = config.sound?.useGlobalSound !== false;
      customSoundWrapper.style.display = config.sound?.useGlobalSound !== false ? 'none' : 'block';
    }
    
    if (customSoundUrl) {
      customSoundUrl.value = config.sound?.customSoundUrl || '';
    }
    
    updateNotificationPermissionStatus();
  }

  // ========== 系统级通知功能结束 ==========




  function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
      const element = document.getElementById(elementId);
      const savedValue = state.globalSettings.widgetData[elementId];
      if (element) {
        if (element.tagName === 'IMG') {
          element.src = savedValue;
        } else {
          element.textContent = savedValue;
        }
      }
    }
  }


  function uploadImageLocally() {
    return new Promise(resolve => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*'; // 只接受图片文件

      input.onchange = e => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (readerEvent) => { 
          let base64Result = readerEvent.target.result;

        
          if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
              try {
                
                  const alertModal = document.getElementById('custom-modal-overlay');
                  if (!alertModal.classList.contains('visible')) {
                      await showCustomAlert("请稍候...", "正在上传图片到 ImgBB...");
                  }
                  const imageUrl = await uploadImageToImgBB(base64Result);
                  resolve(imageUrl); 
              } catch (uploadError) {
                  console.error(uploadError);
                  await showCustomAlert("ImgBB 上传失败", `图片上传到图床失败: ${uploadError.message}\n\n将继续使用本地 Base64 格式保存。`);
                  resolve(base64Result); 
              }
          } else {
            
              resolve(base64Result);
          }
      };
      reader.readAsDataURL(file);
        } else {
          resolve(null); // 用户关闭了文件选择框
        }
      };

      input.click();
    });
  }


  async function handleEditText(element) {
    const elementId = element.id;
    const currentValue = element.textContent;
    const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue);
    if (newValue !== null && newValue.trim() !== "") {
      const trimmedValue = newValue.trim();
      element.textContent = trimmedValue;
      state.globalSettings.widgetData[elementId] = trimmedValue;
      await db.globalSettings.put(state.globalSettings);
      alert("文字已更新！");

    }
  }


  async function handleEditImage(element) {
    const elementId = element.id;
  
    const choice = await showChoiceModal("修改图片", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);
  
    let newUrl = null;
    let isBase64 = false; // 标记是否为 Base64
  
    if (choice === 'local') {
        newUrl = await new Promise(resolve => { // 简化版 uploadImageLocally
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => resolve(readerEvent.target.result);
                    reader.readAsDataURL(file);
                } else {
                    resolve(null);
                }
            };
            input.click();
        });
        if (newUrl) isBase64 = true;
  
    } else if (choice === 'url') {
        newUrl = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
        if (newUrl) isBase64 = false;
    }
  
    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        // 1. [核心修改] 立即显示 Base64 或 URL
        element.src = trimmedUrl;
  
        // 2. 立即将 Base64 或 URL 保存到数据库，确保刷新不丢失
        if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
        }
        state.globalSettings.widgetData[elementId] = trimmedUrl;
        await db.globalSettings.put(state.globalSettings);
  
        await showCustomAlert("成功", "组件图片已更新并保存！");
  
        // 3. [核心修改] 只有当它是 Base64 且 ImgBB 开启时，才在后台“静默”上传
        if (isBase64 && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
            (async () => {
                console.log(`[ImgBB] 启动 ${elementId} 的静默上传...`);
                // 这个函数会在后台运行，不会阻塞
                await silentlyUpdateDbUrl(
                    db.globalSettings,
                    'main',
                    `widgetData.${elementId}`,
                    trimmedUrl // 传入 Base64 字符串
                );
            })();
        }
    }
  }



  const cacheManager = {
    getSongCache(query, source) {
      const key = `${source || 'all'}:${query}`;
      if (state.cache && state.cache.songs) {
        const cached = state.cache.songs.get(key);
        if (cached && Date.now() - cached.timestamp < 3600000) {
          return cached.data;
        }
      }
      return null;
    },
    setSongCache(query, data, source) {
      const key = `${source || 'all'}:${query}`;
      if (!state.cache) state.cache = {};
      if (!state.cache.songs) state.cache.songs = new Map();
      state.cache.songs.set(key, {
        data,
        timestamp: Date.now()
      });
    }
  };

  if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
      return new Promise((resolve) => {
        fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
      });
    }
  }
  async function Http_Get(url) {
    return await Http_Get_External(url);
  }

  function checkAudioAvailability(url) {
    return new Promise(resolve => {
      const tester = new Audio();
      tester.addEventListener('loadedmetadata', () => resolve(true), {
        once: true
      });
      tester.addEventListener('error', () => resolve(false), {
        once: true
      });
      tester.src = url;
    });
  }


  async function searchNeteaseMusic(name, singer) {
    try {
      let searchTerm = name.replace(/\s/g, "");
      if (singer) {
        searchTerm += ` ${singer.replace(/\s/g, "")}`;
      }

      const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;

      console.log("正在请求网易云音乐API:", apiUrl);

      const response = await fetch(apiUrl);

      if (!response.ok) {
        throw new Error(`API 请求失败，状态码: ${response.status}`);
      }

      const result = await response.json();

      if (result.code !== 200 || !result.data || result.data.length === 0) {
        console.log("网易云音乐API未返回有效结果:", result);
        return [];
      }


      return result.data.map(song => ({
        name: song.song,
        artist: song.singer,
        id: song.id,
        cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
        source: 'netease'
      })).slice(0, 30); 

    } catch (e) {
      console.error("网易云音乐搜索失败:", e);

      return [];
    }
  }
// --- Toubiec API 核心逻辑 (修复版) ---
const TOUBIEC_BASE_URL = 'https://wyapi-1.toubiec.cn/api/music';

async function fetchToubiec(endpoint, bodyData) {
    try {
        const response = await fetch(`${TOUBIEC_BASE_URL}/${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(bodyData)
        });
        const result = await response.json();
        return result;
    } catch (error) {
        console.error(`Toubiec API Error [${endpoint}]:`, error);
        return null;
    }
}

// 1. 搜索功能 (修复了数据结构解析)
// 1. 搜索功能 (修复字段映射)
// 1. 搜索功能 (修复字段映射：适配 picimg 和 singer)
async function searchToubiec(keyword) {
    const res = await fetchToubiec('search', { keywords: keyword, page: 1 });
    
    // 兼容处理：数据可能在 data, data.list, data.songs 中
    let songList = [];
    if (res) {
        if (Array.isArray(res)) {
            songList = res;
        } else if (res.data) {
             if (Array.isArray(res.data)) {
                songList = res.data;
            } else if (Array.isArray(res.data.list)) {
                songList = res.data.list;
            } else if (Array.isArray(res.data.songs)) {
                songList = res.data.songs;
            }
            // 针对你提供的JSON结构：直接返回了 data 对象的情况（虽不少见但为了保险）
            else if (typeof res.data === 'object') {
                songList = [res.data];
            }
        }
    }

    if (songList.length === 0) return [];
    
    return songList.map(song => ({
        name: song.name,
        // 【修复】优先读取 singer (你的API返回字段)，其次 artists
        artist: song.singer || song.artists || (Array.isArray(song.ar) ? song.ar.map(a => a.name).join('/') : (song.artist || '未知歌手')),
        id: String(song.id),
        // 【修复】优先读取 picimg (你的API返回字段)
        cover: song.picimg || song.cover || song.al?.picUrl || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
        source: 'toubiec',
        albumId: song.al?.id
    }));
}

// 2. 解析歌单 (输入歌单ID)
async function getToubiecPlaylist(playlistId) {
    const res = await fetchToubiec('playlist', { id: String(playlistId) });
    if (!res || !res.data || !res.data.tracks) return [];
    
    return res.data.tracks.map(song => ({
        name: song.name,
        artist: Array.isArray(song.ar) ? song.ar.map(a => a.name).join('/') : (song.artist || '未知歌手'),
        id: String(song.id),
        cover: song.al?.picUrl || song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
        source: 'toubiec'
    }));
}

// 3. 解析专辑 (输入专辑ID)
async function getToubiecAlbum(albumId) {
    const res = await fetchToubiec('album', { id: String(albumId) });
    if (!res || !res.data || !res.data.songs) return [];
    
    return res.data.songs.map(song => ({
        name: song.name,
        artist: Array.isArray(song.ar) ? song.ar.map(a => a.name).join('/') : '未知歌手',
        id: String(song.id),
        cover: song.al?.picUrl || res.data.album?.picUrl, // 优先用单曲封面，没有则用专辑封面
        source: 'toubiec'
    }));
}
// 6. [新增] 获取歌曲详情 (用于修复封面和歌手信息)
async function getToubiecDetail(id) {
    // 调用 detail 接口
    const res = await fetchToubiec('detail', { id: String(id) });
    if (res && res.code === 200 && res.data) {
        return res.data; // 返回包含 picimg, singer 等信息的对象
    }
    return null;
}
// 4. 获取高音质播放链接 (修复版：适配 data 为数组的情况)
async function getToubiecUrl(id, preferredLevel = 'exhigh') {
    // 定义音质降级链
    const qualityLadder = ['jymaster', 'dolby', 'sky', 'jyeffect', 'hires', 'lossless', 'exhigh', 'standard'];
    
    let startIndex = qualityLadder.indexOf(preferredLevel);
    if (startIndex === -1) startIndex = 5; 

    for (let i = startIndex; i < qualityLadder.length; i++) {
        const level = qualityLadder[i];
        const res = await fetchToubiec('url', { id: String(id), level: level });
        
        if (res && res.code === 200 && res.data) {
            let url = null;

            // 【核心修复】你提供的JSON显示 data 是一个数组 [{id:..., url:...}]
            if (Array.isArray(res.data) && res.data.length > 0) {
                // 取数组第一个元素的 url 字段
                url = res.data[0].url; 
            }
            // 兼容 data 是对象的情况
            else if (!Array.isArray(res.data) && res.data.url) {
                url = res.data.url;
            }

            if (url) {
                console.log(`[Toubiec] 成功获取链接 (${level}): ${url}`);
                // 确保 HTTPS，防止混合内容报错
                return url.replace(/^http:\/\//i, 'https://');
            }
        }
    }
    console.warn(`[Toubiec] 未能获取任何音质的链接: ID ${id}`);
    return null;
}

// 5. 获取歌词
async function getToubiecLyric(id) {
    const res = await fetchToubiec('lyric', { id: String(id) });
    if (res && res.data) {
        // 组合原词(lrc)和翻译(tlyric)
        const lrc = res.data.lrc || "";
        const tlyric = res.data.tlyric || "";
        return lrc + "\n" + tlyric;
    }
    return "";
}
// --- Toubiec API 集成结束 ---
 
  async function searchTencentMusic(name) {
    try {
      name = name.replace(/\s/g, "");
      const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
      if (!result?.data?.length) return [];
      return result.data.map(song => ({
        name: song.song,
        artist: song.singer,
        id: song.id,
        cover: song.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
        source: 'tencent'
      })).slice(0, 30);
    } catch (e) {
      console.error("QQ音乐搜索API失败:", e);
      return [];
    }
  }

// --- 3. 重构搜索主入口 (已去除图标) ---
// --- 3. 重构搜索主入口 (已去除图标) ---
async function addSongFromSearch() {
    // 1. 第一步：选择模式 (去除了 Emoji)
    const modeChoice = await showChoiceModal("请选择操作模式", [
        { text: '搜索歌曲 (新源·支持选音质)', value: 'search_new' },
        { text: '解析歌单 (输入ID)', value: 'playlist_new' },
        { text: '解析专辑 (输入ID)', value: 'album_new' },
        { text: '普通搜索 (网易/腾讯旧源)', value: 'search_old' }
    ]);

    if (!modeChoice) return;

    let searchResults = [];
    let selectedQuality = 'exhigh'; // 默认极高

    // 2. 第二步：如果是新源，选择音质 (去除了 Emoji)
    if (modeChoice.includes('_new')) {
        const qualityChoice = await showChoiceModal("请选择期望音质", [
            { text: '无损 (Lossless - FLAC)', value: 'lossless' },
            { text: '高解析 (Hi-Res - FLAC)', value: 'hires' },
            { text: '母带级 (Master - FLAC)', value: 'jymaster' },
            { text: '杜比全景声 (Dolby - MP4)', value: 'dolby' },
            { text: '极高 (ExHigh - MP3)', value: 'exhigh' },
            { text: '标准 (Standard - MP3)', value: 'standard' },
            { text: '环绕沉浸 (Sky)', value: 'sky' },
            { text: '空间音效 (Effect)', value: 'jyeffect' }
        ]);
        if (!qualityChoice) return;
        selectedQuality = qualityChoice;
    }

    // 3. 第三步：输入关键词或ID
    let promptText = "请输入歌曲名称";
    if (modeChoice === 'playlist_new') promptText = "请输入歌单 ID (数字)";
    if (modeChoice === 'album_new') promptText = "请输入专辑 ID (数字)";
    
    const input = await showCustomPrompt(promptText, "在此输入...");
    if (!input || !input.trim()) return;
    const query = input.trim();

    await showCustomAlert("请稍候...", "正在请求资源...");

    // 4. 执行搜索/解析 (保持原逻辑不变)
    try {
        if (modeChoice === 'search_new') {
            searchResults = await searchToubiec(query);
        } 
        else if (modeChoice === 'playlist_new') {
            searchResults = await getToubiecPlaylist(query);
            if (searchResults.length > 0) {
                 await showCustomAlert("解析成功", `成功解析歌单，共 ${searchResults.length} 首歌曲。`);
            }
        } 
        else if (modeChoice === 'album_new') {
            searchResults = await getToubiecAlbum(query);
            if (searchResults.length > 0) {
                 await showCustomAlert("解析成功", `成功解析专辑，共 ${searchResults.length} 首歌曲。`);
            }
        } 
        else if (modeChoice === 'search_old') {
            // 旧版并行搜索逻辑
            let musicName = query;
            let singerName = "";
            if (query.includes('-')) {
                const parts = query.split('-');
                musicName = parts[0].trim();
                singerName = parts[1].trim();
            }
            const [netease, tencent] = await Promise.all([
                searchNeteaseMusic(musicName, singerName),
                searchTencentMusic(musicName)
            ]);
            searchResults = [...netease, ...tencent];
        }
    } catch (e) {
        console.error(e);
        await showCustomAlert("错误", "搜索或解析过程中发生错误，请检查ID是否正确。");
        return;
    }

    // 5. 渲染结果
    if (searchResults.length === 0) {
      await showCustomAlert("无结果", "未找到相关内容。");
      return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';
    document.getElementById('select-all-music-search').checked = false;

    searchResults.forEach(song => {
      // 【关键】将用户选择的音质写入歌曲对象
      if (modeChoice.includes('_new')) {
          song.preferredQuality = selectedQuality;
      }

      const item = document.createElement('div');
      item.className = 'search-result-item';
      item.dataset.songJson = JSON.stringify(song);

      // 显示来源标签 (去除了 Emoji)
      let sourceTag = '';
      if (song.source === 'toubiec') {
          // 显示具体的音质标签
          const qualityLabels = {
              'lossless': '无损', 'hires': 'Hi-Res', 'jymaster': '母带',
              'dolby': '杜比', 'exhigh': '极高', 'standard': '标准',
              'sky': '全景', 'jyeffect': '空间'
          };
          const qLabel = qualityLabels[selectedQuality] || 'Pro';
          sourceTag = `<span class="source" style="color:#ff3b30; border-color:#ff3b30;">${qLabel}</span>`;
      } else if (song.source === 'netease') {
          sourceTag = '<span class="source" style="color:#c20c0c; border-color:#c20c0c;">网易云</span>';
      } else {
          sourceTag = '<span class="source" style="color:#00e09e; border-color:#00e09e;">QQ音乐</span>';
      }

      item.innerHTML = `
            <input type="checkbox" class="music-search-checkbox" style="margin-right: 15px;">
            <div class="search-result-info">
                <div class="title">${song.name}</div>
                <div class="artist">${song.artist} ${sourceTag}</div>
            </div>
        `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
}

 
  // --- 2. 修改详情获取逻辑 (修复版：增加 detail 解析以获取封面) ---
async function getPlayableSongDetails(songData) {
    let playableResult = null;
    let finalSource = songData.source;

    // --- 处理 Toubiec 源 ---
    if (songData.source === 'toubiec') {
        const quality = songData.preferredQuality || 'exhigh';
        
        // 1. 获取播放链接
        const url = await getToubiecUrl(songData.id, quality);
        
        // 2. 【核心修复】获取歌曲详情 (为了拿到 picimg 封面)
        try {
            const detail = await getToubiecDetail(songData.id);
            if (detail) {
                // 如果API返回了封面，强制更新
                if (detail.picimg) {
                    console.log(`[Toubiec] 获取到封面: ${detail.picimg}`);
                    songData.cover = detail.picimg;
                }
                // 同步更新歌手名
                if (detail.singer) {
                    songData.artist = detail.singer;
                }
            }
        } catch (e) {
            console.warn("[Toubiec] 获取详情失败，将使用默认封面", e);
        }

        if (url) {
             playableResult = {
                url: url.replace(/^http:\/\//i, 'https://'), // 强制 HTTPS
                id: songData.id,
                source: 'toubiec'
            };
        }
    } 
    // --- 原有逻辑 (网易/腾讯) ---
    else if (songData.source === 'netease') {
        const primaryApiUrl = `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`;
        let primaryResult = await Http_Get(primaryApiUrl);
        if (primaryResult?.data?.url) {
            playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
        }
    } else {
        const primaryApiUrl = `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
        let primaryResult = await Http_Get(primaryApiUrl);
        if (primaryResult?.data?.url) {
             playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
        }
    }

    // --- 统一返回处理 ---
    if (playableResult) {
      let lrcContent = "";
      // 获取歌词
      if (finalSource === 'toubiec') {
          lrcContent = await getToubiecLyric(playableResult.id);
      } else {
          lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";
      }

      return {
        name: songData.name,
        artist: songData.artist,
        src: playableResult.url,
        cover: songData.cover, // 这里现在已经是更新过的封面了
        isLocal: false,
        lrcContent: lrcContent
      };
    }

    return null;
}

 
  async function getLyricsForSong(songId, source) {
    const url = source === 'netease' ?
      `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}` :
      `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;

    const response = await Http_Get(url);
    if (response?.data) {
      const lrc = response.data.lrc || response.data.lyric || "";
      const tlyric = response.data.trans || response.data.tlyric || "";
      return lrc + "\n" + tlyric;
    }
    return "";
  }

  async function handleManualLrcImport(trackIndex) {
    if (trackIndex < 0 || trackIndex >= musicState.playlist.length) return;

    const choice = await showChoiceModal('选择歌词导入方式', [{
        text: '📁 从本地文件 (.lrc)',
        value: 'file'
      },
      {
        text: '📋 直接粘贴歌词文本',
        value: 'paste'
      }
    ]);

    let lrcContent = null;

    if (choice === 'file') {
      lrcContent = await new Promise(resolve => {
        const lrcInput = document.getElementById('lrc-upload-input');
        const lrcChangeHandler = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = readEvent => resolve(readEvent.target.result);
            reader.onerror = () => resolve(null);
            reader.readAsText(file);
          } else {
            resolve(null);
          }
          lrcInput.removeEventListener('change', lrcChangeHandler);
          lrcInput.value = '';
        };
        lrcInput.addEventListener('change', lrcChangeHandler, {
          once: true
        });
        lrcInput.click();
      });
    } else if (choice === 'paste') {
      const pastedText = await showCustomPrompt('粘贴歌词', '请在此处粘贴完整的LRC格式歌词...', '', 'textarea');
      if (pastedText) lrcContent = pastedText.replace(/\[/g, '\n[').trim();
    }

    if (lrcContent !== null) {
      musicState.playlist[trackIndex].lrcContent = lrcContent;


      await saveGlobalPlaylist(); 

      if (musicState.currentIndex === trackIndex) {
        musicState.parsedLyrics = parseLRC(lrcContent);
        renderLyrics();
        updateLyricsUI();
      }
      await showCustomAlert('成功', `《${musicState.playlist[trackIndex].name}》的歌词已成功保存！`);
    }
  }

  
  async function toggleBackgroundBlur() {
    if (musicState.currentIndex === -1) return;

    const track = musicState.playlist[musicState.currentIndex];
    if (!track) return;


    track.isBgClear = !track.isBgClear;


    await saveGlobalPlaylist();


    const playerWindow = document.querySelector('.music-player-window');
    const toggleBtn = document.getElementById('toggle-blur-btn');

    playerWindow.classList.toggle('bg-clear', track.isBgClear);
    toggleBtn.classList.toggle('active', track.isBgClear);
  }

 
  function toggleMusicPlayerAvatars() {
    const avatarDisplay = document.getElementById('music-player-avatar-display');
    const toggleBtn = document.getElementById('show-avatars-btn');
    if (avatarDisplay && toggleBtn) {
      avatarDisplay.classList.toggle('visible');
      toggleBtn.classList.toggle('active');
    }
  }


  function togglePlayerFullscreen() {
    const playerWindow = document.querySelector('.music-player-window');
    const overlay = document.getElementById('music-player-overlay');
    if (playerWindow && overlay) {

      playerWindow.classList.toggle('fullscreen');
      overlay.classList.toggle('fullscreen-active');
    }
  }

  window.togglePlayerFullscreen = togglePlayerFullscreen;


  async function cleanupInvalidSongs() {
    if (musicState.playlist.length === 0) {
      alert("播放列表是空的，无需清理。");
      return;
    }

    const confirmed = await showCustomConfirm(
      '确认清理无效歌曲？',
      '此操作将检查播放列表中的每一首网络歌曲，并移除所有无法播放的“死链”。本地歌曲不会受影响。', {
        confirmText: '开始清理'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在检查 ${musicState.playlist.length} 首歌曲，这可能需要一些时间...`);

    const originalCount = musicState.playlist.length;
    const validPlaylist = [];
    const invalidSongs = [];

    const checkPromises = musicState.playlist.map(async (track) => {
      if (track.isLocal) {
        validPlaylist.push(track);
        return;
      }

      const isAvailable = await checkAudioAvailability(track.src);
      if (isAvailable) {
        validPlaylist.push(track);
      } else {
        invalidSongs.push(track.name);
        console.warn(`无效链接: ${track.name} - ${track.src}`);
      }
    });

    await Promise.all(checkPromises);

    const removedCount = originalCount - validPlaylist.length;

    if (removedCount > 0) {
      const currentPlayingTrack = musicState.playlist[musicState.currentIndex];
      const isCurrentTrackRemoved = invalidSongs.includes(currentPlayingTrack?.name);

      musicState.playlist = validPlaylist;
      await saveGlobalPlaylist();

      if (isCurrentTrackRemoved) {
        audioPlayer.pause();
        audioPlayer.src = '';
        musicState.currentIndex = musicState.playlist.length > 0 ? 0 : -1;
        musicState.isPlaying = false;
      } else if (currentPlayingTrack) {
        musicState.currentIndex = musicState.playlist.findIndex(t => t.src === currentPlayingTrack.src);
      }

      updatePlaylistUI();
      updatePlayerUI();

      await showCustomAlert("清理完成", `成功移除了 ${removedCount} 首无效歌曲:\n\n- ${invalidSongs.join('\n- ')}`);
    } else {
      await showCustomAlert("检查完成", "所有歌曲链接均有效，无需清理！");
    }
  }
function toggleReadingFullscreen() {
    const readingWindow = document.getElementById('reading-window');
    const readingOverlay = document.getElementById('reading-overlay');
    
    if (readingWindow && readingOverlay) {
        // 切换全屏类名
        readingWindow.classList.toggle('fullscreen');
        readingOverlay.classList.toggle('fullscreen-active');
    }
}

// 将函数暴露给全局（可选，为了保险）
window.toggleReadingFullscreen = toggleReadingFullscreen;

  function applyStatusBarVisibility() {
    const phoneScreen = document.getElementById('phone-screen');

    phoneScreen.classList.toggle('status-bar-visible', !!state.globalSettings.showStatusBar);
  }

  async function openClearPostsSelectorModal() {
    const modal = document.getElementById('clear-posts-modal');
    const listEl = document.getElementById('clear-posts-list');
    listEl.innerHTML = '';


    const options = [];


    options.push({
      text: '清空所有动态 (危险)',
      value: 'all',
      isDanger: true
    });


    const myNickname = state.qzoneSettings.nickname || '我';
    options.push({
      text: `仅清空 ${myNickname} 的动态 (用户)`,
      value: 'user'
    });


    Object.values(state.chats).forEach(chat => {
      if (!chat.isGroup) {
        options.push({
          text: `仅清空 ${chat.name} 的动态 (角色)`,
          value: chat.id
        });
      }
    });


    try {
      const npcs = await db.npcs.toArray();
      if (npcs.length > 0) {

        options.push({
          isSeparator: true,
          text: 'NPC 列表'
        });

        npcs.forEach(npc => {
          options.push({
            text: `仅清空 ${npc.name} 的动态 (NPC)`,

            value: `npc_${npc.id}`
          });
        });
      }
    } catch (e) {
      console.error("加载NPC列表失败:", e);
    }



    options.forEach(opt => {

      if (opt.isSeparator) {
        const separator = document.createElement('div');
        separator.textContent = opt.text;
        separator.style.cssText = `
                padding: 10px 18px 5px;
                font-size: 13px;
                font-weight: 500;
                color: var(--text-secondary);
                background-color: #f0f2f5;
                border-top: 1px solid var(--border-color);
                border-bottom: 1px solid var(--border-color);
                margin-top: 5px;
            `;
        listEl.appendChild(separator);
        return;
      }


      const item = document.createElement('div');
      item.className = 'clear-posts-item';
      if (opt.isDanger) {
        item.classList.add('danger-option');
      }
      item.dataset.targetId = opt.value;
      item.innerHTML = `
            <div class="checkbox"></div>
            <span class="name">${opt.text}</span>
        `;
      listEl.appendChild(item);
    });


    modal.classList.add('visible');
  }

 
  async function handleConfirmClearPosts() {
    const selectedItems = document.querySelectorAll('#clear-posts-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("请至少选择一个要清空的范围。");
      return;
    }

    const targetIds = Array.from(selectedItems).map(item => item.dataset.targetId);


    let targetNames = [];
    if (targetIds.includes('all')) {
      targetNames.push('所有动态');
    } else {
      if (targetIds.includes('user')) {
        targetNames.push(`“${state.qzoneSettings.nickname}”`);
      }
      targetIds.forEach(id => {
        const character = state.chats[id];
        if (character) {
          targetNames.push(`“${character.name}”`);
        }
      });
    }
    const confirmMessage = `此操作将永久删除 ${targetNames.join('、 ')} 的所有动态，且无法恢复！`;

    const confirmed = await showCustomConfirm(
      '确认清空动态？',
      confirmMessage, {
        confirmButtonClass: 'btn-danger',
        confirmText: '确认清空'
      }
    );

    if (!confirmed) return;

    try {
      if (targetIds.includes('all')) {
        await db.qzonePosts.clear();
      } else {

        await db.qzonePosts.where('authorId').anyOf(targetIds).delete();
      }


      qzonePostsCache = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
      qzonePostsRenderCount = 0;
      await renderQzonePosts();

      document.getElementById('clear-posts-modal').classList.remove('visible'); // 关闭选择器
      await showCustomAlert('操作成功', '选定范围内的动态已被清空。');

    } catch (error) {
      console.error("清空动态时出错:", error);
      await showCustomAlert('操作失败', `清空动态时发生错误: ${error.message}`);
    }
  }



  async function handleDeleteThought(timestamp) {
    const confirmed = await showCustomConfirm(
      '确认删除',
      '确定要永久删除这条心声记录吗？此操作不可恢复。', {
        confirmButtonClass: 'btn-danger',
        confirmText: '确认删除'
      }
    );

    if (confirmed) {
      const chat = state.chats[state.activeChatId];
      if (!chat || !chat.thoughtsHistory) return;

      const indexToDelete = chat.thoughtsHistory.findIndex(thought => thought.timestamp === timestamp);
      if (indexToDelete === -1) return;


      const isLatest = indexToDelete === chat.thoughtsHistory.length - 1;


      chat.thoughtsHistory = chat.thoughtsHistory.filter(thought => thought.timestamp !== timestamp);


      if (isLatest) {
        if (chat.thoughtsHistory.length > 0) {

          const newLatestThought = chat.thoughtsHistory[chat.thoughtsHistory.length - 1];
          chat.heartfeltVoice = newLatestThought.heartfeltVoice;
          chat.randomJottings = newLatestThought.randomJottings;

          const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
          const randomJottingsEl = document.getElementById('profile-random-jottings');
          if (heartfeltVoiceEl) heartfeltVoiceEl.textContent = chat.heartfeltVoice;
          if (randomJottingsEl) randomJottingsEl.textContent = chat.randomJottings;

          console.log("已删除最新心声，当前心声已回滚至上一条。");
        } else {

          chat.heartfeltVoice = '...';
          chat.randomJottings = '...';


          const heartfeltVoiceEl = document.getElementById('profile-heartfelt-voice');
          const randomJottingsEl = document.getElementById('profile-random-jottings');
          if (heartfeltVoiceEl) heartfeltVoiceEl.textContent = chat.heartfeltVoice;
          if (randomJottingsEl) randomJottingsEl.textContent = chat.randomJottings;

          console.log("已删除最后一条心声，当前心声已重置。");
        }
      }

      await db.chats.put(chat);


      renderThoughtsHistory();

      await showCustomAlert('成功', '该条记录已成功删除。');
    }
  }


  document.getElementById('thoughts-history-list').addEventListener('click', (e) => {

    const deleteBtn = e.target.closest('.thought-delete-btn');
    if (deleteBtn) {

      const timestamp = parseInt(deleteBtn.dataset.timestamp);
      if (!isNaN(timestamp)) {

        handleDeleteThought(timestamp);
      }
    }
  });

 
  async function loadCssPresetsDropdown() {
    const selectEl = document.getElementById('css-preset-select');
    selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';

    const presets = await db.appearancePresets.where('type').equals('global_css').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });
  }

 
  async function handleCssPresetSelectionChange() {
    const selectEl = document.getElementById('css-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset) {
      const cssInput = document.getElementById('global-css-input');
      cssInput.value = preset.value;
      applyGlobalCss(preset.value);
    }
  }


  async function saveCssPreset() {
    const name = await showCustomPrompt('保存CSS预设', '请输入预设名称');
    if (!name || !name.trim()) return;

    const cssValue = document.getElementById('global-css-input').value;

    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'global_css'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;

      await db.appearancePresets.update(existingPreset.id, {
        value: cssValue
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'global_css',
        value: cssValue
      });
    }

    await loadCssPresetsDropdown();
    alert('CSS 预设已保存！');
  }

 
  async function deleteCssPreset() {
    const selectEl = document.getElementById('css-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('请先从下拉框中选择一个要删除的预设。');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadCssPresetsDropdown();
      alert('预设已删除。');
    }
  }




  async function loadFontPresetsDropdown() {
    const selectEl = document.getElementById('font-preset-select');
    selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';

    const presets = await db.appearancePresets.where('type').equals('font').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });
  }


  async function handleFontPresetSelectionChange() {
    const selectEl = document.getElementById('font-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset) {
      const fontUrlInput = document.getElementById('font-url-input');
      fontUrlInput.value = preset.value;
      applyCustomFont(preset.value, true);
    }
  }

 
  async function saveFontPreset() {
    const name = await showCustomPrompt('保存字体预设', '请输入预设名称');
    if (!name || !name.trim()) return;

    const fontUrl = document.getElementById('font-url-input').value.trim();
    if (!fontUrl) {
      alert("字体URL不能为空！");
      return;
    }

    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'font'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;

      await db.appearancePresets.update(existingPreset.id, {
        value: fontUrl
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'font',
        value: fontUrl
      });
    }

    await loadFontPresetsDropdown();
    alert('字体预设已保存！');
  }


  async function deleteFontPreset() {
    const selectEl = document.getElementById('font-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('请先从下拉框中选择一个要删除的预设。');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadFontPresetsDropdown();
      alert('预设已删除。');
    }
  }
  // 找到这个函数并替换
  async function loadAppearancePresetsDropdown(forceSelectedId = null) {
    const selectEl = document.getElementById('appearance-preset-select');
    selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';

    const presets = await db.appearancePresets.where('type').equals('appearance').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });

    // 如果传入了强制选中的ID，直接选中它，不再进行复杂的对比
    if (forceSelectedId) {
        selectEl.value = forceSelectedId;
        return;
    }

    // 只有在没有强制选中时，才执行原来的自动匹配逻辑
    const currentSettings = {
      wallpaper: state.globalSettings.wallpaper,
      cphoneWallpaper: state.globalSettings.cphoneWallpaper,
      globalChatBackground: state.globalSettings.globalChatBackground,
      appIcons: state.globalSettings.appIcons,
      cphoneAppIcons: state.globalSettings.cphoneAppIcons,
      chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
      theme: localStorage.getItem('ephone-theme') || 'light',
      showStatusBar: state.globalSettings.showStatusBar,
      notificationSoundUrl: state.globalSettings.notificationSoundUrl,
      widgetData: state.globalSettings.widgetData
    };

    let matchingPresetId = null;

    for (const preset of presets) {
      if (JSON.stringify(preset.value) === JSON.stringify(currentSettings)) {
        matchingPresetId = preset.id;
        break;
      }
    }

    if (matchingPresetId) {
      selectEl.value = matchingPresetId;
    } else {
      selectEl.value = '';
    }
  }


 
  // 找到这个函数并替换
  async function handleAppearancePresetSelectionChange() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset && preset.value) {
      const data = preset.value;

      // 1. 智能合并图标（保留上一轮的修复）
      const mergedAppIcons = {
        ...DEFAULT_APP_ICONS,      
        ...(data.appIcons || {})   
      };
      const mergedCPhoneIcons = {
        ...DEFAULT_CPHONE_ICONS,       
        ...(data.cphoneAppIcons || {}) 
      };

      Object.assign(state.globalSettings, data);
      state.globalSettings.appIcons = mergedAppIcons;
      state.globalSettings.cphoneAppIcons = mergedCPhoneIcons;

      applyTheme(data.theme || 'light');
      await db.globalSettings.put(state.globalSettings);

      applyGlobalWallpaper();
      applyCPhoneWallpaper();
      renderIconSettings();       
      renderCPhoneIconSettings(); 
      applyAppIcons();
      applyCPhoneAppIcons();
      applyStatusBarVisibility();
      applyWidgetData();
      
      if (data.chatActionButtonsOrder) {
          renderButtonOrderEditor();
          applyButtonOrder();
      }

      // 【关键修改】：调用 renderWallpaperScreen 时传入 selectedId
      // 这样下拉框就会被强制设置为当前选中的预设，而不会跳回“请选择”
      renderWallpaperScreen(selectedId);

      alert(`已成功加载外观预设：“${preset.name}”\n(缺失的新App图标已自动重置为默认)`);
    }
  }

 
  async function saveAppearancePreset() {
    const name = await showCustomPrompt('保存外观预设', '请输入预设名称');
    if (!name || !name.trim()) return;


    const appearanceData = {
      wallpaper: state.globalSettings.wallpaper,
      cphoneWallpaper: state.globalSettings.cphoneWallpaper,
      globalChatBackground: state.globalSettings.globalChatBackground,
      appIcons: state.globalSettings.appIcons,
      cphoneAppIcons: state.globalSettings.cphoneAppIcons,
      chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
      theme: localStorage.getItem('ephone-theme') || 'light',
      showStatusBar: state.globalSettings.showStatusBar,
      notificationSoundUrl: state.globalSettings.notificationSoundUrl,
      widgetData: state.globalSettings.widgetData
    };


    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'appearance'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;

      await db.appearancePresets.update(existingPreset.id, {
        value: appearanceData
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'appearance',
        value: appearanceData
      });
    }


    await loadAppearancePresetsDropdown();
    alert('外观预设已保存！');
  }

 
  async function deleteAppearancePreset() {
    const selectEl = document.getElementById('appearance-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('请先从下拉框中选择一个要删除的预设。');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadAppearancePresetsDropdown();
      alert('预设已删除。');
    }
  }



  
  async function loadThemePresetsDropdown() {
    const selectEl = document.getElementById('theme-preset-select');
    selectEl.innerHTML = '<option value="">-- 选择一个预设 --</option>';

    const presets = await db.appearancePresets.where('type').equals('bubble_theme').toArray();
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });
  }

 
  async function handleThemePresetSelectionChange() {
    const selectEl = document.getElementById('theme-preset-select');
    const selectedId = parseInt(selectEl.value);
    if (isNaN(selectedId)) return;

    const preset = await db.appearancePresets.get(selectedId);
    if (preset) {


      const baseTheme = preset.value.base || 'default';
      const customCss = preset.value.custom || '';


      const themeRadio = document.querySelector(`input[name="theme-select"][value="${baseTheme}"]`);
      if (themeRadio) {
        themeRadio.checked = true;
      }


      const customCssInput = document.getElementById('custom-css-input');
      customCssInput.value = customCss;


      updateSettingsPreview();

    }
  }

 
  async function saveThemePreset() {
    const name = await showCustomPrompt('保存主题预设', '请输入预设名称');
    if (!name || !name.trim()) return;



    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    const themeValue = selectedThemeRadio ? selectedThemeRadio.value : 'default';


    const cssValue = document.getElementById('custom-css-input').value.trim();


    const presetValueObject = {
      base: themeValue,
      custom: cssValue
    };


    const existingPreset = await db.appearancePresets.where({
      name: name.trim(),
      type: 'bubble_theme'
    }).first();
    if (existingPreset) {
      const confirmed = await showCustomConfirm('覆盖预设', `名为 “${name.trim()}” 的预设已存在。要覆盖它吗？`, {
        confirmButtonClass: 'btn-danger'
      });
      if (!confirmed) return;


      await db.appearancePresets.update(existingPreset.id, {
        value: presetValueObject
      });
    } else {
      await db.appearancePresets.add({
        name: name.trim(),
        type: 'bubble_theme',

        value: presetValueObject
      });
    }

    await loadThemePresetsDropdown();
    alert('主题预设已保存！');
  }

  
  async function deleteThemePreset() {
    const selectEl = document.getElementById('theme-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (isNaN(selectedId)) {
      alert('请先从下拉框中选择一个要删除的预设。');
      return;
    }

    const preset = await db.appearancePresets.get(selectedId);
    if (!preset) return;

    const confirmed = await showCustomConfirm('删除预设', `确定要删除预设 “${preset.name}” 吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.appearancePresets.delete(selectedId);
      await loadThemePresetsDropdown();
      alert('预设已删除。');
    }
  }



 
  async function openStickerCategoryManager() {
    await renderStickerCategoriesInManager();
    document.getElementById('sticker-category-manager-modal').classList.add('visible');
  }


  async function renderStickerCategoriesInManager() {
    const listEl = document.getElementById('existing-sticker-categories-list');
    const categories = await db.stickerCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
      return;
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
                    <span class="group-name">${cat.name}</span>
                    <span class="delete-group-btn" data-id="${cat.id}">×</span>
                `;
      listEl.appendChild(item);
    });
  }

  async function addNewStickerCategory() {
    const input = document.getElementById('new-sticker-category-name-input');
    const name = input.value.trim();
    if (!name) {
      alert('分类名不能为空！');
      return;
    }
    const existing = await db.stickerCategories.where('name').equals(name).first();
    if (existing) {
      alert(`分类 "${name}" 已经存在了！`);
      return;
    }
    await db.stickerCategories.add({
      name
    });
    input.value = '';
    await renderStickerCategoriesInManager();
  }


  async function deleteStickerCategory(categoryId) {
    const category = await db.stickerCategories.get(categoryId);
    if (!category) return;

    const stickersInCateogry = await db.userStickers.where('categoryId').equals(categoryId).count();

    const confirmMessage = stickersInCateogry > 0 ?
      `确定要删除分类《${category.name}》吗？\n\n【警告】\n此操作将同时永久删除该分类下的 ${stickersInCateogry} 个表情包，且无法恢复！` :
      `确定要删除分类《${category.name}》吗？`;

    const confirmed = await showCustomConfirm(
      '确认删除分类',
      confirmMessage, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      try {

        await db.transaction('rw', db.stickerCategories, db.userStickers, async () => {

          const stickerIdsToDelete = await db.userStickers.where('categoryId').equals(categoryId).primaryKeys();


          if (stickerIdsToDelete.length > 0) {
            await db.userStickers.bulkDelete(stickerIdsToDelete);
          }


          await db.stickerCategories.delete(categoryId);
        });


        state.userStickers = await db.userStickers.toArray();
        if (activeStickerCategoryId === categoryId) {
          activeStickerCategoryId = 'all';
        }
        await renderStickerCategoriesInManager();
        await renderStickerPanel();

        alert(`分类《${category.name}》及其下的表情已成功删除。`);

      } catch (error) {
        console.error("删除分类及表情时出错:", error);
        alert("删除失败，请查看控制台错误信息。");
      }
    }
  }


  function switchStickerCategory(categoryId) {
    activeStickerCategoryId = categoryId;
    document.querySelectorAll('.sticker-category-tab').forEach(tab => {
      tab.classList.toggle('active', String(tab.dataset.categoryId) === String(categoryId));
    });
    renderStickerPanel(false);


    const selectAllCheckbox = document.getElementById('select-all-stickers-checkbox');
    if (selectAllCheckbox) selectAllCheckbox.checked = false;
  }

 
  async function exportSingleChat() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    try {
      const backupData = {
        type: 'EPhoneSingleChat',
        version: 1,
        chatData: chat
      };

      const blob = new Blob(
        [JSON.stringify(backupData, null, 2)], {
          type: 'application/json'
        }
      );
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;

      link.download = `EPhone-Chat-${chat.name}-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);

      await showCustomAlert('导出成功', `与“${chat.name}”的聊天记录已成功导出！`);

    } catch (error) {
      console.error("导出单个聊天时出错:", error);
      await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
  }

 
  async function importSingleChat(file) {
    if (!file || !state.activeChatId) return;
    const currentChatId = state.activeChatId;
    const currentChat = state.chats[currentChatId];

    try {
      const text = await file.text();
      const data = JSON.parse(text);


      if (data.type !== 'EPhoneSingleChat' || !data.chatData) {
        throw new Error("文件格式不正确，这不是一个有效的单聊备份文件。");
      }


      const confirmed = await showCustomConfirm(
        '严重警告！',
        `这将用备份文件中的数据【完全覆盖】当前与“${currentChat.name}”的聊天记录和设置。此操作不可撤销！<br><br><strong>确定要继续吗？</strong>`, {
          confirmButtonClass: 'btn-danger',
          confirmText: '确认覆盖'
        }
      );

      if (!confirmed) return;


      const importedChatData = data.chatData;


      importedChatData.id = currentChatId;


      await db.chats.put(importedChatData);
      state.chats[currentChatId] = importedChatData;


      await showCustomAlert('导入成功', '聊天记录已成功覆盖！正在刷新界面...');


      renderChatInterface(currentChatId);
      renderChatList();
      document.getElementById('chat-settings-btn').click();

    } catch (error) {
      console.error("导入单个聊天时出错:", error);
      await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
    }
  }



  function openCharacterSelector() {
    renderCharacterSelector();
    showScreen('character-selection-screen');
  }


  function renderCharacterSelector() {
    const gridEl = document.getElementById('character-grid');
    gridEl.innerHTML = '';


    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有可以查看手机的角色哦~</p>';
      return;
    }

    characters.forEach(char => {
      const item = document.createElement('div');
      item.className = 'character-select-item';
      item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${char.name}</span>
        `;
      item.addEventListener('click', () => switchToCharacterPhone(char.id));
      gridEl.appendChild(item);
    });
  }


 
  async function switchToCharacterPhone(characterId) {
    activeCharacterId = characterId;
    console.log(`已切换到角色 ${characterId} 的手机`);


    applyCPhoneWallpaper();
    applyCPhoneAppIcons();


    renderCharHomeScreen();
    showScreen('character-phone-screen');
  }


 
  function switchToMyPhone() {
    activeCharacterId = null;
    console.log("已返回我的手机");
    showScreen('home-screen');
  }


  function renderCharHomeScreen() {
    // 新布局不需要在这里更新大时钟了
    switchToCharScreen('char-home-screen');
  }

// ==========================================
// CPhone 气泡文字专用编辑函数 (修复无法修改问题)
// ==========================================
window.editBubbleText = async function(elementId) {
    const textElement = document.getElementById(elementId);
    if (!textElement) return;
    
    // 如果已经是 input 模式，直接返回，防止重复点击
    if (textElement.tagName === 'INPUT') return;

    const currentText = textElement.innerText;
    const parent = textElement.parentElement;

    // 创建临时输入框
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.className = 'bubble-edit-input'; // 使用我们在 CSS 里定义的样式
    
    // 继承字体样式
    const computedStyle = window.getComputedStyle(textElement);
    input.style.fontFamily = computedStyle.fontFamily;
    input.style.fontSize = computedStyle.fontSize;
    input.style.fontWeight = computedStyle.fontWeight;
    input.style.textAlign = computedStyle.textAlign;

    // 保存函数
    async function saveEdit() {
        const newText = input.value.trim();
        if (newText) {
            textElement.innerText = newText;
            // 尝试保存到数据库 (复用 widgetData)
            if (!state.globalSettings.widgetData) {
                state.globalSettings.widgetData = {};
            }
            state.globalSettings.widgetData[elementId] = newText;
            await db.globalSettings.put(state.globalSettings);
        }
        // 替换回文本标签
        if(input.parentNode) input.replaceWith(textElement);
    }

    // 绑定事件：失去焦点或回车时保存
    input.addEventListener('blur', saveEdit);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            input.blur();
        }
    });

    // 替换 DOM
    textElement.replaceWith(input);
    input.focus();
    // 阻止事件冒泡，防止触发其他点击
    if(window.event) window.event.stopPropagation();
}
  function switchToCharScreen(screenId) {
    document.querySelectorAll('.char-screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId).classList.add('active');
  }

  window.switchToCharScreen = switchToCharScreen;




  async function openCharApp(appName) {
    if (!activeCharacterId) return;
    const char = state.chats[activeCharacterId];


    await logAppUsage(activeCharacterId, appName);


    switch (appName) {
      case 'qq':
        renderCharSimulatedQQ();
        switchToCharScreen('char-qq-screen');
        break;
      case 'album':
        renderCharAlbum();
        switchToCharScreen('char-album-screen');
        break;
      case 'browser':
        renderCharBrowserHistory();
        switchToCharScreen('char-browser-screen');
        break;
      case 'taobao':
        renderCharTaobao();
        switchToCharScreen('char-taobao-screen');
        break;
      case 'memo':
        renderCharMemoList();
        switchToCharScreen('char-memo-screen');
        break;
      case 'diary':
        renderCharDiaryList();
        switchToCharScreen('char-diary-screen');
        break;
      case 'amap':
        renderCharAmap();
        switchToCharScreen('char-amap-screen');
        break;



      case 'music':
        renderCharMusicScreen();
        switchToCharScreen('char-music-screen');
        break;
      case 'bilibili':
        
        document.getElementById('char-bilibili-search-input').value = '';

        renderCharBilibiliScreen(); 
        switchToCharScreen('char-bilibili-screen');
        break;
      case 'reddit':
    // 默认加载热门内容
    if (char.simulatedRedditFeed && char.simulatedRedditFeed.length > 0) {
            console.log("加载已保存的 Reddit 推荐流");
            renderRedditList(char.simulatedRedditFeed);
        } else {
            // 只有当没有缓存时，才去加载热门内容
            console.log("无缓存，加载默认热门内容");
            handleRedditSearch('popular'); 
        }
    switchToCharScreen('char-reddit-screen');
    break;
      case 'usage':
        renderCharAppUsage();
        switchToCharScreen('char-usage-screen');
        break;
    }
  }


  async function renderCharAlbum() {
    const gridEl = document.getElementById('char-album-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterId) return;
    const char = state.chats[activeCharacterId];

    const photos = char.simulatedAlbum || [];

    if (photos.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的相册还是空的，<br>点击右上角刷新按钮生成一些照片吧！</p>';
      return;
    }

    const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

    photos.forEach(photo => {
      const item = document.createElement('div');
      item.className = 'char-photo-item';
      item.dataset.description = photo.description;
      gridEl.appendChild(item);



      if (state.globalSettings.enableAiDrawing) {

        item.style.backgroundColor = '#e9ecef';
        const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
        const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
        const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;

        const img = new Image();
        img.onload = function() {
          item.style.backgroundImage = `url(${this.src})`;
        };
        img.onerror = function() {
          item.style.backgroundImage = `url(${fallbackImageUrl})`;
        };
        img.src = imageUrl;

      } else {

        item.style.backgroundColor = '#f0f2f5';
        item.style.border = '1px solid #e0e0e0';


        const descriptionEl = document.createElement('p');
        descriptionEl.className = 'char-photo-description';
        descriptionEl.textContent = photo.description || '(这张照片没有描述)';


        item.appendChild(descriptionEl);
      }

    });
  }


  function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    // 如果没有历史记录，尝试生成默认的假数据
    if (!char.simulatedBrowserHistory || char.simulatedBrowserHistory.length === 0) {
        // 这里保留你原有的生成逻辑，或者显示空状态
        // 为了保持视觉统一，即使是随机生成的假数据也应用新结构
        const historyKeywords = [char.name, "爱好", "旅游", "美食", "新闻", ...char.settings.aiPersona.split(/，|。|\s/).slice(0, 5)];
        const historySites = ["知乎", "Bilibili", "小红书", "微博", "维基百科"];
        
        // 临时生成演示数据
        const demoHistory = [];
        for (let i = 0; i < 10; i++) {
            const keyword = historyKeywords[Math.floor(Math.random() * historyKeywords.length)];
            const site = historySites[Math.floor(Math.random() * historySites.length)];
            demoHistory.push({
                title: `${keyword} - ${site}`,
                url: `www.${site.toLowerCase()}.com`,
                content: "内容加载中..."
            });
        }
        char.simulatedBrowserHistory = demoHistory; 
    }

    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的浏览器空空如也，<br>点击右上角刷新按钮生成一些记录吧！</p>';
        return;
    }

    // 定义地球图标的 SVG
    const globeIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>`;
    
    // 定义右箭头 SVG
    const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    history.forEach((item, index) => {
        const entryEl = document.createElement('div');
        entryEl.className = 'char-browser-item';
        
        // 简化 URL 显示，去掉 https://
        let cleanUrl = item.url.replace(/^https?:\/\//, '').replace(/^www\./, '');
        if(cleanUrl.length > 25) cleanUrl = cleanUrl.substring(0, 25) + '...';

        entryEl.innerHTML = `
            <div class="char-browser-icon-box">
                ${globeIcon}
            </div>
            <div class="char-browser-info">
                <div class="title">${item.title}</div>
                <div class="url">${cleanUrl}</div>
            </div>
            <div class="char-browser-arrow">
                ${arrowIcon}
            </div>
        `;

        entryEl.addEventListener('click', () => openCharArticle(index));
        listEl.appendChild(entryEl);
    });
}



  function renderCharTaobao() {
    const gridEl = document.getElementById('char-product-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const purchases = char.simulatedTaobaoHistory?.purchases || [];

    if (purchases.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA最近好像什么都没买呢，<br>点击右上角刷新按钮生成一些记录吧！</p>';
      return;
    }

    purchases.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-product-item';
      itemEl.dataset.reason = item.reason;

      let imageOrTextHtml;
      if (state.globalSettings.enableAiDrawing) {
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt || 'a random product')}`;
        imageOrTextHtml = `<img src="${imageUrl}" class="product-image">`;
      } else {
        imageOrTextHtml = `
                        <div class="char-product-description-overlay">
                            <p class="char-photo-description">${item.reason || '(无购买理由)'}</p>
                        </div>
                    `;
      }


      itemEl.innerHTML = `
                    ${imageOrTextHtml}
                    <div class="product-info">
                        <div class="product-name">${item.itemName}</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                            <div class="product-price">${(item.price || 0).toFixed(2)}</div>
                            <div class="char-product-status">${item.status}</div>
                        </div>
                    </div>
                `;

      gridEl.appendChild(itemEl);
    });
  }

  function switchToCharHomeScreen() {
    switchToCharScreen('char-home-screen');
  }




  function renderCharChatList() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;


    const relatedChats = Object.values(state.chats).filter(chat => {

      if (chat.id === activeCharacterId) return true;

      if (chat.isGroup && chat.members.some(m => m.id === activeCharacterId)) return true;
      return false;
    });

    relatedChats.forEach(chat => {
      const item = createChatListItem(chat);
      listEl.appendChild(item);
    });
  }

 
  async function logAppUsage(characterId, appName) {
    const char = state.chats[characterId];
    if (!char) return;
    if (!char.appUsageLog) {
      char.appUsageLog = [];
    }
    char.appUsageLog.push({
      appName: appName,
      timestamp: Date.now()
    });

    if (char.appUsageLog.length > 50) {
      char.appUsageLog.shift();
    }
    await db.chats.put(char);
  }

 
  function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const log = (char.appUsageLog || []).slice().reverse();

    if (log.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何使用记录。</p>';
      return;
    }

    const appNameMap = {
      'qq': 'QQ',
      'album': '相册',
      'browser': '浏览器',
      'taobao': '淘宝',
      'memo': '备忘录',
      'diary': '日记',
      'amap': '高德地图',
      'usage': 'App记录'
    };

    log.forEach(entry => {
      const item = document.createElement('div');
      item.className = 'usage-item';
      item.innerHTML = `
            <div class="timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
            <div class="action">打开了 <strong>${appNameMap[entry.appName] || entry.appName}</strong></div>
        `;
      listEl.appendChild(item);
    });
  }

  async function sendCharLocationShare(locationName) {
    const userChat = state.chats[activeCharacterId];
    if (!userChat) return;

    const msg = {
      role: 'assistant',
      senderName: userChat.originalName,
      type: 'location_share',
      content: locationName,
      imageUrl: 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg',
      timestamp: Date.now()
    };

    userChat.history.push(msg);
    await db.chats.put(userChat);


    if (state.activeChatId === activeCharacterId) {
      appendMessage(msg, userChat);
    }

    await showCustomAlert("分享成功", `“${userChat.name}” 的位置已发送到你们的聊天中。`);
  }


 
  async function viewMemo(memoId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.memos) return;

    const memo = char.memos.find(m => m.id === memoId);
    if (memo) {

      activeMemoForViewing = memo;

      const titleEl = document.getElementById('char-memo-detail-title');
      const contentEl = document.getElementById('char-memo-detail-content');
      const favBtn = document.getElementById('favorite-memo-btn');

      if (titleEl) titleEl.textContent = memo.title;
      if (contentEl) contentEl.value = memo.content;


      const existingFavorite = await db.favorites.where({
        type: 'char_memo',
        'content.id': memoId
      }).first();
      favBtn.classList.toggle('active', !!existingFavorite);

      switchToCharScreen('char-memo-detail-screen');
    }
  }

  
  function renderCharMemoList() {
    const listEl = document.getElementById('char-memo-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const memos = (char.memos || []).slice().reverse();

    if (memos.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有备忘录。</p>';
      return;
    }

    // SVG 图标: 类似文件的图标
    const memoIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`;
    // SVG 图标: 右箭头
    const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    memos.forEach(memo => {
      const item = document.createElement('div');
      // 注意：移除了旧的 'list-item' 类，只保留 'memo-item' 以应用新样式
      item.className = 'memo-item'; 
      
      // 获取内容预览 (第一行)
      const previewText = (memo.content || '').split('\n')[0] || '无内容';

      item.innerHTML = `
            <div class="cphone-item-icon-box memo-icon-style">
                ${memoIconSVG}
            </div>
            <div class="cphone-item-info">
                <div class="cphone-item-title">${memo.title}</div>
                <div class="cphone-item-preview">${previewText}</div>
            </div>
            <div class="cphone-item-arrow">
                ${arrowIcon}
            </div>
        `;

      item.addEventListener('click', () => viewMemo(memo.id));
      addLongPressListener(item, () => deleteMemo(memo.id));
      listEl.appendChild(item);
    });
  }

 
  async function openMemoEditor(memoId = null) {
    editingMemoId = null;


    const newTitle = await showCustomPrompt("新建备忘录", "请输入标题");
    if (newTitle === null || !newTitle.trim()) return;

    const newContent = await showCustomPrompt(`标题: ${newTitle}`, "请输入备忘录内容", "", 'textarea');
    if (newContent !== null) {

      await saveMemo({
        title: newTitle.trim(),
        content: newContent
      });
      switchToCharScreen('char-memo-screen');
    }
  }

 
  async function saveMemo(memoData) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];


    char.memos.push({
      id: Date.now(),
      title: memoData.title,
      content: memoData.content
    });

    await db.chats.put(char);
    renderCharMemoList();
  }

  async function saveMemo(content) {
    const char = state.chats[activeCharacterId];
    if (!char.memos) char.memos = [];

    if (editingMemoId) {
      const memo = char.memos.find(m => m.id === editingMemoId);
      if (memo) memo.content = content;
    } else {
      char.memos.push({
        id: Date.now(),
        content: content
      });
    }

    await db.chats.put(char);
    renderCharMemoList();
    editingMemoId = null;
  }





 
  async function handleGenerateSimulatedDiaries() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”翻开TA的日记本...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('请先在API设置中配置好API信息。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const userPersona = chat.settings.myPersona || '(未设置)';
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器和故事作家。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【5到8篇】TA最近可能会写的日记。

# 核心规则
1.  **【时间 (最高优先级)】**:
    -   今天的日期是 **${new Date().toLocaleDateString('zh-CN')}**。
    -   你生成的【所有】日记的标题日期，【必须】是今天或今天以前的日期。
    -   【绝对禁止】生成任何未来的日期！
2.  **【沉浸感】**: 每一篇日记都必须使用【第一人称视角 ("我")】来写，并且要充满角色的个人情感、思考和秘密。在日记中描述自己的行为或想法时，【绝对禁止】使用第三人称“他”或“她” (TA)。
3.  **【长度】**: 每一篇日记的正文长度【必须不少于300字】。
4.  **【格式铁律 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一篇日记，格式【必须】如下:
    \`\`\`json
    [
      {
        "title": "这篇日记的标题，例如：9月20日 晴",
        "content": "这里是日记的详细正文，必须支持换行符\\n，并且必须巧妙地使用下面的【日记专属Markdown语法】来丰富文本表现力。"
      }
    ]
    \`\`\`
5.  **【占位符替换 (最高优先级)】**: 在你的日记内容中，【绝对不能】出现 "{{user}}" 这个占位符。你【必须】使用 “${userDisplayNameForAI}” 来指代你的聊天对象（用户）。
6.  **【日记专属Markdown语法 (必须使用！)】**:
    -   \`**加粗文字**\`: 用于强调。
    -   \`~~划掉的文字~~\`: 用于表示改变主意或自我否定。
    -   \`!h{黄色高亮}\`: 用于标记关键词或重要信息。
    -   \`!u{粉色下划线}\`: 用于标注人名、地名或特殊名词。
    -   \`!e{粉色强调}\`: 用于表达强烈的情绪。
    -   \`!w{手写体}\`: 用于写下引言、歌词或特殊笔记。
    -   \`!m{凌乱的手写体}\`: 用于表达激动、慌乱或潦草记录时的心情。
    -   \`||涂黑||\`: 用于隐藏秘密或敏感词汇 (每次涂黑2~5个字)。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的聊天对象设定**:${userPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始撰写这组充满真情实感、并熟练运用了Markdown语法的日记。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的日记内容。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.95,

          })
        });


      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedDiaries;
      try {
        simulatedDiaries = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


      chat.diary = simulatedDiaries.map(entry => ({
        id: Date.now() + Math.random(),
        title: entry.title,
        content: entry.content,
        timestamp: Date.now()
      }));

      await db.chats.put(chat);
      await renderCharDiaryList();

    } catch (error) {
      console.error("生成模拟日记失败:", error);
      await showCustomAlert("生成失败", `无法生成日记，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }

 
  async function handleWriteNewDiaryEntry() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”写一篇新日记...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || []).map(bookId => state.worldBooks.find(wb => wb.id === bookId)).filter(Boolean).map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e=>e.enabled).map(e=>`- ${e.content}`).join('\n')}`).join('');


    const systemPrompt = `          
# 你的任务
你是一个虚拟生活模拟器和故事作家。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【1篇】TA今天可能会写的日记。

# 核心规则
1.  **【【【时间铁律 (最高优先级)】】】**:
    -   今天的日期是 **${new Date().toLocaleDateString('zh-CN')}**。
    -   你生成的日记标题日期【必须】是今天或今天以前的日期。
    -   【绝对禁止】生成任何未来的日期！
2.  **【【【沉浸感铁律】】】**: 日记必须使用【第一人称视角 ("我")】来写，并且要充满角色的个人情感、思考和秘密。在日记中描述自己的行为或想法时，【绝对禁止】使用第三人称“他”或“她” (TA)。
3.  **【【【长度铁律】】】**: 日记的正文长度【必须不少于300字】。
4.  **【【【格式铁律 (最高优先级)】】】**: 你的回复【必须且只能】是一个JSON数组，且数组中【只包含一个】对象，格式【必须】如下:
    \`\`\`json
    [
      {
        "title": "这篇日记的标题，例如：9月20日 晴",
        "content": "这里是日记的详细正文，必须支持换行符\\n，并且必须巧妙地使用下面的【日记专属Markdown语法】来丰富文本表现力。"
      }
    ]
    \`\`\`
5.  **【【【日记专属Markdown语法 (必须使用！)】】】**:
    -   \`**加粗文字**\`: 用于强调。
    -   \`~~划掉的文字~~\`: 用于表示改变主意或自我否定。
    -   \`!h{黄色高亮}\`: 用于标记关键词或重要信息。
    -   \`!u{粉色下划线}\`: 用于标注人名、地名或特殊名词。
    -   \`!e{粉色强调}\`: 用于表达强烈的情绪。
    -   \`!w{手写体}\`: 用于写下引言、歌词或特殊笔记。
    -   \`!m{凌乱的手写体}\`: 用于表达激动、慌乱或潦草记录时的心情。
    -   \`||涂黑||\`: 用于隐藏秘密或敏感词汇(每次涂黑2~5个字)。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始撰写这篇充满真情实感、并熟练运用了Markdown语法的日记。`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，写一篇新日记。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);
      const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: [{
            role: 'system',
            content: systemPrompt
          }, ...messagesForApi],
          temperature: state.globalSettings.apiTemperature || 0.95,
        })
      });
      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);
      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let newDiaryEntry;
      try {
        newDiaryEntry = JSON.parse(cleanedJsonString)[0];
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


      if (!chat.diary) chat.diary = [];

      chat.diary.push({
        id: Date.now(),
        title: newDiaryEntry.title,
        content: newDiaryEntry.content,
        timestamp: Date.now()
      });

      await db.chats.put(chat);
      await renderCharDiaryList();

    } catch (error) {
      console.error("生成新日记失败:", error);
      await showCustomAlert("生成失败", `错误: ${error.message}`);
    }
  }

  function renderCharDiaryList() {
    const listEl = document.getElementById('char-diary-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    const diaries = (char.diary || []).slice().reverse();

    if (diaries.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">日记本还是空的。</p>';
      return;
    }

    // SVG 图标: 书本图标
    const diaryIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>`;
    // SVG 图标: 右箭头
    const arrowIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    diaries.forEach(entry => {
      const item = document.createElement('div');
      // 注意：移除了旧的 'list-item' 类
      item.className = 'diary-item';
      
      // 格式化日期
      const dateStr = new Date(entry.timestamp).toLocaleDateString('zh-CN');

      item.innerHTML = `
             <div class="cphone-item-icon-box diary-icon-style">
                ${diaryIconSVG}
            </div>
            <div class="cphone-item-info">
                <div class="cphone-item-title">${entry.title}</div>
                <div class="cphone-item-preview">${dateStr}</div>
            </div>
            <div class="cphone-item-arrow">
                ${arrowIcon}
            </div>
        `;
        
      item.addEventListener('click', () => viewDiary(entry.id));
      addLongPressListener(item, () => deleteDiary(entry.id));
      listEl.appendChild(item);
    });
  }



  async function viewDiary(diaryId) {
    const char = state.chats[activeCharacterId];
    if (!char || !char.diary) return;

    const entry = char.diary.find(d => d.id === diaryId);
    if (entry) {

      activeDiaryForViewing = entry;

      const titleEl = document.getElementById('char-diary-detail-title');
      const contentEl = document.getElementById('char-diary-detail-content');
      const favBtn = document.getElementById('favorite-diary-btn');

      titleEl.textContent = entry.title;
      const formattedContent = parseMarkdown(entry.content)
        .split('\n')
        .map(p => `<p>${p || '&nbsp;'}</p>`)
        .join('');
      contentEl.innerHTML = formattedContent;


      const existingFavorite = await db.favorites.where({
        type: 'char_diary',
        'content.id': diaryId
      }).first();
      favBtn.classList.toggle('active', !!existingFavorite);

      switchToCharScreen('char-diary-detail-screen');
    }
  }

 
  async function toggleDiaryFavorite() {
    if (!activeDiaryForViewing || !activeCharacterId) return;

    const diary = activeDiaryForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-diary-btn');


    const existingFavorite = await db.favorites.where({
      type: 'char_diary',
      'content.id': diary.id
    }).first();

    if (existingFavorite) {

      await db.favorites.delete(existingFavorite.id);
      favBtn.classList.remove('active');
      await showCustomAlert('操作成功', '已取消收藏。');
    } else {

      const newFavorite = {
        type: 'char_diary',

        content: {
          id: diary.id,
          title: diary.title,
          content: diary.content,
          timestamp: diary.timestamp,
          characterId: activeCharacterId,
          characterName: char.name
        },
        timestamp: Date.now()
      };
      await db.favorites.add(newFavorite);
      favBtn.classList.add('active');
      await showCustomAlert('操作成功', '已成功收藏到“我的收藏”页面！');
    }
  }



  async function toggleMemoFavorite() {

    if (!activeMemoForViewing || !activeCharacterId) return;

    const memo = activeMemoForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-memo-btn');


    const existingFavorite = await db.favorites.where({
      type: 'char_memo',
      'content.id': memo.id
    }).first();

    if (existingFavorite) {

      await db.favorites.delete(existingFavorite.id);
      favBtn.classList.remove('active');
      await showCustomAlert('操作成功', '已取消收藏。');
    } else {

      const newFavorite = {
        type: 'char_memo',

        content: {
          id: memo.id,
          title: memo.title,
          content: memo.content,
          timestamp: memo.timestamp,
          characterId: activeCharacterId,
          characterName: char.name
        },
        timestamp: Date.now()
      };
      await db.favorites.add(newFavorite);
      favBtn.classList.add('active');
      await showCustomAlert('操作成功', '已成功收藏到“我的收藏”页面！');
    }
  }


  async function deleteDiary(diaryId) {
    const confirmed = await showCustomConfirm('删除日记', '确定要删除这篇日记吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      const char = state.chats[activeCharacterId];
      char.diary = char.diary.filter(d => d.id !== diaryId);
      await db.chats.put(char);
      renderCharDiaryList();
    }
  }




  async function renderCharSimulatedQQ() {
    const listEl = document.getElementById('char-chat-list');
    listEl.innerHTML = '';
    const char = state.chats[activeCharacterId];
    if (!char) return;


    const userDisplayName = char.settings.myNickname || (state.qzoneSettings.nickname || '我');
    const lastRealMessage = char.history.filter(m => !m.isHidden).slice(-1)[0] || {
      content: '...'
    };


    let lastMsgContent = '...';
    if (lastRealMessage) {
      if (typeof lastRealMessage.content === 'string') {
        lastMsgContent = lastRealMessage.content;
      } else if (Array.isArray(lastRealMessage.content) && lastRealMessage.content[0]?.type === 'image_url') {
        lastMsgContent = '[图片]';
      } else if (lastRealMessage.type) {
        const typeMap = {
          'voice_message': '[语音]',
          'transfer': '[转账]',
          'ai_image': '[图片]'
        };
        lastMsgContent = typeMap[lastRealMessage.type] || `[${lastRealMessage.type}]`;
      }
    }


    const myAvatar = char.settings.myAvatar || defaultAvatar;
    const myFrame = char.settings.myAvatarFrame || '';
    let avatarHtml;
    if (myFrame) {
      avatarHtml = `<div class="avatar-group has-frame" style="width: 45px; height: 45px;"><div class="avatar-with-frame" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar-img" style="border-radius: 50%;"><img src="${myFrame}" class="avatar-frame"></div></div>`;
    } else {
      avatarHtml = `<div class="avatar-group" style="width: 45px; height: 45px;"><img src="${myAvatar}" class="avatar" style="border-radius: 50%; width: 45px; height: 45px;"></div>`;
    }

    const userChatItem = document.createElement('div');
    userChatItem.className = 'chat-list-item';

    userChatItem.dataset.conversationIndex = "-1";
    userChatItem.innerHTML = `
        ${avatarHtml}
        <div class="info">
            <div class="name-line">
                <span class="name">${userDisplayName}</span>
            </div>
            <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
        </div>
    `;
    listEl.appendChild(userChatItem);


    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc]));
    const conversations = char.simulatedConversations || [];

    if (conversations.length === 0 && !userChatItem) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">点击右上角刷新按钮，<br>看看TA最近都和谁聊天了吧！</p>';
      return;
    }

    conversations.forEach((convo, index) => {

      if (convo.type === 'private_user') {
        return;
      }


      const item = document.createElement('div');
      item.className = 'chat-list-item';
      item.dataset.conversationIndex = index;

      let lastMessage, avatarHtml, displayName;

      if (convo.type === 'group') {
        displayName = convo.groupName + ` <span class="group-tag">群</span>`;
        lastMessage = convo.messages.slice(-1)[0] || {
          content: '...'
        };
        const groupAvatarPrompt = `logo, simple, flat design, for a group chat named '${convo.groupName}'`;
        const avatarUrl = state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(groupAvatarPrompt)}` : defaultGroupAvatar;
        avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;

      } else {
        displayName = convo.participant.name;
        lastMessage = convo.messages.slice(-1)[0] || {
          content: '...'
        };
        const npcData = npcMap.get(displayName);
        let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
          (state.globalSettings.enableAiDrawing ? `https://image.pollinations.ai/prompt/${encodeURIComponent(convo.participant.avatar_prompt || 'anime person')}` : defaultGroupMemberAvatar);
        avatarHtml = `<div class="avatar-group"><img src="${avatarUrl}" class="avatar" style="border-radius: 50%;"></div>`;
      }

      let lastMsgContent = '...';
      if (lastMessage && lastMessage.content) {
        lastMsgContent = lastMessage.content;
      }

      item.innerHTML = `
            ${avatarHtml}
            <div class="info">
                <div class="name-line">
                    <span class="name">${displayName}</span>
                </div>
                <div class="last-msg">${String(lastMsgContent).substring(0, 20)}...</div>
            </div>
        `;
      listEl.appendChild(item);
    });
  }
 
  async function handleGenerateSimulatedQQ() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在根据“${chat.name}”的记忆和人设，生成全新的社交动态...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('请先在API设置中配置好API信息。');
      return;
    }

    const allNpcs = await db.npcs.toArray();
    const associatedNpcs = allNpcs.filter(npc =>
      npc.associatedWith && npc.associatedWith.includes(activeCharacterId)
    );
    let npcContext = "# 你的社交圈 (绑定的NPC)\n";
    if (associatedNpcs.length > 0) {
      npcContext += "这是你认识的、关系密切的NPC。在生成对话时，你应该【优先】与他们互动。\n";
      associatedNpcs.forEach(npc => {
        npcContext += `- **姓名**: ${npc.name}\n  - **人设**: ${npc.persona}\n`;
      });
    } else {
      npcContext += "（你目前没有绑定的NPC伙伴，可以自由创造新的NPC。）\n";
    }

    const userDisplayNameForAI = state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname ? '用户' : state.qzoneSettings.nickname;
    const userNicknameInThisChat = chat.settings.myNickname || userDisplayNameForAI;
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistoryWithUser_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userNicknameInThisChat : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定 (你可以将其中角色作为聊天对象):\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
    const characterOriginalName = chat.originalName || chat.name;
    const stickerContext = getGroupStickerContextForPrompt(chat);

    const systemPrompt = `
# 你的任务
你是一个虚拟社交生活模拟器，扮演角色“${chat.name}”。你的任务是虚构出【5到7段】TA最近的QQ聊天记录。

# 核心规则
1.  **【NPC唯一性铁律】**: 在你本次生成的所有对话中（包括私聊和群聊），每一个NPC的名字【必须是独一-无二的】。绝对禁止出现重名的NPC，禁止出现重复群聊。
2.  **【NPC来源】**: 你应该优先从“你的社交圈 (绑定的NPC)”和“世界书”中寻找角色作为聊天对象。如果不够，你也可以自由创造全新的NPC，对话内容要多样化，反映角色的生活。
3.  **关联性**: 对话内容应巧妙地反映角色的长期记忆、世界观，以及与用户互动可能带来的心情变化。
4.  **简洁性**: 每段对话的总长度应在8到15句之间。
# 格式铁律 (最高优先级)
- 你的回复【必须且只能】是一个JSON数组格式的字符串，以 \`[\` 开始，并以 \`]\` 结束。
- 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记。
- 数组中的每个元素都代表一段对话，且【必须】是以下两种格式之一：



### 格式 A：与NPC的私聊
\`\`\`json
{
  "type": "private_npc",
  "participant": {
    "name": "NPC的名字",
    "avatar_prompt": "(仅当NPC是新创造时提供)一段用于生成头像的【英文】关键词, 风格为动漫/插画/二次元等, 禁止真人"
  },
"messages": [
  {"sender": "${characterOriginalName}", "content": "对话内容1"},
  {"sender": "NPC的名字", "content": "对话内容2"},
  {"sender": "${characterOriginalName}", "type": "sticker", "meaning": "表情的含义(必须从可用表情列表选择)"}
]
}
\`\`\`

### 格式 B：群聊
\`\`\`json
{
  "type": "group",
  "groupName": "一个虚构的群名",
  "participants": [
    {"name": "NPC成员1", "avatar_prompt": "(仅当NPC是新创造时提供) 成员1头像【英文】关键词"},
    {"name": "NPC成员2", "avatar_prompt": "(仅当NPC是新创造时提供) 成员2头像【英文】关键词"}
  ],
"messages": [
  {"sender": "${characterOriginalName}", "content": "我在群里说的话"},
  {"sender": "NPC成员1", "content": "成员1回复我"},
  {"sender": "NPC成员2", "type": "sticker", "meaning": "表情的含义(必须从可用表情列表选择)"}
]
}
\`\`\`

# 角色与上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**: ${longTermMemoryContext}
- **世界观**: ${worldBookContext}
- **最近与用户的互动**: ${recentHistoryWithUser}
${npcContext}
# 可用表情包 (必须严格遵守！)
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
${stickerContext}
现在，请严格按照格式铁律，生成聊天记录的JSON数组。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成模拟聊天记录。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedConversations;
      try {
        simulatedConversations = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }

      chat.simulatedConversations = simulatedConversations;
      await db.chats.put(chat);

      await renderCharSimulatedQQ();


      const hiddenMessage = {
        role: 'system',
        content: `[系统指令：你刚刚在自己的手机上活动了一番（和朋友聊天、逛群等）。现在请根据你的角色设定，主动给用户发一条消息，可以聊聊你刚才看到或聊到的趣事，或者仅仅是问候一下。]`,
        timestamp: Date.now(),
        isHidden: true
      };
      chat.history.push(hiddenMessage);
      await db.chats.put(chat);
      triggerAiResponse();

    } catch (error) {
      console.error("生成模拟聊天失败:", error);
      await showCustomAlert("生成失败", `无法生成模拟聊天记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }

 
  async function handleContinueRealConversationFromCPhone() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;



    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成对话。');
      }

      const maxMemory = parseInt(chat.settings.maxMemory) || 10;
      const historySlice = chat.history.slice(-maxMemory);
      const filteredHistory = await filterHistoryWithDoNotSendRules(historySlice, activeCharacterId);
      const myNickname = chat.settings.myNickname || '我';






      const userPersona = chat.settings.myPersona || '用户';


      const longTermMemoryContext = `# 长期记忆 (必须严格遵守)\n${
            chat.longTermMemory && chat.longTermMemory.length > 0 
                ? chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') 
                : '- (暂无)'
        }`;


      let worldBookContext = '';
      if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
          const worldBook = state.worldBooks.find(wb => wb.id === bookId);
          if (!worldBook || !Array.isArray(worldBook.content)) return '';
          const formattedEntries = worldBook.content
            .filter(entry => entry.enabled !== false)
            .map(entry => `\n### 条目: ${entry.comment || '无备注'}\n**内容:**\n${entry.content}`)
            .join('');
          return formattedEntries ? `\n\n## 世界书: ${worldBook.name}\n${formattedEntries}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
          worldBookContext = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
        }
      }

      const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
      const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
      const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
      const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
      const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
      const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

      let multiLayeredSummaryContext = '';
      if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
        multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
        if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
        if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
        if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
        if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
        if (summaryToday) multiLayeredSummaryContext += summaryToday;
        if (summary3Days) multiLayeredSummaryContext += summary3Days;
        if (summary7Days) multiLayeredSummaryContext += summary7Days;
      }
      const stickerContext = getStickerContextForPrompt(chat);
      const systemPrompt = `
# 你的核心任务
你正在扮演角色“${chat.originalName}”。用户刚刚在TA的手机（CPhone）上点击了一个按钮，希望你能继续你们之前的对话。你的任务是根据上下文，生成【3到5条】符合你人设的、简短的、连续的新回复。

# 输出格式铁律 (最高优先级)
- 你的回复【必须】是一个JSON数组，每个对象代表一条消息。
- 格式: \`[{"type": "text", "content": "第一句话"}, {"type": "text", "content": "第二句话"}, {"type": "sticker", "meaning": "表情的含义(从可用表情列表选择)"}]\`
- 你可以自由组合使用 "text", "sticker", "ai_image", "voice_message" 等多种消息类型。
请根据当前情景和你的情绪，从列表中【选择一个最合适的】表情含义来使用 "sticker" 指令。尽量让你的表情丰富多样，避免重复。
# 你的角色设定
${chat.settings.aiPersona}
# 可用表情包 (必须严格遵守！)
- 当你需要发送表情时，你【必须】从下面的列表中【精确地选择一个】含义（meaning）。
- 【绝对禁止】使用任何不在列表中的表情含义！
${stickerContext}

# 你的聊天对象（用户）的人设
${userPersona}  

# 供你参考的上下文
- **你的本名**: "${chat.originalName}"
- **用户的备注**: "${myNickname}"
${worldBookContext}
${longTermMemoryContext}
${multiLayeredSummaryContext} 
- **你们最后的对话**:
${historySlice.map(msg => `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`).join('\n')}

现在，请继续这场对话。
`;


      const messagesPayload = filteredHistory.map(msg => ({
        role: msg.role,
        content: `${msg.role === 'user' ? myNickname : chat.name}: ${String(msg.content)}`
      }));

      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesPayload],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) {
        throw new Error(`API 请求失败: ${(await response.json()).error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const messagesArray = parseAiResponse(aiResponseContent);

      if (!messagesArray || messagesArray.length === 0) {
        throw new Error("AI返回了空内容。");
      }

      let newMessagesCount = 0;
      let messageTimestamp = Date.now();
      for (const msgData of messagesArray) {
        const baseMessage = {
          role: 'assistant',
          senderName: chat.originalName,
          timestamp: messageTimestamp++
        };
        let aiMessage = null;
        switch (msgData.type) {
          case 'text':
            aiMessage = {
              ...baseMessage,
              content: String(msgData.content || msgData.message)
            };
            break;
          case 'sticker':
            if (msgData.meaning) {
              const sticker = findBestStickerMatch(msgData.meaning, state.userStickers);
              if (sticker) {
                aiMessage = {
                  ...baseMessage,
                  type: 'sticker',
                  content: sticker.url,
                  meaning: sticker.name
                };
              } else {
                console.warn(`AI (CPhone) 尝试使用一个不存在的表情: "${msgData.meaning}"`);
                aiMessage = null;
              }
            } else {
              console.warn("AI (CPhone) 发送了一个没有 'meaning' 的 sticker 指令。", msgData);
              aiMessage = {
                ...baseMessage,
                type: 'sticker',
                content: msgData.url,
                meaning: '未知表情'
              };
            }
            break;
        }
        if (aiMessage) {
          chat.history.push(aiMessage);
          newMessagesCount++;
        }
      }

      if (newMessagesCount > 0) {
        chat.unreadCount = (chat.unreadCount || 0) + newMessagesCount;
      }

      await db.chats.put(chat);
      await renderChatList();

      if (newMessagesCount > 0) {
        showNotification(chat.id, `发来了 ${newMessagesCount} 条新消息`);
      }

    } catch (error) {
      console.error("从CPhone推进真实对话失败:", error);
      await showCustomAlert('操作失败', `无法生成新回复: ${error.message}`);
    }
  }
 
  async function loadMoreMirroredMessages() {
    if (isLoadingMoreCphoneMessages || !activeCharacterId) return;
    isLoadingMoreCphoneMessages = true;

    const messagesContainer = document.getElementById('char-conversation-messages');
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) {
      isLoadingMoreCphoneMessages = false;
      return;
    }

    showLoader(messagesContainer, 'top');
    const oldScrollHeight = messagesContainer.scrollHeight;


    await new Promise(resolve => setTimeout(resolve, 500));

    const totalMessages = mainChar.history.length;
    const renderWindow = state.globalSettings.chatRenderWindow || 50;
    const nextSliceEnd = totalMessages - cphoneRenderedCount;
    const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);

    const messagesToPrepend = mainChar.history.slice(nextSliceStart, nextSliceEnd);


    hideLoader(messagesContainer);

    if (messagesToPrepend.length === 0) {
      isLoadingMoreCphoneMessages = false;
      return;
    }


    for (const msg of messagesToPrepend.reverse()) {
      const mirroredMsg = {
        ...msg,
        role: msg.role === 'user' ? 'assistant' : 'user'
      };


      const tempChatObjectForRendering = {
        id: 'temp_user_chat_mirror',
        isGroup: false,
        name: mainChar.name,
        settings: {
          ...mainChar.settings,
          myAvatar: mainChar.settings.aiAvatar,
          myAvatarFrame: mainChar.settings.aiAvatarFrame,
          aiAvatar: mainChar.settings.myAvatar,
          aiAvatarFrame: mainChar.settings.myAvatarFrame
        }
      };

      const messageEl = await createMessageElement(mirroredMsg, tempChatObjectForRendering);
      if (messageEl) {
        messagesContainer.prepend(messageEl);
      }
    }

    cphoneRenderedCount += messagesToPrepend.length;


    const newScrollHeight = messagesContainer.scrollHeight;
    messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

    isLoadingMoreCphoneMessages = false;
  }

  async function openCharSimulatedConversation(conversationIndex) {
    const mainChar = state.chats[activeCharacterId];
    if (!mainChar) return;

    cphoneActiveConversationType = (conversationIndex === -1) ? 'private_user' : mainChar.simulatedConversations[conversationIndex]?.type;

    const bodyEl = document.getElementById('char-conversation-messages');
    bodyEl.innerHTML = '';
    bodyEl.dataset.theme = mainChar.settings.theme || 'default';
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
    bodyEl.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';

    let tempChatObjectForRendering;
    let messagesToRender = [];
    const allNpcs = await db.npcs.toArray();
    const npcMap = new Map(allNpcs.map(npc => [npc.name, npc])); 

    if (conversationIndex === -1) {

      cphoneActiveConversationType = 'private_user';
      const titleEl = document.getElementById('char-conversation-partner-name');
    
      const inputEl = document.getElementById('char-simulated-input');

      bodyEl.innerHTML = '';
      titleEl.textContent = mainChar.settings.myNickname || (state.qzoneSettings.nickname || '我');
      inputEl.placeholder = `与 ${mainChar.settings.myNickname || '我'} 的对话 (只读)`;

      cphoneRenderedCount = 0;
      isLoadingMoreCphoneMessages = false;

      const history = mainChar.history;
      const renderWindow = state.globalSettings.chatRenderWindow || 50;
      const initialMessages = history.slice(-renderWindow);

      tempChatObjectForRendering = {
        id: 'temp_user_chat_mirror',
        isGroup: false,
        name: mainChar.name,
        settings: {
          ...mainChar.settings,
          myAvatar: mainChar.settings.aiAvatar,
          myAvatarFrame: mainChar.settings.aiAvatarFrame,
          aiAvatar: mainChar.settings.myAvatar,
          aiAvatarFrame: mainChar.settings.myAvatarFrame
        }
      };

      messagesToRender = initialMessages.map(msg => ({
        ...msg,
        role: msg.role === 'user' ? 'assistant' : 'user'
      }));
      cphoneRenderedCount = initialMessages.length;

    } else {

      const conversation = mainChar.simulatedConversations[conversationIndex];
      if (!conversation) return;
      cphoneActiveConversationType = conversation.type;

      const titleEl = document.getElementById('char-conversation-partner-name');
   
      const inputEl = document.getElementById('char-simulated-input');

      if (conversation.type === 'group') {
        titleEl.textContent = `${conversation.groupName} (${conversation.participants.length + 1})`;
        inputEl.placeholder = `在 ${conversation.groupName} 中聊天`;
        tempChatObjectForRendering = {
          id: 'temp_group_chat',
          isGroup: true,
          name: conversation.groupName,
          originalName: mainChar.originalName,
          members: conversation.participants.map(p => {
            const npcData = npcMap.get(p.name);
            let avatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
              (state.globalSettings.enableAiDrawing ?
                `https://image.pollinations.ai/prompt/${encodeURIComponent(p.avatar_prompt || 'anime person')}` :
                defaultGroupMemberAvatar);
            return {
              originalName: p.name,
              groupNickname: p.name,
              avatar: avatarUrl
            };
          }),
          settings: {
            ...mainChar.settings,
            myNickname: mainChar.name,
            myAvatar: mainChar.settings.aiAvatar,
            myAvatarFrame: mainChar.settings.aiAvatarFrame,
          }
        };
      } else {
        titleEl.textContent = conversation.participant.name;
        inputEl.placeholder = `与 ${conversation.participant.name} 的对话`;
        const npcData = npcMap.get(conversation.participant.name);
        const npcAvatarUrl = (npcData && npcData.avatar) ? npcData.avatar :
          (state.globalSettings.enableAiDrawing ?
            `https://image.pollinations.ai/prompt/${encodeURIComponent(conversation.participant.avatar_prompt || 'anime person')}` :
            defaultGroupMemberAvatar);
        tempChatObjectForRendering = {
          id: 'temp_npc_chat',
          isGroup: false,
          name: conversation.participant.name,
          originalName: mainChar.originalName,
          settings: {
            ...mainChar.settings,
            myAvatar: mainChar.settings.aiAvatar,
            myAvatarFrame: mainChar.settings.aiAvatarFrame,
            aiAvatar: npcAvatarUrl,
            aiAvatarFrame: ''
          }
        };
      }
      messagesToRender = conversation.messages; 
    }


    
    for (const msg of messagesToRender) {
      let role = msg.role; 
      if (conversationIndex !== -1) {
        const isFromMainChar = msg.sender === (mainChar.originalName || mainChar.name);
        role = isFromMainChar ? 'user' : 'assistant';
      }

      const tempMessageObject = {
        role: role,
        senderName: msg.sender || (role === 'user' ? tempChatObjectForRendering.settings.myNickname : tempChatObjectForRendering.name),
        timestamp: msg.timestamp || (Date.now() + Math.random())
      };


      if (msg.type === 'sticker' && msg.meaning) {

        const sticker = state.userStickers.find(s => s.name === msg.meaning);
        if (sticker) {
          tempMessageObject.content = sticker.url;
          tempMessageObject.meaning = msg.meaning;
          tempMessageObject.type = 'sticker';
        } else {

          console.warn(`模拟表情含义 "${msg.meaning}" 在库中未找到。`);
          tempMessageObject.content = `[表情: ${msg.meaning}]`;
          tempMessageObject.type = 'text';
        }
      } else {

        tempMessageObject.content = msg.content;
        tempMessageObject.type = msg.type || 'text';
      }

      const bubbleElement = await createMessageElement(tempMessageObject, tempChatObjectForRendering);
      if (bubbleElement) {
        bodyEl.appendChild(bubbleElement);
      }
    }

    switchToCharScreen('char-qq-conversation-screen');
    setTimeout(() => bodyEl.scrollTop = bodyEl.scrollHeight, 0); // 渲染完成后滚动到底部
  }

  function closeSimulatedTranscriptModal() {
    document.getElementById('char-qq-transcript-modal').classList.remove('visible');
  }


 
  async function handleGenerateSimulatedAlbum() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];

    if (!chat) {
      await showCustomAlert("操作失败", "无法找到当前角色的数据。");
      return;
    }

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”回忆TA的相册照片...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('请先在API设置中配置好API信息。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e=>e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，构思出【8到10张】TA最近可能会拍摄或珍藏在手机相册里的照片。

# 核心规则
1.  **创造性与合理性**: 照片内容必须完全符合角色的性格、爱好、职业和生活环境。
2.  **多样性**: 照片主题要丰富，可以包括自拍、风景、食物、宠物、朋友合影、工作场景等。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一张照片，格式【必须】如下:
    \`\`\`json
    [
      {
        "description": "这是照片背后的故事或角色的心情日记，必须使用第一人称“我”来写。",
        "image_prompt": "一段用于生成这张照片的、详细的【英文】关键词。"
      }
    ]
    \`\`\`
    - **【image_prompt 绝对禁止】**: 绝对禁止包含任何中文字符、句子、特殊符号、或任何可能涉及敏感（NSFW）、暴力、血腥、政治的内容！也禁止真人！
    - **【image_prompt 必须是】**: 必须是纯英文的、用逗号分隔的【关键词组合】 (e.g., "1boy, solo, basketball jersey, in locker room, smiling, selfie")。
    - **【画风指令】**: 在 prompt 的末尾，总是加上画风指令，例如： \`best quality, masterpiece, anime style, cinematic lighting\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组照片的描述和绘画指令。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的相册内容。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9

          })
        });


      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedAlbumData;
      try {
        simulatedAlbumData = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


      chat.simulatedAlbum = simulatedAlbumData;
      await db.chats.put(chat);

      await renderCharAlbum();

    } catch (error) {
      console.error("生成模拟相册失败:", error);
      await showCustomAlert("生成失败", `无法生成模拟相册，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }



 
  async function renderCharAlbum() {
    const gridEl = document.getElementById('char-album-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterId) return;
    const char = state.chats[activeCharacterId];

    const photos = char.simulatedAlbum || [];

    if (photos.length === 0) {
      gridEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的相册还是空的，<br>点击右上角刷新按钮生成一些照片吧！</p>';
      return;
    }

    const fallbackImageUrl = `https://i.postimg.cc/KYr2qRCK/1.jpg`;

    photos.forEach(photo => {
      const item = document.createElement('div');
      item.className = 'char-photo-item';
      item.dataset.description = photo.description;
      gridEl.appendChild(item);







      if (state.globalSettings.enableAiDrawing) {

        item.style.backgroundColor = '#e9ecef';
        const containsNonEnglish = /[^\x00-\x7F]/.test(photo.image_prompt);
        const isValidPrompt = photo.image_prompt && photo.image_prompt.trim() && !containsNonEnglish;
        const finalPrompt = isValidPrompt ? photo.image_prompt : 'a beautiful scenery, anime style, cinematic lighting';
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}`;

        const img = new Image();
        img.onload = function() {
          item.style.backgroundImage = `url(${this.src})`;
        };
        img.onerror = function() {
          item.style.backgroundImage = `url(${fallbackImageUrl})`;
        };
        img.src = imageUrl;

      } else {

        item.style.backgroundColor = '#f0f2f5';
        item.style.border = '1px solid #e0e0e0';

        const descriptionEl = document.createElement('p');
        descriptionEl.className = 'char-photo-description';
        descriptionEl.textContent = photo.description || '(这张照片没有描述)';

        item.appendChild(descriptionEl);
      }
    });
  }


  async function handleGenerateBrowserHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在模拟“${chat.name}”的网上冲浪足迹...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成内容。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistoryWithUser = chat.history.slice(-maxMemory).map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const userPersona = chat.settings.myPersona || '(未设置)';
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【10到20条】TA最近的浏览器搜索/浏览记录。

# 核心规则
1.  **创造性与合理性**: 记录必须完全符合角色的性格、爱好、职业和生活环境。
2.  **多样性**: 记录类型要丰富，可以是帖子、文章、新闻、问答等。
3.  **【格式 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都代表一条浏览记录，并且【必须】使用以下格式:
    \`\`\`json
    [
      {
        "type": "text",
        "title": "精炼且吸引人的标题 (不超过20字)",
        "url": "www.example.com/article/123 (看起来像真实的简洁网址)",
        "content": "一篇200-400字的、分段良好的文章正文，使用\\n换行。"
      }
    ]
    \`\`\`
    
    **【绝对禁止】**: 你的回复中【绝对不能】包含 "type": "image" 的对象。所有记录都必须是文字内容。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- ** 你的聊天对象（用户）的人设**:${userPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组【纯文本】的浏览记录。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的浏览器记录。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9

          })
        });


      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedHistory;
      try {
        simulatedHistory = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


      chat.simulatedBrowserHistory = simulatedHistory;
      await db.chats.put(chat);

      await renderCharBrowserHistory();

    } catch (error) {
      console.error("生成模拟浏览器历史失败:", error);
      await showCustomAlert("生成失败", `无法生成浏览记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }

  function renderCharBrowserHistory() {
    const listEl = document.getElementById('char-browser-history');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedBrowserHistory || [];

    if (history.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的浏览器空空如也，<br>点击右上角刷新按钮生成一些记录吧！</p>';
      return;
    }

    history.forEach((item, index) => {
      const entryEl = document.createElement('div');
      entryEl.className = 'char-browser-item';
      entryEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="url">${item.url}</div>
        `;

      entryEl.addEventListener('click', () => openCharArticle(index));
      listEl.appendChild(entryEl);
    });
  }



  async function openCharArticle(index) {
    const char = state.chats[activeCharacterId];
    const articleData = char.simulatedBrowserHistory[index];
    if (!articleData) return;



    activeArticleForViewing = articleData;


    renderCharArticle(articleData);
    switchToCharScreen('char-browser-article-screen');



    const favBtn = document.getElementById('favorite-article-btn');

    const existingFavorite = await db.favorites.where({
      type: 'char_browser_article',
      'content.url': articleData.url
    }).first();
    favBtn.classList.toggle('active', !!existingFavorite);

  }


  async function toggleBrowserArticleFavorite() {
    if (!activeArticleForViewing || !activeCharacterId) return;

    const article = activeArticleForViewing;
    const char = state.chats[activeCharacterId];
    const favBtn = document.getElementById('favorite-article-btn');


    const existingFavorite = await db.favorites.where({
      type: 'char_browser_article',
      'content.url': article.url
    }).first();

    if (existingFavorite) {

      await db.favorites.delete(existingFavorite.id);
      favBtn.classList.remove('active');
      await showCustomAlert('操作成功', '已取消收藏。');
    } else {

      const newFavorite = {
        type: 'char_browser_article',

        content: {
          ...article,
          characterId: activeCharacterId,
          characterName: char.name
        },
        timestamp: Date.now()
      };
      await db.favorites.add(newFavorite);
      favBtn.classList.add('active');
      await showCustomAlert('操作成功', '已成功收藏到“我的收藏”页面！');
    }
  }
 
  function renderCharArticle(articleData) {
    const titleEl = document.getElementById('char-article-title'); // 顶部导航栏的小标题
    const contentEl = document.getElementById('char-article-content'); // 内容区域

    // 导航栏只显示来源或简略标题
    let navTitle = "网页浏览";
    if (articleData.url) {
        // 尝试从 URL 提取域名作为导航标题
        try {
            const urlObj = new URL(articleData.url.startsWith('http') ? articleData.url : `http://${articleData.url}`);
            navTitle = urlObj.hostname.replace('www.', '');
        } catch (e) {
            navTitle = articleData.title.substring(0, 10) + '...';
        }
    }
    titleEl.textContent = navTitle;
    
    contentEl.innerHTML = '';

    if (articleData.type === 'image') {
        // 图片类型的文章
        contentEl.innerHTML = `
            <div class="char-browser-image-description">
                <div style="font-size: 40px; margin-bottom: 20px; opacity: 0.5;">🖼️</div>
                ${articleData.title || '(无标题图片)'}
            </div>`;
    } else {
        // 文本类型的文章
        const largeTitle = `<div class="article-large-title">${articleData.title}</div>`;
        
        // 处理正文换行，包裹在 p 标签中
        const paragraphs = (articleData.content || '内容加载失败...')
            .split('\n')
            .filter(line => line.trim() !== '') // 过滤空行
            .map(line => `<p>${line}</p>`)
            .join('');

        contentEl.innerHTML = `
            ${largeTitle}
            <div class="article-body">
                ${paragraphs}
            </div>
        `;
    }
}





  async function handleGenerateTaobaoHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在模拟“${chat.name}”的购物习惯...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成内容。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出TA最近的淘宝购物记录和账户余额。

# 核心规则
1.  **余额铁律 (最高优先级)**: 你【必须】根据角色的【经济状况】设定一个合理的 \`totalBalance\` (总余额)。例如，富有的角色应该有更高的余额，而学生或经济拮据的角色则应该有较低的余额。
2.  **合理性**: 购买记录必须完全符合角色的性格、爱好和经济状况。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个【单一的JSON对象】。
    - 你的回复必须以 \`{\` 开始，并以 \`}\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记。
    - 格式【必须】如下:
    \`\`\`json
    {
      "totalBalance": 12345.67, // (这是一个示例数字，你必须根据角色的经济状况生成一个全新的、合理的余额！)
      "purchases": [
        {
          "itemName": "一个具体、生动的商品名称",
          "price": 128.80,
          "status": "已签收",
          "reason": "这是角色购买这件商品的内心独白或理由，必须使用第一人称“我”来写。",
          "image_prompt": "一段用于生成这张商品图片的、详细的【英文】关键词, 风格为 realistic product photo, high quality, on a clean white background"
        }
      ]
    }
    \`\`\`
    - **purchases**: 一个包含12到15个商品对象的数组。
    - **status (订单状态)**: 只能从 "已签收", "待发货", "运输中", "待评价" 中选择。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext} 
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请生成包含总余额和购买记录的JSON对象。`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的淘宝购买记录和余额。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
      if (!jsonMatch) throw new Error("AI返回的内容中未找到有效的JSON对象。");
      const simulatedTaobaoData = JSON.parse(jsonMatch[0]);


      if (!simulatedTaobaoData.purchases) {
        simulatedTaobaoData.purchases = [];
      }

      chat.simulatedTaobaoHistory = simulatedTaobaoData;
      await db.chats.put(chat);

      await renderCharTaobao();

    } catch (error) {
      console.error("生成模拟淘宝记录失败:", error);
      await showCustomAlert("生成失败", `无法生成购物记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }


 
  function openCharWallet() {
    renderCharWallet();
    switchToCharScreen('char-wallet-screen');
  }


  async function renderCharWallet() {
    const contentEl = document.getElementById('char-wallet-content');
    contentEl.innerHTML = '';
    
    // 获取当前角色信息
    const char = state.chats[activeCharacterId];
    const history = char.simulatedTaobaoHistory || {};
    const purchases = history.purchases || [];
    const totalBalance = history.totalBalance || 0;

    // 1. 显示账户余额卡片
    const summaryCard = document.createElement('div');
    summaryCard.style.cssText = `
        background-color: #fff;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    `;
    summaryCard.innerHTML = `
        <p style="color: #8a8a8a; margin: 0 0 10px 0;">账户余额</p>
        <p style="font-size: 32px; font-weight: 600; color: #1f1f1f; margin: 0;">¥${totalBalance.toFixed(2)}</p>
    `;
    contentEl.appendChild(summaryCard);

    // 2. 显示亲属卡 (修复名字 + 增加解绑)
    try {
        const myWallet = await db.userWallet.get('main');
        const kinshipCard = myWallet?.kinshipCards?.find(c => c.chatId === activeCharacterId);

        if (kinshipCard) {
            // 【修复名字逻辑】优先使用聊天设置里的昵称，其次是动态昵称，最后是“我”
            const myNicknameInChat = char.settings.myNickname || state.qzoneSettings.nickname || '我';

            const cardDiv = document.createElement('div');
            // 样式：红色背景卡片，增加 relative 定位以便放置解绑按钮
            cardDiv.style.cssText = `
                background: linear-gradient(135deg, #ff5252, #ff1744); 
                color: white; 
                padding: 15px; 
                border-radius: 12px; 
                margin-bottom: 20px; 
                box-shadow: 0 4px 10px rgba(255,82,82,0.3); 
                display: flex; 
                flex-direction: column; 
                gap: 5px;
                position: relative; 
            `;
            
            const remaining = kinshipCard.limit - (kinshipCard.spent || 0);
            
            cardDiv.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="font-size:14px; opacity:0.9; font-weight:500;">${myNicknameInChat} 赠送的亲属卡</div>
                    <div style="font-size:12px; opacity:0.8;">支付宝</div>
                </div>
                <div style="font-size:28px; font-weight:bold; margin:10px 0; font-family: 'DIN Alternate', sans-serif;">¥ ${remaining.toFixed(2)}</div>
                <div style="font-size:12px; opacity:0.8; display:flex; justify-content:space-between;">
                    <span>本月可用额度</span>
                    <span>总额 ¥${kinshipCard.limit}</span>
                </div>
                
                <!-- 解绑按钮 -->
                <button class="unbind-kinship-btn" data-chat-id="${activeCharacterId}" style="
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(255,255,255,0.2);
                    border: 1px solid rgba(255,255,255,0.4);
                    color: white;
                    font-size: 11px;
                    padding: 2px 8px;
                    border-radius: 10px;
                    cursor: pointer;
                    backdrop-filter: blur(2px);
                ">解绑</button>
            `;
            contentEl.appendChild(cardDiv);
        }
    } catch (e) {
        console.error("渲染亲属卡失败:", e);
    }

    // 3. 显示最近支出
    const detailsTitle = document.createElement('h3');
    detailsTitle.textContent = '最近支出';
    detailsTitle.style.cssText = `font-size: 16px; color: #555; margin-bottom: 10px;`;
    contentEl.appendChild(detailsTitle);

    if (purchases.length === 0) {
      contentEl.innerHTML += '<p style="text-align:center; color: var(--text-secondary);">暂无支出记录。</p>';
    } else {
        purchases.forEach(item => {
          const itemEl = document.createElement('div');
          itemEl.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px 0;
                border-bottom: 1px solid #f0f0f0;
            `;
          itemEl.innerHTML = `
                <div>
                    <p style="font-weight: 500; margin: 0 0 4px 0;">${item.itemName}</p>
                    <p style="font-size: 12px; color: #8a8a8a; margin: 0;">${item.status}</p>
                </div>
                <div style="font-weight: 600; font-size: 16px; color: #ff5722;">- ¥${(item.price || 0).toFixed(2)}</div>
            `;
          contentEl.appendChild(itemEl);
        });
    }
}




 
  async function handleGenerateSimulatedMemos() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”分享TA的备忘录...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('请先在API设置中配置好API信息。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }
    const userPersona = chat.settings.myPersona || '(未设置)';
    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【12到20条】TA最近可能会写在手机备忘录里的内容。

# 核心规则
1.  **创造性与合理性**: 备忘录内容必须完全符合角色的性格、爱好、职业和生活环境。可以是购物清单、待办事项、灵感片段、一些随笔和感悟、草稿等。
2.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一条备忘录，格式【必须】如下:
    \`\`\`json
    [
      {
        "title": "备忘录的标题，例如：购物清单 或 周末计划",
        "content": "备忘录的详细内容，必须支持换行符\\n。"
      }
    ]
    \`\`\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- ** 你的聊天对象（用户）的人设**:${userPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组备忘录。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的备忘录内容。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
          
          })
        });


      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        const errorMessage = errorData?.error?.message || response.statusText;
        throw new Error(`API 错误: ${response.status} - ${errorMessage}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedMemos;
      try {
        simulatedMemos = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


      if (!Array.isArray(simulatedMemos)) {
        throw new Error(`AI返回的数据不是一个数组。原始返回: ${JSON.stringify(simulatedMemos)}`);
      }

      chat.memos = simulatedMemos.map(memo => ({
        id: Date.now() + Math.random(),
        title: memo.title,
        content: memo.content
      }));

      await db.chats.put(chat);
      await renderCharMemoList();

    } catch (error) {
      console.error("生成模拟备忘录失败:", error);
      await showCustomAlert("生成失败", `无法生成备忘录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }

 
  async function handleGenerateAmapHistory() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在生成“${chat.name}”的出行足迹...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成内容。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出【12到20条】TA最近的“高德地图”出行足迹。

# 核心规则
1.  **【时间 (最高优先级)】**:
    -   今天的日期是 **${new Date().toISOString()}**。
    -   你生成的【所有】足迹的 \`timestamp\` 字段，【必须】是今天或今天以前的日期。
    -   【绝对禁止】生成任何未来的日期！
    -   请生成一个看起来像是过去几周内的、时间【从新到旧】排列的足迹列表。
2.  **创造性与合理性**: 足迹必须完全符合角色的性格、爱好、职业和生活环境。
3.  **多样性**: 地点类型要丰富，可以包括餐厅、商场、公园、公司、朋友家等。
4.  **【格式铁律 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一条足迹，格式【必须】如下:
    \`\`\`json
    [
      {
        "locationName": "一个具体、生动的地点名称",
        "address": "一个虚构但看起来很真实的详细地址",
        "comment": "这是角色对这次出行或这个地点的内心独白或评论，必须使用第一人称“我”来写。",
        "image_prompt": "(可选)一段用于生成这张地点照片的、详细的【英文】关键词, 风格为 realistic photo, high quality",
        "timestamp": "符合 ISO 8601 格式的日期时间字符串 (例如: '2025-09-25T18:30:00Z')"
      }
    ]
    \`\`\`
    - **重要**: 大约有【三分之一】的足迹需要包含 \`image_prompt\` 字段来生成一张照片。
    - **图片**: image_prompt 生成的图片【绝对禁止包含真人】。如果地点是室内，可以生成空无一人的场景；如果是室外，可以只有风景或建筑。

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组足迹记录。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的高德地图足迹。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
           
          })
        });


      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);


      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch || !jsonMatch[0]) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const cleanedJsonString = jsonMatch[0];
      let simulatedAmapData;
      try {
        simulatedAmapData = JSON.parse(cleanedJsonString);
      } catch (e) {
        throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


      chat.simulatedAmapHistory = simulatedAmapData;
      await db.chats.put(chat);

      await renderCharAmap();

    } catch (error) {
      console.error("生成模拟足迹失败:", error);
      await showCustomAlert("生成失败", `无法生成足迹，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }


  function renderCharAmap() {
    const listEl = document.getElementById('char-amap-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const history = char.simulatedAmapHistory || [];

    if (history.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有留下任何足迹，<br>点击右上角刷新按钮生成一些记录吧！</p>';
      return;
    }


    history.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-amap-item';

      let photoHtml = '';
      if (item.image_prompt) {
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
        photoHtml = `<div class="amap-item-photo" style="background-image: url('${imageUrl}')" data-comment="${item.comment}"></div>`;
      }

      // 使用我们之前创建的 formatTimeAgo 函数来格式化时间
      const timeAgo = item.timestamp ? formatTimeAgo(new Date(item.timestamp).getTime()) : '某个时间';

      itemEl.innerHTML = `
                    <div class="amap-item-header">
                        <div class="amap-item-icon">📍</div>
                        <div class="amap-item-info">
                            <div class="amap-item-title">${item.locationName}</div>
                            <div class="amap-item-address">${item.address}</div>
                        </div>
                    </div>
                    <div class="amap-item-body">
                        <div class="amap-item-comment">${item.comment.replace(/\n/g, '<br>')}</div>
                        ${photoHtml}
                    </div>
                    <div class="amap-item-footer">${timeAgo}</div>
                `;
      listEl.appendChild(itemEl);
    });

  }


 
  async function handleGenerateAppUsage() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在分析“${chat.name}”的手机使用习惯...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成内容。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
    const summary3Hours = generateSummaryForTimeframe(chat, 3, 'hours');
    const summary6Hours = generateSummaryForTimeframe(chat, 6, 'hours');
    const summary9Hours = generateSummaryForTimeframe(chat, 9, 'hours');
    const summaryToday = generateSummaryForTimeframe(chat, 1, 'days');
    const summary3Days = generateSummaryForTimeframe(chat, 3, 'days');
    const summary7Days = generateSummaryForTimeframe(chat, 7, 'days');

    let multiLayeredSummaryContext = '';
    if (summary3Hours || summary6Hours || summary9Hours || summaryToday || summary3Days || summary7Days) {
      multiLayeredSummaryContext += `\n# 智能总结 (基于不同时间维度的对话回顾)\n`;
      if (summary3Hours) multiLayeredSummaryContext += summary3Hours;
      if (summary6Hours) multiLayeredSummaryContext += summary6Hours;
      if (summary9Hours) multiLayeredSummaryContext += summary9Hours;
      if (summary3Hours || summary6Hours || summary9Hours) multiLayeredSummaryContext += '\n';
      if (summaryToday) multiLayeredSummaryContext += summaryToday;
      if (summary3Days) multiLayeredSummaryContext += summary3Days;
      if (summary7Days) multiLayeredSummaryContext += summary7Days;
    }

    const systemPrompt = `
# 你的任务
你是一个虚拟生活模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，虚构出TA最近一天的【手机App屏幕使用时间】记录，总共约20条。

# 核心规则
1.  **创造性与多样性**: 生成的App列表【不必局限于】Cphone主屏幕上已有的App。你可以自由地虚构TA可能使用的其他App，例如 Instagram, Twitter, 各种游戏 (如：原神, 王者荣耀), 视频App (如：抖音, YouTube), 学习或工作软件等，这能更好地体现角色的隐藏兴趣和生活习惯。
2.  **合理性**: 使用时长和App类型必须完全符合角色的性格、爱好、职业和生活环境。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一个App的使用记录，格式【必须】如下:
    \`\`\`json
    [
      {
        "appName": "App的名称 (例如: 微信, 微博, 原神)",
        "usageTimeMinutes": 125,
        "category": "App的分类 (例如: 社交, 游戏, 影音, 工具, 阅读, 购物)",
        "image_prompt": "一段用于生成这个App【图标】的、简洁的【英文】关键词。风格必须是 modern app icon, flat design, simple, clean background"
      }
    ]
    \`\`\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
${multiLayeredSummaryContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请开始生成这组App使用记录。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的App使用记录。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9
            // response_format: { "type": "json_object" } <-- 此行已被删除
          })
        });


      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');

      const simulatedUsageData = JSON.parse(cleanedJson);

      chat.simulatedAppUsage = simulatedUsageData;
      await db.chats.put(chat);

      await renderCharAppUsage();

    } catch (error) {
      console.error("生成模拟App使用记录失败:", error);
      await showCustomAlert("生成失败", `无法生成记录，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }

  function renderCharAppUsage() {
    const listEl = document.getElementById('char-usage-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const usageData = (char.simulatedAppUsage || []).sort((a, b) => b.usageTimeMinutes - a.usageTimeMinutes);

    if (usageData.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有任何使用记录，<br>点击右上角刷新按钮生成一些吧！</p>';
      return;
    }

    usageData.forEach(item => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-usage-item';

      const hours = Math.floor(item.usageTimeMinutes / 60);
      const minutes = item.usageTimeMinutes % 60;
      let timeString = '';
      if (hours > 0) timeString += `${hours}小时`;
      if (minutes > 0) timeString += `${minutes}分钟`;
      if (!timeString) timeString = '小于1分钟';

      const prompt = item.image_prompt || `modern app icon for ${item.appName}, flat design, simple`;

      const iconUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}`;


      itemEl.innerHTML = `
                    <img src="${iconUrl}" class="usage-item-icon">
                    <div class="usage-item-info">
                        <div class="usage-item-name">${item.appName}</div>
                        <div class="usage-item-category">${item.category}</div>
                    </div>
                    <div class="usage-item-time">${timeString}</div>
                `;
      listEl.appendChild(itemEl);
    });
  }


async function handleGenerateSimulatedBilibili() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在结合世界观与人设，分析“${chat.name}”的B站兴趣...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    // 1. 准备上下文
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;
    
    // 2. 准备记忆和世界观
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    
    // 3. 准备世界书
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '无';

    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');
 
    const userPersona = chat.settings.myPersona || '(未设置)';
 
    // 4. 构建 Prompt：核心改变是让 AI 生成关键词，而不是假数据
    const systemPrompt = `
# 你的任务
你是一个虚拟用户画像分析师。你的任务是扮演角色“${chat.name}”，根据TA的人设、所处的世界观、长期记忆、以及与用户（${userDisplayNameForAI}）的关系，**推测TA现在最想在 Bilibili (B站) 上搜索或观看的视频关键词**。

# 核心规则
1.  **深度人设绑定**: 关键词必须紧扣角色的性格、职业、爱好以及**世界观设定**。
    - 例如：如果世界书里设定了“魔法”，角色可能会搜“火球术教学”；如果是“末世”，可能会搜“生存指南”。
2.  **关系导向**: 如果用户人设是你喜欢的人，你可能会搜“给喜欢的人送什么礼物”；如果是死对头，可能会搜“如何优雅地怼人”。必须逻辑自洽。
3.  **多样性**: 请生成 **10到12个** 具体的搜索关键词。
4.  **具体性**: 关键词最好具体一点。
5.  **格式铁律**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 数组中的每个元素都是一个**字符串** (即搜索关键词)。
    - 示例: \`["关键词1", "关键词2", "关键词3"...]\`

# 供你参考的详细上下文
- **角色人设**: ${chat.settings.aiPersona}
- **用户(${userDisplayNameForAI})的人设**: ${userPersona} 
- **长期记忆**: 
${longTermMemoryContext}
${worldBookContext} 
- **最近对话**:
${recentHistoryWithUser}

现在，请结合以上所有信息，生成这组搜索关键词。`;

    try {
        const messagesForApi = [{ role: 'user', content: "请生成B站搜索关键词列表。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    temperature: state.globalSettings.apiTemperature || 1.0,
                })
            });

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        const keywords = JSON.parse(cleanedJson);

        if (!Array.isArray(keywords)) throw new Error("AI没有返回数组格式的关键词。");

        await showCustomAlert("请稍候...", `AI已结合世界观生成 ${keywords.length} 个关键词，正在逐个搜索B站视频 (为防封禁，速度会稍慢)...`);

        // 定义延时函数，防止请求太快被B站接口封IP
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        const results = [];
        
        // 5. 遍历关键词，调用真实的搜索接口
        for (const [index, keyword] of keywords.entries()) {
            let retryCount = 0; // 当前关键词的重试次数
            let success = false; // 是否成功标记
            const maxRetries = 5; // 最大重试次数，防止死循环

            // 使用 while 循环，直到成功或超过最大重试次数
            while (!success && retryCount < maxRetries) {
                try {
                    // 如果是重试，打印日志提示
                    const retryMsg = retryCount > 0 ? ` (第 ${retryCount} 次重试)` : "";
                    console.log(`[B站搜索 ${index + 1}/${keywords.length}] 正在搜索: ${keyword}${retryMsg}`);
                    
                    // 使用你脚本里原本使用的接口，经过CORS代理
                    const targetUrl = `https://api.52vmy.cn/api/query/bilibili/video?msg=${encodeURIComponent(keyword)}&n=1`;
                    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                    
                    const res = await fetch(proxyUrl);
                    
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const text = await res.text();
                    
                    // --- 修改重点开始：检测限流并重试 ---
                    if (text.includes("访问过快") || text.includes("频繁") || text.includes("Too Many Requests")) {
                         console.warn(`⚠️ 关键词 "${keyword}" 触发限流，等待冷却后重试...`);
                         
                         // 动态等待时间：基础等待 5秒 + 每次重试增加 2秒 (5s, 7s, 9s...)
                         await delay(5000 + (retryCount * 2000)); 
                         
                         retryCount++; // 增加重试计数
                         continue; // 跳过本次 while 循环的剩余部分，重新发起请求
                    }
                    // --- 修改重点结束 ---

                    let json;
                    try { 
                        json = JSON.parse(text); 
                    } catch(e) { 
                        // 如果JSON解析失败（可能是接口报错返回了HTML），也视为失败进行重试
                        console.warn(`JSON解析失败，准备重试: ${keyword}`);
                        retryCount++;
                        await delay(3000);
                        continue; 
                    }
                    
                    // 接口返回格式兼容处理
                    let videoData = null;
                    if (json.data && Array.isArray(json.data) && json.data.length > 0) {
                        videoData = json.data[0]; 
                    } else if (json.code === 200 && json.data) {
                        videoData = Array.isArray(json.data) ? json.data[0] : json.data;
                    } else if (json.title) {
                         videoData = json;
                    }

                    if (videoData && videoData.title && videoData.url) {
                        results.push(videoData);
                    }
                    
                    // 如果代码跑到这里，说明没有触发限流且没有报错，标记成功以退出 while 循环
                    success = true; 

                } catch (e) {
                    console.warn(`搜索关键词 "${keyword}" 发生错误:`, e);
                    // 网络错误也进行重试
                    retryCount++;
                    await delay(3000);
                }
            }

            // 如果超过最大重试次数仍然失败
            if (!success) {
                console.error(`❌ 关键词 "${keyword}" 重试 ${maxRetries} 次后仍然失败，已跳过。`);
            }

            // 关键词之间的正常间隔 (建议稍微调大一点，比如 2000ms，以减少触发限流的概率)
            await delay(1500); 
        }

        // 6. 保存真实数据
        chat.simulatedBilibiliFeed = results;
        await db.chats.put(chat);

        // 7. 渲染界面
        renderCharBilibiliScreen();
        await showCustomAlert("完成", `成功为你生成了 ${results.length} 个符合 ${chat.name} 人设与世界观的视频推荐！`);

    } catch (error) {
        console.error("生成B站推荐失败:", error);
        await showCustomAlert("生成失败", `无法生成推荐内容。\n错误: ${error.message}`);
    }
}
function renderCharBilibiliScreen() {
    const listEl = document.getElementById('char-bilibili-list');
    listEl.innerHTML = '';
    
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    
    // 读取保存的模拟数据
    const videos = chat.simulatedBilibiliFeed || [];

    if (videos.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">首页空空如也，<br>点击右上角刷新按钮获取个性化推荐吧！</p>';
        return;
    }

    videos.forEach(video => {
        const item = document.createElement('div');
        item.className = 'bilibili-item';
        
        // 处理封面图和信息
        // 使用 img 标签配合 no-referrer 来绕过 Safari 的防盗链检查
        item.innerHTML = `
            <div class="bili-cover" style="position: relative; overflow: hidden;">
                <img src="${video.img_url || video.pic}" referrerpolicy="no-referrer" style="width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; z-index: 1;" onerror="this.style.display='none'">
                <div class="bili-duration" style="position: absolute; z-index: 2;">▶</div>
            </div>
            <div class="bili-info">
                <div class="bili-title">${video.title}</div>
                <div class="bili-author">UP: ${video.user || video.author || '未知UP主'}</div>
            </div>
        `;
        
        // 点击播放
        item.onclick = () => playCharBilibiliVideo(video);
        listEl.appendChild(item);
    });
}
  async function handleGenerateSimulatedMusic() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在请求“${chat.name}”分享TA的私人歌单...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('请先在API设置中配置好API信息。');
      return;
    }

    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;

    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》设定:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');


    const systemPrompt = `
# 你的任务
你是一个虚拟音乐品味模拟器。你的任务是扮演角色“${chat.name}”，并根据其人设、记忆和最近的互动，挑选出【14到18首】最能代表TA此刻心情或品味的歌曲。

# 核心规则
1.  **创造性与合理性**: 歌单必须完全符合角色的性格、爱好和生活背景。
2.  **多样性**: 歌曲风格可以多样，但必须逻辑自洽。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一个对象，代表一首歌，格式【必须】如下:
    \`\`\`json
    [
      {
        "songName": "歌曲的准确名称",
        "artistName": "歌曲的准确艺术家/歌手名"
      }
    ]
    \`\`\`

# 供你参考的上下文
- **你的角色设定**: ${chat.settings.aiPersona}
- **你的长期记忆**:
${longTermMemoryContext}
${worldBookContext}
- **你最近和“${userDisplayNameForAI}”的对话摘要**:
${recentHistoryWithUser}

现在，请生成这份歌单。`;


    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据你的设定，生成你的歌单。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);


      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 1.0,
          })
        });


      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
      const songPicks = JSON.parse(cleanedJson);

      await showCustomAlert("请稍候...", `歌单已生成，正在从网络获取 ${songPicks.length} 首歌曲的详细信息...`);

      const songDetailPromises = songPicks.map(async (pick) => {
        let searchResults = await searchNeteaseMusic(pick.songName, pick.artistName);
        if (!searchResults || searchResults.length === 0) {
          searchResults = await searchTencentMusic(pick.songName);
        }
        if (searchResults.length > 0) {
          return getPlayableSongDetails(searchResults[0]);
        }
        console.warn(`所有音乐源都未能找到歌曲：“${pick.songName} - ${pick.artistName}”`);
        return null;
      });

      const fullSongObjects = (await Promise.all(songDetailPromises)).filter(Boolean);

      chat.simulatedMusicPlaylist = fullSongObjects;
      await db.chats.put(chat);

      await renderCharMusicScreen();

    } catch (error) {
      console.error("生成模拟歌单失败:", error);
      await showCustomAlert("生成失败", `无法生成歌单，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }

 
  function renderCharMusicScreen() {
    const listEl = document.getElementById('char-music-list');
    listEl.innerHTML = '';
    if (!activeCharacterId) return;

    const char = state.chats[activeCharacterId];
    const playlist = char.simulatedMusicPlaylist || [];

    if (playlist.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">TA的歌单还是空的，<br>点击右上角刷新按钮生成一些歌曲吧！</p>';
      return;
    }

    playlist.forEach((track, index) => {
      const itemEl = document.createElement('div');
      itemEl.className = 'char-music-item';
      itemEl.innerHTML = `
            <img src="${track.cover}" class="music-item-cover">
            <div class="music-item-info">
                <div class="music-item-name">${track.name}</div>
                <div class="music-item-artist">${track.artist}</div>
            </div>
        `;

      itemEl.addEventListener('click', () => playCharSong(index, playlist));
      listEl.appendChild(itemEl);
    });
  }



  let charPlayerState = {
    currentPlaylist: [],
    currentIndex: -1,
    isPlaying: false,
    playMode: 'order', 
    lrcUpdateInterval: null,
  
    parsedLyrics: [],
    currentLyricIndex: -1
  };

  
  function playCharSong(songIndex, playlist) { 
    const player = document.getElementById('char-audio-player');
    const modal = document.getElementById('char-music-player-modal');

    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();


    charPlayerState.currentPlaylist = playlist; 

    charPlayerState.currentIndex = songIndex; 

    const songObject = playlist[songIndex]; 
    if (!songObject) {
        console.error("playCharSong: 歌曲索引无效或歌单为空。");
        return;
    }

    document.getElementById('char-music-player-title').textContent = songObject.name;
    document.getElementById('char-music-artist').textContent = songObject.artist;
    document.getElementById('char-music-cover').src = songObject.cover;


    charPlayerState.parsedLyrics = parseLRC(songObject.lrcContent || "");
    renderCharLyrics();


    if (songObject.isLocal) {
      const blob = new Blob([songObject.src], {
        type: songObject.fileType || 'audio/mpeg'
      });
      player.src = URL.createObjectURL(blob);
    } else {
      player.src = songObject.src;
    }
    player.play().catch(e => console.error("音频播放失败:", e));

    player.onloadedmetadata = () => {
      document.getElementById('char-music-total-time').textContent = formatMusicTime(player.duration);
      charPlayerState.lrcUpdateInterval = setInterval(updateCharMusicProgress, 1000);
    };

    modal.classList.add('visible');
  }


function minimizeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    modal.classList.remove('visible');
  
    document.getElementById('char-music-restore-btn').style.display = 'flex';
}


function restoreCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    modal.classList.add('visible');
    
    document.getElementById('char-music-restore-btn').style.display = 'none';
}


function closeCharMusicPlayer() {
    const modal = document.getElementById('char-music-player-modal');
    const player = document.getElementById('char-audio-player');

    if (charPlayerState.lrcUpdateInterval) clearInterval(charPlayerState.lrcUpdateInterval);
    player.pause();
    // player.src = ''; // 建议注释掉这行，防止下次打开要重新加载，或者保留看你需求
    
    modal.classList.remove('visible');
    charPlayerState.isPlaying = false;
    document.getElementById('char-vinyl-container').classList.remove('spinning');
    
   
    document.getElementById('char-music-restore-btn').style.display = 'none';
}


  function updateCharMusicProgress() {
    const player = document.getElementById('char-audio-player');
    if (!player.duration) return;

    const currentTime = player.currentTime;
    const duration = player.duration;
    document.getElementById('char-music-progress-fill').style.width = `${(currentTime / duration) * 100}%`;
    document.getElementById('char-music-current-time').textContent = formatMusicTime(currentTime);


    updateCharActiveLyric(currentTime);
  }



  function renderCharLyrics() {
    const lyricsContainer = document.getElementById('char-music-lyrics');
    lyricsContainer.innerHTML = ''; 
    charPlayerState.currentLyricIndex = -1;
    
   
    const scrollWrapper = document.createElement('div');
    scrollWrapper.id = 'char-lyrics-scroll-wrapper';
    scrollWrapper.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
    lyricsContainer.appendChild(scrollWrapper);

    if (!charPlayerState.parsedLyrics || charPlayerState.parsedLyrics.length === 0) {
        scrollWrapper.innerHTML = '<p>♪ 暂无歌词 ♪</p>';
        return;
    }
    charPlayerState.parsedLyrics.forEach((line, index) => {
        const p = document.createElement('p');
        p.textContent = line.text;
        p.dataset.index = index;
     
        p.style.margin = '0';
        p.style.padding = '5px 0';
        p.style.color = '#888';
        p.style.transition = 'all 0.3s';
        scrollWrapper.appendChild(p);
    });
}

function updateCharActiveLyric(currentTime) {
    const lyrics = charPlayerState.parsedLyrics;
    if (lyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < lyrics.length; i++) {
        if (currentTime >= lyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === charPlayerState.currentLyricIndex) return;
    charPlayerState.currentLyricIndex = newLyricIndex;

   
    const wrapper = document.getElementById('char-lyrics-scroll-wrapper');
    if(!wrapper) return; 

    const lines = wrapper.querySelectorAll('p');
    lines.forEach(line => {
        line.classList.remove('active');
        line.style.color = '#888';
        line.style.transform = 'scale(1)';
    });

    if (newLyricIndex > -1) {
        const activeLine = wrapper.querySelector(`p[data-index="${newLyricIndex}"]`);
        if (activeLine) {
            activeLine.classList.add('active');
            activeLine.style.color = '#333';
            activeLine.style.fontWeight = 'bold';
            activeLine.style.transform = 'scale(1.1)';
           
            const containerHeight = document.getElementById('char-music-lyrics').clientHeight;
            const offset = (containerHeight / 2) - activeLine.offsetTop - (activeLine.clientHeight / 2);
            
            wrapper.style.transform = `translateY(${offset}px)`;
        }
    }
}



  function playNextCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    let nextIndex;
    switch (charPlayerState.playMode) {
      case 'random':
        nextIndex = Math.floor(Math.random() * charPlayerState.currentPlaylist.length);
        break;
      case 'single':

        playCharSong(charPlayerState.currentPlaylist[charPlayerState.currentIndex]);
        return;
      case 'order':
      default:
        nextIndex = (charPlayerState.currentIndex + 1) % charPlayerState.currentPlaylist.length;
        break;
    }
    playCharSong(nextIndex, charPlayerState.currentPlaylist);
  }

  function playPrevCharSong() {
    if (charPlayerState.currentPlaylist.length === 0) return;
    const newIndex = (charPlayerState.currentIndex - 1 + charPlayerState.currentPlaylist.length) % charPlayerState.currentPlaylist.length;
    playCharSong(newIndex, charPlayerState.currentPlaylist);
  }

  function changeCharPlayMode() {
    const modes = ['order', 'random', 'single'];
    const currentModeIndex = modes.indexOf(charPlayerState.playMode);
    charPlayerState.playMode = modes[(currentModeIndex + 1) % modes.length];
    document.getElementById('char-music-mode-btn').textContent = {
      'order': '顺序',
      'random': '随机',
      'single': '单曲'
    } [charPlayerState.playMode];
  }



  function setupCharPlayerControls() {
    const player = document.getElementById('char-audio-player');
    const playBtn = document.getElementById('char-music-play-pause-btn');
    const vinyl = document.getElementById('char-vinyl-container');

    playBtn.addEventListener('click', () => {
      if (player.paused) {
        if (charPlayerState.currentIndex > -1) player.play();
      } else {
        player.pause();
      }
    });

    player.onplay = () => {
      playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>`;
      vinyl.classList.add('spinning');
      charPlayerState.isPlaying = true;
    };
    player.onpause = () => {
      playBtn.innerHTML = `<svg viewBox="0 0 24 24" width="32" height="32" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>`;
      vinyl.classList.remove('spinning');
      charPlayerState.isPlaying = false;
    };
    player.onended = () => {
      vinyl.classList.remove('spinning');
      charPlayerState.isPlaying = false;
      playNextCharSong();
    };

    document.getElementById('char-music-prev-btn').addEventListener('click', playPrevCharSong);
    document.getElementById('char-music-next-btn').addEventListener('click', playNextCharSong);
    document.getElementById('char-music-mode-btn').addEventListener('click', changeCharPlayMode);

    document.getElementById('char-music-progress-bar').addEventListener('click', (e) => {
      if (!player.duration) return;
      const bar = e.currentTarget;
      const clickX = e.offsetX;
      player.currentTime = (clickX / bar.clientWidth) * player.duration;
    });
  }

  async function renderDoubanScreen() {
    const listEl = document.getElementById('douban-posts-list');
    listEl.innerHTML = '';

    const posts = await db.doubanPosts.orderBy('timestamp').reverse().toArray();

    if (posts.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里空空如也，<br>点击右上角刷新按钮，看看大家都在聊什么吧！</p>';
      return;
    }

    posts.forEach(post => {
      let avatarUrl;


      const authorChatByOriginalName = post.authorOriginalName ?
        Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorOriginalName) :
        null;

      if (authorChatByOriginalName) {

        avatarUrl = authorChatByOriginalName.settings.aiAvatar;
      } else {

        const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
        if (authorChatByName) {
          avatarUrl = authorChatByName.settings.aiAvatar;
        } else if (post.authorAvatarPrompt) {

          avatarUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
        } else {

          avatarUrl = defaultAvatar;
        }
      }


      const itemEl = document.createElement('div');
      itemEl.className = 'douban-post-item';
      itemEl.onclick = () => openDoubanPostDetail(post.id);

      itemEl.innerHTML = `
            <div class="douban-post-header">
                <img src="${avatarUrl}" class="douban-post-avatar">
                <div class="douban-author-info">
                    <div class="douban-author-name">${post.authorName}</div>
                    <div class="douban-group-name">来自 ${post.groupName}</div>
                </div>
            </div>
            <div class="douban-post-title">${post.postTitle}</div>
            <div class="douban-post-content">${post.content.replace(/\n/g, '<br>')}</div>
            <div class="douban-post-footer">
                 <div class="douban-post-actions">
                    <span><svg viewBox="0 0 1024 1024"><path d="M170.666667 170.666667h128v682.666666h-128zM426.666667 170.666667h170.666666v682.666666h-170.666666zM725.333333 170.666667h128v682.666666h-128z"></path></svg> ${post.likesCount}</span>
                    <span><svg viewBox="0 0 1024 1024"><path d="M853.333333 85.333333H170.666667c-46.933333 0-85.333333 38.4-85.333334 85.333334v512c0 46.933333 38.4 85.333333 85.333334 85.333333h512l170.666667 170.666667V170.666667c0-46.933333-38.4-85.333333-85.333334-85.333334z m-42.666666 554.666667H170.666667V170.666667h640v469.333333zM256 384h512v85.333333H256V384z m0-170.666667h512v85.333334H256v-85.333334z"></path></svg> ${post.commentsCount}</span>
                </div>
                <span class="douban-post-timestamp">${formatTimeAgo(post.timestamp)}</span>
            </div>
        `;
      listEl.appendChild(itemEl);
    });
  }



  async function handleGenerateDoubanPosts() {
    const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];

    if (activeCharacterIds.length === 0) {
      await showCustomAlert("请先选择角色", "请点击右上角的“角色选择”按钮，选择至少一个参与豆瓣互动的角色。");
      return;
    }

    await showCustomAlert("请稍候...", `正在为您选择的 ${activeCharacterIds.length} 位角色生成豆瓣动态...`);

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('请先在API设置中配置好API信息。');
      return;
    }

    const allLinkedBookIds = new Set();
    activeCharacterIds.forEach(charId => {
      const c = state.chats[charId];
      if (c && c.settings.linkedWorldBookIds) {
        c.settings.linkedWorldBookIds.forEach(bookId => allLinkedBookIds.add(bookId));
      }
    });

    let sharedWorldBookContext = '';
    if (allLinkedBookIds.size > 0) {
      sharedWorldBookContext += '\n\n# 统一世界观设定 (以下设定适用于所有参与角色)\n';
      allLinkedBookIds.forEach(bookId => {
        const book = state.worldBooks.find(wb => wb.id === bookId);
        if (book) {
          const enabledEntries = book.content
            .filter(e => e.enabled !== false)
            .map(e => `- ${e.content}`)
            .join('\n');
          if (enabledEntries) {
            sharedWorldBookContext += `\n## 来自《${book.name}》:\n${enabledEntries}`;
          }
        }
      });
    }

    const doubanWorldBook = state.worldBooks.find(wb => wb.name === '豆瓣设定');
    let doubanSettingContext = '';
    let npcCharacters = [];
    if (doubanWorldBook) {
      doubanWorldBook.content.forEach(entry => {
        if (entry.comment.includes('小组风格')) {
          doubanSettingContext += `\n# 豆瓣社区风格设定 (来自世界书)\n${entry.content}`;
        }
        if (entry.comment.includes('NPC人设')) {
          const lines = entry.content.split('\n');
          lines.forEach(line => {
            const match = line.match(/- \*\*昵称\*\*:\s*(.*?)\s*\*\*人设\*\*:\s*(.*)/);
            if (match) {
              npcCharacters.push({
                name: match[1].trim(),
                persona: match[2].trim()
              });
            }
          });
        }
      });
    }

    const userNickname = state.qzoneSettings.nickname || '我';
    const userPersona = activeCharacterIds.length > 0 && state.chats[activeCharacterIds[0]] ?
      state.chats[activeCharacterIds[0]].settings.myPersona :
      '(未设置)';

    let charactersContext = '';
    activeCharacterIds.forEach(charId => {
      const c = state.chats[charId];
      if (c) {
        const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : '无';
        const recentHistory = c.history.slice(-10).map(msg =>
          `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`
        ).join('\n');

        charactersContext += `
<character>
  <name>${c.name}</name>
  <persona>${c.settings.aiPersona}</persona>
  <memory>${longTermMemory}</memory>
  <recent_dialogue_with_user>${recentHistory}</recent_dialogue_with_user>
</character>
`;
      }
    });
    npcCharacters.forEach(npc => {
      charactersContext += `
<character>
  <name>${npc.name}</name>
  <persona>${npc.persona}</persona>
</character>
`;
    });

    const now = new Date();
    const currentTimeString = now.toLocaleString('zh-CN', {
      dateStyle: 'full',
      timeStyle: 'short'
    });
    const minPosts = state.globalSettings.doubanMinPosts || 12;
    const maxPosts = state.globalSettings.doubanMaxPosts || 20;
    const systemPrompt = `
# 你的任务
你是一个虚拟社区内容生成器。你的任务是根据下面提供的【统一角色列表】，虚构出【${minPosts}到${maxPosts}篇】他们最近可能会在各种豆瓣小组中发布的帖子和评论。

# 核心规则
1.  **【时间感知】**:
    -   你【必须】意识到当前是 **${currentTimeString}**。
    -   你的帖子和评论内容【必须】自然地体现出对【当前真实时间】的感知。
2.  **【禁止扮演用户 (最最最高优先级！！！)】**:
    -   用户的昵称是“${userNickname}”。
    -   你【绝对不能】生成 authorName 或 commenter 字段为 “${userNickname}” 的帖子或评论。你的任务是扮演【除了用户以外】的所有角色。
3.  **【身份 (最高优先级！)】**: 
    -   \`authorName\`: 你可以为主要角色起一个符合情景的、临时的【发帖昵称】，也可以直接使用他们的本名。
    -   \`authorOriginalName\`: 如果发帖者是【主要角色】，你【必须】在这里填上TA在角色列表里的【原始备注名】，这是程序的“身份证”。
    -   如果发帖者是【路人NPC】，则【省略】\`authorOriginalName\` 字段。
4.  **【作者平衡】**: 帖子的作者【必须】从下面的 \`<character>\` 列表中【均匀地、多样化地】选择。你【必须】确保帖子列表中【至少有 70% 的帖子是由路人NPC发布的】，以营造一个真实的社区氛围。
    - "comments": 一个包含【7到12条】评论的数组。评论者可以是路人，也可以是角色列表中的其他角色，以体现互动性。
5.  **【角色扮演】**: 帖子的作者和内容【必须】深度结合该角色的<persona>, <memory>, 和 <worldview>。
6.  **【“豆瓣味”内容风格指南】**: 帖子风格必须多样化且充满生活气息！你需要生成包括但不限于：情感树洞、生活吐槽、吃瓜八卦、兴趣分享、无用良品等各种类型的帖子。
7.  **【头像生成 (最高优先级！)】**:
    -   为每一个【首次出现】的路人NPC（无论是发帖还是评论），你都【必须】为其添加一个 \`avatar_prompt\` 字段。
    -   这个字段的内容是用于生成该NPC头像的、简洁的【英文】关键词。
    -   不同的NPC【必须】有不同的头像指令，以确保他们的头像是独一无二的。
8.  **【头像一致性 (至关重要！)】**:
    -   如果一个路人NPC在同一个帖子中多次出现（例如，既是发帖人又是评论者，或多次评论），你【必须】为TA的所有出现都使用【完全相同】的 \`avatar_prompt\`。这至关重要！
9.  **【格式 (最高优先级)】**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 你的回复必须以 \`[\` 开始，并以 \`]\` 结束。
    - 【绝对禁止】在JSON数组前后添加任何多余的文字、解释、或 markdown 标记 (如 \`\`\`json)。
    - 数组中的每个元素都是一篇帖子，格式【必须】如下:
    \`\`\`json
    [
      {
        "groupName": "一个生动有趣的小组名称",
        "postTitle": "一个引人-注目的帖子标题",
        "authorName": "发帖角色的【备注名】",
        "authorOriginalName": "(仅当发帖者是主要角色时【必须】提供) TA的原始备注名",
        "authorAvatarPrompt": "(仅当发帖者是路人NPC时【必须】提供) 一段用于生成该NPC头像的【英文】关键词。风格为 anime style, simple background",
        "content": "帖子的详细正文，必须支持换行符\\n。",
        "likesCount": 152,
        "commentsCount": 38,
        "comments": [
            { "commenter": "路人甲", "text": "这是一个路人评论。", "avatar_prompt": "cute cat avatar, simple, flat" },
            { "commenter": "另一个角色名", "commenterOriginalName": "(如果评论者是主要角色，必须提供其本名)", "text": "这是一个来自其他角色的互动评论。" }
        ]
      }
    ]
    \`\`\`
    - **comments**: 
        -   评论者可以是路人，也可以是角色列表中的其他角色。评论区【必须】体现出互动性。
        -   【评论身份】: 如果评论者是【主要角色】，你【必须】为其添加 \`commenterOriginalName\` 字段，并填入其本名。如果是路人NPC，则省略此字段。

# 供你参考的上下文
${doubanSettingContext}
${sharedWorldBookContext}

# 当前情景
- **当前真实时间**: ${currentTimeString}

# 【你的聊天对象（用户）的身份档案】
- **昵称**: ${userNickname}
- **人设**: ${userPersona}

# 统一角色列表 (你扮演的角色 + 路人NPC)
${charactersContext}

现在，请严格遵守所有规则，特别是【时间感知】和【禁止扮演用户】的铁律，开始生成这组生动、多样且充满“豆瓣味”的小组帖子。`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据角色列表，生成豆瓣小组帖子。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 1.0,
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/\[[\s\S]*\]/);

      if (!jsonMatch) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }

      const simulatedPosts = JSON.parse(jsonMatch[0]);
      await db.doubanPosts.clear();
      await db.doubanPosts.bulkAdd(simulatedPosts.map(p => ({
        ...p,
        timestamp: Date.now() - Math.random() * 100000
      })));

      await renderDoubanScreen();

    } catch (error) {
      console.error("生成豆瓣帖子失败:", error);
      await showCustomAlert("生成失败", `无法生成内容，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }


  async function openDoubanPostDetail(postId) {
    showScreen('douban-post-detail-screen');
    activeDoubanPostId = postId;
    const post = await db.doubanPosts.get(postId);
    if (!post) {
      showScreen('douban-screen');
      return;
    }

    document.getElementById('douban-post-detail-title').textContent = '帖子详情';


    let authorAvatar = defaultAvatar;
    let authorDisplayName = post.authorName;

    const authorChatByOriginalName = post.authorOriginalName ?
      Object.values(state.chats).find(c => !c.isGroup && c.originalName === post.authorOriginalName) :
      null;

    if (authorChatByOriginalName) {
      authorAvatar = authorChatByOriginalName.settings.aiAvatar;
    } else {
      const authorChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === post.authorName);
      if (authorChatByName) {
        authorAvatar = authorChatByName.settings.aiAvatar;
      } else if (post.authorAvatarPrompt) {
        authorAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(post.authorAvatarPrompt)}`;
      }
    }


    document.getElementById('douban-detail-avatar').src = authorAvatar;
    document.getElementById('douban-detail-author').textContent = authorDisplayName;
    document.getElementById('douban-detail-group').textContent = `来自 ${post.groupName}`;
    document.getElementById('douban-detail-post-title').textContent = post.postTitle;
    document.getElementById('douban-detail-content').innerHTML = post.content.replace(/\n/g, '<br>');
    document.getElementById('douban-my-comment-avatar').src = state.qzoneSettings.avatar;
    document.getElementById('douban-comment-input').value = '';

    const commentsListEl = document.getElementById('douban-detail-comments-list');
    commentsListEl.innerHTML = '';


    if (post.comments && post.comments.length > 0) {

      const commenterAvatarMap = new Map();

      post.comments.forEach(comment => {
        let commenterAvatar = defaultAvatar;
        const myNickname = state.qzoneSettings.nickname || '我';
        const commenterName = comment.commenter;

        if (commenterAvatarMap.has(commenterName)) {

          commenterAvatar = commenterAvatarMap.get(commenterName);
        } else {

          if (commenterName === myNickname) {
            commenterAvatar = state.qzoneSettings.avatar;
          } else if (commenterName === post.authorName) {
            commenterAvatar = authorAvatar;
          } else {
            const commenterChatByOriginalName = comment.commenterOriginalName ?
              Object.values(state.chats).find(c => !c.isGroup && c.originalName === comment.commenterOriginalName) :
              null;

            if (commenterChatByOriginalName) {
              commenterAvatar = commenterChatByOriginalName.settings.aiAvatar;
            } else {
              const commenterChatByName = Object.values(state.chats).find(c => !c.isGroup && c.name === commenterName);
              if (commenterChatByName) {
                commenterAvatar = commenterChatByName.settings.aiAvatar;
              } else if (comment.avatar_prompt) {
                commenterAvatar = `https://image.pollinations.ai/prompt/${encodeURIComponent(comment.avatar_prompt)}`;
              }
            }
          }

          commenterAvatarMap.set(commenterName, commenterAvatar);
        }

        const commentEl = document.createElement('div');
        commentEl.className = 'douban-comment-item';
        commentEl.innerHTML = `
                <img src="${commenterAvatar}" class="douban-comment-avatar">
                <div class="douban-comment-body">
                    <div class="douban-comment-author">${commenterName}</div>
                    <div class="douban-comment-text">${comment.text.replace(/\n/g, '<br>')}</div>
                </div>
            `;
        commentsListEl.appendChild(commentEl);
      });
    } else {
      commentsListEl.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">还没有回应</p>';
    }

    const contentWrapper = document.getElementById('douban-detail-content-wrapper');
    if (contentWrapper) contentWrapper.scrollTop = 0;
  }


  async function handleSendDoubanComment() {
    if (!activeDoubanPostId) return;

    const input = document.getElementById('douban-comment-input');
    const commentText = input.value.trim();
    if (!commentText) return;

    const post = await db.doubanPosts.get(activeDoubanPostId);
    if (!post) return;

    if (!post.comments) {
      post.comments = [];
    }

    const myNickname = state.qzoneSettings.nickname || '我';

    post.comments.push({
      commenter: myNickname,
      text: commentText
    });
    post.commentsCount++;

    await db.doubanPosts.put(post);
    input.value = '';


    await openDoubanPostDetail(activeDoubanPostId);


  }


  async function handleDoubanWaitReply() {
    if (!activeDoubanPostId) return;

    const postId = activeDoubanPostId;
    const post = await db.doubanPosts.get(postId);
    if (!post) return;

    const lastComment = post.comments && post.comments.slice(-1)[0];
    if (!lastComment) {
      alert("还没有任何评论，无法等待回复。");
      return;
    }

    await showCustomAlert("请稍候...", "正在请求AI角色们加入讨论...");

    try {
      const {
        proxyUrl,
        apiKey,
        model
      } = state.apiConfig;
      if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成内容。');
      }

      const userNickname = state.qzoneSettings.nickname || '我';
      const userPersona = state.chats[Object.keys(state.chats)[0]]?.settings.myPersona || '(未设置)';

      const existingNpcs = new Map();
      if (post.comments) {
        post.comments.forEach(comment => {
          const isMainCharacter = (state.globalSettings.doubanActiveCharacterIds || []).some(id => state.chats[id]?.name === comment.commenter);
          if (!isMainCharacter && comment.avatar_prompt) {
            existingNpcs.set(comment.commenter, comment.avatar_prompt);
          }
        });
      }

      let existingNpcContext = "# 已有路人NPC头像指令 (必须遵守！)\n";
      if (existingNpcs.size > 0) {
        existingNpcContext += "如果以下任何一位NPC再次评论，你【必须】使用我们提供的、完全相同的`avatar_prompt`，以保持头像一致性。\n";
        existingNpcs.forEach((prompt, name) => {
          existingNpcContext += `- **${name}**: "${prompt}"\n`;
        });
      } else {
        existingNpcContext += "（当前帖子还没有路人NPC发表评论。）\n";
      }

      const doubanWorldBook = state.worldBooks.find(wb => wb.name === '豆瓣设定');
      let npcCharacters = [];
      if (doubanWorldBook) {
        doubanWorldBook.content.forEach(entry => {
          if (entry.comment.includes('NPC人设')) {
            const lines = entry.content.split('\n');
            lines.forEach(line => {
              const match = line.match(/- \*\*昵称\*\*:\s*(.*?)\s*\*\*人设\*\*:\s*(.*)/);
              if (match) {
                npcCharacters.push({
                  name: match[1].trim(),
                  persona: match[2].trim()
                });
              }
            });
          }
        });
      }

      let charactersContext = '';
      const activeCharacterIds = state.globalSettings.doubanActiveCharacterIds || [];
      activeCharacterIds.forEach(charId => {
        const c = state.chats[charId];
        if (c) {
          const longTermMemory = c.longTermMemory && c.longTermMemory.length > 0 ? c.longTermMemory.map(m => m.content).join('; ') : '无';
          const recentHistory = c.history.slice(-10).map(msg => `${msg.role === 'user' ? userNickname : c.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
          charactersContext += `\n- ${c.name}: ${c.settings.aiPersona.substring(0,50)}... [记忆: ${longTermMemory}] [最近对话: ${recentHistory}]`;
        }
      });
      npcCharacters.forEach(npc => {
        charactersContext += `\n- ${npc.name}: ${npc.persona}`;
      });


      const now = new Date();
      const currentTimeString = now.toLocaleString('zh-CN', {
        dateStyle: 'full',
        timeStyle: 'short'
      });


      const systemPrompt = `
# 你的任务
你是一个虚拟社区的AI导演。下面的“帖子摘要”和“已有评论”来自于一个豆瓣小组的帖子。用户“${userNickname}”刚刚对最后一条评论点击了“等待回复”，TA希望看到更多角色参与讨论。
你的任务是：根据所有角色的设定，选择【10到20位】最适合参与讨论的角色，让他们针对已有评论，发表【全新的、符合人设的】回应。

# 核心规则
1.  **【时间感知】**:
    -   你【必须】意识到当前是 **${currentTimeString}**。
    -   你的评论内容【必须】自然地体现出对【当前真实时间】的感知。
2.  **【禁止扮演用户 (最最最高优先级！！！)】**:
    -   用户的昵称是“${userNickname}”。
    -   你【绝对不能】生成 commenter 字段为 “${userNickname}” 的评论。你的任务是扮演【除了用户以外】的所有角色。
3.  **【互动】**: 新生成的评论【必须】是针对【已有评论】的延续或回应，让讨论能继续下去。
4.  **【头像一致性 (最高优先级！)】**: 你【必须】参考下面的“已有路人NPC头像指令”列表。如果一个已有的NPC再次发言，【必须】复用它旧的头像指令。只有在创造一个【全新的、从未出现过的】NPC时，才为其生成新的头像指令。
5.  **【格式】**: 你的回复【必须且只能】是一个JSON数组，数组中的每个元素都代表一条新评论，格式【必须】如下:
    \`\`\`json
    [
      { "commenter": "角色A的名字", "text": "角色A的新评论内容。", "avatar_prompt": "(可选)如果评论者是【全新的】NPC,提供头像指令" },
      { "commenter": "角色B的名字", "text": "角色B对角色A或楼主的看法。" }
    ]
    \`\`\`

# 上下文
- **帖子标题**: 《${post.postTitle}》
- **发帖人**: ${post.authorName}
- **帖子内容摘要**: ${post.content.substring(0, 100)}...
- **已有评论**:
${post.comments.map(c => `- ${c.commenter}: ${c.text}`).join('\n')}

${existingNpcContext}

# 当前情景
- **当前真实时间**: ${currentTimeString}

# 【你的聊天对象（用户）的人设】
- **昵称**: ${userNickname}
- **人设**: ${userPersona}

# 你的角色库 (你可以从中选择【任何角色】进行评论，并参考他们的记忆和对话)
${charactersContext}

现在，请生成新的评论。`;

      const messagesForApi = [{
        role: 'user',
        content: "请根据以上情景，生成新的评论。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 1.0,
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
      const newComments = JSON.parse(cleanedJson);

      if (Array.isArray(newComments) && newComments.length > 0) {
        post.comments.push(...newComments);
        post.commentsCount += newComments.length;
        await db.doubanPosts.put(post);
      }

      await openDoubanPostDetail(postId);

      hideCustomModal();

    } catch (error) {
      console.error("等待回复失败:", error);
      await showCustomAlert("操作失败", `无法获取AI回复，请检查API配置或稍后再试。\n错误: ${error.message}`);
    }
  }



  async function openDoubanCastSelector() {
    const modal = document.getElementById('douban-cast-modal');
    const listEl = document.getElementById('douban-cast-list');
    listEl.innerHTML = '';

    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
 
    const activeIds = new Set(state.globalSettings.doubanActiveCharacterIds || []);

    if (allCharacters.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; padding: 50px 0;">还没有可以参与的角色。</p>';
    } else {
      allCharacters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.innerHTML = `
                <input type="checkbox" class="douban-cast-checkbox" data-chat-id="${char.id}" ${activeIds.has(char.id) ? 'checked' : ''} style="margin-right: 15px;">
                <img src="${char.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${char.name}</span>
            `;
        listEl.appendChild(item);
      });
    }
    modal.classList.add('visible');
  }


  async function saveDoubanCastSelection() {
    const selectedCheckboxes = document.querySelectorAll('#douban-cast-list .douban-cast-checkbox:checked');
    const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.dataset.chatId);


    state.globalSettings.doubanActiveCharacterIds = selectedIds;
    await db.globalSettings.put(state.globalSettings);

    document.getElementById('douban-cast-modal').classList.remove('visible');


    await handleGenerateDoubanPosts();
  }



  document.getElementById('douban-cast-select-btn').addEventListener('click', openDoubanCastSelector);
  document.getElementById('cancel-douban-cast-btn').addEventListener('click', () => {
    document.getElementById('douban-cast-modal').classList.remove('visible');
  });
  document.getElementById('save-douban-cast-btn').addEventListener('click', saveDoubanCastSelection);

  document.getElementById('douban-cast-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (item) {
      const checkbox = item.querySelector('.douban-cast-checkbox');
      if (checkbox && e.target !== checkbox) {
        checkbox.checked = !checkbox.checked;
      }
    }
  });

  async function importAppearanceSettings(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '导入外观设置',
        '即将导入文件。如果文件是 JSON 备份，将覆盖所有设置；如果是纯文本/Word文档，将尝试识别为 CSS 代码或 JSON 配置。\n\n确定要继续吗？', {
            confirmText: '确认导入'
        }
    );

    if (!confirmed) return;

    await showCustomAlert("处理中...", "正在解析文件内容...");

    try {
        let textContent = '';

        // 1. 根据文件类型读取文本
        if (file.name.toLowerCase().endsWith('.docx')) {
            if (typeof mammoth === 'undefined') {
                throw new Error("未加载 mammoth.js 库，无法读取 Word 文档。请检查网络或 HTML。");
            }
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
            textContent = result.value;
        } else {
            // .json 或 .txt 直接读取文本
            textContent = await file.text();
        }

        if (!textContent || !textContent.trim()) {
            throw new Error("文件内容为空。");
        }

        // 2. 尝试解析为 JSON（完整配置模式）
        try {
            // 预处理：有时候 Word 会包含不可见的 BOM 或多余空格，尝试清理并提取 JSON 部分
            let cleanText = textContent.trim();
            // 尝试提取第一个 { 到最后一个 } 之间的内容，防止文档前后有杂质
            const jsonMatch = cleanText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                cleanText = jsonMatch[0];
            }

            const data = JSON.parse(cleanText);

            // 检查是否是有效的外观配置对象
            if (data.wallpaper || data.globalCss || data.appIcons || data.theme) {
                Object.assign(state.globalSettings, data);
                await db.globalSettings.put(state.globalSettings);
                
                // 应用设置
                applyGlobalWallpaper();
                applyCPhoneWallpaper();
                applyAppIcons();
                applyCPhoneAppIcons();
                applyGlobalCss(state.globalSettings.globalCss);
                applyCustomFont(state.globalSettings.fontUrl);
                applyStatusBarVisibility();
                applyWidgetData();
                if (data.chatActionButtonsOrder) {
                    renderButtonOrderEditor();
                    applyButtonOrder();
                }
                
                // 刷新界面
                renderWallpaperScreen();
                
                await showCustomAlert('JSON导入成功', '完整外观设置已成功导入并应用！');
                return; // 成功结束
            }
        } catch (jsonError) {
            // JSON 解析失败，进入下一步：尝试作为纯 CSS 导入
            console.log("非 JSON 格式，尝试作为 CSS 处理...");
        }

        // 3. 如果不是 JSON，则视为纯 CSS 代码导入
        // 简单的防呆检查：CSS 通常包含 { 或 ;
        if (textContent.includes('{') || textContent.includes(';')) {
            const cssConfirm = await showCustomConfirm(
                '检测到 CSS 代码',
                '文件内容似乎不是标准的 JSON 配置包，但看起来像 CSS 代码。\n\n是否将其直接应用到【全局自定义 CSS】中？(这将覆盖现有的 CSS)',
                { confirmText: '应用为 CSS' }
            );

            if (cssConfirm) {
                state.globalSettings.globalCss = textContent;
                await db.globalSettings.put(state.globalSettings);
                applyGlobalCss(state.globalSettings.globalCss);
                
                // 刷新界面显示
                const cssInput = document.getElementById('global-css-input');
                if (cssInput) cssInput.value = textContent;

                await showCustomAlert('CSS导入成功', '代码已应用到全局样式表。');
            }
        } else {
            throw new Error("无法识别文件内容。它既不是有效的 JSON 配置，也不像 CSS 代码。");
        }

    } catch (error) {
        console.error("导入外观设置时出错:", error);
        await showCustomAlert('导入失败', `文件解析失败: ${error.message}`);
    }
}

// 导出美化版外观设置
async function exportAppearanceSettings() {
    try {
        // 1. 提取外观相关的数据
        // 即使包含大段 Base64 图片，JSON 格式化后结构依然清晰
        const appearanceData = {
            export_info: {
                generated_by: "EPhone",
                timestamp: new Date().toLocaleString(),
                note: "此文件包含外观设置、CSS样式、壁纸和图标数据。"
            },
            // 核心设置
            theme: localStorage.getItem('ephone-theme') || 'light',
            showStatusBar: state.globalSettings.showStatusBar,
            enableMinimalChatUI: state.globalSettings.enableMinimalChatUI,
            detachStatusBar: state.globalSettings.detachStatusBar,
            // CSS (最需要美化阅读的部分)
            globalCss: state.globalSettings.globalCss || "",
            // 字体
            fontUrl: state.globalSettings.fontUrl || "",
            // 布局排序
            chatActionButtonsOrder: state.globalSettings.chatActionButtonsOrder,
            // 资源数据 (壁纸/图标)
            wallpaper: state.globalSettings.wallpaper,
            cphoneWallpaper: state.globalSettings.cphoneWallpaper,
            globalChatBackground: state.globalSettings.globalChatBackground,
            appIcons: state.globalSettings.appIcons,
            cphoneAppIcons: state.globalSettings.cphoneAppIcons,
            widgetData: state.globalSettings.widgetData,
            lockScreenWallpaper: state.globalSettings.lockScreenWallpaper,
            notificationSoundUrl: state.globalSettings.notificationSoundUrl
        };

        // 2. 关键步骤：格式化 JSON (美化)
        // 第三个参数 4 表示使用 4 个空格进行缩进，让文件结构清晰、易读、易修改
        const jsonString = JSON.stringify(appearanceData, null, 4);

        // 3. 创建下载链接
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        
        // 生成文件名
        const dateStr = new Date().toISOString().split('T')[0];
        link.href = url;
        link.download = `EPhone_Appearance_Config_${dateStr}.json`;
        
        // 触发下载
        document.body.appendChild(link);
        link.click();
        
        // 清理
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        await showCustomAlert('导出成功', '外观配置已导出！\n这是一个格式化好的 JSON 文件，你可以用记事本打开查看或编辑 CSS。');

    } catch (error) {
        console.error("导出外观配置失败:", error);
        await showCustomAlert('导出失败', `发生错误: ${error.message}`);
    }
} 




  async function simulateBackgroundActivity(minutesOffline) {
    console.log(`检测到应用离线了 ${minutesOffline.toFixed(1)} 分钟，开始模拟后台活动...`);


    const activeCharacters = Object.values(state.chats).filter(chat =>
      !chat.isGroup &&
      chat.settings.enableBackgroundActivity &&
      chat.relationship?.status === 'friend'
    );

    if (activeCharacters.length === 0) {
      console.log("没有配置为后台活跃的角色，跳过模拟。");
      return;
    }


    for (const char of activeCharacters) {

      const cooldownMinutes = char.settings.actionCooldownMinutes || 15;
      const timeSinceLastAction = char.lastActionTimestamp ?
        (Date.now() - char.lastActionTimestamp) / (1000 * 60) :
        Infinity;


      if (minutesOffline > cooldownMinutes && timeSinceLastAction > cooldownMinutes) {



        if (Math.random() < 0.3) {
          console.log(`角色 "${char.name}" 触发了后台行动！`);


          if (Math.random() < 0.7) {

            await triggerInactiveAiAction(char.id);
          } else {

            console.log(`角色 "${char.name}" 决定去发一条动态... (此处为模拟)`);
          }
        }
      }
    }
  }


  function openSearchHistoryScreen() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];


    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';

    document.getElementById('chat-search-results-list').innerHTML = `<p style="text-align:center; color: var(--text-secondary);">输入关键词或选择日期进行搜索。</p>`;


    showScreen('search-history-screen');
  }

  async function handleSearchHistory() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const keyword = document.getElementById('keyword-search-input').value.trim().toLowerCase();
    const dateValue = document.getElementById('date-search-input').value;

    if (!keyword && !dateValue) {
      alert("请输入关键词或选择一个日期。");
      return;
    }

    let results = chat.history.filter(msg => !msg.isHidden);


    if (keyword) {
      results = results.filter(msg => {
        let contentString = '';

        if (typeof msg.content === 'string') {
          contentString = msg.content;
        } else if (msg.type === 'voice_message') {
          contentString = msg.content;
        } else if (msg.type === 'ai_image' || msg.type === 'user_photo') {
          contentString = msg.content;
        } else if (msg.type === 'offline_text') {
          contentString = `${msg.dialogue || ''} ${msg.description || ''}`;
        } else if (msg.quote) {
          contentString = msg.content;
        }
        return contentString.toLowerCase().includes(keyword);
      });
    }


    if (dateValue) {
      const selectedDate = new Date(dateValue);
      const startOfDay = new Date(selectedDate.setHours(0, 0, 0, 0)).getTime();
      const endOfDay = new Date(selectedDate.setHours(23, 59, 59, 999)).getTime();

      results = results.filter(msg => msg.timestamp >= startOfDay && msg.timestamp <= endOfDay);
    }


    await renderSearchResults(results);
  }



  async function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    if (results.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">未找到相关的聊天记录。</p>';
      return;
    }

    let lastDateString = '';
    for (const msg of results) {
      const msgDate = new Date(msg.timestamp);
      const currentDateString = msgDate.toLocaleDateString();

      if (currentDateString !== lastDateString) {
        const dateSeparator = document.createElement('div');
        dateSeparator.className = 'date-separator';
        dateSeparator.textContent = `--- ${msgDate.getFullYear()}年${msgDate.getMonth() + 1}月${msgDate.getDate()}日 ---`;
        listEl.appendChild(dateSeparator);
        lastDateString = currentDateString;
      }

      const messageEl = await createMessageElement(msg, chat);
      if (messageEl) {


        messageEl.style.cursor = 'pointer';

        messageEl.addEventListener('click', () => jumpToOriginalMessage(msg.timestamp));

        listEl.appendChild(messageEl);
      }
    }
  }



 
  async function jumpToOriginalMessage(timestamp) {
    const chatId = state.activeChatId;
    if (!chatId) return;


    showScreen('chat-interface-screen');


    setTimeout(async () => {
      const messagesContainer = document.getElementById('chat-messages');
      const selector = `.message-bubble[data-timestamp="${timestamp}"]`;
      let targetMessage = messagesContainer.querySelector(selector);
      let attempts = 0;
      const maxAttempts = 20;


      while (!targetMessage && attempts < maxAttempts) {
        const loadMoreBtn = document.getElementById('load-more-btn');
        if (loadMoreBtn) {
          console.log(`目标消息未找到, 正在加载更多历史记录... (尝试 ${attempts + 1})`);
          await loadMoreMessages();
          targetMessage = messagesContainer.querySelector(selector);
          attempts++;
        } else {

          break;
        }
      }


      scrollToOriginalMessage(timestamp);

    }, 200);
  }




  async function clearSearchFilters() {
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('date-search-input').value = '';

    await renderSearchResults(state.chats[state.activeChatId].history.filter(msg => !msg.isHidden));
  }

  async function populateFrameGrids(isForMember = false, memberAvatar = null, memberFrame = null) {
    const aiFrameGrid = document.getElementById('ai-frame-grid');
    const myFrameGrid = document.getElementById('my-frame-grid');
    const chat = state.chats[state.activeChatId];
    aiFrameGrid.innerHTML = '';
    myFrameGrid.innerHTML = '';


    const customFrames = await db.customAvatarFrames.toArray();

    const allFrames = [...avatarFrames, ...customFrames];

    document.querySelector('#avatar-frame-modal .frame-tabs').style.display = isForMember ? 'none' : 'flex';
    document.getElementById('ai-frame-content').style.display = 'block';
    document.getElementById('my-frame-content').style.display = 'none';
    document.getElementById('ai-frame-tab').classList.add('active');
    document.getElementById('my-frame-tab').classList.remove('active');

    if (isForMember) {
      allFrames.forEach(frame => {
        const item = createFrameItem(frame, 'my', memberAvatar);
        if (frame.url === memberFrame) {
          item.classList.add('selected');
        }
        aiFrameGrid.appendChild(item);
      });
    } else {
      const aiAvatarForPreview = chat.settings.aiAvatar || defaultAvatar;
      const myAvatarForPreview = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
      allFrames.forEach(frame => {
        const aiItem = createFrameItem(frame, 'ai', aiAvatarForPreview);
        if (frame.url === currentFrameSelection.ai) aiItem.classList.add('selected');
        aiFrameGrid.appendChild(aiItem);

        const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
        if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
        myFrameGrid.appendChild(myItem);
      });
    }
  }

 
  function createFrameItem(frame, type, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.dataset.frameUrl = frame.url;
    item.title = frame.name;

    const isCustom = typeof frame.id === 'number';
    const deleteButtonHtml = isCustom ? `<button class="delete-btn" data-id="${frame.id}" style="display:block;">×</button>` : '';

    item.innerHTML = `
        ${deleteButtonHtml}
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
    `;


    item.addEventListener('click', (e) => {

      if (e.target.classList.contains('delete-btn')) {
        return;
      }


      if (isFrameManagementMode) {

        if (isCustom) {
          const frameId = parseInt(frame.id);
          item.classList.toggle('selected');
          if (selectedFrames.has(frameId)) {
            selectedFrames.delete(frameId);
          } else {
            selectedFrames.add(frameId);
          }
          updateDeleteFrameButton();
        }
      } else {

        currentFrameSelection[type] = frame.url;
        const grid = type === 'ai' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
        grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
      }
    });

    return item;
  }



  async function handleUploadFrame() {
    const fileInput = document.getElementById('custom-frame-upload-input');

    const file = await new Promise(resolve => {
      const changeHandler = (e) => {
        resolve(e.target.files[0] || null);
        fileInput.removeEventListener('change', changeHandler);
      };
      fileInput.addEventListener('change', changeHandler, {
        once: true
      });
      fileInput.click();
    });

    if (!file) return;

    const name = await showCustomPrompt("命名头像框", "请为这个新头像框起个名字");
    if (!name || !name.trim()) return;
    
    const trimmedName = name.trim();

    const base64Url = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = async (readerEvent) => { 
            resolve(readerEvent.target.result);
        };
        reader.readAsDataURL(file);
    });

    const newFrame = {
      name: trimmedName,
      url: base64Url
    };
    const newId = await db.customAvatarFrames.add(newFrame);
    
    populateFrameGrids(editingFrameForMember);
    await showCustomAlert("添加成功！", `头像框“${trimmedName}”已添加。\n\n图片将在后台静默上传到图床...`);

    // 【【【已修复的调用】】】
    (async () => {
        await silentlyUpdateDbUrl(
            db.customAvatarFrames, // table
            newId, // recordId
            'url', // pathString (指向简单属性)
            base64Url // base64ToFind
            // nameToMatch (不需要)
        );
    })();
  }


  async function handleBatchUploadFrames() {
    const placeholder = `请按照以下格式粘贴，一行一个：\n\n头像框名字1: https://.../image1.png\n头像框名字2: https://.../image2.gif`;
    const pastedText = await showCustomPrompt("批量导入头像框", "从完整链接批量导入", "", 'textarea', `<p style="font-size:12px;color:#888;">${placeholder}</p>`);

    if (!pastedText || !pastedText.trim()) return;

    const lines = pastedText.trim().split('\n');
    const newFrames = [];
    let errorCount = 0;

    for (const line of lines) {

      const match = line.match(/^(.+?)[:：]\s*(https?:\/\/.+)$/);
      if (match) {
        newFrames.push({
          name: match[1].trim(),
          url: match[2].trim()
        });
      } else if (line.trim()) {
        errorCount++;
      }
    }

    if (newFrames.length > 0) {
      await db.customAvatarFrames.bulkAdd(newFrames);
      populateFrameGrids(editingFrameForMember);
      await showCustomAlert("导入成功", `成功导入 ${newFrames.length} 个新头像框！`);
    }

    if (errorCount > 0) {
      await showCustomAlert("部分失败", `有 ${errorCount} 行格式不正确，已被忽略。`);
    }
  }

  async function handleDeleteCustomFrame(frameId) {
    const frame = await db.customAvatarFrames.get(frameId);
    if (!frame) return;

    const confirmed = await showCustomConfirm(
      "确认删除",
      `确定要删除头像框 “${frame.name}” 吗？`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
      await db.customAvatarFrames.delete(frameId);
      populateFrameGrids(editingFrameForMember);
    }
  }





  let currentPage = 0;
  const totalPages = 2;


  function setupHomeScreenPagination() {
    const pagesContainer = document.getElementById('home-screen-pages-container');
    const pages = document.getElementById('home-screen-pages');
    const dots = document.querySelectorAll('.pagination-dot');
    let startX = 0,
      startY = 0;
    let currentX = 0;
    let isDragging = false;
    let isClick = true;

    const updatePagination = () => {
      pages.style.transform = `translateX(-${currentPage * (100 / totalPages)}%)`;
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentPage);
      });
    };

    const onDragStart = (e) => {
      isDragging = true;
      isClick = true;
      startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      pages.style.transition = 'none';
    };

    const onDragMove = (e) => {
      if (!isDragging) return;

      const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      const diffX = currentX - startX;
      const diffY = currentY - startY;


      if (isClick && (Math.abs(diffX) > 10 || Math.abs(diffY) > 10)) {
        isClick = false;
      }


      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (e.cancelable) e.preventDefault();
        pages.style.transform = `translateX(calc(-${currentPage * (100 / totalPages)}% + ${diffX}px))`;
      }
    };

    const onDragEnd = (e) => {
      if (!isDragging) return;
      isDragging = false;
      pages.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)';


      if (isClick) {
        updatePagination();

        return;
      }


      const diffX = currentX - startX;
      if (Math.abs(diffX) > pagesContainer.offsetWidth / 4) {
        if (diffX > 0 && currentPage > 0) {
          currentPage--;
        } else if (diffX < 0 && currentPage < totalPages - 1) {
          currentPage++;
        }
      }
      updatePagination();
    };

    pagesContainer.addEventListener('mousedown', onDragStart);
    pagesContainer.addEventListener('mousemove', onDragMove);
    pagesContainer.addEventListener('mouseup', onDragEnd);
    pagesContainer.addEventListener('mouseleave', onDragEnd);


    pagesContainer.addEventListener('touchstart', onDragStart, {
      passive: false
    });
    pagesContainer.addEventListener('touchmove', onDragMove, {
      passive: false
    });
    pagesContainer.addEventListener('touchend', onDragEnd);
  }



  let editingPresetId = null;

  async function openPresetScreen() {
    await renderPresetScreen();
    showScreen('preset-screen');
  }


  async function renderPresetScreen() {
    const tabsContainer = document.getElementById('preset-tabs');
    const contentContainer = document.getElementById('preset-content-container');
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    const [presets, categories] = await Promise.all([
      db.presets.toArray(),
      db.presetCategories.orderBy('name').toArray()
    ]);

    state.presets = presets;

    if (presets.length === 0) {
      contentContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一个预设</p>';
      return;
    }


    const allTab = document.createElement('button');
    allTab.className = 'world-book-tab active';
    allTab.textContent = '全部';
    allTab.dataset.categoryId = 'all';
    tabsContainer.appendChild(allTab);

    const allPane = document.createElement('div');
    allPane.className = 'world-book-category-pane active';
    allPane.dataset.categoryId = 'all';
    contentContainer.appendChild(allPane);

    categories.forEach(category => {
      const categoryTab = document.createElement('button');
      categoryTab.className = 'world-book-tab';
      categoryTab.textContent = category.name;
      categoryTab.dataset.categoryId = String(category.id);
      tabsContainer.appendChild(categoryTab);

      const categoryPane = document.createElement('div');
      categoryPane.className = 'world-book-category-pane';
      categoryPane.dataset.categoryId = String(category.id);
      contentContainer.appendChild(categoryPane);
    });

    const hasUncategorized = presets.some(p => !p.categoryId);
    if (hasUncategorized) {
      const uncategorizedTab = document.createElement('button');
      uncategorizedTab.className = 'world-book-tab';
      uncategorizedTab.textContent = '未分类';
      uncategorizedTab.dataset.categoryId = 'uncategorized';
      tabsContainer.appendChild(uncategorizedTab);

      const uncategorizedPane = document.createElement('div');
      uncategorizedPane.className = 'world-book-category-pane';
      uncategorizedPane.dataset.categoryId = 'uncategorized';
      contentContainer.appendChild(uncategorizedPane);
    }


    presets.forEach(preset => {

      const contentPreview = `该预设包含 ${preset.content.length} 个条目。`;

      const card = document.createElement('div');
      card.className = 'world-book-card';
      card.innerHTML = `
            <div class="card-title">${preset.name}</div>
            <div class="card-content-preview">${contentPreview}</div>
        `;


      const cardClickHandler = () => openPresetEditor(preset.id);
      const cardLongPressHandler = async () => {
        const confirmed = await showCustomConfirm('删除预设', `确定要删除《${preset.name}》吗？`, {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          await db.presets.delete(preset.id);
          state.presets = await db.presets.toArray();
          renderPresetScreen();
        }
      };

      card.addEventListener('click', cardClickHandler);
      addLongPressListener(card, cardLongPressHandler);

      const clonedCardForAll = card.cloneNode(true);
      clonedCardForAll.addEventListener('click', cardClickHandler);
      addLongPressListener(clonedCardForAll, cardLongPressHandler);
      allPane.appendChild(clonedCardForAll);

      const categoryKey = preset.categoryId ? String(preset.categoryId) : 'uncategorized';
      const targetPane = contentContainer.querySelector(`.world-book-category-pane[data-category-id="${categoryKey}"]`);
      if (targetPane) {
        targetPane.appendChild(card);
      }
    });



    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
      tab.addEventListener('click', () => switchPresetCategory(tab.dataset.categoryId));
    });
  }


  function switchPresetCategory(categoryId) {
    document.querySelectorAll('#preset-tabs .world-book-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.categoryId === categoryId);
    });
    document.querySelectorAll('#preset-content-container .world-book-category-pane').forEach(pane => {
      pane.classList.toggle('active', pane.dataset.categoryId === categoryId);
    });
  }


  async function openPresetEditor(presetId) {

    showScreen('preset-editor-screen');
    editingPresetId = presetId;

    try {

      const [preset, categories] = await Promise.all([
        db.presets.get(presetId),
        db.presetCategories.toArray()
      ]);


      if (!preset) {
        console.error("错误：尝试打开一个不存在的预设，ID:", presetId);
        await showCustomAlert("加载失败", "找不到这个预设的详细信息。");
        showScreen('preset-screen');
        return;
      }



      setTimeout(() => {

        document.getElementById('preset-editor-title').textContent = preset.name;
        document.getElementById('preset-name-input').value = preset.name;

        const selectEl = document.getElementById('preset-category-select');
        selectEl.innerHTML = '<option value="">-- 未分类 --</option>';
        categories.forEach(cat => {
          const option = document.createElement('option');
          option.value = cat.id;
          option.textContent = cat.name;
          if (preset.categoryId === cat.id) option.selected = true;
          selectEl.appendChild(option);
        });

        const entriesContainer = document.getElementById('preset-entries-container');
        entriesContainer.innerHTML = '';
        if (Array.isArray(preset.content) && preset.content.length > 0) {
          preset.content.forEach(entry => {
            const block = createPresetEntryBlock(entry);
            entriesContainer.appendChild(block);
          });
        } else {
          entriesContainer.innerHTML = '<p style="text-align:center; color: var(--text-secondary); margin-top: 20px;">还没有内容，点击下方按钮添加第一条吧！</p>';
        }
      }, 50);

    } catch (error) {
      console.error("打开预设编辑器时发生严重错误:", error);
      await showCustomAlert("加载失败", `加载预设详情时发生错误: ${error.message}`);
      showScreen('preset-screen');
    }
  }


  function createPresetEntryBlock(entry = {
    keys: [],
    comment: '',
    content: '',
    enabled: true
  }) {
    const block = document.createElement('div');
    block.className = 'message-editor-block';
    const isChecked = entry.enabled !== false ? 'checked' : '';


    block.innerHTML = `
        <div style="display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 5px;">
            <label class="toggle-switch" title="启用/禁用此条目">
                <input type="checkbox" class="entry-enabled-switch" ${isChecked}>
                <span class="slider"></span>
            </label>
            <button type="button" class="delete-block-btn" title="删除此条目">×</button>
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">备注 (可选)</label>
            <input type="text" class="entry-comment-input" value="${entry.comment || ''}" placeholder="例如：角色核心设定" style="padding: 8px;">
        </div>
        <div class="form-group" style="margin-bottom: 10px;">
            <label style="font-size: 0.8em;">关键词 (用英文逗号,分隔)</label>
            <input type="text" class="entry-keys-input" value="${(entry.keys || []).join(', ')}" placeholder="例如: key1, key2" style="padding: 8px;">
        </div>
        
        <!-- 这里是全新的、带有“展开/收起”按钮的结构 -->
        <div class="form-group" style="margin-bottom: 0;">
            <label style="font-size: 0.8em; display: flex; justify-content: space-between; align-items: center;">
                <span>内容 (点击右侧展开)</span>
                <button type="button" class="toggle-content-btn">展开</button>
            </label>
            <div class="entry-content-container">
                 <textarea class="entry-content-textarea" rows="8" style="width: 100%; font-size: 14px;">${entry.content || ''}</textarea>
            </div>
        </div>
    `;



    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());


    const toggleBtn = block.querySelector('.toggle-content-btn');
    const contentContainer = block.querySelector('.entry-content-container');
    toggleBtn.addEventListener('click', () => {
      const isHidden = contentContainer.style.display === 'none';
      contentContainer.style.display = isHidden ? 'block' : 'none';
      toggleBtn.textContent = isHidden ? '收起' : '展开';
    });

    return block;
  }


  async function openPresetCategoryManager() {
    await renderPresetCategoriesInManager();

    document.querySelector('#group-management-modal .modal-header span').textContent = '管理预设分类';
    document.getElementById('add-new-group-btn').onclick = addNewPresetCategory;
    document.getElementById('existing-groups-list').onclick = (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        deletePresetCategory(parseInt(e.target.dataset.id));
      }
    };
    document.getElementById('close-group-manager-btn').onclick = () => {
      document.getElementById('group-management-modal').classList.remove('visible');
      renderPresetScreen();
    };
    document.getElementById('group-management-modal').classList.add('visible');
  }

  async function renderPresetCategoriesInManager() {
    const listEl = document.getElementById('existing-groups-list');
    const categories = await db.presetCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `<span class="group-name">${cat.name}</span><span class="delete-group-btn" data-id="${cat.id}">×</span>`;
      listEl.appendChild(item);
    });
  }

  async function addNewPresetCategory() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) return alert('分类名不能为空！');
    const existing = await db.presetCategories.where('name').equals(name).first();
    if (existing) return alert(`分类 "${name}" 已经存在了！`);
    await db.presetCategories.add({
      name
    });
    input.value = '';
    await renderPresetCategoriesInManager();
  }

  async function deletePresetCategory(categoryId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分类后，该分类下的所有预设将变为“未分类”。确定吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.presetCategories.delete(categoryId);
      await db.presets.where('categoryId').equals(categoryId).modify({
        categoryId: null
      });


      state.presets = await db.presets.toArray();


      await renderPresetCategoriesInManager();
    }
  }



  async function handlePresetImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      if (!file.name.endsWith('.json')) {
        throw new Error("文件格式不支持。请选择 .json 格式的 Tavern 预设文件。");
      }

      const text = await file.text();
      const tavernData = JSON.parse(text);


      await importTavernPresetFile(tavernData, file.name);

    } catch (error) {
      console.error("预设导入失败:", error);
      await showCustomAlert("导入失败", `无法解析预设文件。\n错误: ${error.message}`);
    } finally {

      event.target.value = null;
    }
  }


  async function importTavernPresetFile(tavernData, fileName) {
    let newEntries = [];




    if (Array.isArray(tavernData.prompts) && Array.isArray(tavernData.prompt_order) && tavernData.prompt_order.length > 0) {
      console.log("检测到 Tavern/SillyTavern 预设格式，将严格按照 prompt_order 排序。");


      const promptsMap = new Map(tavernData.prompts.map(p => [p.identifier, p]));


      const orderArray = tavernData.prompt_order.reduce((acc, curr) => (
        (curr.order && curr.order.length > (acc.length || 0)) ? curr.order : acc
      ), []);

      if (orderArray && orderArray.length > 0) {
        newEntries = orderArray
          .map(orderItem => {

            const promptData = promptsMap.get(orderItem.identifier);
            if (promptData) {

              return {
                keys: [],
                comment: promptData.name || '无标题',
                content: promptData.content || '',

                enabled: orderItem.enabled
              };
            }
            return null;
          })
          .filter(Boolean);
      }
    } else if (tavernData.entries && typeof tavernData.entries === 'object') {
      console.log("检测到 'entries' 对象格式的预设，将尝试按顺序导入。");
      if (Array.isArray(tavernData.order)) {
        console.log("检测到 'order' 字段，将按指定顺序导入条目。");
        newEntries = tavernData.order
          .map(key => tavernData.entries[key])
          .filter(Boolean)
          .map(entry => ({
            keys: entry.key || [],
            comment: entry.comment || '无备注',
            content: entry.content || '',
            enabled: !entry.disable
          }));
      } else {
        console.warn("未在文件中找到 'order' 字段，条目可能无法按原始顺序导入。");
        newEntries = Object.values(tavernData.entries).map(entry => ({
          keys: entry.key || [],
          comment: entry.comment || '无备注',
          content: entry.content || '',
          enabled: !entry.disable
        }));
      }
    } else if (Array.isArray(tavernData.prompts)) {
      console.log("检测到简单的 'prompts' 数组格式，将按数组内顺序导入。");
      newEntries = tavernData.prompts.map(prompt => ({
        keys: [],
        comment: prompt.name || '无标题',
        content: prompt.content || '',
        enabled: true
      }));
    } else {
      throw new Error("文件格式无法识别。未找到有效的 'prompts' 数组或 'entries' 对象。");
    }



    newEntries = newEntries.filter(entry => entry.content);

    if (newEntries.length === 0) {
      alert("这个预设文件中没有找到任何有效的提示词条目。");
      return;
    }


    const presetNameSuggestion = fileName.replace(/\.json$/i, '');
    const newPresetName = await showCustomPrompt("导入 Tavern 预设", "请为这组提示词预设命名：", presetNameSuggestion);
    if (!newPresetName || !newPresetName.trim()) {
      alert("导入已取消，因为未提供名称。");
      return;
    }

    const newPreset = {
      id: 'preset_' + Date.now(),
      name: newPresetName.trim(),
      content: newEntries,
      categoryId: null
    };

    await db.presets.add(newPreset);
    state.presets.push(newPreset);

    await renderPresetScreen();
    await showCustomAlert('导入成功！', `已成功从文件导入预设《${newPresetName}》。`);
  }



  async function renderOfflinePresetSelector(chat) {
    const selectEl = document.getElementById('offline-preset-select');
    if (!selectEl) return;


    const presets = state.presets || [];


    selectEl.innerHTML = '<option value="">-- 不使用预设 --</option>';
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.id;
      option.textContent = preset.name;
      selectEl.appendChild(option);
    });


    if (chat.settings.offlinePresetId) {
      selectEl.value = chat.settings.offlinePresetId;
    }
  }


  function renderButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    editor.innerHTML = '';



    let buttonOrder = state.globalSettings.chatActionButtonsOrder || DEFAULT_BUTTON_ORDER;

    buttonOrder.forEach(buttonId => {
      const originalButton = document.getElementById(buttonId);
      if (originalButton) {
        const item = document.createElement('div');
        item.className = 'draggable-button-item';
        item.draggable = true;
        item.dataset.buttonId = buttonId;
        item.innerHTML = originalButton.innerHTML;
        editor.appendChild(item);
      }
    });
  }



  function initializeButtonOrderEditor() {
    const editor = document.getElementById('button-order-editor');
    if (!editor) return;

    let draggingItem = null;


    const handleDragStart = (e) => {
      const target = e.target.closest('.draggable-button-item');
      if (!target) return;

      draggingItem = target;
      draggingItem.classList.add('dragging');


      if (e.cancelable) e.preventDefault();
    };

    const handleDragMove = (e) => {
      if (!draggingItem) return;


      const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;

      const afterElement = getDragAfterElement(editor, clientX);

      if (afterElement == null) {
        editor.appendChild(draggingItem);
      } else {
        editor.insertBefore(draggingItem, afterElement);
      }
    };

    const handleDragEnd = () => {
      if (!draggingItem) return;

      draggingItem.classList.remove('dragging');
      draggingItem = null;


      saveButtonOrder();
    };



    editor.addEventListener('mousedown', handleDragStart);
    editor.addEventListener('touchstart', handleDragStart, {
      passive: false
    });


    editor.addEventListener('mousemove', handleDragMove);
    editor.addEventListener('touchmove', handleDragMove, {
      passive: false
    });


    editor.addEventListener('mouseup', handleDragEnd);
    editor.addEventListener('mouseleave', handleDragEnd);
    editor.addEventListener('touchend', handleDragEnd);
  }



  function getDragAfterElement(container, x) {

    const draggableElements = [...container.querySelectorAll('.draggable-button-item:not(.dragging)')];


    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();

      const offset = x - box.left - box.width / 2;


      if (offset < 0 && offset > closest.offset) {
        return {
          offset: offset,
          element: child
        };
      } else {
        return closest;
      }
    }, {
      offset: Number.NEGATIVE_INFINITY
    }).element;
  }


  async function saveButtonOrder() {
    const editor = document.getElementById('button-order-editor');
    const newOrder = Array.from(editor.querySelectorAll('.draggable-button-item')).map(item => item.dataset.buttonId);

    state.globalSettings.chatActionButtonsOrder = newOrder;
    await db.globalSettings.put(state.globalSettings);



  }

 
  function applyButtonOrder() {
    const buttonOrder = state.globalSettings.chatActionButtonsOrder;
    if (!buttonOrder || !Array.isArray(buttonOrder) || buttonOrder.length === 0) {
      return;
    }

    const container = document.getElementById('chat-input-actions-top');
    if (!container) return;


    buttonOrder.forEach(buttonId => {
      const button = document.getElementById(buttonId);
      if (button) {
        container.appendChild(button);
      }
    });
  }



  const DEFAULT_BUTTON_ORDER = [
    'open-sticker-panel-btn', 'send-photo-btn', 'upload-image-btn',
    'transfer-btn', 'voice-message-btn', 'send-waimai-request-btn',
    'video-call-btn', 'group-video-call-btn', 'send-poll-btn',
    'share-link-btn', 'share-location-btn', 'gomoku-btn',
    'open-shopping-btn', 'pat-btn', 'edit-last-response-btn',
    'regenerate-btn', 'propel-btn', 'show-announcement-board-btn',
    'werewolf-game-btn',

    'read-together-btn',
    'open-nai-gallery-btn',
    'open-todo-list-btn',
    'open-quick-reply-btn',
    'character-monitor-btn'
  ];


  async function resetButtonOrder() {

    state.globalSettings.chatActionButtonsOrder = null;
    await db.globalSettings.put(state.globalSettings);


    renderButtonOrderEditor();


    applyButtonOrder();


    await showCustomAlert("成功", "按钮顺序已恢复为默认设置！");
  }





  let selectedCharsForClear = [];
  let selectedTypesForClear = [];


  function openDataClearWizard() {
    const modal = document.getElementById('data-clear-wizard-modal');
    selectedCharsForClear = [];
    selectedTypesForClear = [];


    renderClearWizardStep1();


    document.getElementById('data-clear-step-1').style.display = 'flex';
    document.getElementById('data-clear-step-2').style.display = 'none';

    modal.classList.add('visible');
  }


  function renderClearWizardStep1() {
    const listEl = document.getElementById('data-clear-char-list');
    listEl.innerHTML = '';


    const userItem = document.createElement('div');
    userItem.className = 'clear-posts-item';
    userItem.dataset.charId = 'user';
    userItem.innerHTML = `
        <div class="checkbox"></div>
        <span class="name">${state.qzoneSettings.nickname || '我'} (用户)</span>
    `;
    listEl.appendChild(userItem);


    Object.values(state.chats).forEach(chat => {
      if (!chat.isGroup) {
        const charItem = document.createElement('div');
        charItem.className = 'clear-posts-item';
        charItem.dataset.charId = chat.id;
        charItem.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${chat.name} (角色)</span>
            `;
        listEl.appendChild(charItem);
      }
    });
  }


  function renderClearWizardStep2() {
    const listEl = document.getElementById('data-clear-type-list');
    listEl.innerHTML = '';

    const dataTypes = [{
        id: 'chat',
        name: '聊天记录',
        description: '将清空选定角色的所有对话消息、曾用备注和你的昵称。'
      },
      {
        id: 'qzone',
        name: '动态与互动',
        description: '将清空选定角色的所有动态、评论和点赞。'
      },
      {
        id: 'calls',
        name: '通话记录',
        description: '将清空选定角色的所有通话记录。'
      },
      {
        id: 'thoughts',
        name: '心声',
        description: '将清空选定角色的心声和散记历史。'
      },
      {
        id: 'memories',
        name: '长期记忆',
        description: '将清空选定角色的所有长期记忆。'
      },
      {
        id: 'favorites',
        name: '收藏',
        description: '将清空收藏夹中所有与该角色相关的内容（如聊天、动态、日记等）。'
      },
      {
        id: 'cphone',
        name: 'Cphone数据 (CPhone)',
        description: '将清空角色的相册、QQ、浏览器、淘宝、日记、备忘录等所有模拟手机数据。'
      },
      {
        id: 'todo',
        name: '待办事项 (To-Do)',
        description: '将清空选定角色的待办事项清单。(若第一步选“我”，则清除所有角色中由“我”创建的待办)'
      },
       {
            id: 'alipay_bills',
            name: '支付宝账单 (Alipay)',
            description: '将清空支付宝的所有交易流水、转账记录和基金买卖记录。(仅在第一步选择“我”时生效)'
        }
    ];

    dataTypes.forEach(type => {
      const item = document.createElement('div');
      item.className = 'clear-posts-item';
      item.dataset.typeId = type.id;
      item.innerHTML = `
                    <div class="checkbox"></div>
                    <div>
                        <span class="name">${type.name}</span>
                        <p style="font-size: 12px; color: #888; margin: 4px 0 0;">${type.description}</p>
                    </div>
                `;
      listEl.appendChild(item);
    });
  }



  function handleDataClearNext() {
    const selectedItems = document.querySelectorAll('#data-clear-char-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("请至少选择一个要清理的角色。");
      return;
    }

    selectedCharsForClear = Array.from(selectedItems).map(item => item.dataset.charId);


    renderClearWizardStep2();
    document.getElementById('data-clear-step-1').style.display = 'none';
    document.getElementById('data-clear-step-2').style.display = 'flex';
  }


  function handleDataClearBack() {
    document.getElementById('data-clear-step-2').style.display = 'none';
    document.getElementById('data-clear-step-1').style.display = 'flex';

    document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
      if (selectedCharsForClear.includes(item.dataset.charId)) {
        item.classList.add('selected');
      }
    });
  }


  async function handleConfirmDataClear() {
    const selectedItems = document.querySelectorAll('#data-clear-type-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("请至少选择一种要清理的数据类型。");
      return;
    }

    selectedTypesForClear = Array.from(selectedItems).map(item => item.dataset.typeId);

    const confirmed = await showCustomConfirm(
      '最后确认！',
      '此操作将永久删除您选择的所有数据，且无法恢复！确定要继续吗？', {
        confirmButtonClass: 'btn-danger',
        confirmText: '确认删除'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在执行清理操作，请不要关闭页面...");

    try {
      await db.transaction('rw', db.tables, async () => {
        for (const charId of selectedCharsForClear) {
          for (const type of selectedTypesForClear) {
            if (type === 'todo') {
                if (charId === 'user') {
                    // 如果第一步选的是“我 (用户)”，则遍历所有聊天，只删除 creator 为 'user' 的待办
                    const allChats = await db.chats.toArray();
                    for (const chat of allChats) {
                        if (chat.todoList && chat.todoList.length > 0) {
                            const originalLength = chat.todoList.length;
                            // 过滤掉用户创建的，保留AI创建的
                            chat.todoList = chat.todoList.filter(t => t.creator !== 'user');
                            
                            if (chat.todoList.length < originalLength) {
                                await db.chats.put(chat);
                            }
                        }
                    }
                    console.log("已清理所有由用户创建的待办事项");
                } else {
                    // 如果选的是具体角色，直接清空该角色的待办列表 (todoList)
                    const chat = await db.chats.get(charId);
                    if (chat) {
                        chat.todoList = []; // 直接置空
                        await db.chats.put(chat);
                        console.log(`已清空角色 ${chat.name} 的待办事项`);
                    }
                }
            }
            if (type === 'alipay_bills') {
                // 只有当第一步选择了“我(用户)”时，才执行清空，防止误操作
                if (charId === 'user') {
                    await db.userTransactions.clear(); // 清空账单表
                    console.log("支付宝账单已全部清空");
                    
                    // 可选：如果你还想重置钱包余额和基金持仓，可以解开下面注释
                    /*
                    const wallet = await db.userWallet.get('main');
                    if(wallet) {
                        wallet.balance = 0; // 重置余额
                        wallet.fundHoldings = []; // 重置基金
                        await db.userWallet.put(wallet);
                    }
                    */
                } else {
                    // 如果选择了某个角色，尝试删除该角色名字相关的账单(模糊匹配)
                    // 注意：这依赖于description包含角色名，可能不完全准确，建议只用上面的清空全部
                    const chat = await db.chats.get(charId);
                    if (chat) {
                        const nameKeys = [chat.name, chat.originalName];
                        // 这是一个比较耗时的过滤删除，但对于清理特定角色流水很有用
                        await db.userTransactions
                            .filter(t => nameKeys.some(k => t.description && t.description.includes(k)))
                            .delete();
                    }
                }
            }
            if (type === 'chat') {
              if (charId === 'user') {
                const allChats = await db.chats.toArray();
                for (const chat of allChats) {
                  chat.history = chat.history.filter(msg => msg.role !== 'user');
                  await db.chats.put(chat);
                }
              } else {
                const chat = await db.chats.get(charId);
                if (chat) {
                  chat.history = [];
                  chat.heartfeltVoice = '...';
                  chat.randomJottings = '...';
                  if (Array.isArray(chat.nameHistory)) {
                    chat.nameHistory = [];
                  }
                  if (chat.settings) {
                    chat.settings.myNickname = '我';
                  }
                  await db.chats.put(chat);
                }
              }
            }

            if (type === 'qzone') {
              const authorId = (charId === 'user') ? 'user' : charId;
              await db.qzonePosts.where('authorId').equals(authorId).delete();
            }

            if (type === 'calls' && charId !== 'user') {
              await db.callRecords.where('chatId').equals(charId).delete();
            }

            if (type === 'thoughts' && charId !== 'user') {
              const chat = await db.chats.get(charId);
              if (chat) {
                chat.thoughtsHistory = [];
                chat.heartfeltVoice = '...';
                chat.randomJottings = '...';
                await db.chats.put(chat);
              }
            }

            if (type === 'memories' && charId !== 'user') {
              const chat = await db.chats.get(charId);
              if (chat) {
                chat.longTermMemory = [];
                await db.chats.put(chat);
              }
            }


            if (type === 'favorites') {
              if (charId === 'user') {

                await db.favorites.where('type').equals('qzone_post').filter(fav => fav.content.authorId === 'user').delete();

                await db.favorites.where('type').equals('chat_message').filter(fav => fav.content.role === 'user').delete();
              } else {

                await db.favorites.where('type').equals('chat_message').and(fav => fav.chatId === charId).delete();

                await db.favorites.where('type').equals('qzone_post').filter(fav => fav.content.authorId === charId).delete();

                await db.favorites.where('type').equals('char_diary').filter(fav => fav.content.characterId === charId).delete();
                await db.favorites.where('type').equals('char_browser_article').filter(fav => fav.content.characterId === charId).delete();
                await db.favorites.where('type').equals('char_memo').filter(fav => fav.content.characterId === charId).delete();
              }
            }


            if (type === 'cphone' && charId !== 'user') {
              const chat = await db.chats.get(charId);
              if (chat) {
                chat.simulatedAlbum = [];
                chat.simulatedConversations = [];
                chat.simulatedBrowserHistory = [];
                chat.simulatedTaobaoHistory = null;
                chat.simulatedAmapHistory = [];
                chat.simulatedAppUsage = [];
                chat.simulatedMusicPlaylist = [];
                chat.diary = [];
                chat.memos = [];
                await db.chats.put(chat);
              }
            }
          }
        }
      });

      await loadAllDataFromDB();
      await renderChatList();
      const alipayScreen = document.getElementById('alipay-screen');
      if (alipayScreen && alipayScreen.classList.contains('active')) {
          // 如果你之前定义了 loadBills 函数
          if (typeof loadBills === 'function') {
              await loadBills(true); // true 代表重置并重新加载
          }
          // 同时更新余额显示（如果刚才解开了重置余额的注释）
          if (window.userBalance !== undefined) {
             const wallet = await db.userWallet.get('main');
             if(wallet) {
                 window.userBalance = wallet.balance;
                 document.getElementById('alipay-balance-display').textContent = window.userBalance.toFixed(2);
             }
          }
      }
      document.getElementById('data-clear-wizard-modal').classList.remove('visible');
      await showCustomAlert("清理完成", "指定的数据已成功清除。");

    } catch (error) {
      console.error("高级数据清理失败:", error);
      await showCustomAlert("清理失败", `操作失败: ${error.message}`);
    }
  }

  async function handleIconChange(iconId, phoneType, itemElement) {
    const appName = itemElement.querySelector('.icon-preview').alt;

    const choice = await showChoiceModal(`更换“${appName}”图标`, [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newUrl = null;
    let isBase64 = false;

    if (choice === 'local') {
        newUrl = await new Promise(resolve => { // 简化版 uploadImageLocally
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => resolve(readerEvent.target.result);
                    reader.readAsDataURL(file);
                } else {
                    resolve(null);
                }
            };
            input.click();
        });
        if (newUrl) isBase64 = true;
        
    } else if (choice === 'url') {
        const currentUrl = (phoneType === 'cphone') ?
            state.globalSettings.cphoneAppIcons[iconId] :
            state.globalSettings.appIcons[iconId];
        const isCurrentUrlBase64 = currentUrl && currentUrl.startsWith('data:image'); 
        
        const initialValueForPrompt = isCurrentUrlBase64 ? '' : currentUrl;
        
        newUrl = await showCustomPrompt(`更换图标`, '请输入新的图片URL', initialValueForPrompt, 'url');
        
     
        if (newUrl) isBase64 = false;
    }

    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        
        itemElement.querySelector('.icon-preview').src = trimmedUrl;

       
        const dbPath = (phoneType === 'cphone') ? `cphoneAppIcons.${iconId}` : `appIcons.${iconId}`;
        if (phoneType === 'cphone') {
            state.globalSettings.cphoneAppIcons[iconId] = trimmedUrl;
        } else {
            state.globalSettings.appIcons[iconId] = trimmedUrl;
        }
        await db.globalSettings.put(state.globalSettings);
        await showCustomAlert("成功", "图标已更新！");

        
        if (isBase64) {
            (async () => {
                console.log(`[ImgBB] 启动 ${dbPath} 的静默上传...`);
                await silentlyUpdateDbUrl(
                    db.globalSettings,
                    'main',
                    dbPath,
                    trimmedUrl // The Base64 string
                );
            })();
        }
    } else if (newUrl !== null) {
        alert("请输入一个有效的URL或选择一个文件！");
    }
  }


  async function compressAllLocalImages() {

    const confirmed = await showCustomConfirm(
      '确认压缩图片？',
      '此操作将扫描并压缩所有本地上传的图片（Base64格式），将其转换为JPEG以减小体积。这会轻微降低图片质量且【不可恢复】。<br><br><strong>强烈建议在操作前先进行数据备份！</strong>', {
        confirmButtonClass: 'btn-danger',
        confirmText: '我已了解风险，确认压缩'
      }
    );

    if (!confirmed) return;


    await showCustomAlert("请稍候...", "正在开始全面压缩图片，根据图片数量，这可能需要几分钟时间，请不要关闭或刷新页面...");

    let stats = {
      found: 0,
      compressed: 0,
      skipped: 0,
      originalSize: 0,
      newSize: 0
    };

    try {





      console.log("压缩步骤 1/3: 正在从数据库读取所有相关数据...");
      const tablesToScan = [
        'chats', 'globalSettings', 'qzoneSettings',
        'userStickers', 'customAvatarFrames'
      ];
      const allData = [];
      for (const tableName of tablesToScan) {
        const table = db.table(tableName);
        const records = await table.toArray();
        allData.push({
          tableName,
          records
        });
      }


      console.log("压缩步骤 2/3: 正在内存中异步压缩图片，这可能需要一些时间...");
      for (const data of allData) {
        for (const record of data.records) {

          await traverseAndCompress(record, stats);
        }
      }


      console.log("压缩步骤 3/3: 正在将压缩后的数据写回数据库...");
      await db.transaction('rw', tablesToScan, async () => {
        for (const data of allData) {

          await db.table(data.tableName).bulkPut(data.records);
        }
      });






      const reduction = stats.originalSize - stats.newSize;
      const reductionPercent = stats.originalSize > 0 ? (reduction / stats.originalSize * 100).toFixed(2) : 0;

      await showCustomAlert(
        '压缩完成！',
        `扫描完成！<br>
            - 共找到 ${stats.found} 张本地图片<br>
            - 成功压缩 ${stats.compressed} 张<br>
            - 跳过(已压缩或无需压缩) ${stats.skipped} 张<br>
            - 空间节省了 <strong>${(reduction / 1024 / 1024).toFixed(2)} MB</strong> (压缩率 ${reductionPercent}%)
            <br><br>
            建议刷新页面以应用所有更改。`
      );

    } catch (error) {
      console.error("图片压缩过程中发生错误:", error);
      await showCustomAlert('压缩失败', `操作失败: ${error.message}`);
    }
  }

  function calculateTotalSizeRecursive(obj, parentKey = '') {
    let totalSize = 0;
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        if (typeof value === 'string' && value.startsWith('data:image')) {

     
          const isExcluded =
          
            (parentKey === 'globalSettings' && (key === 'wallpaper' || key === 'cphoneWallpaper' || key === 'globalChatBackground')) ||
        
            (parentKey === 'widgetData') ||
      
            (parentKey === 'settings' && key === 'background') ||
       
            (parentKey === 'appIcons' || parentKey === 'cphoneAppIcons');

          if (!isExcluded) {
            totalSize += value.length;
          }
      

        } else if (typeof value === 'object' && value !== null) {
        
          totalSize += calculateTotalSizeRecursive(value, key);
        }
      }
    }
    return totalSize;
  }


  async function displayTotalImageSize() {
    const displayElement = document.getElementById('total-image-size-display');
    if (!displayElement) return;

    displayElement.innerHTML = `
        <span id="image-size-label">正在计算可压缩图片大小...</span>
        <span id="image-size-value">-- MB</span>
    `;

    try {
      let totalBytes = 0;
      const tablesToScan = [
        'chats', 'globalSettings', 'qzoneSettings',
        'userStickers', 'customAvatarFrames'
      ];

      for (const tableName of tablesToScan) {
        const table = db.table(tableName);
        await table.each(record => {

          totalBytes += calculateTotalSizeRecursive(record);
        });
      }

      const totalMB = (totalBytes / 1024 / 1024).toFixed(2);

      displayElement.innerHTML = `
            <span id="image-size-label">本地图片(头像/表情/头像框/等)大小:</span>
            <span id="image-size-value"><strong>${totalMB} MB</strong></span>
        `;

    } catch (error) {
      console.error("计算图片总大小时出错:", error);
      displayElement.innerHTML = `
            <span id="image-size-label">计算图片大小时出错</span>
            <span id="image-size-value">Error</span>
        `;
    }
  }

function calculateSkippedStats(obj) {
    let found = 0;
    let size = 0;
    if (typeof obj !== 'object' || obj === null) return {
        found,
        size
    };

    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const value = obj[key];
            if (typeof value === 'string' && value.startsWith('data:image')) {
                found++;
                size += value.length;
            } else if (typeof value === 'object' && value !== null) {
                const nestedStats = calculateSkippedStats(value);
                found += nestedStats.found;
                size += nestedStats.size;
            }
        }
    }
    return {
        found,
        size
    };
}

 async function traverseAndCompress(obj, stats, parentKey = '') {
    
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            
          
            if (parentKey === '' && (key === 'widgetData' || key === 'appIcons' || key === 'cphoneAppIcons')) {
                console.log(`跳过压缩整个对象: ${key}`);
                const {
                    found,
                    size
                } = calculateSkippedStats(obj[key]);
                stats.found += found;
                stats.skipped += found;
                stats.originalSize += size;
                stats.newSize += size;
                continue; 
            }

            const value = obj[key];

          
            if (typeof value === 'string' && value.startsWith('data:image')) {

               
                const isExcluded =
                    
                    (parentKey === '' && (key === 'wallpaper' || key === 'cphoneWallpaper' || key === 'globalChatBackground')) ||
                   
                    (parentKey === 'settings' && key === 'background');

                if (isExcluded) {
                    console.log(`跳过压缩背景图片: ${parentKey || 'global'}.${key}`);
                    stats.found++;
                    stats.skipped++;
                    stats.originalSize += value.length;
                    stats.newSize += value.length;
                    continue; 
                }

                stats.found++;
                stats.originalSize += value.length;
                
                const compressedBase64 = await compressImage(value);
                if (compressedBase64 && compressedBase64 !== value) {
                    obj[key] = compressedBase64;
                    stats.compressed++;
                    stats.newSize += compressedBase64.length;
                } else {
                    stats.skipped++;
                    stats.newSize += value.length;
                }
            

            } else if (typeof value === 'object' && value !== null) {
               
                await traverseAndCompress(value, stats, key);
            }
        }
    }
}


  async function compressImage(base64Str) {
 
    if (!base64Str.startsWith('data:image')) {
      return base64Str;
    }

    
    const MAX_BASE64_SIZE_TO_SKIP = 500000; 
    if (base64Str.startsWith('data:image/jpeg') && base64Str.length < MAX_BASE64_SIZE_TO_SKIP) {
      console.log('跳过压缩：图片已经是小体积JPEG。');
      return base64Str; 
    }
    
    try {
     
      const imageBlob = await (await fetch(base64Str)).blob();

    
      const SIZE_THRESHOLD_BYTES = 0.3 * 1024 * 1024; 
      if (imageBlob.size < SIZE_THRESHOLD_BYTES) {
          console.log(`跳过压缩：图片大小 (${(imageBlob.size / 1024 / 1024).toFixed(2)} MB) 已小于 0.3 MB。`);
          return base64Str; 
      }
    

    
      const options = {
        maxSizeMB: 0.5,      
        maxWidthOrHeight: 800,
        useWebWorker: true,
        initialQuality: 0.5,
        fileType: 'image/jpeg' 
      };

    

      console.log(`开始压缩图片，原始大小: ${(imageBlob.size / 1024 / 1024).toFixed(2)} MB`);
      const compressedFile = await imageCompression(imageBlob, options);
      console.log(`压缩完成，新的大小: ${(compressedFile.size / 1024 / 1024).toFixed(2)} MB`);

      
      if (compressedFile.size > imageBlob.size) {
          console.warn("压缩后的图片体积增大，已保留原始图片。");
          return base64Str;
      }

     
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(compressedFile);
      });

    } catch (error) {
      console.error("使用 browser-image-compression 压缩失败:", error);
      return base64Str; 
    }
  }

 
  function compareVersions(v1, v2) {

    if (!v1 || !v2 || typeof v1 !== 'string' || typeof v2 !== 'string') {
      return 0;
    }

    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);
    const len = Math.max(parts1.length, parts2.length);

    for (let i = 0; i < len; i++) {
      const p1 = parts1[i] || 0; // 如果部分不存在，则视为 0
      const p2 = parts2[i] || 0;

      if (p1 > p2) {
        return 1;
      }
      if (p1 < p2) {
        return -1;
      }
    }
    return 0;
  }


  async function checkForUpdates() {



    const CURRENT_APP_VERSION = "1.0";

    try {

      const response = await fetch('update-notice.html?_=' + Date.now());
      if (!response.ok) {
        console.warn('获取更新通知文件失败。');
        return;
      }
      const noticeHtml = await response.text();


      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = noticeHtml;
      const noticeContent = tempDiv.querySelector('[data-version]');

      if (!noticeContent) {
        console.error('更新通知文件中缺少 data-version 属性。');
        return;
      }

      const notificationVersion = noticeContent.dataset.version;


      const dismissedVersion = localStorage.getItem('dismissedUpdateVersion');



      if (!dismissedVersion || compareVersions(notificationVersion, dismissedVersion) > 0) {
        console.log(`发现新版本通知: ${notificationVersion} (已忽略版本: ${dismissedVersion || '无'})`);
        showUpdateNotice(notificationVersion, noticeContent.innerHTML);
      } else {
        console.log(`当前通知版本 (${notificationVersion}) 已被用户忽略或为旧版本，无需显示。`);
      }

    } catch (error) {
      console.error('检查更新时出错:', error);
    }
  }


  function showUpdateNotice(version, contentHtml) {
    const modal = document.getElementById('update-notice-modal');
    const body = document.getElementById('update-notice-body');
    const confirmBtn = document.getElementById('update-notice-confirm-btn');
    const dismissBtn = document.getElementById('update-notice-dismiss-btn');

    body.innerHTML = contentHtml;


    confirmBtn.disabled = true;
    dismissBtn.disabled = true;

  
    const confirmOriginalText = confirmBtn.textContent;
    let countdown = 10;
    confirmBtn.textContent = `${confirmOriginalText} (${countdown}s)`;


    const countdownInterval = setInterval(() => {
      countdown--;
      if (countdown > 0) {
      
        confirmBtn.textContent = `${confirmOriginalText} (${countdown}s)`;
      } else {
       
        clearInterval(countdownInterval); 
        confirmBtn.disabled = false; 
        dismissBtn.disabled = false; 
        confirmBtn.textContent = confirmOriginalText;
      }
    }, 1000);

 
    confirmBtn.onclick = () => {
      clearInterval(countdownInterval); 
      modal.classList.remove('visible');
      confirmBtn.textContent = confirmOriginalText; 
    };

    dismissBtn.onclick = () => {
      clearInterval(countdownInterval);
      localStorage.setItem('dismissedUpdateVersion', version);
      modal.classList.remove('visible');
      console.log(`用户已忽略版本: ${version}`);
      confirmBtn.textContent = confirmOriginalText; 
    };

  

    modal.classList.add('visible');
  }




 
  function openDoubanSettingsModal() {
    const modal = document.getElementById('douban-settings-modal');


    document.getElementById('douban-min-posts-input').value = state.globalSettings.doubanMinPosts || 12;
    document.getElementById('douban-max-posts-input').value = state.globalSettings.doubanMaxPosts || 20;

    modal.classList.add('visible');
  }


  async function saveDoubanSettings() {
    const minInput = document.getElementById('douban-min-posts-input');
    const maxInput = document.getElementById('douban-max-posts-input');

    const min = parseInt(minInput.value);
    const max = parseInt(maxInput.value);


    if (isNaN(min) || isNaN(max) || min < 1 || max < 1) {
      alert("请输入有效的正整数！");
      return;
    }
    if (min > max) {
      alert("最小帖子数不能大于最大帖子数！");
      return;
    }


    state.globalSettings.doubanMinPosts = min;
    state.globalSettings.doubanMaxPosts = max;
    await db.globalSettings.put(state.globalSettings);


    document.getElementById('douban-settings-modal').classList.remove('visible');
    await showCustomAlert('保存成功', '豆瓣设置已更新！下次重新生成时将生效。');
  }


  async function openWerewolfLobby(mode) {
    const modal = document.getElementById('werewolf-lobby-modal');
    const listEl = document.getElementById('werewolf-player-selection-list');
    listEl.innerHTML = '';

    let potentialPlayers = [];

    if (mode === 'global') {
      const characters = Object.values(state.chats).filter(c => !c.isGroup);
      const npcs = await db.npcs.toArray();
      potentialPlayers = [

        {
          id: 'user',
          name: state.qzoneSettings.nickname || '我',
          originalName: state.qzoneSettings.nickname || '我',
          avatar: state.qzoneSettings.avatar,
          type: 'user'
        },

        ...characters.map(c => ({
          id: c.id,
          name: c.name,
          originalName: c.originalName,
          avatar: c.settings.aiAvatar,
          type: 'character'
        })),

        ...npcs.map(n => ({
          id: `npc_${n.id}`,
          name: n.name,
          originalName: n.name,
          avatar: n.avatar,
          type: 'npc'
        }))
      ];
      werewolfGameState.chatId = null;
    } else {
      const chat = state.chats[state.activeChatId];
      if (!chat || !chat.isGroup) return;

      potentialPlayers = [

        {
          id: 'user',
          name: chat.settings.myNickname || '我',
          originalName: state.qzoneSettings.nickname || '我',
          avatar: chat.settings.myAvatar,
          type: 'user'
        },

        ...chat.members.map(m => {
          const char = state.chats[m.id];
          const memberAvatar = m.avatar || (char ? char.settings.aiAvatar : defaultGroupMemberAvatar);
          return {
            id: m.id,
            name: m.groupNickname,
            originalName: m.originalName,
            avatar: memberAvatar,
            type: m.isNpc ? 'npc' : 'character'
          };
        })
      ];
      werewolfGameState.chatId = state.activeChatId;
    }

    potentialPlayers.forEach(player => {
      const item = document.createElement('div');
      item.className = 'contact-picker-item';
      item.innerHTML = `
            <input type="checkbox" class="werewolf-player-checkbox" data-player-json='${JSON.stringify(player)}' ${player.type === 'user' ? 'checked disabled' : 'checked'}>
            <img src="${player.avatar}" class="avatar">
            <span class="name">${player.name}</span>
        `;
      listEl.appendChild(item);
    });

    modal.classList.add('visible');
  }

 
  async function initializeWerewolfGame() {
    const selectedCheckboxes = document.querySelectorAll('.werewolf-player-checkbox:checked');
    const playerCount = selectedCheckboxes.length;

    let roles = [];
    if (playerCount === 6) {
      werewolfGameState.gameMode = '6p';
      roles = ['狼人', '狼人', '平民', '平民', '预言家', '猎人'];
    } else if (playerCount === 9) {
      werewolfGameState.gameMode = '9p';
      roles = ['狼人', '狼人', '狼人', '平民', '平民', '平民', '预言家', '女巫', '猎人'];
    } else if (playerCount === 12) {
      werewolfGameState.gameMode = '12p';
      roles = ['狼人', '狼人', '狼人', '狼人', '平民', '平民', '平民', '平民', '预言家', '女巫', '猎人', '守卫'];
    } else {
      alert(`当前人数 ${playerCount} 不支持。请选择6、9或12人。`);
      return;
    }

    document.getElementById('werewolf-lobby-modal').classList.remove('visible');
    await showCustomAlert('正在发牌...', '游戏即将开始，正在为各位玩家分配身份...');

    for (let i = roles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [roles[i], roles[j]] = [roles[j], roles[i]];
    }

    const selectedPlayers = Array.from(selectedCheckboxes).map(cb => JSON.parse(cb.dataset.playerJson));
    werewolfGameState.players = [];

    for (let i = 0; i < selectedPlayers.length; i++) {
      const playerInfo = selectedPlayers[i];
      const role = roles[i];

      let character_persona = "一个普通玩家";
      if (playerInfo.type === 'character') {
        const char = state.chats[playerInfo.id];
        character_persona = char ? char.settings.aiPersona : '未知设定的角色';
      } else if (playerInfo.type === 'npc') {
        const npcs = await db.npcs.toArray();
        const npc = npcs.find(n => `npc_${n.id}` === playerInfo.id);
        character_persona = npc ? npc.persona : '未知设定的NPC';
      } else if (playerInfo.type === 'user') {
        const activeChat = werewolfGameState.chatId ? state.chats[werewolfGameState.chatId] : null;
        character_persona = activeChat ? activeChat.settings.myPersona : '我是谁呀。';
      }

      const playerObject = {
        ...playerInfo,
        role: role,
        isAlive: true,
        character_persona: character_persona
      };


      if (role === '女巫') {
        playerObject.antidoteUsed = false;
        playerObject.poisonUsed = false;
      }
      if (role === '守卫') {
        playerObject.lastGuardedId = null;
      }


      werewolfGameState.players.push(playerObject);
    }

    werewolfGameState.isActive = true;
    werewolfGameState.currentDay = 1;
    werewolfGameState.currentPhase = 'start';
    werewolfGameState.gameLog = [];
    werewolfGameState.discussionLog = [];

    const roleCounts = roles.reduce((acc, role) => {
      acc[role] = (acc[role] || 0) + 1;
      return acc;
    }, {});
    const roleSummary = Object.entries(roleCounts).map(([role, count]) => `${role} x${count}`).join('、');
    addGameLog(`游戏配置：${playerCount}人局，身份为 ${roleSummary}。`);

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

    renderWerewolfScreen();
    showScreen('werewolf-game-screen');

    showMyRole(myPlayer.role);
  }



  function renderWerewolfScreen() {
    const gridEl = document.getElementById('werewolf-player-grid');
    gridEl.innerHTML = '';
    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => a.isAlive - b.isAlive);

    sortedPlayers.forEach((p, index) => {
      const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
      const avatarEl = document.createElement('div');
      avatarEl.className = 'werewolf-player-avatar';
      if (!p.isAlive) avatarEl.classList.add('dead');
      avatarEl.innerHTML = `
            <img src="${p.avatar}">
            <span class="player-name">${playerIndex}. ${p.name}</span>
        `;
      gridEl.appendChild(avatarEl);
    });

    const logEl = document.getElementById('werewolf-log');
    logEl.innerHTML = '';


    for (let day = 1; day <= werewolfGameState.currentDay; day++) {

      const logsThisDay = [
        ...werewolfGameState.gameLog.filter(entry => entry.day === day),
        ...werewolfGameState.discussionLog.filter(entry => entry.day === day)
      ].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));


      if (logsThisDay.length > 0) {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'werewolf-log-entry system';
        dayHeader.textContent = `--- 第 ${day} 天 ---`;
        dayHeader.style.cssText = 'font-weight: bold; background: rgba(255, 193, 7, 0.2);';
        logEl.appendChild(dayHeader);


        logsThisDay.forEach(entry => {
          const entryEl = document.createElement('div');
          entryEl.className = `werewolf-log-entry ${entry.type}`;
          if (entry.type === 'dialogue') {
            entryEl.innerHTML = `<span class="speaker">${entry.speaker}:</span> ${entry.content}`;
          } else {
            entryEl.textContent = entry.content;
          }
          logEl.appendChild(entryEl);
        });
      }
    }


    logEl.scrollTop = logEl.scrollHeight;


    const phaseMap = {
      'start': '游戏开始',
      'night': `第${werewolfGameState.currentDay}天 - 夜晚`,
      'day': `第${werewolfGameState.currentDay}天 - 白天`,
      'discussion': `第${werewolfGameState.currentDay}天 - 讨论`,
      'voting': `第${werewolfGameState.currentDay}天 - 投票`,
      'gameover': '游戏结束'
    };
    document.getElementById('werewolf-game-title').textContent = `狼人杀 - ${phaseMap[werewolfGameState.currentPhase] || werewolfGameState.currentPhase}`;
  }



  function showMyRole(role) {
    const roleDescriptions = {
      '狼人': '你的目标是杀死所有好人。每晚可以和同伴一起刀一个玩家。',
      '平民': '你没有任何特殊能力，你的目标是通过投票放逐所有狼人。',
      '预言家': '每晚可以查验一个玩家的身份是好人还是狼人。',
      '猎人': '当你死亡时，你可以选择带走场上任意一名玩家。',
      '女巫': '你有一瓶解药和一瓶毒药，解药可以救活当晚被杀的玩家，毒药可以毒死任意一名玩家。',
      '守卫': '每晚可以守护一名玩家，使其免受狼人袭击。不能连续两晚守护同一个人。'
    };

    document.getElementById('werewolf-role-name').textContent = role;
    document.getElementById('werewolf-role-description').textContent = roleDescriptions[role] || '一个神秘的角色。';
    document.getElementById('werewolf-role-modal').classList.add('visible');
  }

  async function executeNightPhase() {
    werewolfGameState.currentPhase = `第${werewolfGameState.currentDay}天 - 夜晚`;
    werewolfGameState.nightActions = {};
    addGameLog('天黑请闭眼...');
    renderWerewolfScreen();

    document.getElementById('werewolf-action-bar').style.display = 'none';
    document.getElementById('werewolf-retry-btn').style.display = 'none';
    await new Promise(resolve => setTimeout(resolve, 1500));


    const guard = werewolfGameState.players.find(p => p.role === '守卫' && p.isAlive);
    if (guard) {
      addGameLog('守卫请睁眼，请选择要守护的玩家。');
      renderWerewolfScreen();
      let guardedId = null;
      if (guard.id === 'user') {
        guardedId = await openSelectionModal('guard', guard.lastGuardedId);
      } else {
        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== guard.lastGuardedId);
        if (potentialTargets.length > 0) {
          guardedId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
        }
      }
      if (guardedId) {
        werewolfGameState.nightActions.guardedId = guardedId;
        guard.lastGuardedId = guardedId;
      }
      addGameLog('守卫已行动，守卫请闭眼。');
      renderWerewolfScreen();
      await new Promise(resolve => setTimeout(resolve, 1500));
    }



    addGameLog('狼人请睁眼，请选择要刀的玩家。');
    renderWerewolfScreen();

    const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
    const userIsWolf = wolves.some(p => p.id === 'user');

    let wolfTargetId = null;


    werewolfGameState.lastFailedAction = 'wolfKill';
    try {
      if (userIsWolf) {
        addGameLog('你是狼人，请选择刀人目标。');
        renderWerewolfScreen();
        wolfTargetId = await openWolfKillModal();
      } else {

        if (werewolfGameState.currentDay === 1) {
          console.log("第一夜，执行本地随机刀人逻辑...");
          const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');
          if (potentialTargets.length > 0) {
            wolfTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
          }
        } else {

          wolfTargetId = await getAiWolfKillTarget();
        }
      }

      werewolfGameState.lastFailedAction = null;
    } catch (error) {
      console.error("狼人行动API失败:", error);
      await showCustomAlert("操作失败", "AI狼人团队无法决定目标，游戏暂停。请点击右上角的“重试”按钮继续。");
      document.getElementById('werewolf-retry-btn').style.display = 'block';
      return;
    }

    werewolfGameState.nightActions.killedId = wolfTargetId;
    addGameLog('狼人已行动，狼人请闭眼。');
    renderWerewolfScreen();
    await new Promise(resolve => setTimeout(resolve, 1500));


    const witch = werewolfGameState.players.find(p => p.role === '女巫' && p.isAlive);
    if (witch) {
      addGameLog('女巫请睁眼。');
      renderWerewolfScreen();
      const killedPlayer = werewolfGameState.players.find(p => p.id === werewolfGameState.nightActions.killedId);


      const isGuarded = werewolfGameState.nightActions.guardedId === werewolfGameState.nightActions.killedId;


      const playerToShowWitch = (isGuarded || !killedPlayer) ? null : killedPlayer;

      if (witch.id === 'user') {
        let userWitchAction = await openWitchActionModal(playerToShowWitch, witch);
        if (userWitchAction.save) {
          werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
          witch.antidoteUsed = true;
        }
        if (userWitchAction.poison) {
          werewolfGameState.nightActions.poisonedId = userWitchAction.poison;
          witch.poisonUsed = true;
        }
      } else {

        if (!witch.antidoteUsed && playerToShowWitch) {
          let saveChance = 0;
          if (werewolfGameState.currentDay === 1) {

            saveChance = 0.3;
          } else {

            saveChance = 0.8;
          }

          console.log(`AI女巫决策：今天是第${werewolfGameState.currentDay}天，救人概率为 ${saveChance * 100}%`);

          if (Math.random() < saveChance) {
            console.log("AI女巫决定使用解药！");
            werewolfGameState.nightActions.savedId = werewolfGameState.nightActions.killedId;
            witch.antidoteUsed = true;
          } else {
            console.log("AI女巫决定保留解药。");
          }
        }


        if (!werewolfGameState.nightActions.savedId && !witch.poisonUsed && Math.random() < 0.5) {
          const poisonTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== werewolfGameState.nightActions.killedId);
          if (poisonTargets.length > 0) {
            const target = poisonTargets[Math.floor(Math.random() * poisonTargets.length)];
            werewolfGameState.nightActions.poisonedId = target.id;
            witch.poisonUsed = true;
            console.log(`AI女巫决定使用毒药，目标是: ${target.name}`);
          }
        }

      }
      addGameLog('女巫已行动，女巫请闭眼。');
      renderWerewolfScreen();
      await new Promise(resolve => setTimeout(resolve, 1500));
    }


    const prophet = werewolfGameState.players.find(p => p.role === '预言家' && p.isAlive);
    if (prophet) {
      addGameLog('预言家请睁眼，请选择要查验的玩家。');
      renderWerewolfScreen();

      if (prophet.id === 'user') {
        const targetId = await openSelectionModal('prophet');
        const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
        if (targetPlayer) {
          const isWolf = targetPlayer.role === '狼人';
          await showCustomAlert('查验结果', `你查验的玩家 ${targetPlayer.name} 的身份是：${isWolf ? '狼人' : '好人'}`);
          werewolfGameState.nightActions.prophetCheck = {
            target: targetId,
            result: isWolf ? '狼人' : '好人'
          };
        }
      } else {
        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== prophet.id);
        if (potentialTargets.length > 0) {
          const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
          werewolfGameState.nightActions.prophetCheck = {
            target: target.id,
            result: target.role === '狼人' ? '狼人' : '好人'
          };
        }
      }
      addGameLog('预言家已行动，预言家请闭眼。');
      renderWerewolfScreen();
      await new Promise(resolve => setTimeout(resolve, 1500));
    }


    executeDayPhase();
  }


  async function executeDayPhase() {
    werewolfGameState.currentPhase = `第${werewolfGameState.currentDay}天 - 白天`;
    werewolfGameState.voteResults = {};
    addGameLog('天亮了。');

    const {
      killedId,
      guardedId,
      savedId,
      poisonedId
    } = werewolfGameState.nightActions;
    const deathsThisNight = new Set();


    if (killedId && killedId !== guardedId && killedId !== savedId) {
      deathsThisNight.add(killedId);
    }


    if (poisonedId) {

      deathsThisNight.add(poisonedId);
    }


    if (deathsThisNight.size === 0) {
      addGameLog('昨晚是平安夜。');
    } else {
      for (const deadPlayerId of deathsThisNight) {
        const deadPlayer = werewolfGameState.players.find(p => p.id === deadPlayerId);
        if (deadPlayer && deadPlayer.isAlive) {
          deadPlayer.isAlive = false;
          addGameLog(`昨晚 ${deadPlayer.name} 死亡了。`);


          if (deadPlayer.role === '猎人') {
            addGameLog('猎人死亡，请选择一名玩家带走！');
            renderWerewolfScreen();
            let hunterTargetId = null;
            if (deadPlayer.id === 'user') {
              hunterTargetId = await openSelectionModal('hunter');
            } else {
              const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== deadPlayer.id);
              if (potentialTargets.length > 0) {
                hunterTargetId = potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
              }
            }
            const targetPlayer = werewolfGameState.players.find(p => p.id === hunterTargetId);
            if (targetPlayer) {
              targetPlayer.isAlive = false;
              addGameLog(`猎人带走了 ${targetPlayer.name}。`);
            }
          }
        }
      }
    }

    renderWerewolfScreen();

    if (checkGameOver()) return;

    await startDiscussionPhase();
  }


 
  async function startDiscussionPhase() {



    addGameLog('现在开始讨论，请各位玩家依次发言。');
    renderWerewolfScreen();

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成对话。');
      return;
    }

    const systemPrompt = buildWerewolfPrompt();
    werewolfGameState.lastFailedAction = 'startDiscussion';
    try {
      await showCustomAlert("请稍候", "正在等待AI角色们进行激烈的讨论...");

      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: '请所有AI角色根据你们的身份和人设开始发言。'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.95,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API 错误: ${errorData.error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch) {
        throw new Error(`AI返回的讨论内容格式不正确。原始返回: ${aiResponseContent}`);
      }
      const dialogues = JSON.parse(jsonMatch[0]);

      for (const dialogue of dialogues) {
        if (dialogue.speaker_name && dialogue.dialogue) {
          addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
          renderWerewolfScreen();
          await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
        }
      }

      werewolfGameState.lastFailedAction = null;

    } catch (error) {
      console.error("狼人杀AI讨论生成失败:", error);
      await showCustomAlert("AI 发言失败", `讨论无法开始，游戏暂停。请点击右上角的“重试”按钮继续。\n错误: ${error.message}`);
      document.getElementById('werewolf-retry-btn').style.display = 'block';
      return;
    }

    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    const actionBar = document.getElementById('werewolf-action-bar');
    const waitReplyBtn = document.getElementById('werewolf-wait-reply-btn');
    const finishSpeechBtn = document.getElementById('werewolf-finish-speech-btn');
    const userInput = document.getElementById('werewolf-user-input');

    actionBar.style.display = 'flex';

    if (myPlayer && myPlayer.isAlive) {
      waitReplyBtn.textContent = '等待回应';
      finishSpeechBtn.textContent = '结束发言';
      waitReplyBtn.style.display = 'block';
      finishSpeechBtn.style.display = 'block';
      userInput.disabled = false;
      userInput.placeholder = "轮到你发言了...";
      userInput.focus();

      const newWaitBtn = waitReplyBtn.cloneNode(true);
      waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
      newWaitBtn.addEventListener('click', handleWerewolfWaitReply);

      const newFinishBtn = finishSpeechBtn.cloneNode(true);
      finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
      newFinishBtn.addEventListener('click', handleUserWerewolfSpeech);

    } else {
      addGameLog('你已经死亡，无法发言。请等待其他玩家发言结束。');
      renderWerewolfScreen();

      waitReplyBtn.textContent = '继续讨论';
      finishSpeechBtn.textContent = '进入投票';
      waitReplyBtn.style.display = 'block';
      finishSpeechBtn.style.display = 'block';
      userInput.disabled = true;
      userInput.placeholder = "你已死亡，正在围观...";

      const newWaitBtn = waitReplyBtn.cloneNode(true);
      waitReplyBtn.parentNode.replaceChild(newWaitBtn, waitReplyBtn);
      newWaitBtn.addEventListener('click', handleAiContinueDiscussion);

      const newFinishBtn = finishSpeechBtn.cloneNode(true);
      finishSpeechBtn.parentNode.replaceChild(newFinishBtn, finishSpeechBtn);
      newFinishBtn.addEventListener('click', startVotingPhase);
    }
  }



  function buildWerewolfPrompt() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const myPlayerObject = werewolfGameState.players.find(p => p.id === 'user');
    const myPlayerName = myPlayerObject ? myPlayerObject.name : '用户';
    const isUserAlive = alivePlayers.some(p => p.id === 'user');


    let charactersAndPlayersDossier = "# 角色与玩家档案 (Character & Player Dossiers)\n";
    charactersAndPlayersDossier += "这是所有在场玩家的公开信息、人设和社交背景。\n";

    alivePlayers.forEach((p, i) => {
      const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;

      let socialContext = '';
      const playerChat = state.chats[p.id];

      if (playerChat) {
        const friendsInGame = alivePlayers.filter(otherPlayer =>
          otherPlayer.id !== p.id &&
          state.chats[otherPlayer.id] &&
          state.chats[otherPlayer.id].groupId === playerChat.groupId &&
          playerChat.groupId !== null
        ).map(friend => friend.name).join('、');

        if (friendsInGame) {
          socialContext += `- **你的好友 (必须保护)**: 你和 ${friendsInGame} 是同一个分组的好友。\n`;
        }
      }
      if (p.id !== 'user') {
        socialContext += `- **与用户的关系**: 你和用户(${myPlayerName})的关系请参考你的人设、长期记忆和最近的对话。\n`;
      }

      charactersAndPlayersDossier += `
## ${playerIndex}号玩家: ${p.name} (这是TA的昵称)
- **本名 (你在对话中必须用这个名字称呼TA)**: ${p.originalName}
- **身份**: ${p.id === 'user' ? '【用户 (User)】' : '【AI角色】'}
- **人设 (必须严格遵守)**: ${p.character_persona}
`;

      if (p.type === 'character') {
        const char = state.chats[p.id];
        if (char && char.longTermMemory && char.longTermMemory.length > 0) {
          const memoryContent = char.longTermMemory.map(mem => mem.content).join('; ');
          charactersAndPlayersDossier += `- **长期记忆 (必须参考)**: ${memoryContent}\n`;
        }
      }
      if (socialContext) {
        charactersAndPlayersDossier += `
- **你的社交关系 (必须参考)**:
${socialContext}`;
      }
    });


    let nightEventSummary = "# 昨晚事件总结 (Night Event Summary)\n";
    nightEventSummary += "这是所有玩家都能听到的【公开信息】。\n";
    const deathsThisNight = werewolfGameState.gameLog.filter(entry => entry.content.includes('死亡了') && entry.day === werewolfGameState.currentDay);
    if (deathsThisNight.length === 0) {
      nightEventSummary += "- 昨晚是平安夜，无人死亡。\n";
    } else {
      deathsThisNight.forEach(death => {
        nightEventSummary += `- ${death.content}\n`;
      });
    }


    let previousDaysSummary = "# 前几日完整历史回顾 (Full Recap of Previous Days)\n";
    if (werewolfGameState.currentDay > 1) {
      for (let day = 1; day < werewolfGameState.currentDay; day++) {
        previousDaysSummary += `\n**--- 第 ${day} 天 ---**\n`;
        const eventsThisDay = werewolfGameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('死亡') || entry.content.includes('放逐')));
        if (eventsThisDay.length > 0) {
          previousDaysSummary += `*事件*: ${eventsThisDay.map(e => e.content).join(' ')}\n`;
        } else {
          previousDaysSummary += "*事件*: 平安夜，无人出局。\n";
        }
        const discussionsThisDay = werewolfGameState.discussionLog.filter(entry => entry.day === day);
        if (discussionsThisDay.length > 0) {
          previousDaysSummary += `*讨论记录*:\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
        }
      }
    } else {
      previousDaysSummary += "(今天是第一天，没有历史记录)\n";
    }


    let discussionHistoryContext = "# 今日完整讨论记录 (Today's Full Discussion Record)\n";
    const todayDiscussions = werewolfGameState.discussionLog.filter(entry => entry.day === werewolfGameState.currentDay);
    if (todayDiscussions.length > 0) {
      discussionHistoryContext += todayDiscussions.map(d => `- **${d.speaker}**: ${d.content}`).join('\n');
    } else {
      discussionHistoryContext += "(你是第一个发言的人)";
    }


    let internalMonologueBuilder = `
# 【逻辑隔离与TGS三核思考 (最高优先级指令)】
为了兼顾游戏逻辑和角色扮演，你【必须】在内部为【每一个AI角色】按顺序执行以下“三阶段思考”：

## 阶段1：内部独立思考 (Internal Monologue Scratchpad)
(这部分内容【绝对不能】出现在你最终的JSON输出中，这仅供你内部模拟使用)
`;


    alivePlayers.forEach(p => {
      if (p.id !== 'user') { // 只为AI角色生成思考模块
        const playerIndex = werewolfGameState.players.findIndex(player => player.id === p.id) + 1;
        internalMonologueBuilder += `
### 正在模拟 ${playerIndex}号玩家: ${p.name} (本名: ${p.originalName})

#### 阶段 A：数据输入 (Data Input)
1.  **我的秘密身份**: 我是【${p.role}】。
2.  **我掌握的秘密信息 (仅我可见)**:
`;

        // 1. 注入秘密
        let playerSecrets = "";
        if (p.role === '狼人') {
          const teammates = werewolfGameState.players.filter(t => t.role === '狼人' && t.id !== p.id && t.isAlive).map(t => t.name).join('、');
          playerSecrets += `    - 我的狼队友是：${teammates || '无'}\n`;
          const killedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.killedId);
          playerSecrets += `    - 我们昨晚攻击了：${killedPlayer ? killedPlayer.name : '空刀'}\n`;
        }
        if (p.role === '预言家' && werewolfGameState.nightActions.prophetCheck) {
          const checkedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.prophetCheck.target);
          playerSecrets += `    - 我昨晚查验了 ${checkedPlayer.name}，TA的身份是：【${werewolfGameState.nightActions.prophetCheck.result}】\n`;
        }
        if (p.role === '女巫') {
          if (werewolfGameState.nightActions.savedId) {
            const savedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.savedId);
            playerSecrets += `    - 我昨晚用解药救了 ${savedPlayer.name}。\n`;
          }
          if (werewolfGameState.nightActions.poisonedId) {
            const poisonedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.poisonedId);
            playerSecrets += `    - 我昨晚用毒药毒了 ${poisonedPlayer.name}。\n`;
          }
          playerSecrets += `    - 我的解药：${p.antidoteUsed ? '已使用' : '未使用'}\n`;
          playerSecrets += `    - 我的毒药：${p.poisonUsed ? '已使用' : '未使用'}\n`;
        }
        if (p.role === '守卫') {
          if (werewolfGameState.nightActions.guardedId) {
            const guardedPlayer = werewolfGameState.players.find(pl => pl.id === werewolfGameState.nightActions.guardedId);
            playerSecrets += `    - 我昨晚守护了 ${guardedPlayer.name}。\n`;
          } else {
            playerSecrets += `    - 我昨晚空守了。\n`;
          }
        }
        if (playerSecrets === "") {
          playerSecrets = "    - 我没有掌握任何特殊的夜晚信息。\n";
        }
        internalMonologueBuilder += playerSecrets;

        // 2. 注入公开信息
        internalMonologueBuilder += `3.  **我看到的公开信息 (所有人可见)**:
    - **昨晚事件**: ${nightEventSummary.replace(/\n/g, ' ')}
    - **今日讨论**: ${discussionHistoryContext.replace(/\n/g, ' ')}
4.  **我的人设与社交关系**:
    - **人设**: ${p.character_persona}
    - **社交**: 
`;
        // 3. 注入社交关系
        let socialContext = "";
        const playerChat = state.chats[p.id];
        if (playerChat) {
          const friendsInGame = alivePlayers.filter(otherPlayer =>
            otherPlayer.id !== p.id && state.chats[otherPlayer.id] &&
            state.chats[otherPlayer.id].groupId === playerChat.groupId && playerChat.groupId !== null
          ).map(friend => friend.name).join('、');
          if (friendsInGame) {
            socialContext += `      - ${friendsInGame} 是我的好友。\n`;
          }
        }
        if (p.id !== 'user') {
          socialContext += `      - ${myPlayerName} 是我的重要互动对象（用户）。\n`;
        }
        if (socialContext === "") {
          socialContext = "      - 我在此次游戏中没有特别的社交关系。\n";
        }
        internalMonologueBuilder += socialContext;

     
        internalMonologueBuilder += `
#### 阶段 B：TGS 融合思考 (Task-Game-Social)
1.  **T (Task - 游戏任务)**: 基于我的身份和秘密，我的【逻辑目标】是 (例如：找出狼人 / 悍跳预言家 / 隐藏身份 / 保护队友 / 攻击${myPlayerName})。
2.  **G (Game - 游戏互动)**: 针对【今日讨论】中 ${todayDiscussions.length > 0 ? '其他人的发言' : '昨晚的死讯'}，我的看法是... 我【必须】回应...
3.  **S (Social - 社交表演)**: 我要如何用我的【人设】和【社交关系】来包装我的发言？
    - (例如：我的好友 ${myPlayerName} 被怀疑了，虽然我的逻辑也怀疑TA，但我的表演必须是维护TA的：“我不觉得${myPlayerName}是狼...”)
    - (例如：我的敌人发言了，我的表演就是无视TA的逻辑，直接攻击TA。)
    - (例如：我是一个${p.role}，我的人设很${p.character_persona.substring(0, 20)}...，所以我决定这样说...)

#### 阶段 C：最终发言稿 (草稿)
(结合T, G, S的思考，我准备这样说：...)
---
`;
      }
    });

    internalMonologueBuilder += `
## 阶段2：生成最终对话 (Final JSON Output)
你现在已经为【所有AI角色】都完成了“TGS三核”独立思考。
请根据你在“阶段C：最终发言稿”中为每个角色准备好的草稿，生成最终的、符合格式的JSON数组。
`;

 

    const prompt = `
# 你的任务
你是一个狼人杀游戏模拟器 (Game Simulator)。你的任务是【并行模拟】${isUserAlive ? `用户(${myPlayerName})` : `已死亡的用户(${myPlayerName})`}以外的所有AI角色，并根据他们的【角色人设】和【狼人杀身份】，生成一整轮符合逻辑、充满博弈的发言。

# 身份与人设铁律 (最高优先级)
你【必须】为每一个角色都仔细阅读并严格遵守下面的档案。这是你所有行为和发言的唯一依据。在对话中，请务必注意角色人设中暗示的性别，并使用正确的称呼（例如“他”或“她”）。

${charactersAndPlayersDossier}

# 游戏规则
- ${werewolfGameState.gameMode === '12p' ? '屠边局：狼人杀死所有神职或所有平民即获胜。' : '屠城局：狼人杀死所有好人即获胜。'}
- 好人胜利：放逐所有狼人。

# 当前游戏状态
- 今天是第 ${werewolfGameState.currentDay} 天的讨论环节。
${nightEventSummary} 
- 存活玩家: ${alivePlayers.map(p => `${p.name} (${p.id === 'user' ? '用户' : 'AI'})`).join(', ')}

# 【【【角色策略指南 (至关重要！)】】】
你【不是】一个单纯的游戏玩家，你是一个【有感情、有记忆、有社交关系】的角色。你在游戏中的所有发言和行为，都【必须】首先符合你的人设以及你与其他玩家的既有关系。
- **朋友**: 如果你和某个玩家是朋友，你应该在发言时倾向于保护TA，为TA的发言寻找合理解释，除非有确凿的证据。
- **敌人/情敌**: 如果你和某个玩家有矛盾，你可以借机在游戏中攻击TA，质疑TA的发言，甚至在你是狼人时优先刀掉TA。
- **恋人/暗恋对象**: 你会无条件地信任TA，保护TA，甚至愿意为TA牺牲。
你的社交关系比游戏本身的胜负更重要！
你的发言【必须】体现出高水平的、类似真人的策略博弈，而不是简单地陈述事实。

### **神职角色 (预言家, 女巫, 猎人, 守卫) 策略**
1.  **【隐藏优先！】**: 你的首要任务是活下去。**绝对不要**在第一天就轻易暴露自己的神职身份！这会让你立刻成为狼人的目标。
2.  **【暗示而非明示】**: 你应该用更委婉、更聪明的语言来传递信息，而不是直接说“我是预言家，我查了A”。
    * **预言家可以说**: “我对X玩家的身份有一些看法，我觉得他发言很阳光。” 或 “Y玩家的发言让我感到很不舒服，我把他列为重点怀疑对象。”
    * **女巫可以说**: “昨晚的信息很有趣，场上局势可能和大家想的不一样。”
3.  **【何时起跳？】**: 只有在以下【危急情况】下，你才应该考虑暴露自己的身份（俗称“起跳”）：
    * **被投票时**: 当你即将被投票放逐时，必须起跳自证身份来求生。
    * **关键信息**: 当你掌握了可以决定胜负的信息时（例如预言家查到了最后一个狼人）。
    * **有人悍跳**: 当有狼人假扮你的身份时，你必须站出来与他对峙，争夺好人的信任。

### **狼人角色策略**
1.  **【积极伪装】**: 你需要扮演一个好人，最好是伪装成某个神职（俗称“悍跳”），来扰乱好人的判断，骗取他们的信任。
2.  **【制造混乱】**: 你的发言应该引导好人去怀疑其他无辜的好人。可以故意曲解别人的发言，或者制造逻辑陷阱。
3.  **【团队合作】**: 如果你的狼队友被怀疑，你应该想办法为他辩护，或者通过攻击其他玩家来转移焦点。

### **平民角色策略**
1.  **【逻辑为王】**: 你是场上的“法官”。你的核心任务是仔细倾听每个人的发言，找出其中的逻辑漏洞和矛盾之处。
2.  **【积极分析】**: 不要只是说“我不知道，我过了”。你应该大胆说出你的怀疑，并解释你的理由。例如：“A玩家说B是狼人，但是他的理由很牵强，所以我更怀疑A。”
3.  **【跟票与站边】**: 在你相信某位神职玩家后，你应该坚定地支持他，并号召其他好人一起投票给神职指认的狼人。

# 其他核心指令 (必须遵守)
1.  **互动铁律**: 角色之间【必须】互相质疑、支持、分析【本轮已有发言】。你【绝对不能】无视 ${myPlayerName} (用户) 或其他AI的发言，必须对他们的观点和逻辑做出回应。
2.  **记忆力与连贯性**: 你的新发言【必须】是基于**过去几天和今天发生的所有事件和讨论**的逻辑延续。
3.  **格式铁律**: 你的回复【必须且只能】是一个JSON数组，格式为: \`{"speaker_name": "角色的【昵称】", "dialogue": "发言内容"}\`。**必须**为每一个存活的AI角色都生成一段发言。
4.  **称呼铁律**: 你的发言中【绝对禁止】提及任何玩家的编号。在对话中互相称呼时，你【必须】使用玩家的【本名】，而不是他们的昵称。

# ${previousDaysSummary}

# ${discussionHistoryContext}

${internalMonologueBuilder}

现在，请严格按照“阶段2”的指令，为所有【存活的AI角色】生成他们充满策略和博弈的发言JSON数组。`;

    return prompt;
  }
 
  function createWerewolfGameSummary(gameState) {
    let summary = `--- 狼人杀对局完整复盘 ---\n\n`;
    const winner = gameState.gameLog.find(log => log.content.includes('胜利'))?.content || '胜负未分';
    summary += `### 最终结果: ${winner}\n\n`;

    summary += "### 玩家身份配置:\n";


    gameState.players.forEach(player => {
      const status = player.isAlive ? "存活" : "已死亡";
      summary += `- ${player.name}: ${player.role} (${status})\n`;
    });


    summary += "\n### 详细对局流程:\n";
    for (let day = 1; day <= gameState.currentDay; day++) {
      summary += `\n**--- 第 ${day} 天 ---**\n`;


      const nightEvents = gameState.gameLog.filter(entry => entry.day === day && (entry.content.includes('死亡')));
      if (nightEvents.length > 0) {
        summary += `**[夜晚]** ${nightEvents.map(e => e.content).join(' ')}\n`;
      } else if (day > 1 || (day === 1 && gameState.currentDay > 1)) {
        summary += `**[夜晚]** 平安夜。\n`;
      }


      const discussionsThisDay = gameState.discussionLog.filter(entry => entry.day === day);
      if (discussionsThisDay.length > 0) {
        summary += `**[讨论环节]**\n${discussionsThisDay.map(d => `- ${d.speaker}: ${d.content}`).join('\n')}\n`;
      }


      const voteLog = gameState.gameLog.find(entry => entry.day === day && entry.content.includes('被投票放逐'));
      if (voteLog) {
        summary += `**[投票结果]** ${voteLog.content}\n`;
      }
    }

    summary += "\n--- 复盘结束 ---";
    return summary;
  }


  async function injectSummaryIntoMemories(summary) {
    let injectedCount = 0;

    for (const player of werewolfGameState.players) {

      if (player.type === 'character') {
        const chat = state.chats[player.id];
        if (chat) {

          const newMemory = {
            content: summary,
            timestamp: Date.now(),
            source: 'werewolf_summary'
          };
          if (!chat.longTermMemory) {
            chat.longTermMemory = [];
          }
          chat.longTermMemory.push(newMemory);

          await db.chats.put(chat);
          injectedCount++;
        }
      }
    }
    return injectedCount;
  }


  async function handleManualWerewolfSummary() {
    if (!werewolfGameState.isActive && werewolfGameState.currentPhase === 'gameover') {
      await showCustomAlert("请稍候...", "正在为所有AI角色生成并注入游戏记忆...");
      try {
        const summary = createWerewolfGameSummary(werewolfGameState);



        const count = await injectSummaryIntoMemories(summary);


        await showCustomAlert("成功", `游戏记忆已成功注入到 ${count} 位AI角色的长期记忆中！`);
      } catch (error) {
        console.error("手动注入狼人杀记忆失败:", error);
        await showCustomAlert("失败", `手动注入记忆时出错: ${error.message}`);
      }
    } else {
      alert("游戏尚未结束，无法进行总结。");
    }
  }
 
  async function endGame(winner) {
    werewolfGameState.isActive = false;
    werewolfGameState.currentPhase = 'gameover';


    addGameLog(`${winner}阵营胜利！`);

    document.getElementById('werewolf-game-over-title').textContent = `${winner}胜利！`;
    let reason = '';
    if (winner === '好人') {
      reason = '所有狼人已被放逐，好人阵营获得了胜利！';
    } else {
      reason = '狼人数量已达到胜利条件，狼人阵营获得了胜利！';
    }
    const reasonEl = document.getElementById('werewolf-game-over-reason');
    reasonEl.textContent = reason;

    const roleListEl = document.getElementById('werewolf-role-reveal-list');
    roleListEl.innerHTML = '';

    const sortedPlayers = [...werewolfGameState.players].sort((a, b) => {
      const aIndex = werewolfGameState.players.findIndex(p => p.id === a.id);
      const bIndex = werewolfGameState.players.findIndex(p => p.id === b.id);
      return aIndex - bIndex;
    });

    sortedPlayers.forEach((player, index) => {
      const itemEl = document.createElement('div');
      itemEl.style.cssText = `display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #444; color: white;`;
      if (index === sortedPlayers.length - 1) itemEl.style.borderBottom = 'none';
      const roleColor = player.role === '狼人' ? '#ff4d4d' : '#52c41a';
      itemEl.innerHTML = `
                    <img src="${player.avatar}" style="width: 30px; height: 30px; border-radius: 50%; margin-right: 12px; filter: ${player.isAlive ? 'none' : 'grayscale(100%)'};">
                    <span style="flex-grow: 1; text-align: left; text-decoration: ${player.isAlive ? 'none' : 'line-through'};">${index + 1}. ${player.name}</span>
                    <strong style="color: ${roleColor};">${player.role}</strong>
                `;
      roleListEl.appendChild(itemEl);
    });

    document.getElementById('werewolf-game-over-modal').classList.add('visible');


    try {
      console.log("游戏结束，开始自动总结并注入记忆...");

      const summaryContext = createWerewolfGameSummary(werewolfGameState);

      const count = await generateAndInjectWerewolfMemories(summaryContext);
      console.log(`狼人杀游戏总结已自动存入 ${count} 位角色的记忆中。`);
    } catch (error) {
      console.error("自动总结狼人杀游戏失败:", error);
      if (reasonEl) {
        reasonEl.innerHTML += '<br><small style="color: #ff8a80; margin-top: 10px; display: block;">自动记忆总结失败，可稍后手动尝试。</small>';
      }
    }

  }



  function addGameLog(content) {

    werewolfGameState.gameLog.push({
      type: 'system',
      content,
      timestamp: Date.now(),
      day: werewolfGameState.currentDay
    });
  }

  function addDialogueLog(speaker, content) {

    werewolfGameState.discussionLog.push({
      type: 'dialogue',
      speaker,
      content,
      timestamp: Date.now(),
      day: werewolfGameState.currentDay
    });
  }




  function openSelectionModal(type) {
    return new Promise(resolve => {
      const modalId = `werewolf-${type}-modal`;
      const listId = `werewolf-${type}-selection-list`;
      let confirmBtnId = '';
      if (type === 'prophet') confirmBtnId = 'confirm-prophet-check-btn';
      if (type === 'hunter') confirmBtnId = 'confirm-hunter-shot-btn';
      if (type === 'vote') confirmBtnId = 'confirm-vote-btn';

      const modal = document.getElementById(modalId);
      const listEl = document.getElementById(listId);
      const confirmBtn = document.getElementById(confirmBtnId);

      listEl.innerHTML = '';
      let selectedId = null;


      const potentialTargets = werewolfGameState.players.filter(p =>
        p.isAlive && (type === 'hunter' || type === 'vote' || p.id !== 'user')
      );
      potentialTargets.forEach(p => {
        const item = document.createElement('div');
        item.className = 'werewolf-selection-item';
        item.dataset.id = p.id;
        item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
        item.onclick = () => {
          listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
          item.classList.add('selected');
          selectedId = p.id;
        };
        listEl.appendChild(item);
      });

      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.onclick = () => {
        if (selectedId) {
          modal.classList.remove('visible');
          resolve(selectedId);
        } else {
          alert('请选择一个目标。');
        }
      };

      modal.classList.add('visible');
    });
  }


  function openWolfKillModal() {
    return new Promise(resolve => {
      const modal = document.getElementById('werewolf-kill-modal');
      const listEl = document.getElementById('werewolf-kill-selection-list');
      const confirmBtn = document.getElementById('confirm-wolf-kill-btn');
      const header = modal.querySelector('.modal-header span');

      const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
      const teammates = wolves.filter(w => w.id !== 'user').map(w => w.name).join('、');

      if (teammates) {
        header.innerHTML = `狼人请选择刀人对象<br><small style="font-weight:normal; font-size: 13px;">你的队友是: ${teammates}</small>`;
      } else {
        header.textContent = '狼人请选择刀人对象';
      }

      listEl.innerHTML = '';
      let selectedId = null;

      const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');
      potentialTargets.forEach(p => {
        const item = document.createElement('div');
        item.className = 'werewolf-selection-item';
        item.dataset.id = p.id;
        item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
        item.onclick = () => {
          listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
          item.classList.add('selected');
          selectedId = p.id;
        };
        listEl.appendChild(item);
      });

      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.onclick = () => {
        if (selectedId) {
          modal.classList.remove('visible');
          resolve(selectedId);
        } else {
          alert('请选择一个目标。');
        }
      };

      modal.classList.add('visible');
    });
  }


  function handleUserWerewolfSpeech() {
    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

    if (!myPlayer || !myPlayer.isAlive) return;

    const userInput = document.getElementById('werewolf-user-input');
    const speech = userInput.value.trim();

    if (speech) {
      addDialogueLog(myPlayer.name, speech);
      renderWerewolfScreen();
    }


    document.getElementById('werewolf-action-bar').style.display = 'none';
    userInput.value = '';

    startVotingPhase();
  }

  async function handleAiContinueDiscussion() {
    addGameLog('你让大家继续讨论...');
    renderWerewolfScreen();


    const continueBtn = document.getElementById('werewolf-wait-reply-btn');
    if (continueBtn) continueBtn.disabled = true;



    await showCustomAlert("请稍候", "正在等待AI角色们继续讨论...");

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成对话。');
      return;
    }

    const systemPrompt = buildWerewolfPrompt();

    try {
      let isGemini = proxyUrl.includes('generativelanguage');

      let messagesForApi = [{
        role: 'user',
        content: '请AI角色们继续进行讨论。'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API 错误: ${errorData.error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const jsonMatch = aiResponseContent.match(/(\[[\s\S]*\])/);
      if (!jsonMatch) {
        throw new Error(`AI返回的内容中未找到有效的JSON数组。原始返回: ${aiResponseContent}`);
      }
      const dialogues = JSON.parse(jsonMatch[0]);

      for (const dialogue of dialogues) {
        if (dialogue.speaker_name && dialogue.dialogue) {
          addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
          renderWerewolfScreen();
          await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
        }
      }
    } catch (error) {
      console.error("狼人杀AI回应生成失败:", error);
      await showCustomAlert("AI 发言失败", `错误: ${error.message}`);
    } finally {

      if (continueBtn) continueBtn.disabled = false;
    }
  }

  async function handleWerewolfWaitReply() {
    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');

    if (!myPlayer || !myPlayer.isAlive) {
      console.warn("handleWerewolfWaitReply 被调用，但用户已死亡。操作被忽略。");
      return;
    }


    const userInput = document.getElementById('werewolf-user-input');
    const speech = userInput.value.trim();

    if (!speech) {
      alert("请先输入你的发言内容。");
      return;
    }

    addDialogueLog(myPlayer.name, speech);
    renderWerewolfScreen();
    userInput.value = '';

    await showCustomAlert("请稍候", "正在等待AI角色们对你的发言做出回应...");

    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
      alert('API未配置，无法生成对话。');
      return;
    }

    const systemPrompt = buildWerewolfPrompt();

    try {
      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: `现在，请所有AI角色针对刚刚的发言（特别是'${myPlayer.name}'的发言）继续进行讨论。`
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.9,
          })
        });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API 错误: ${errorData.error.message}`);
      }

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

   

      let dialogues;
      try {
      
        let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        const startIndex = cleanedJsonString.indexOf('[');
        const endIndex = cleanedJsonString.lastIndexOf(']');

        if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
          throw new Error("AI返回的内容中未找到有效的JSON数组结构 (`[...]`)。");
        }

        const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);

     
        dialogues = JSON.parse(jsonArrayString);

      } catch (e) {
    
        if (e.message.includes("Bad control character")) {
          console.warn("检测到JSON中的非法控制字符，尝试清理并重试...");

      
          const sanitizeJsonString = (str) => {
            let inString = false;
            let escaped = false;
            let result = '';
            for (let i = 0; i < str.length; i++) {
              const char = str[i];

              if (escaped) {
                result += char;
                escaped = false;
                continue;
              }
              if (char === '\\') {
                result += char;
                escaped = true;
                continue;
              }
              if (char === '"') {
                result += char;
                inString = !inString;
                continue;
              }

              if (inString) {
              
                if (char === '\n') result += '\\n';
                else if (char === '\r') result += '\\r';
                else if (char === '\t') result += '\\t';
              
                else if (char.charCodeAt(0) < 32) continue;
                else result += char;
              } else {
            
                result += char;
              }
            }
            return result;
          };

        
          let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();

        
          const sanitizedString = sanitizeJsonString(cleanedJsonString);

          const jsonMatch = sanitizedString.match(/(\[[\s\S]*\])/);
          if (!jsonMatch) throw new Error("清理后仍未找到JSON数组。");

          dialogues = JSON.parse(jsonMatch[0]);

        } else {
       
          throw new Error(`解析AI返回的JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
        }
      }
      

      for (const dialogue of dialogues) {
        if (dialogue.speaker_name && dialogue.dialogue) {
          addDialogueLog(dialogue.speaker_name, dialogue.dialogue);
          renderWerewolfScreen();
          await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));
        }
      }
    } catch (error) {
      console.error("狼人杀AI回应生成失败:", error);
      await showCustomAlert("AI 发言失败", `错误: ${error.message}`);
    }
  }

 
  async function startVotingPhase() {
    addGameLog('发言结束，现在开始投票。');
    renderWerewolfScreen();


    werewolfGameState.votes = {};

    let aiVotes = null;
    werewolfGameState.lastFailedAction = 'getVotes';
    try {

      aiVotes = await getAiVotes();
      if (aiVotes) {
        aiVotes.forEach(vote => {
          const voter = werewolfGameState.players.find(p => p.name === vote.voter_name);
          const target = werewolfGameState.players.find(p => p.name === vote.vote_for_name);
          if (voter && voter.isAlive && target) {
            werewolfGameState.votes[voter.name] = target.name;
          }
        });
      }
      werewolfGameState.lastFailedAction = null;
    } catch (error) {
      console.error("AI投票决策API失败:", error);

      await showCustomAlert("操作失败", `AI角色无法完成投票，游戏暂停。请点击右上角的“重试”按钮继续。\n错误: ${error.message}`);
      document.getElementById('werewolf-retry-btn').style.display = 'block';
      return;
    }



    const myPlayer = werewolfGameState.players.find(p => p.id === 'user');
    if (myPlayer && myPlayer.isAlive) {
      addGameLog('请你投票。');
      renderWerewolfScreen();
      const userVoteTargetId = await openSelectionModal('vote');
      const targetPlayer = werewolfGameState.players.find(p => p.id === userVoteTargetId);
      if (targetPlayer) {

        werewolfGameState.votes[myPlayer.name] = targetPlayer.name;
      }
    }


    handleVotingResults();
  }


  async function getAiVotes() {
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const aliveAiPlayers = werewolfGameState.players.filter(p => p.isAlive && p.id !== 'user');
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive).map(p => p.name);

    let systemPrompt = buildWerewolfPrompt();
    systemPrompt += `
# 【【【最终投票指令 (最高优先级)】】】
现在是投票环节。请你扮演【每一个存活的AI角色】，根据以上所有信息（特别是刚刚的讨论环节），为他们各自决定要投票放逐哪一位玩家。
- **投票依据**: 你的投票【必须】基于逻辑分析和你的身份。狼人可能会投给好人，好人需要找出狼人。
- **格式铁律**: 你的回复【必须且只能】是一个JSON数组，格式如下：
\`\`\`json
[
  {"voter_name": "角色A的名字", "vote_for_name": "角色A投票的玩家名字"},
  {"voter_name": "角色B的名字", "vote_for_name": "角色B投票的玩家名字"}
]
\`\`\`
- **可投票的玩家列表**: ${potentialTargets.join(', ')}

现在，请为所有存活的AI角色生成他们的投票决定。`;

    try {
      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: '请所有AI角色开始投票。'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      let cleanedJsonString = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '').trim();


      const startIndex = cleanedJsonString.indexOf('[');
      const endIndex = cleanedJsonString.lastIndexOf(']');


      if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
        throw new Error("AI返回的投票结果中未找到有效的JSON数组结构 (`[...]`)。");
      }



      const jsonArrayString = cleanedJsonString.substring(startIndex, endIndex + 1);


      try {

        const matches = jsonArrayString.match(/(\[[\s\S]*?\])/g);
        if (matches && matches.length > 0) {
          return JSON.parse(matches[matches.length - 1]);
        }
        return JSON.parse(jsonArrayString);
      } catch (e) {

        throw new Error(`解析AI返回的投票JSON时出错: ${e.message}\n\nAI原始返回内容:\n${aiResponseContent}`);
      }


    } catch (error) {
      console.error("获取AI投票失败:", error);
      throw new Error(`获取AI投票决策失败: ${error.message}`);
    }
  }


  function handleVotingResults() {
    const voteCounts = {};
    const voteDetails = {};


    for (const voterName in werewolfGameState.votes) {
      const targetName = werewolfGameState.votes[voterName];

      voteCounts[targetName] = (voteCounts[targetName] || 0) + 1;

      if (!voteDetails[targetName]) {
        voteDetails[targetName] = [];
      }
      voteDetails[targetName].push(voterName);
    }

    let maxVotes = 0;
    let mostVotedPlayers = [];


    for (const playerName in voteCounts) {
      const count = voteCounts[playerName];
      if (count > maxVotes) {
        maxVotes = count;
        mostVotedPlayers = [playerName];
      } else if (count === maxVotes) {
        mostVotedPlayers.push(playerName);
      }
    }


    addGameLog('投票结果：');
    for (const playerName in voteDetails) {
      addGameLog(`${playerName} (${voteDetails[playerName].length}票): ${voteDetails[playerName].join('、 ')}`);
    }


    if (mostVotedPlayers.length === 1 && maxVotes > 0) {
      const playerToEliminate = werewolfGameState.players.find(p => p.name === mostVotedPlayers[0]);
      if (playerToEliminate) {
        playerToEliminate.isAlive = false;
        addGameLog(`${playerToEliminate.name} 被投票放逐。`);


        if (playerToEliminate.role === '猎人') {

        }
      }
    } else {
      addGameLog('平票或无人投票，此轮无人出局。');
    }

    renderWerewolfScreen();

    if (checkGameOver()) return;


    werewolfGameState.currentDay++;
    executeNightPhase();
  }

 
  async function getAiWolfKillTarget() {
    const {
      proxyUrl,
      apiKey,
      model
    } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    const wolves = werewolfGameState.players.filter(p => p.role === '狼人' && p.isAlive);
    const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.role !== '狼人');

    const systemPrompt = `
# 你的任务
你现在是狼人团队的指挥官。你的任务是分析当前局势，并为狼人团队选择一个最佳的刀人目标。
# 核心规则
1.  **目标**: 优先刀掉预言家、女巫等神职人员。如果没有明确的神职信息，可以根据发言来判断谁的逻辑清晰、威胁最大。
2.  **格式铁律**: 你的回复【必须且只能】是一个JSON对象，格式如下:
    \`{"target_name": "你决定要刀的玩家名字"}\`

# 游戏状态
- **你的狼队友是**: ${wolves.map(w=>w.name).join('、 ')}
- **可以刀的玩家列表**: ${potentialTargets.map(p=>p.name).join('、 ')}
- **讨论摘要**: 
${werewolfGameState.discussionLog.map(d => `${d.speaker}: ${d.content}`).join('\n')}

现在，请做出你的决定。`;

    try {
      let isGemini = proxyUrl.includes('generativelanguage');
      let messagesForApi = [{
        role: 'user',
        content: '请选择今晚的目标。'
      }];
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
            temperature: state.globalSettings.apiTemperature || 0.8,
          })
        });

      if (!response.ok) throw new Error((await response.json()).error.message);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);
      const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
      if (!jsonMatch) throw new Error("AI返回的刀人目标格式不正确。");
      const decision = JSON.parse(jsonMatch[0]);

      const targetPlayer = werewolfGameState.players.find(p => p.name === decision.target_name);
      return targetPlayer ? targetPlayer.id : null;

    } catch (error) {
      console.error("获取AI狼人目标失败:", error);

      return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
    }
  }

 
  function openWitchActionModal(killedPlayer, witchPlayer) {
    return new Promise(resolve => {
      const modal = document.getElementById('werewolf-witch-modal');
      const listEl = document.getElementById('werewolf-witch-selection-list');
      const titleEl = document.getElementById('witch-modal-title');


      const poisonBtn = document.getElementById('confirm-witch-poison-btn');
      const doNothingBtn = document.getElementById('witch-do-nothing-btn');
      listEl.innerHTML = '';


      const newPoisonBtn = poisonBtn.cloneNode(true);
      poisonBtn.parentNode.replaceChild(newPoisonBtn, poisonBtn);
      const newDoNothingBtn = doNothingBtn.cloneNode(true);
      doNothingBtn.parentNode.replaceChild(newDoNothingBtn, doNothingBtn);


      newPoisonBtn.style.display = 'block';
      newPoisonBtn.disabled = true;

      let action = {
        save: false,
        poison: null
      };
      let selectedPoisonTarget = null;


      if (killedPlayer && !witchPlayer.antidoteUsed) {
        titleEl.textContent = `昨晚 ${killedPlayer.name} 被刀了`;
        const saveBtn = document.createElement('button');
        saveBtn.className = 'form-button';
        saveBtn.textContent = '使用解药救TA';
        saveBtn.style.margin = '20px';
        saveBtn.onclick = () => {
          action.save = true;
          modal.classList.remove('visible');
          resolve(action);
        };
        listEl.appendChild(saveBtn);
      } else if (killedPlayer) {
        titleEl.textContent = `昨晚 ${killedPlayer.name} 被刀了 (你没有解药了)`;
      } else {
        titleEl.textContent = '昨晚是平安夜';
      }


      if (!witchPlayer.poisonUsed) {
        const poisonTitle = document.createElement('p');
        poisonTitle.textContent = '是否要使用毒药？';
        poisonTitle.style.textAlign = 'center';
        poisonTitle.style.marginTop = '20px';
        listEl.appendChild(poisonTitle);

        const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== killedPlayer?.id);
        potentialTargets.forEach(p => {
          const item = document.createElement('div');
          item.className = 'werewolf-selection-item';
          item.dataset.id = p.id;
          item.innerHTML = `<img src="${p.avatar}" class="avatar"><span class="name">${p.name}</span>`;
          item.onclick = () => {
            listEl.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            item.classList.add('selected');
            selectedPoisonTarget = p.id;


            newPoisonBtn.disabled = false;
          };
          listEl.appendChild(item);
        });
      }


      newPoisonBtn.onclick = () => {
        if (selectedPoisonTarget) {
          action.poison = selectedPoisonTarget;
          modal.classList.remove('visible');
          resolve(action);
        }
      };

      newDoNothingBtn.onclick = () => {
        modal.classList.remove('visible');
        resolve(action);
      };

      modal.classList.add('visible');
    });
  }




  async function handleWerewolfRetry() {
    const actionToRetry = werewolfGameState.lastFailedAction;
    if (!actionToRetry) return;

    document.getElementById('werewolf-retry-btn').style.display = 'none';
    await showCustomAlert("请稍候...", `正在重试"${actionToRetry}"操作...`);

    switch (actionToRetry) {
      case 'wolfKill':

        await executeNightPhase();
        break;
      case 'startDiscussion':

        await startDiscussionPhase();
        break;
      case 'getVotes':

        await startVotingPhase();
        break;

    }
  }




 
  function checkGameOver() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const aliveWolves = alivePlayers.filter(p => p.role === '狼人');
    const aliveGods = alivePlayers.filter(p => ['预言家', '女巫', '猎人', '守卫'].includes(p.role));
    const aliveVillagers = alivePlayers.filter(p => p.role === '平民');

    let winner = null;


    if (aliveWolves.length === 0) {
      winner = '好人';
    } else if (aliveWolves.length >= (aliveGods.length + aliveVillagers.length)) {
      winner = '狼人';
    } else if (werewolfGameState.gameMode === '12p') {

      if (aliveGods.length === 0 || aliveVillagers.length === 0) {
        winner = '狼人';
      }
    } else {

      if (aliveGods.length === 0 && aliveVillagers.length === 0) {
        winner = '狼人';
      }
    }


    if (winner) {

      endGame(winner);
      return true;
    }


    return false;
  }



  async function checkAndFixData() {
    const confirmed = await showCustomConfirm(
      '确认操作',
      '此功能将扫描数据库，尝试找出并修复“角色在数据库中存在，但未在聊天列表显示”的问题。<br><br><strong>操作通常是安全的，但仍建议在操作前备份数据。</strong>', {
        confirmText: '开始检查'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在扫描和修复数据...");

    try {
      const chatsFromDB = await db.chats.toArray();
      let fixedCount = 0;

      for (const chat of chatsFromDB) {
        let isModified = false;


        if (!Array.isArray(chat.history)) {
          chat.history = [];
          isModified = true;
        }

        if (typeof chat.settings !== 'object' || chat.settings === null) {
          chat.settings = {};
          isModified = true;
        }

        if (!chat.isGroup && !chat.originalName) {
          chat.originalName = chat.name;
          isModified = true;
        }

        if (typeof chat.unreadCount === 'undefined') {
          chat.unreadCount = 0;
          isModified = true;
        }

        if (!Array.isArray(chat.longTermMemory)) {
          chat.longTermMemory = [];
          isModified = true;
        }



        if (isModified) {
          fixedCount++;
          console.log(`修复了角色 "${chat.name}" (ID: ${chat.id}) 的残缺数据。`);
          await db.chats.put(chat);
        }


        state.chats[chat.id] = chat;
      }

      if (fixedCount > 0) {
        await showCustomAlert(
          '修复完成！',
          `成功检查并修复了 ${fixedCount} 个角色的数据问题！\n\n聊天列表已为您刷新。`
        );

        await renderChatList();
      } else {
        await showCustomAlert('检查完成', '未发现任何需要修复的数据问题。');
      }

    } catch (error) {
      console.error("数据检查与修复失败:", error);
      await showCustomAlert('操作失败', `执行检查时发生错误: ${error.message}`);
    }
  }


  function showLoader(container, position = 'top') {

    if (container.querySelector('.loader-container')) return;
    const loader = document.createElement('div');
    loader.className = 'loader-container';
    loader.innerHTML = '<div class="spinner"></div>';

    if (position === 'bottom') {
      container.appendChild(loader);
    } else {
      container.prepend(loader);
    }
  }

 
  function hideLoader(container) {
    const loader = container.querySelector('.loader-container');
    if (loader) {
      loader.remove();
    }
  }



  async function openWorldBookDeletionModal() {
    const modal = document.getElementById('delete-world-books-modal');
    const listEl = document.getElementById('delete-world-books-list');
    const selectAllCheckbox = document.getElementById('select-all-world-books-for-clear');
    listEl.innerHTML = '';
    selectAllCheckbox.checked = false;

    const books = await db.worldBooks.toArray();

    if (books.length === 0) {
      listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">没有可以删除的世界书。</p>';
    } else {
      books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `
                <div class="checkbox"></div>
                <span class="name">${book.name}</span>
            `;
        listEl.appendChild(item);
      });
    }

    modal.classList.add('visible');
  }


  async function handleConfirmWorldBookDeletion() {
    const selectedItems = document.querySelectorAll('#delete-world-books-list .clear-posts-item.selected');
    if (selectedItems.length === 0) {
      alert("请至少选择一个要删除的世界书。");
      return;
    }

    const idsToDelete = Array.from(selectedItems).map(item => item.dataset.bookId);

    const confirmed = await showCustomConfirm(
      '最后确认！',
      `此操作将永久删除您选择的 ${selectedItems.length} 本世界书，并解除它们与所有角色的关联。此操作【不可恢复】！`, {
        confirmButtonClass: 'btn-danger',
        confirmText: '确认删除'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在执行删除操作...");

    try {
      await db.transaction('rw', db.worldBooks, db.chats, async () => {

        await db.worldBooks.bulkDelete(idsToDelete);


        const allChats = await db.chats.toArray();
        for (const chat of allChats) {
          if (chat.settings && Array.isArray(chat.settings.linkedWorldBookIds)) {
            const originalCount = chat.settings.linkedWorldBookIds.length;

            chat.settings.linkedWorldBookIds = chat.settings.linkedWorldBookIds.filter(id => !idsToDelete.includes(id));


            if (chat.settings.linkedWorldBookIds.length < originalCount) {
              await db.chats.put(chat);
            }
          }
        }
      });


      state.worldBooks = state.worldBooks.filter(book => !idsToDelete.includes(book.id));

      document.getElementById('delete-world-books-modal').classList.remove('visible');
      await showCustomAlert("删除成功", `${selectedItems.length} 本世界书已成功删除。`);

    } catch (error) {
      console.error("删除世界书失败:", error);
      await showCustomAlert("删除失败", `操作失败: ${error.message}`);
    }
  }




  function openReadingRoom() {
    if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const overlay = document.getElementById('reading-overlay');
    const windowEl = document.getElementById('reading-window');
    const restoreBtn = document.getElementById('reading-restore-btn');

    let session = readingState[chatId];


    if (session && session.isActive) {
      if (session.isMinimized) {
        restoreReadingRoom();
      }

      overlay.style.display = 'flex';
      return;
    }


    initReadingSession(chatId);
    renderReadingRoom(chatId);


    overlay.style.display = 'flex';
    windowEl.classList.remove('minimized');
    restoreBtn.style.display = 'none';




    const phoneScreen = document.getElementById('phone-screen');
    const windowRect = windowEl.getBoundingClientRect();


    const top = (phoneScreen.clientHeight - windowRect.height) / 2;
    const left = (phoneScreen.clientWidth - windowRect.width) / 2;


    windowEl.style.top = `${top}px`;
    windowEl.style.left = `${left}px`;
    windowEl.style.transform = '';

  }

 
  function initReadingSession(chatId) {
    readingState[chatId] = {
      isActive: true,
      isMinimized: false,
      title: '未选择书籍',
      contentLines: [],
      currentPage: 0,
      totalPages: 0,
      linesPerPage: 15,
      currentSnippet: ''
    };
  }


  function closeReadingRoom() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId] || !readingState[chatId].isActive) return;


    document.getElementById('reading-overlay').style.display = 'none';
    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');


    readingState[chatId].isActive = false;
    console.log("读书会话已关闭。");
  }


  


  function renderReadingRoom(chatId) {
    const session = readingState[chatId];
    if (!session) return;
    
    // --- 【新增/修改部分开始】 ---
    // 1. 获取当前聊天的字体设置
    const chat = state.chats[chatId];
    // 默认 13px，如果有设置则使用设置值
    const fontSize = (chat && chat.settings && chat.settings.fontSize) ? chat.settings.fontSize : 13;
    
    const contentEl = document.getElementById('reading-content');
    
    // 2. 将字体大小应用到读书容器
    contentEl.style.fontSize = `${fontSize}px`;
    // 3. 动态调整行高 (Line Height)，防止字体变大后文字挤在一起
    // 1.6 是一个比较舒适的阅读倍率
    contentEl.style.lineHeight = '1.6';
    // --- 【新增/修改部分结束】 ---

    const titleEl = document.getElementById('reading-title');
    // const contentEl = document.getElementById('reading-content'); // 这行上面已经获取了，可以注释掉或删除
    const pageIndicator = document.getElementById('page-indicator');
    const prevBtn = document.getElementById('prev-page-btn');
    const nextBtn = document.getElementById('next-page-btn');
    
    titleEl.textContent = session.title;
    
    if (session.contentLines.length === 0) {
      contentEl.innerHTML = '<p style="text-align:center; padding-top:50px; color:#888;">点击“导入”按钮，<br>从本地.txt文件或网络URL加载书籍内容。</p>';
      session.totalPages = 0;
      session.currentPage = 0;
    } else {
      const startLine = session.currentPage * session.linesPerPage;
      const endLine = startLine + session.linesPerPage;
      contentEl.textContent = session.contentLines.slice(startLine, endLine).join('\n');
    }
    
    pageIndicator.textContent = `${session.currentPage + 1} / ${session.totalPages}`;
    prevBtn.disabled = session.currentPage === 0;
    nextBtn.disabled = session.currentPage >= session.totalPages - 1;
  }

  function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
      session.currentPage++;
      renderReadingRoom(state.activeChatId);
      document.getElementById('reading-content').scrollTop = 0;

      saveReadingProgress(session.activeBookId, session.currentPage);
    }
  }


  async function showPrevPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage > 0) {
      session.currentPage--;
      renderReadingRoom(state.activeChatId);
      document.getElementById('reading-content').scrollTop = 0;
      await saveReadingProgress(session.activeBookId, session.currentPage);


      await notifyAiOfPageTurn(state.activeChatId, session);
    }
  }


  function importBook() {

    document.getElementById('book-upload-input').click();
  }

  async function decodeTextFile(arrayBuffer) {
    const uint8array = new Uint8Array(arrayBuffer);


    if (uint8array.length >= 3 && uint8array[0] === 0xEF && uint8array[1] === 0xBB && uint8array[2] === 0xBF) {
      console.log("检测到 UTF-8 BOM，使用 UTF-8 解码。");
      return new TextDecoder('utf-8').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFF && uint8array[1] === 0xFE) {
      console.log("检测到 UTF-16 LE BOM，使用 UTF-16 LE 解码。");
      return new TextDecoder('utf-16le').decode(uint8array);
    }
    if (uint8array.length >= 2 && uint8array[0] === 0xFE && uint8array[1] === 0xFF) {
      console.log("检测到 UTF-16 BE BOM，使用 UTF-16 BE 解码。");
      return new TextDecoder('utf-16be').decode(uint8array);
    }


    try {
      console.log("未检测到BOM，尝试使用 UTF-8 解码...");

      const decoded = new TextDecoder('utf-8', {
        fatal: true
      }).decode(uint8array);
      console.log("UTF-8 解码成功。");
      return decoded;
    } catch (e) {
      console.log("UTF-8 解码失败，将尝试 GBK (ANSI) 解码...");

      try {
        const decoded = new TextDecoder('gbk').decode(uint8array);
        console.log("GBK 解码成功。");
        return decoded;
      } catch (err) {
        console.error("所有解码尝试均失败:", err);

        throw new Error("无法识别的文件编码。请尝试将文件转换为 UTF-8 格式后重新导入。");
      }
    }
  }

  async function handleBookFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {

      const arrayBuffer = await file.arrayBuffer();

      const textContent = await decodeTextFile(arrayBuffer);

      const title = file.name.replace(/\.txt$/i, '');

      const newBookId = await db.readingLibrary.add({
        title: title,
        content: textContent,
        lastOpened: Date.now()
      });

      await loadBookFromLibrary(newBookId);
      if (document.getElementById('reading-library-modal').classList.contains('visible')) {
        renderBookLibrary();
      }
    } catch (error) {

      console.error("导入书籍失败:", error);
      await showCustomAlert("导入失败", error.message);
    } finally {
      event.target.value = null;
    }
  }
  async function handlePageJump() {
    const chatId = state.activeChatId;
    if (!chatId) return;
    const session = readingState[chatId];
    if (!session || session.totalPages <= 1) return;

    const targetPageStr = await showCustomPrompt(
      '页面跳转',
      `请输入想跳转的页码 (1 - ${session.totalPages})`,
      session.currentPage + 1
    );

    if (targetPageStr === null) return;

    const targetPage = parseInt(targetPageStr);

    if (isNaN(targetPage) || targetPage < 1 || targetPage > session.totalPages) {
      alert("请输入一个有效的页码！");
      return;
    }

    session.currentPage = targetPage - 1;
    renderReadingRoom(chatId);

    saveReadingProgress(session.activeBookId, session.currentPage);
  }


  async function saveReadingProgress(bookId, pageNumber) {
    if (!bookId) return;
    try {

      await db.readingLibrary.update(bookId, {
        currentPage: pageNumber
      });
    } catch (error) {
      console.error(`保存书籍(ID: ${bookId})的阅读进度失败:`, error);
    }
  }

  async function showNextPage() {
    const session = readingState[state.activeChatId];
    if (session && session.currentPage < session.totalPages - 1) {
      session.currentPage++;
      renderReadingRoom(state.activeChatId);
      document.getElementById('reading-content').scrollTop = 0;
      await saveReadingProgress(session.activeBookId, session.currentPage);


      await notifyAiOfPageTurn(state.activeChatId, session);
    }
  }

  



  async function openBookLibrary() {

    document.getElementById('reading-library-search-input').value = '';

    await renderBookLibrary();
    document.getElementById('reading-library-modal').classList.add('visible');
  }

  
  async function renderBookLibrary(searchTerm = '') {
    const listEl = document.getElementById('reading-library-list');
    let books = await db.readingLibrary.orderBy('lastOpened').reverse().toArray();
    listEl.innerHTML = '';


    if (searchTerm) {
      books = books.filter(book =>
        book.title.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }


    if (books.length === 0) {
      const message = searchTerm ?
        '找不到匹配的书籍' :
        '书库是空的，点击“导入新书”添加第一本吧！';
      listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
      return;
    }

    books.forEach(book => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
            <span class="group-name" style="cursor:pointer;" data-book-id="${book.id}">${book.title}</span>
            <button class="delete-group-btn" data-book-id="${book.id}" title="删除书籍">×</button>
        `;
      listEl.appendChild(item);
    });
  }


  // 找到 loadBookFromLibrary 函数，替换整个函数
async function loadBookFromLibrary(bookId) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    let book = await db.readingLibrary.get(bookId);
    if (!book) {
      alert('找不到这本书！');
      return;
    }

    // --- 【核心新增逻辑：同步绿江内容】 ---
    if (book.linkedStoryId) {
        try {
            const grStory = await db.grStories.get(book.linkedStoryId);
            if (grStory) {
                console.log(`[同步] 正在从绿江同步《${grStory.title}》的最新章节...`);
                
                // 拼接所有章节内容
                // 格式：
                // 第1章 标题
                // 正文...
                let fullContent = "";
                grStory.chapters.forEach((ch, idx) => {
                    const title = ch.title || `第 ${idx + 1} 章`;
                    fullContent += `\n\n========== ${title} ==========\n\n`;
                    fullContent += ch.content;
                });

                // 更新内存里的临时对象
                book.title = grStory.title; // 同步标题
                book.content = fullContent; // 同步内容

                // 同时更新数据库，保持缓存最新
                await db.readingLibrary.update(bookId, {
                    title: grStory.title,
                    content: fullContent,
                    lastOpened: Date.now()
                });
            } else {
                console.warn("关联的绿江作品已被删除，保留最后一次缓存的内容。");
            }
        } catch (e) {
            console.error("同步绿江内容失败:", e);
        }
    } else {
        // 普通书籍只更新时间
        await db.readingLibrary.update(bookId, {
          lastOpened: Date.now()
        });
    }
    // -------------------------------------

    const session = readingState[chatId];
    session.activeBookId = bookId;
    session.title = book.title;
    // 处理内容换行
    session.contentLines = (book.content || "").split(/\r\n?|\n/).map(line => line.replace(/ +/g, ' '));
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    
    // 如果总页数为0，至少设为1
    if(session.totalPages === 0) session.totalPages = 1;

    session.currentPage = book.currentPage || 0;

    // 防止页码越界（比如同步后内容变短了，虽然一般是变长）
    if (session.currentPage >= session.totalPages) {
        session.currentPage = session.totalPages - 1;
    }
    if (session.currentPage < 0) session.currentPage = 0;

    renderReadingRoom(chatId);

    document.getElementById('reading-content').scrollTop = 0;
    document.getElementById('reading-library-modal').classList.remove('visible');
}

async function addGreenRiverToShelf(storyId, btnElement) {
    try {
        const story = await db.grStories.get(storyId);
        if (!story) return;

        // 防止重复添加
        const existing = await db.readingLibrary.where('linkedStoryId').equals(storyId).first();
        if (existing) {
            alert("该书籍已在书架中。");
            return;
        }

        let fullContent = "";
        story.chapters.forEach((ch, idx) => {
            const title = ch.title || `第 ${idx + 1} 章`;
            fullContent += `\n\n========== ${title} ==========\n\n`;
            fullContent += ch.content;
        });
        
        if (!fullContent) fullContent = "(暂无内容，请作者赶快更新...)";

        await db.readingLibrary.add({
            title: story.title,
            content: fullContent,
            lastOpened: Date.now(),
            currentPage: 0,
            linkedStoryId: story.id
        });

        // 【核心修改】更新按钮UI为“已添加”状态，并绑定移除事件
        if (btnElement) {
            btnElement.textContent = "✓ 已在书架";
            btnElement.classList.add('added');
            // 重新绑定 onclick 为移除函数
            btnElement.onclick = (e) => {
                e.stopPropagation();
                removeGreenRiverFromShelf(storyId, btnElement);
            };
        }

        await showCustomAlert("收藏成功", `《${story.title}》已加入书架，并开启同步更新。`);

    } catch (e) {
        console.error("加入书架失败:", e);
        alert("加入失败: " + e.message);
    }
}

// 记得把这个函数暴露给全局，否则 HTML onclick 找不到
window.addGreenRiverToShelf = addGreenRiverToShelf;
// 【新增】从“一起读”书架中移除绿江作品
async function removeGreenRiverFromShelf(storyId, btnElement) {
    try {
        // 查找对应的书架记录
        const bookRecord = await db.readingLibrary.where('linkedStoryId').equals(storyId).first();
        
        if (!bookRecord) {
            // 数据库里可能已经被删了，直接更新UI
            if (btnElement) resetBtnToAddState(storyId, btnElement);
            return;
        }

        const confirmed = await showCustomConfirm(
            "移出书架",
            `确定要将《${bookRecord.title}》从“一起读”书架中移除吗？\n(绿江APP中的原稿不会被删除)`,
            { confirmButtonClass: 'btn-danger', confirmText: '移出' }
        );

        if (confirmed) {
            // 删除书架记录
            await db.readingLibrary.delete(bookRecord.id);
            
            // 更新 UI 为“未添加”状态
            if (btnElement) {
                resetBtnToAddState(storyId, btnElement);
            }
            
            await showCustomAlert("已移除", "书籍已从书架移出。");
        }
    } catch (e) {
        console.error("移除失败:", e);
    }
}

// 辅助函数：重置按钮为“加入”状态
function resetBtnToAddState(storyId, btn) {
    btn.textContent = "+ 加入共读";
    btn.classList.remove('added');
    btn.onclick = (e) => {
        e.stopPropagation();
        addGreenRiverToShelf(storyId, btn);
    };
}

// 暴露给全局
window.removeGreenRiverFromShelf = removeGreenRiverFromShelf;
  async function deleteBookFromLibrary(bookId) {
    const book = await db.readingLibrary.get(bookId);
    if (!book) return;

    const confirmed = await showCustomConfirm('删除书籍', `确定要删除《${book.title}》吗？`, {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.readingLibrary.delete(bookId);
      await renderBookLibrary();
    }
  }

  function processImportedText(title, textContent) {
    const chatId = state.activeChatId;
    if (!chatId) return;

    const session = readingState[chatId];
    session.title = title.replace(/\.txt$/i, '');
    session.contentLines = textContent.split(/\r\n?|\n/);
    session.totalPages = Math.ceil(session.contentLines.length / session.linesPerPage);
    session.currentPage = 0;

    renderReadingRoom(chatId);
  }



  function makeDraggable(windowEl, headerEl) {
    let pos1 = 0,
      pos2 = 0,
      pos3 = 0,
      pos4 = 0;
    let isDragging = false;
    let hasMoved = false;
    const phoneScreen = document.getElementById('phone-screen');

    const startDrag = (e) => {

      if (windowEl !== headerEl && e.target.closest('button')) {
        return;
      }

      isDragging = true;
      hasMoved = false;

      const event = e.type === 'touchstart' ? e.touches[0] : e;
      pos3 = event.clientX;
      pos4 = event.clientY;


      windowEl.style.top = `${windowEl.offsetTop}px`;
      windowEl.style.left = `${windowEl.offsetLeft}px`;
      windowEl.style.transform = '';

      document.addEventListener('mouseup', endDrag);
      document.addEventListener('mousemove', elementDrag);
      document.addEventListener('touchend', endDrag);

      document.addEventListener('touchmove', elementDrag, {
        passive: false
      });
    };

    const elementDrag = (e) => {
      if (!isDragging) return;

      const event = e.type === 'touchmove' ? e.touches[0] : e;
      const diffX = event.clientX - pos3;
      const diffY = event.clientY - pos4;


      if (!hasMoved && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
        hasMoved = true;
      }


      if (hasMoved && e.cancelable) {
        e.preventDefault();
      }

      pos1 = pos3 - event.clientX;
      pos2 = pos4 - event.clientY;
      pos3 = event.clientX;
      pos4 = event.clientY;

      let newTop = windowEl.offsetTop - pos2;
      let newLeft = windowEl.offsetLeft - pos1;

      const maxTop = phoneScreen.clientHeight - windowEl.offsetHeight - 10;
      const maxLeft = phoneScreen.clientWidth - windowEl.offsetWidth - 10;
      newTop = Math.max(10, Math.min(newTop, maxTop));
      newLeft = Math.max(10, Math.min(newLeft, maxLeft));

      windowEl.style.top = newTop + "px";
      windowEl.style.left = newLeft + "px";
    };

    const endDrag = () => {
      document.removeEventListener('mouseup', endDrag);
      document.removeEventListener('mousemove', elementDrag);
      document.removeEventListener('touchend', endDrag);
      document.removeEventListener('touchmove', elementDrag);

      if (!isDragging) return;
      isDragging = false;


      if (!hasMoved) {

        windowEl.click();
      }
    };

    headerEl.addEventListener('mousedown', startDrag);

    headerEl.addEventListener('touchstart', startDrag, {
      passive: false
    });
  }


 
  function minimizeReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-window').classList.add('minimized');
    document.getElementById('reading-restore-btn').style.display = 'flex';
    session.isMinimized = true;
  }


  function restoreReadingRoom() {
    const session = readingState[state.activeChatId];
    if (!session || !session.isActive) return;

    document.getElementById('reading-restore-btn').style.display = 'none';
    document.getElementById('reading-window').classList.remove('minimized');
    session.isMinimized = false;
  }





  function debounce(func, delay) {
    let timeout;
    return function(...args) {
      const context = this;
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(context, args), delay);
    };
  }


 
  function formatReadingStateForAI(chatId) {
    const session = readingState[chatId];


    if (!session || !session.isActive) {
      return "";
    }

    const title = session.title || '未知书籍';
    let contentForAI = '';
    let contextLabel = '';


    if (session.currentSnippet && session.currentSnippet.trim()) {
      contentForAI = session.currentSnippet;
      contextLabel = '你正在阅读的段落';
    } else if (session.contentLines.length > 0) {
      const startLine = session.currentPage * session.linesPerPage;
      const endLine = startLine + session.linesPerPage;
      contentForAI = session.contentLines.slice(startLine, endLine).join('\n').substring(0, 200);
      contextLabel = '当前页内容摘要';
    } else {
      contentForAI = '(无内容)';
      contextLabel = '内容';
    }
    return `
    - **书名**: 《${title}》
    - **${contextLabel}**: "${contentForAI}..."
    #一起读书模式 | 行为铁律
    1.  **角色定位**: 你【不是】书中的任何角色，你是【你自己】(${state.chats[chatId]?.originalName || 'AI角色'})，正在和用户一起【阅读和讨论】这本书。
    2.  **行为准则**: 你的回复【必须】是作为读者的【感想、评论、提问或联想】。你可以：
        -   分享你对当前段落的看法。
        -   对书中的角色或情节发表评论。
        -   向用户提问，询问TA对内容的看法。
        -   根据书本内容，联想到你自己的经历或记忆。
    3.  **严禁**: 你的回复【绝对禁止】使用书中角色的口吻和人称！【绝对禁止】扮演书中的任何角色！【绝对禁止】续写或模仿书中的情节！你必须时刻记住，你只是一个读者。    
`;
  }


  
  function updateReadingContextOnScroll() {
    const chatId = state.activeChatId;
    if (!chatId || !readingState[chatId]) return;

    const session = readingState[chatId];
    const container = document.getElementById('reading-content');
    
    if (!container) return;

   
    const chat = state.chats[chatId];
 
    const fontSize = (chat && chat.settings && chat.settings.fontSize) ? chat.settings.fontSize : 13;
    
    const approximateLineHeight = fontSize * 1.6; 
 
    const scrollTop = container.scrollTop;
    const clientHeight = container.clientHeight;
    const scrollBottom = scrollTop + clientHeight;

   
    const firstVisibleLine = Math.floor(scrollTop / approximateLineHeight);
    const lastVisibleLine = Math.ceil(scrollBottom / approximateLineHeight);

   
    const absoluteStartIndex = (session.currentPage * session.linesPerPage) + firstVisibleLine;
    const absoluteEndIndex = (session.currentPage * session.linesPerPage) + lastVisibleLine;

    if (absoluteStartIndex < 0 || absoluteStartIndex >= session.contentLines.length) {
      return;
    }

   
    const newSnippet = session.contentLines.slice(
      Math.max(0, absoluteStartIndex),
      Math.min(session.contentLines.length, absoluteEndIndex)
    ).join('\n');

    session.currentSnippet = newSnippet;
    
    // 调试日志（可选，如果你想在控制台看效果）
    // console.log(`[阅读视口更新] 字体:${fontSize}px, 行高:${approximateLineHeight}, 可见行:${firstVisibleLine}-${lastVisibleLine}`);
  }




  function playSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer) {

      const playPromise = silentPlayer.play();
      if (playPromise !== undefined) {
        playPromise.then(_ => {
          console.log("静音音频已启动，用于后台活动保活。");
        }).catch(error => {


          console.warn("无法自动播放静音音频（这在iOS首次加载时是正常现象）:", error);
        });
      }
    }
  }

 
  function stopSilentAudio() {
    const silentPlayer = document.getElementById('silent-audio-player');
    if (silentPlayer && !silentPlayer.paused) {
      silentPlayer.pause();
      silentPlayer.currentTime = 0;
      console.log("静音音频已停止。");
    }
  }


  function hexToUint8Array(hexString) {
    if (!hexString) return new Uint8Array();
    const arrayBuffer = new Uint8Array(hexString.length / 2);
    for (let i = 0; i < hexString.length; i += 2) {
        arrayBuffer[i / 2] = parseInt(hexString.substr(i, 2), 16);
    }
    return arrayBuffer;
}
// --- 新增：视频通话专用 TTS 播放函数 ---
async function playVideoCallPureTTS(text, voiceId) {
    // 1. 正则去除括号及括号内的内容 (支持中英文括号 [])
    // 匹配：(xxx) 或 （xxx） 或 [xxx] 或 【xxx】
    const cleanText = text.replace(/(\[.*?\]|\(.*?\)|（.*?）|【.*?】)/g, '').trim();

    // 如果去除括号后没字了，就不读
    if (!cleanText) return;

    // 2. 检查配置
    const { minimaxGroupId, minimaxApiKey } = state.apiConfig;
    if (!minimaxGroupId || !minimaxApiKey || !voiceId) return;

    // 3. 检查当前是否静音或被暂停 (可选，这里直接播放)
    const ttsPlayer = document.getElementById('tts-audio-player');
    
    // 简单的防抖：如果正在读同样的内容，忽略
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === cleanText) return;

    console.log(`[视频通话TTS] 正在朗读: ${cleanText}`);

    try {
        const savedDomain = state.apiConfig.minimaxDomain || localStorage.getItem('minimax-domain') || 'https://api.minimax.chat';
        const modelId = state.apiConfig.minimaxModel || "speech-01-hd";

        const response = await fetch(`${savedDomain}/v1/t2a_v2?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: modelId,
                text: cleanText, // 使用过滤后的文本
                stream: false,
                voice_setting: {
                    voice_id: voiceId,
                    speed: 1.0,
                    vol: 1.0,
                    pitch: 0
                },
                audio_setting: {
                    sample_rate: 32000,
                    bitrate: 128000,
                    format: "mp3",
                    channel: 1
                }
            })
        });

        if (!response.ok) throw new Error("API请求失败");

        const data = await response.json();
        if (data.base_resp && data.base_resp.status_code !== 0) throw new Error(data.base_resp.status_msg);

        const audioHex = data.data?.audio;
        if (!audioHex) return;

        // 使用现有的 hexToUint8Array 函数转换
        const audioBytes = hexToUint8Array(audioHex);
        const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;
        ttsPlayer.dataset.currentText = cleanText; // 标记当前文本
        ttsPlayer.play().catch(e => console.error("视频语音播放失败:", e));

    } catch (error) {
        console.error("视频通话TTS生成失败:", error);
    }
}
async function playTtsAudio(bodyElement) {
    const text = decodeURIComponent(bodyElement.dataset.text);

    // 1. 获取 Voice ID
    let voiceId = bodyElement.dataset.voiceId;
    // 新增：初始化语言设置，默认为普通话
    let ttsLanguage = 'zh-CN';

    if (state.activeChatId && state.chats[state.activeChatId]) {
        const chat = state.chats[state.activeChatId];
        if (!chat.isGroup && chat.settings.enableTts !== false) {
            // 优先使用标签上的ID，如果没有则用设置里的
            if (!voiceId) voiceId = chat.settings.minimaxVoiceId;
            // 【关键修复】获取用户在设置中选择的语言/方言
            if (chat.settings.ttsLanguage) ttsLanguage = chat.settings.ttsLanguage;
        }
    }

    if (!voiceId) {
        alert("错误：无法获取 Voice ID。请检查角色设置。");
        return;
    }

    const button = bodyElement.querySelector('.voice-play-btn');
    const spinner = bodyElement.querySelector('.loading-spinner');
    const ttsPlayer = document.getElementById('tts-audio-player');

    // 播放/暂停逻辑
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === text && ttsPlayer.dataset.currentVoiceId === voiceId) {
        ttsPlayer.pause();
        return;
    }
    ttsPlayer.pause();
    document.querySelectorAll('.voice-play-btn').forEach(btn => btn.textContent = '▶');

    // 2. 检查缓存 (Key加入语言区分，防止切换方言后读到旧缓存)
    const cacheKey = `tts_v2_${voiceId}_${ttsLanguage}_${text}`;
    let cachedAudio = state.ttsCache.get(cacheKey);
    if (cachedAudio) {
        console.log("从缓存播放 TTS...");
        await playAudioFromData(cachedAudio.url, cachedAudio.type, text, voiceId, bodyElement);
        return;
    }

    console.log(`请求 Minimax T2A v2... VoiceID: ${voiceId}, Language: ${ttsLanguage}`);
    if (button) button.style.display = 'none';
    spinner.style.display = 'block';

    const {
        minimaxGroupId,
        minimaxApiKey
    } = state.apiConfig;

    const languageMap = {
        'zh-CN': 'Chinese',
        'zh-HK': 'Chinese,Yue',   // 粤语特殊处理
        'en-US': 'English',
        'ja-JP': 'Japanese',
        'ko-KR': 'Korean',
        'de-DE': 'German',
        'fr-FR': 'French',
        'es-ES': 'Spanish',
        'it-IT': 'Italian',
        'ru-RU': 'Russian',
        'pt-BR': 'Portuguese',
        'nl-NL': 'Dutch',
        'pl-PL': 'Polish',
        'sv-SE': 'Swedish',
        'tr-TR': 'Turkish',
        'id-ID': 'Indonesian',
        'ms-MY': 'Malay',
        'vi-VN': 'Vietnamese',
        'th-TH': 'Thai',
        'hi-IN': 'Hindi',
        'ar-SA': 'Arabic'
    };

    // 获取对应的 boost 值，如果没有匹配到就默认 'auto'
    const boostValue = languageMap[ttsLanguage] || 'auto';

    // 2. 发送请求 (注意 language_boost 的位置)
    try {
        const savedDomain = state.apiConfig.minimaxDomain || localStorage.getItem('minimax-domain') || 'https://api.minimax.chat';
        const minimaxBaseUrl = savedDomain;
        const modelId = state.apiConfig.minimaxModel || "speech-01-hd";

        const response = await fetch(`${minimaxBaseUrl}/v1/t2a_v2?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: modelId,
                text: text,
                stream: false,
                
               
                language_boost: boostValue, 

                voice_setting: {
                    voice_id: voiceId,
                    speed: 1.0,
                    vol: 1.0,
                    pitch: 0
                },
                audio_setting: {
                    sample_rate: 32000,
                    bitrate: 128000,
                    format: "mp3",
                    channel: 1
                }
            })
        });

        if (!response.ok) {
            let errorMsg = `API 失败: ${response.status}`;
            try {
                const errJson = await response.json();
                errorMsg += ` - ${errJson.base_resp?.status_msg || JSON.stringify(errJson)}`;
            } catch (e) {}
            throw new Error(errorMsg);
        }

        const data = await response.json();

        // 4. 检查业务状态码
        if (data.base_resp && data.base_resp.status_code !== 0) {
            throw new Error(`API 错误: ${data.base_resp.status_msg}`);
        }

        // 5. 解析 Hex 音频数据
        const audioHex = data.data?.audio;
        if (!audioHex) throw new Error("API 未返回音频数据");

        const audioBytes = hexToUint8Array(audioHex);
        const audioBlob = new Blob([audioBytes], {
            type: 'audio/mpeg'
        });
        const audioUrl = URL.createObjectURL(audioBlob);

        await playAudioFromData(audioUrl, 'audio/mpeg', text, voiceId, bodyElement);

        // 写入缓存
        const reader = new FileReader();
        reader.onloadend = function() {
            state.ttsCache.set(cacheKey, {
                url: reader.result,
                type: 'audio/mpeg'
            });
        }
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("TTS 生成失败:", error);
        await showCustomAlert("语音生成失败", `错误: ${error.message}`);
    } finally {
        spinner.style.display = 'none';
        if (button) button.style.display = 'flex';
    }
}


  function playAudioFromData(audioSrc, audioType, text, voiceId, bodyElement) {
    return new Promise((resolve, reject) => {
      const ttsPlayer = document.getElementById('tts-audio-player');

      ttsPlayer.src = audioSrc;
      ttsPlayer.type = audioType;
      ttsPlayer.dataset.currentText = text;
      ttsPlayer.dataset.currentVoiceId = voiceId;

      const playPromise = ttsPlayer.play();

      if (playPromise !== undefined) {
        playPromise.then(() => {
          const button = bodyElement.querySelector('.voice-play-btn');
          if (button) button.textContent = '❚❚';


          resolve();
        }).catch(error => {
          console.error("音频播放失败:", error);
          reject(error);
        });
      }

      ttsPlayer.onended = () => {
        const button = bodyElement.querySelector('.voice-play-btn');
        if (button) button.textContent = '▶';
      };
      ttsPlayer.onpause = () => {
        const button = bodyElement.querySelector('.voice-play-btn');
        if (button) button.textContent = '▶';
      };
    });
  }




  function toggleVoiceTranscript(bodyElement) {
    const bubble = bodyElement.closest('.message-bubble');
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    const text = decodeURIComponent(bodyElement.dataset.text);

    if (transcriptEl.style.display === 'block') {

      transcriptEl.style.display = 'none';
    } else {

      transcriptEl.textContent = text;
      transcriptEl.style.display = 'block';
    }
  }



  async function openProductCategoryManager() {
    await renderProductCategoriesInManager();
    document.getElementById('product-category-manager-modal').classList.add('visible');
  }


  async function renderProductCategoriesInManager() {
    const listEl = document.getElementById('existing-product-categories-list');
    const categories = await db.shoppingCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
      listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
      return;
    }
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'existing-group-item';
      item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
      listEl.appendChild(item);
    });
  }


  async function addNewProductCategory() {
    const input = document.getElementById('new-product-category-name-input');
    const name = input.value.trim();
    if (!name) return alert('分类名不能为空！');
    const existing = await db.shoppingCategories.where('name').equals(name).first();
    if (existing) return alert(`分类 "${name}" 已经存在了！`);

    await db.shoppingCategories.add({
      name
    });
    input.value = '';
    await renderProductCategoriesInManager();
  }


  async function deleteProductCategory(categoryId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分类后，该分类下的所有商品将变为“未分类”。确定吗？', {
      confirmButtonClass: 'btn-danger'
    });
    if (confirmed) {
      await db.shoppingCategories.delete(categoryId);
      await db.shoppingProducts.where('categoryId').equals(categoryId).modify({
        categoryId: null
      });
      await renderProductCategoriesInManager();
    }
  }

 
  function addProductVariationInput(variation = {}) {
    const container = document.getElementById('product-variations-container');
    const block = document.createElement('div');
    block.className = 'message-editor-block variation-block'; // 复用样式
    block.innerHTML = `
        <button class="delete-block-btn" title="删除此款式">×</button>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div class="form-group">
                <label style="font-size: 0.8em;">款式名称</label>
                <input type="text" class="variation-name-input" placeholder="例如: 红色" value="${variation.name || ''}">
            </div>
            <div class="form-group">
                <label style="font-size: 0.8em;">价格 (元)</label>
                <input type="number" class="variation-price-input" min="0" step="0.01" value="${variation.price || ''}">
            </div>
        </div>
        <div class="form-group">
            <label style="font-size: 0.8em;">款式图片 (可选)</label>
            <div class="avatar-upload">
                <img class="variation-image-preview" src="${variation.imageUrl || 'https://i.postimg.cc/PqYp5T5M/image.png'}">
                <button type="button" class="form-button-secondary upload-variation-image-btn" style="margin: 0; padding: 8px 12px;">上传</button>
                <input type="file" class="variation-image-input" accept="image/*" hidden>
            </div>
        </div>
    `;

    block.querySelector('.delete-block-btn').addEventListener('click', () => block.remove());
    block.querySelector('.upload-variation-image-btn').addEventListener('click', () => {
      block.querySelector('.variation-image-input').click();
    });
    block.querySelector('.variation-image-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (re) => {
          block.querySelector('.variation-image-preview').src = re.target.result;
        };
        reader.readAsDataURL(file);
      }
    });

    container.appendChild(block);
    return block;
  }

  async function openVariationSelector(productId) {
    const product = await db.shoppingProducts.get(productId);
    if (!product || !product.variations || product.variations.length === 0) return;

    const modal = document.getElementById('variation-selection-modal');
    document.getElementById('variation-product-image').src = product.imageUrl;
    document.getElementById('variation-product-name').textContent = product.name;

    const optionsContainer = document.getElementById('variation-options-container');
    optionsContainer.innerHTML = '';

    product.variations.forEach((variation, index) => {
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'variation-select';
      radio.id = `var-${productId}-${index}`;
      radio.value = index;
      radio.style.display = 'none';
      if (index === 0) radio.checked = true;

      const label = document.createElement('label');
      label.htmlFor = `var-${productId}-${index}`;
      label.textContent = variation.name;
      label.style.cssText = `
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
        `;

      optionsContainer.appendChild(radio);
      optionsContainer.appendChild(label);
    });

    const updateSelectionUI = () => {
      const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
      optionsContainer.querySelectorAll('label').forEach(lbl => {
        lbl.style.borderColor = '#ccc';
        lbl.style.color = '#333';
        lbl.style.backgroundColor = 'white';
      });
      if (selectedRadio) {
        const selectedLabel = optionsContainer.querySelector(`label[for="${selectedRadio.id}"]`);
        selectedLabel.style.borderColor = 'var(--accent-color)';
        selectedLabel.style.color = 'var(--accent-color)';
        selectedLabel.style.backgroundColor = '#e7f3ff';

        const selectedVariation = product.variations[parseInt(selectedRadio.value)];
        document.getElementById('variation-selected-price').textContent = `¥${selectedVariation.price.toFixed(2)}`;
        if (selectedVariation.imageUrl) {
          document.getElementById('variation-product-image').src = selectedVariation.imageUrl;
        } else {
          document.getElementById('variation-product-image').src = product.imageUrl;
        }
      }
    };

    optionsContainer.addEventListener('change', updateSelectionUI);
    updateSelectionUI();

    document.getElementById('variation-quantity-display').textContent = '1';

    const confirmBtn = document.getElementById('confirm-variation-selection-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', async () => {
      const selectedRadio = optionsContainer.querySelector('input[name="variation-select"]:checked');
      const quantity = parseInt(document.getElementById('variation-quantity-display').textContent);
      if (selectedRadio) {
        const selectedVariation = product.variations[parseInt(selectedRadio.value)];
        await addToCart(productId, quantity, selectedVariation);
        modal.classList.remove('visible');
        await showCustomAlert('成功', '已成功加入购物车！');
      }
    });

    modal.classList.add('visible');
  }


  function openShoppingSettingsModal() {
    const modal = document.getElementById('shopping-settings-modal');

    // 从全局设置中读取已保存的值，如果没有就使用默认值
    document.getElementById('shopping-category-count-input').value = state.globalSettings.shoppingCategoryCount || 3;
    document.getElementById('shopping-product-count-input').value = state.globalSettings.shoppingProductCount || 8;

    modal.classList.add('visible');
  }


  async function saveShoppingSettings() {
    const categoryInput = document.getElementById('shopping-category-count-input');
    const productInput = document.getElementById('shopping-product-count-input');

    const categoryCount = parseInt(categoryInput.value);
    const productCount = parseInt(productInput.value);


    if (isNaN(categoryCount) || isNaN(productCount) || categoryCount < 1 || productCount < 1) {
      alert("请输入有效的正整数！");
      return;
    }


    state.globalSettings.shoppingCategoryCount = categoryCount;
    state.globalSettings.shoppingProductCount = productCount;
    await db.globalSettings.put(state.globalSettings);


    document.getElementById('shopping-settings-modal').classList.remove('visible');
    await showCustomAlert('保存成功', '购物中心生成设置已更新！');
  }


  async function handleGenerateShoppingItems() {

    if (!state.activeChatId) {
      await showCustomAlert("操作失败", "请先进入一个聊天页面，再返回购物中心进行生成，以便AI了解要为哪个角色生成商品。");
      return;
    }
    const chat = state.chats[state.activeChatId];

    const confirmed = await showCustomConfirm(
      `为“${chat.name}”生成商品？`,
      '此操作将使用AI生成新的商品和分类，并【添加】到现有列表中。确定要继续吗？', {
        confirmText: '确认生成'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在根据“${chat.name}”的特点生成专属商品...`);


    const useSecondaryApi = state.apiConfig.secondaryProxyUrl && state.apiConfig.secondaryApiKey && state.apiConfig.secondaryModel;
    const {
      proxyUrl,
      apiKey,
      model
    } = useSecondaryApi
      ?
      {
        proxyUrl: state.apiConfig.secondaryProxyUrl,
        apiKey: state.apiConfig.secondaryApiKey,
        model: state.apiConfig.secondaryModel
      } :
      state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
      await showCustomAlert("API未配置", "请先在API设置中配置好（主或副）API。");
      return;
    }

    const categoryCount = state.globalSettings.shoppingCategoryCount || 3;
    const productCount = state.globalSettings.shoppingProductCount || 8;

    const existingCategories = await db.shoppingCategories.toArray();
    let existingCategoriesContext = "";
    if (existingCategories.length > 0) {
      existingCategoriesContext = `
# 【分类复用铁律 (最高优先级！)】
在为新商品指定分类时，你【必须】首先检查下面的“已有分类列表”。
-   如果一个新商品可以被归入某个【已存在的分类】，你【必须】复用那个分类的名称，而不是创造一个相似的新分类！
-   只有当你确定商品【绝对】不属于任何一个已有分类时，你才能创造一个新的分类名称。
-   **已有分类列表**: [${existingCategories.map(c => `"${c.name}"`).join(', ')}]
`;
    }

    const userNickname = state.qzoneSettings.nickname || '我';
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- (记录于 ${formatTimeAgo(mem.timestamp)}) ${mem.content}`).join('\n') :
      '无';
    const recentHistoryContext = chat.history.slice(-10).map(msg =>
      `${msg.role === 'user' ? userNickname : chat.name}: ${String(msg.content).substring(0, 30)}...`
    ).join('\n');

    let worldBookContext = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
      const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';
        const enabledEntries = worldBook.content
          .filter(entry => entry.enabled !== false)
          .map(entry => `- ${entry.content}`)
          .join('\n');
        return enabledEntries ? `\n## 来自《${worldBook.name}》:\n${enabledEntries}` : '';
      }).filter(Boolean).join('');

      if (linkedContents) {
        worldBookContext = `\n# 世界观设定 (必须参考)\n${linkedContents}\n`;
      }
    }

    const systemPrompt = `
# 你的任务
你是一个虚拟的、极具创造力的商品规划师。你的任务是为下面的角色“${chat.name}”量身打造一个专属的商品列表。

# 核心规则
1.  **【角色定制(最高优先级)】**: 你生成的所有商品和分类【必须】深度绑定角色的性格、记忆和最近的对话。它们应该是角色会真正感兴趣、购买或制作的东西。
2.  **创造性与合理性**: 商品和分类必须合理且多样化。
3.  **格式铁律 (最高优先级)**: 
    - 你的回复【必须且只能】是一个【单一的JSON对象】。
    - 你的回复必须以 \`{\` 开始，并以 \`}\` 结束。
    - 【绝对禁止】在JSON对象前后添加任何多余的文字、解释或 markdown 标记。
    - 格式【必须】如下:
    \`\`\`json
    {
      "categories": [
        {
          "name": "分类名称1",
          "products": [
            {
              "name": "商品名称1",
              "price": 99.80,
              "description": "这是商品的详细描述，不少于50字...",
              "variations": [
                { "name": "款式1", "price": 108.80, "image_prompt": "款式1的图片【英文】关键词..." },
                { "name": "款式2", "price": 118.80, "image_prompt": "款式2的图片【英文】关键词..." }
              ],
              "image_prompt": "商品主图的【英文】关键词, 风格为 realistic product photo, high quality, on a clean white background"
            }
          ]
        }
      ]
    }
    \`\`\`
    - **categories**: 生成 ${categoryCount} 个分类。
    - **products**: 每个分类下生成 ${productCount} 个商品。
    - **variations**: 每个商品【必须】包含【2到4个】不同的款式。

# 角色与上下文 (你的灵感来源)
- **角色名称**: ${chat.name}
- **角色人设**: ${chat.settings.aiPersona}
- **长期记忆**: ${longTermMemoryContext}
- **世界书设定**: ${worldBookContext}
${existingCategoriesContext}
- **最近对话摘要**:
${recentHistoryContext}

现在，请根据以上【所有上下文信息】，开始为“${chat.name}”生成这组【与角色高度相关】的商品数据。`;

    try {
      const messagesForApi = [{
        role: 'user',
        content: "请根据以上设定，生成商品数据。"
      }];
      let isGemini = proxyUrl.includes('generativelanguage');
   
      let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

      const response = isGemini ?
        await fetch(geminiConfig.url, geminiConfig.data) :
        await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: model,
            messages: [{
              role: 'system',
              content: systemPrompt
            }, ...messagesForApi],
           
            temperature: state.globalSettings.apiTemperature || 0.9
          })
        });

      if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

      const data = await response.json();
      const aiResponseContent = getGeminiResponseText(data);

      const jsonMatch = aiResponseContent.match(/({[\s\S]*})/);
      if (!jsonMatch) throw new Error("AI返回的内容中未找到有效的JSON对象。");
      const generatedData = JSON.parse(jsonMatch[0]);

      if (!generatedData.categories || !Array.isArray(generatedData.categories)) {
        throw new Error("AI返回的JSON格式不正确，缺少 'categories' 数组。");
      }

     
      await db.transaction('rw', db.shoppingProducts, db.shoppingCategories, async () => {
        for (const category of generatedData.categories) {
          let categoryId;
          const existingCategory = await db.shoppingCategories.where('name').equalsIgnoreCase(category.name).first();
          if (existingCategory) {
            categoryId = existingCategory.id;
          } else {
            categoryId = await db.shoppingCategories.add({
              name: category.name
            });
          }
          const productsToAdd = category.products.map(product => {
            return {
              name: product.name,
              price: product.price || 0,
              description: product.description || '',
              imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(product.image_prompt)}`,
              variations: (product.variations || []).map(v => ({
                ...v,
                imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(v.image_prompt)}`
              })),
              categoryId: categoryId
            };
          });
          if (productsToAdd.length > 0) {
            await db.shoppingProducts.bulkAdd(productsToAdd);
          }
        }
      });

      activeShoppingCategoryId = 'all';
      await renderShoppingProducts();
      await showCustomAlert('生成成功！', `为“${chat.name}”量身定制的商品已上架！`);

    } catch (error) {
      console.error("生成购物中心商品失败:", error);
      await showCustomAlert("生成失败", `无法生成商品，请检查(主/副)API配置或稍后再试。\n错误: ${error.message}`);
    }
  }



  async function handleWidgetImageChange(imageId) {
    const element = document.getElementById(imageId);
    if (!element) return;
  
    const choice = await showChoiceModal("更换图片", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);
  
    let newUrl = null;
    let isBase64 = false; // 标记是否为 Base64
  
    if (choice === 'local') {
        newUrl = await new Promise(resolve => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = e => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => resolve(readerEvent.target.result);
                    reader.readAsDataURL(file);
                } else {
                    resolve(null);
                }
            };
            input.click();
        });
        if (newUrl) isBase64 = true;
  
    } else if (choice === 'url') {
        newUrl = await showCustomPrompt("更换图片", "请输入新的图片URL：", element.src, "url");
        if (newUrl) isBase64 = false;
    }
  
    if (newUrl && newUrl.trim()) {
        const trimmedUrl = newUrl.trim();
        
        // 1. [核心修改] 立即显示 Base64 或 URL
        element.src = trimmedUrl;
  
        // 2. 立即将 Base64 或 URL 保存到数据库，确保刷新不丢失
        if (!state.globalSettings.widgetData) {
            state.globalSettings.widgetData = {};
        }
        state.globalSettings.widgetData[imageId] = trimmedUrl;
        await db.globalSettings.put(state.globalSettings);
  
        await showCustomAlert("成功", "组件图片已更新并保存！");
  
        // 3. [核心修改] 只有当它是 Base64 且 ImgBB 开启时，才在后台“静默”上传
        if (isBase64 && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
            (async () => {
                console.log(`[ImgBB] 启动 ${imageId} 的静默上传...`);
                // 这个函数会在后台运行，不会阻塞
                await silentlyUpdateDbUrl(
                    db.globalSettings,
                    'main',
                    `widgetData.${imageId}`,
                    trimmedUrl // 传入 Base64 字符串
                );
            })();
        }
    }
  }


  window.handleWidgetImageChange = handleWidgetImageChange;

  async function exportDataAsSlicedZip() {

    if (!window.streamSaver || typeof JSZip === 'undefined') {
      await showCustomAlert("库加载失败", "无法启动导出，所需的核心库 (StreamSaver.js 或 JSZip) 未加载。请检查您的网络连接并刷新页面后重试。");
      return;
    }

    await showCustomAlert("正在准备分片导出...", "即将开始打包您的完整备份文件。文件将以ZIP格式流式下载，请勿关闭页面。");

  
    const fileStream = streamSaver.createWriteStream(`330-EPhone-Sliced-Backup-${new Date().toISOString().split('T')[0]}.zip`);
    const zip = new JSZip();

  
    const MAX_SLICE_SIZE = 95 * 1024 * 1024;
    let sliceIndex = 1;
    let currentSliceData = {}; 
    let currentSliceSizeBytes = 0;
    const encoder = new TextEncoder(); 

    try {
      const tablesToBackup = db.tables.map(t => t.name);

      for (const tableName of tablesToBackup) {
        console.log(`正在打包表: ${tableName}...`);
        const tableData = await db.table(tableName).toArray();

     
        if (tableData.length === 0) continue;

        const tableDataString = JSON.stringify(tableData);
        const tableDataSize = encoder.encode(tableDataString).length;

     
        if (tableDataSize > MAX_SLICE_SIZE) {
          console.warn(`警告：表 "${tableName}" (大小: ${(tableDataSize/1024/1024).toFixed(2)}MB) 单独超过了切片限制。`);

      
          if (currentSliceSizeBytes > 0) {
            zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({
              version: 4,
              type: 'slice',
              data: currentSliceData
            }));
            currentSliceData = {};
            currentSliceSizeBytes = 0;
          }

        
          currentSliceData[tableName] = tableData;
          zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({
            version: 4,
            type: 'slice',
            data: currentSliceData
          }));
          currentSliceData = {}; 
          currentSliceSizeBytes = 0;

          continue;
        }

      
        if (currentSliceSizeBytes > 0 && (currentSliceSizeBytes + tableDataSize > MAX_SLICE_SIZE)) {
          console.log(`切片 ${sliceIndex} 已满 (大小: ${(currentSliceSizeBytes/1024/1024).toFixed(2)}MB)，正在归档...`);

      
          zip.file(`slice_${sliceIndex++}.json`, JSON.stringify({
            version: 4,
            type: 'slice',
            data: currentSliceData
          }));

          
          currentSliceData = {};
          currentSliceSizeBytes = 0;
        }

    
        currentSliceData[tableName] = tableData;
        currentSliceSizeBytes += tableDataSize;
      }

    
      if (currentSliceSizeBytes > 0) {
        console.log(`正在归档最后一个切片 ${sliceIndex} (大小: ${(currentSliceSizeBytes/1024/1024).toFixed(2)}MB)...`);
        zip.file(`slice_${sliceIndex}.json`, JSON.stringify({
          version: 4,
          type: 'slice',
          data: currentSliceData
        }));
      }

      console.log("所有切片已打包，开始流式下载ZIP...");

    
      const zipStream = zip.generateInternalStream({
        type: "blob",
        streamFiles: true
      });

     
      const readableStream = new ReadableStream({
        start(controller) {
          zipStream.on('data', (chunk) => {
           
            controller.enqueue(chunk);
          }).on('end', () => {
          
            console.log("ZIP 流生成完毕。");
            controller.close();
          }).on('error', (err) => {
           
            console.error("JSZip 流错误:", err);
            controller.error(err);
          }).resume(); 
        }
      });

    
      await readableStream.pipeTo(fileStream);

      
      await showCustomAlert('导出已开始', '您的分片备份已开始下载。解压后，您可以使用“导入”功能，选择其中的 `slice_X.json` 文件进行增量恢复。');

    } catch (error) {
      console.error("分片导出过程中出错:", error);
      await showCustomAlert('导出失败', `在打包或写入文件流时发生错误: ${error.message}`);

    
      try {
        const writer = fileStream.getWriter();
        writer.abort(error);
      } catch (e) {}
    }
  }
 
  async function exportDataAsStream() {

    if (!window.streamSaver) {
      alert("流式下载库 (StreamSaver.js) 未加载。请检查网络连接或HTML文件配置。");
      return;
    }

    await showCustomAlert("正在准备...", "即将开始下载您的完整备份文件。下载过程中请勿关闭页面。");


    const fileStream = streamSaver.createWriteStream(`330-EPhone-Full-Backup-Streamed-${new Date().toISOString().split('T')[0]}.json`);
    const writer = fileStream.getWriter();
    const encoder = new TextEncoder();

    try {

      await writer.write(encoder.encode('{\n"version": 3,\n"timestamp": ' + Date.now() + ',\n"data": {\n'));

      const tablesToBackup = await db.tables.map(t => t.name);

      for (let i = 0; i < tablesToBackup.length; i++) {
        const tableName = tablesToBackup[i];
        const table = db.table(tableName);


        await writer.write(encoder.encode(`"${tableName}": [\n`));

        let isFirstRecordInTable = true;

        await table.each(record => {
          if (!isFirstRecordInTable) {
            writer.write(encoder.encode(',\n'));
          }

          writer.write(encoder.encode(JSON.stringify(record)));
          isFirstRecordInTable = false;
        });


        await writer.write(encoder.encode('\n]'));
        if (i < tablesToBackup.length - 1) {

          await writer.write(encoder.encode(',\n'));
        }
      }


      await writer.write(encoder.encode('\n}\n}'));

    } catch (error) {
      console.error("流式导出过程中出错:", error);
      await showCustomAlert('导出失败', `在写入文件流时发生错误: ${error.message}`);
    } finally {

      await writer.close();
    }
  }

  async function exportDataAsBlob() {
    await showCustomAlert("正在准备...", "正在读取所有数据到内存中，请稍候...");

    try {
      const backupData = {
        version: 3,
        timestamp: Date.now(),
        data: {}
      };

      const tablesToBackup = db.tables.map(t => t.name);

      for (const tableName of tablesToBackup) {
        const tableData = await db.table(tableName).toArray();
        backupData.data[tableName] = tableData;
        console.log(`已打包表: ${tableName}, 记录数: ${tableData.length}`);
      }

      const blob = new Blob(
        [JSON.stringify(backupData, null, 2)], {
          type: 'application/json'
        }
      );

      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `330-EPhone-Full-Backup-Legacy-${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);

      await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
      console.error("传统导出数据时出错:", error);
      await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
  }

  function updateBackButtonUnreadCount() {

    const totalChatUnread = Object.values(state.chats).reduce((sum, chat) => {

      if (chat.id === state.activeChatId) {
        return sum;
      }
      return sum + (chat.unreadCount || 0);
    }, 0);


    const totalQzoneUnread = unreadPostsCount || 0;


    const totalUnread = totalChatUnread + totalQzoneUnread;


    const backBtn = document.getElementById('back-to-list-btn');
    if (!backBtn) return;



    let indicator = backBtn.querySelector('.unread-indicator');
    if (!indicator) {
      indicator = document.createElement('span');
      indicator.className = 'unread-indicator';
      backBtn.appendChild(indicator);
    }


    let qzoneIndicator = backBtn.querySelector('.unread-indicator.back-btn-indicator');
    if (qzoneIndicator) {
      qzoneIndicator.remove();
    }


    if (totalUnread > 0) {
      indicator.textContent = totalUnread > 99 ? '99+' : totalUnread;
      indicator.style.display = 'block';

      indicator.style.zIndex = '20';
      indicator.style.transform = 'scale(0.8)';
    } else {
      indicator.style.display = 'none';
    }
  }

  async function openStickerCategoryBindingModal(categoryId) {
    const category = categoryId === 'uncategorized' ?
      {
        id: 'uncategorized',
        name: '未分类'
      } :
      await db.stickerCategories.get(categoryId);

    if (!category) {
      console.error("无法为不存在的分类打开绑定模态框:", categoryId);
      return;
    }

    const modal = document.getElementById('sticker-binding-modal');
    const listEl = document.getElementById('sticker-binding-chat-list');
    const header = modal.querySelector('.modal-header span');
    listEl.innerHTML = '';
    header.textContent = `将分类 “${category.name}” 绑定到...`;

    const allChats = Object.values(state.chats).sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    allChats.forEach(chat => {

      const isChecked = Array.isArray(chat.settings?.stickerCategoryIds) && chat.settings.stickerCategoryIds.includes(categoryId);

      const item = document.createElement('div');
      item.className = 'contact-picker-item'; // 复用现有样式
      item.innerHTML = `
            <input type="checkbox" class="sticker-binding-checkbox" data-chat-id="${chat.id}" ${isChecked ? 'checked' : ''} style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
      listEl.appendChild(item);
    });


    document.getElementById('save-sticker-binding-btn').onclick = () => saveStickerCategoryBindings(categoryId);
    document.getElementById('cancel-sticker-binding-btn').onclick = () => modal.classList.remove('visible');

    modal.classList.add('visible');
  }


  async function saveStickerCategoryBindings(categoryId) {
    const selectedChatIds = new Set(
      Array.from(document.querySelectorAll('#sticker-binding-chat-list .sticker-binding-checkbox:checked'))
      .map(cb => cb.dataset.chatId)
    );

    const chatsToUpdate = [];
    for (const chatId in state.chats) {
      const chat = state.chats[chatId];
      if (!Array.isArray(chat.settings.stickerCategoryIds)) {
        chat.settings.stickerCategoryIds = [];
      }

     
      const wasBound = chat.settings.stickerCategoryIds.includes(categoryId);
      const shouldBeBound = selectedChatIds.has(chatId);

      if (wasBound && !shouldBeBound) {
       
        chat.settings.stickerCategoryIds = chat.settings.stickerCategoryIds.filter(id => id !== categoryId);
        chatsToUpdate.push(chat);
      } else if (!wasBound && shouldBeBound) {
       
        chat.settings.stickerCategoryIds.push(categoryId);
        chatsToUpdate.push(chat);
      }
    }

    if (chatsToUpdate.length > 0) {
      await db.chats.bulkPut(chatsToUpdate);
      await showCustomAlert("保存成功", "表情包分类绑定已更新！");
    }

    document.getElementById('sticker-binding-modal').classList.remove('visible');
  }


  function getStickerContextForPrompt(chat) {
    if (!chat || !chat.settings.stickerCategoryIds || chat.settings.stickerCategoryIds.length === 0) {
      return '';
    }

    const categoryIds = chat.settings.stickerCategoryIds;
    let allStickers = [];
    const addedStickerNames = new Set();

    
    categoryIds.forEach(categoryId => {
      let stickersInCategory;

      if (categoryId === 'uncategorized') {
        stickersInCategory = state.userStickers.filter(s => !s.categoryId);
      } else {
        stickersInCategory = state.userStickers.filter(s => s.categoryId === categoryId);
      }

     
      stickersInCategory.forEach(sticker => {
        if (!addedStickerNames.has(sticker.name)) {
          allStickers.push(sticker);
          addedStickerNames.add(sticker.name);
        }
      });
    });

    if (allStickers.length === 0) {
      return '';
    }

    const stickerList = allStickers.map(s => `- ${s.name}`).join('\n');
    return `
# 可用表情包 (选填)
# 【【【表情使用铁律 (最高优先级)】】】
1.  你【只能】在同时发送了【有意义的文本内容】之后，才能【额外】追加一个表情。
2.  【绝对禁止】只发送一个表情作为单独的回复。
3.  【绝对禁止】发明或编造列表中不存在的表情含义。
4.  如果你在列表中找不到【100%完美匹配】的表情，请【不要】使用 "sticker" 指令，只发送文本。
5. 【使用频率】: 你【不应该】在每一轮对话中都发送表情。请只在你觉得【非常必要】或【情绪特别强烈】时才使用表情，保持对话的自然性。
6.  **【重复惩罚 (最高铁律！)】**: 你【绝对禁止】连续几轮回复使用【完全相同】的表情含义。例如，如果你上一轮回复了 "meaning": "害羞"，那么你这一轮【绝对不能】再次使用 "meaning": "害羞"。你必须选择一个不同的含义，或者干脆不发表情。
- **可用列表**:
${stickerList}
`;
  }


  function getGroupStickerContextForPrompt(chat) {
    if (!chat || !chat.isGroup) return '';

    const allCategoryIds = new Set();
    chat.members.forEach(member => {
        if (member.id === 'user') return;
        const memberChat = state.chats[member.id];
        if (memberChat && memberChat.settings.stickerCategoryIds) {
            memberChat.settings.stickerCategoryIds.forEach(id => allCategoryIds.add(id));
        }
    });

    if (allCategoryIds.size === 0) {
      return ''; 
    }

    let allStickers = [];
    const addedStickerNames = new Set();

    allCategoryIds.forEach(categoryId => {
        let stickersInCategory;
        if (categoryId === 'uncategorized') {
            stickersInCategory = state.userStickers.filter(s => !s.categoryId);
        } else {
            stickersInCategory = state.userStickers.filter(s => s.categoryId === categoryId);
        }

        stickersInCategory.forEach(sticker => {
            if (!addedStickerNames.has(sticker.name)) {
                allStickers.push(sticker);
                addedStickerNames.add(sticker.name);
            }
        });
    });

    if (allStickers.length === 0) {
        return '';
    }

    const stickerList = allStickers.map(s => `- ${s.name}`).join('\n');
    return `
# 可用表情包 (全群共享)
# 【【【表情使用铁律 (最高优先级)】】】
1.  【绝对禁止】只发送一个表情作为单独的回复。
2.  【绝对禁止】发明或编造列表中不存在的表情含义。
3.  如果没找到合适的，请不要使用 "sticker" 指令。
4.  **【角色分配】**: 你可以从下面的【共享列表】中选择任意表情，并将其分配给【任意AI角色】。
5. 【使用频率】: 请只在你觉得【非常必要】或【情绪特别强烈】时才使用表情，保持对话的自然性。
6.  **【重复惩罚 (最高铁律！)】**: 你【绝对禁止】连续几轮回复使用【完全相同】的表情含义。例如，如果你上一轮回复了 "meaning": "害羞"，那么你这一轮【绝对不能】再次使用 "meaning": "害羞"。你必须选择一个不同的含义，或者干脆不发表情。
- **可用列表**:
${stickerList}
`;
}

  function estimateTokens(text) {
    if (!text) return 0;
 
    return Math.ceil(text.length / 1.5);
  }


  async function calculateCurrentContextTokens() {
    if (!state.activeChatId) return 0;
    const chat = state.chats[state.activeChatId];
    if (!chat) return 0;

    
    const maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    const linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;
    const isOfflineMode = document.getElementById('offline-mode-toggle').checked;
    const aiPersona = document.getElementById('ai-persona').value;
    const myPersona = document.getElementById('my-persona').value;

    let fullContextString = '';


    const linkedBookIds = Array.from(document.querySelectorAll('#world-book-checkboxes-container input:checked')).map(cb => cb.value.replace('book_', ''));
    if (linkedBookIds.length > 0) {
      const linkedContents = linkedBookIds.map(bookId => {
        const worldBook = state.worldBooks.find(wb => wb.id === bookId);
        if (!worldBook || !Array.isArray(worldBook.content)) return '';
        return worldBook.content.filter(e => e.enabled !== false).map(e => e.content).join('\n');
      }).filter(Boolean).join('\n');
      fullContextString += linkedContents;
    }

 
    if (chat.longTermMemory && chat.longTermMemory.length > 0) {
      fullContextString += chat.longTermMemory.map(mem => mem.content).join('\n');
    }

 
    const linkedMemoryToggle = document.getElementById('link-memory-toggle').checked;
    if (linkedMemoryToggle) {
      const linkedChatIds = Array.from(document.querySelectorAll('#linked-chats-checkboxes-container input:checked')).map(cb => cb.value);
      for (const linkedId of linkedChatIds) {
        const linkedChat = state.chats[linkedId];
        if (linkedChat && linkedChat.history.length > 0) {
          fullContextString += linkedChat.history.slice(-linkedMemoryCount).map(msg => String(msg.content)).join('\n');
        }
      }
    }

   
    if (chat.isGroup) {
      chat.members.forEach(member => {
        fullContextString += member.persona;
      });
    } else {
      fullContextString += aiPersona;
    }
    fullContextString += myPersona;

  
    fullContextString += getStickerContextForPrompt(chat);
    if (chat.isGroup) {
      fullContextString += getGroupStickerContextForPrompt(chat);
    }

   
    if (!chat.isGroup && isOfflineMode) {
      const offlinePresetId = document.getElementById('offline-preset-select').value;
      if (offlinePresetId) {
        const preset = state.presets.find(p => p.id === offlinePresetId);
        if (preset) {
          fullContextString += preset.content.filter(e => e.enabled !== false).map(e => e.content).join('\n');
        }
      }
    }

  
    const historySlice = chat.history.slice(-maxMemory);
    fullContextString += historySlice.map(msg => {
      if (typeof msg.content === 'string') return msg.content;
      if (Array.isArray(msg.content)) return msg.content.map(p => p.text).join(' ');
      return '';
    }).join('\n');

    return estimateTokens(fullContextString);
  }


  const updateTokenCountDisplay = debounce(async () => {
    
    const tokenValueEl = document.getElementById('token-count-value');
    const msgValueEl = document.getElementById('message-count-value');
    
    if (!tokenValueEl) return;

   
    const chat = state.activeChatId ? state.chats[state.activeChatId] : null;
    if (msgValueEl) {
        if (chat && chat.history) {
           
            const visibleCount = chat.history.filter(m => !m.isHidden).length;
            msgValueEl.textContent = `${visibleCount} 条`;
            msgValueEl.style.color = "#000000";
        } else {
            msgValueEl.textContent = "--";
        }
    }

    
    tokenValueEl.textContent = "计算中...";
    try {
      const tokenCount = await calculateCurrentContextTokens();
      tokenValueEl.textContent = `${tokenCount} Tokens`;
      tokenValueEl.style.color = "#000000"; 
      
     
      if (document.body.classList.contains('dark-mode') || document.getElementById('phone-screen').classList.contains('dark-mode')) {
           msgValueEl.style.color = "#ffffff";
           tokenValueEl.style.color = "#ffffff";
      }
      
    } catch (error) {
      console.error("Token calculation error:", error);
      tokenValueEl.textContent = "Error";
    }
  }, 300);

 
  async function openNaiGallery() {
   
    naiGalleryCache = { local: [], cloud: [] };
    naiGalleryRenderCount = { local: 0, cloud: 0 };
    isLoadingMoreNaiImages = { local: false, cloud: false };

    const allNaiImages = [];

    
    try {
      const allChats = await db.chats.toArray();
      for (const chat of allChats) {
        if (chat.history && chat.history.length > 0) {
          chat.history.forEach(msg => {
            if (msg.type === 'naiimag' && msg.imageUrl) {
              allNaiImages.push({
                sourceType: 'chat',
                imageUrl: msg.imageUrl,
                prompt: msg.prompt || msg.fullPrompt || 'NAI Image',
                chatId: chat.id,
                msgTimestamp: msg.timestamp
              });
            }
          });
        }
      }
    } catch (e) {
      console.error("扫描聊天记录失败:", e);
    }

    
    try {
      const allPosts = await db.qzonePosts.toArray();
      allPosts.forEach(post => {
        if (post.type === 'naiimag') {
          const urls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);
          const prompts = Array.isArray(post.prompt) ? post.prompt : [post.prompt || 'NAI Image'];
          urls.forEach((url, index) => {
            allNaiImages.push({
              sourceType: 'qzone',
              imageUrl: url,
              prompt: prompts[index] || prompts[0],
              postId: post.id,
              imageIndex: index
            });
          });
        }
      });
    } catch (e) {
      console.error("扫描动态失败:", e);
    }

    
    allNaiImages.sort((a, b) => (b.msgTimestamp || b.postId || 0) - (a.msgTimestamp || a.postId || 0));

  
    allNaiImages.forEach(img => {
      if (img.imageUrl.startsWith('data:image')) {
        naiGalleryCache.local.push(img);
      } else {
        naiGalleryCache.cloud.push(img);
      }
    });

    
    document.getElementById('nai-gallery-grid-local').innerHTML = '';
    document.getElementById('nai-gallery-grid-cloud').innerHTML = '';

   
    switchNaiGalleryTab('local'); 
    
    document.getElementById('nai-gallery-panel').classList.add('visible');
  }
function switchNaiGalleryTab(tabId) {
    if (isNaiGalleryManagementMode) {
        toggleNaiGalleryManagementMode(); // 切换时自动退出管理模式
    }
    
    activeNaiGalleryTab = tabId;

   
    document.querySelectorAll('.nai-gallery-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tabId === tabId);
    });

   
    document.querySelectorAll('.nai-gallery-page').forEach(page => {
        page.classList.toggle('active', page.id === `nai-gallery-grid-${tabId}`);
    });

  
    const cache = naiGalleryCache[tabId];
    const renderCount = naiGalleryRenderCount[tabId];
    const gridEl = document.getElementById(`nai-gallery-grid-${tabId}`);

    if (renderCount === 0) { 
        gridEl.innerHTML = '';
        if (cache.length === 0) {
            const message = (tabId === 'local') ? 
                '本地画廊是空的，快去生成一些图片吧！' :
                '图床画廊是空的，请从“本地”上传图片。';
            gridEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
        } else {
            loadMoreNaiGalleryImages(); // 加载第一页
        }
    }
    
    
    updateNaiGalleryActionButtons();
  }  
  function renderNaiGalleryGrid(images, gridEl) {
  
    if (images.length === 0 && naiGalleryRenderCount[activeNaiGalleryTab] === 0) {
      const message = (activeNaiGalleryTab === 'local') ? 
          '本地画廊是空的，快去生成一些图片吧！' :
          '图床画廊是空的。';
      gridEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">${message}</p>`;
      return;
    }

    const fragment = document.createDocumentFragment(); 

    images.forEach((img, i) => {
      const item = document.createElement('div');
      item.className = 'nai-gallery-item'; 
      item.title = img.prompt;

  
      const itemKey = `${img.sourceType}_${img.chatId || img.postId}_${img.msgTimestamp || img.imageIndex}`;
      item.dataset.key = itemKey;
      item.dataset.imageUrl = img.imageUrl;
      item.dataset.prompt = img.prompt;

  
      item.innerHTML = `
            <div class="nai-image-container" style="background-image: url(${img.imageUrl})">
                <div class="nai-gallery-controls">
                    <button class="nai-gallery-download-btn" title="下载">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></svg>
                    </button>
                    <button class="nai-gallery-delete-btn" title="删除">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>
                    </button>
                </div>
            </div>
            <span class="nai-gallery-name">${img.prompt}</span>
        `;
    
      fragment.appendChild(item); 
    });

    gridEl.appendChild(fragment); 
  }

  async function loadMoreNaiGalleryImages() {
    const activeTab = activeNaiGalleryTab;
    if (isLoadingMoreNaiImages[activeTab] || naiGalleryRenderCount[activeTab] >= naiGalleryCache[activeTab].length) {
      return; 
    }

    isLoadingMoreNaiImages[activeTab] = true;
    const gridEl = document.getElementById(`nai-gallery-grid-${activeTab}`);
    showLoader(gridEl, 'bottom'); 

   
    setTimeout(() => {
      
      if (activeNaiGalleryTab !== activeTab) {
          isLoadingMoreNaiImages[activeTab] = false;
          hideLoader(gridEl);
          return;
      }
      
      const imagesToAppend = naiGalleryCache[activeTab].slice(
          naiGalleryRenderCount[activeTab], 
          naiGalleryRenderCount[activeTab] + NAI_GALLERY_RENDER_WINDOW
      );

      hideLoader(gridEl); 

      if (imagesToAppend.length > 0) {
        renderNaiGalleryGrid(imagesToAppend, gridEl); 
        naiGalleryRenderCount[activeTab] += imagesToAppend.length;
      }

      isLoadingMoreNaiImages[activeTab] = false;
    }, 500);
  }

  function toggleNaiGalleryManagementMode() {
    isNaiGalleryManagementMode = !isNaiGalleryManagementMode;
    const grid = document.getElementById(`nai-gallery-grid-${activeNaiGalleryTab}`);
    const manageBtn = document.getElementById('manage-nai-gallery-btn');
    const actionBar = document.getElementById('nai-gallery-action-bar');
    const selectAllCheckbox = document.getElementById('select-all-nai-gallery-checkbox');

    grid.classList.toggle('management-mode', isNaiGalleryManagementMode);

    if (isNaiGalleryManagementMode) {
      manageBtn.textContent = '完成';
      actionBar.style.display = 'flex';
      selectedNaiImages.clear();
      selectAllCheckbox.checked = false;
      updateNaiGalleryActionButtons();
      document.querySelectorAll('.nai-gallery-page').forEach(page => page.classList.add('management-mode'));
    } else {
      manageBtn.textContent = '管理';
      actionBar.style.display = 'none';
      document.querySelectorAll('.nai-gallery-page').forEach(page => page.classList.remove('management-mode'));
      grid.querySelectorAll('.nai-gallery-item.selected').forEach(item => item.classList.remove('selected'));
    }
  }

  
  function updateNaiGalleryActionButtons() { 
    const deleteBtn = document.getElementById('delete-selected-nai-gallery-btn');
    const downloadBtn = document.getElementById('download-selected-nai-gallery-btn');
    const uploadBtn = document.getElementById('upload-selected-nai-gallery-btn');
    const exportBtn = document.getElementById('export-selected-nai-gallery-btn'); // 1. 获取按钮元素
    const count = selectedNaiImages.size;

    if (deleteBtn) deleteBtn.textContent = `删除 (${count})`;
    if (downloadBtn) downloadBtn.textContent = `下载 (${count})`;

    // 2. 添加导出按钮逻辑
    if (exportBtn) {
        exportBtn.textContent = `导出 (${count})`;
        // 仅在 'cloud' (图床) 标签页显示，且有选中项时显示(可选)，这里我们只判断是否是图床页
        exportBtn.style.display = (activeNaiGalleryTab === 'cloud') ? 'block' : 'none';
    }

    if (uploadBtn) { 
      uploadBtn.textContent = `上传 (${count})`;
      const shouldShowUpload = (activeNaiGalleryTab === 'local' && state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey);
      uploadBtn.style.display = shouldShowUpload ? 'block' : 'none';
    }
}
async function executeBatchExportNaiImages() {
    if (selectedNaiImages.size === 0) {
      alert("请先选择要导出的图片。");
      return;
    }

    let exportText = "";
    let exportedCount = 0;

   
    selectedNaiImages.forEach(key => {
       
        const item = naiGalleryCache.cloud.find(img => {
             const itemKey = `${img.sourceType}_${img.chatId || img.postId}_${img.msgTimestamp || img.imageIndex}`;
             return itemKey === key;
        });

        if (item && item.imageUrl) {
           
            exportText += `${item.imageUrl}\n`;
            exportedCount++;
        }
    });

    if (exportedCount === 0) {
      alert("未找到所选图片的数据（请确认您在‘图床’分类下）。");
      return;
    }

    const finalText = exportText.trim();
    const textareaId = 'batch-export-nai-textarea-' + Date.now();
    
    const alertHtml = `
        <p style="text-align:left; font-size: 14px; margin: 0 0 10px 0;">
            已提取 ${exportedCount} 条链接：
        </p>
        <textarea id="${textareaId}" 
                  rows="10" 
                  style="width: 100%; font-size: 12px; resize: vertical; border-radius: 6px; border: 1px solid #ccc;"
                  readonly>${finalText}</textarea>
    `;

    showCustomAlert("复制链接", alertHtml);
  
   
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    if (modalConfirmBtn) {
        modalConfirmBtn.textContent = '一键复制';
        const originalOnclick = modalConfirmBtn.onclick;

        modalConfirmBtn.onclick = async (e) => {
            try {
                await navigator.clipboard.writeText(finalText);
                modalConfirmBtn.textContent = '复制成功!';
                setTimeout(() => {
                   modalConfirmBtn.textContent = '完成';
                   modalConfirmBtn.onclick = originalOnclick; 
                }, 1500);
            } catch (err) {
                alert('自动复制失败，请长按文本框手动复制。');
                modalConfirmBtn.textContent = '完成';
                modalConfirmBtn.onclick = originalOnclick;
            }
        };
    }
}
  
  function handleNaiGalleryGridClick(e) {
    const item = e.target.closest('.nai-gallery-item');
    if (!item) return;

    const key = item.dataset.key;
    const imageUrl = item.dataset.imageUrl;
    const prompt = item.dataset.prompt;

 
    if (e.target.closest('.nai-gallery-download-btn')) {
      e.stopPropagation();
      downloadNaiImage(imageUrl, prompt);
      return;
    }

  
    if (e.target.closest('.nai-gallery-delete-btn')) {
      e.stopPropagation();
      executeBatchDeleteNaiImages(new Set([key])); 
      return;
    }

    
    if (isNaiGalleryManagementMode) {
      item.classList.toggle('selected');
      if (selectedNaiImages.has(key)) {
        selectedNaiImages.delete(key);
      } else {
        selectedNaiImages.add(key);
      }
      updateNaiGalleryActionButtons();
    } else {
      const modalTitle = "图片详情";
      const modalContentHtml = `
                <div style="text-align: center;">
                    <img src="${imageUrl}" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">
                </div>
            `;
    
      showCustomAlert(modalTitle, modalContentHtml);
    }
  }

  async function executeBatchDownloadNaiImages() {
  
    const keys = selectedNaiImages;
   

    if (keys.size === 0) {
      alert("请先选择要下载的图片。");
      return;
    }

  
    if (typeof JSZip === 'undefined' || !window.streamSaver) {
      await showCustomAlert("下载失败", "核心库 (JSZip 或 StreamSaver) 未能成功加载，请检查您的网络连接并刷新页面后重试。");
      return;
    }


    await showCustomAlert("请稍候...", `正在准备 ${keys.size} 张图片...`);
 

    const zip = new JSZip();
    let failedDownloads = 0;
    const downloadPromises = [];

 
    const keysArray = Array.from(keys);

    keysArray.forEach((key, index) => { 
     

      const item = document.querySelector(`.nai-gallery-item[data-key="${key}"]`);
      if (!item) return;

      const imageUrl = item.dataset.imageUrl;
      const prompt = item.dataset.prompt;

      
      const baseFilename = generateFilenameForNai(prompt); // e.g., "my_prompt_timestamp.png"
    
      const filename = baseFilename.replace(/\.png$/, `_(${index + 1}).png`);
   

      const promise = (async () => {
        try {
          let blob;
          if (imageUrl.startsWith('data:')) {
            const response = await fetch(imageUrl);
            blob = await response.blob();
          } else {
            let response;
            try {
             
              response = await fetch(imageUrl, {
                mode: 'cors'
              });
              if (!response.ok) throw new Error('直连失败');
            } catch (e) {
            
              console.warn("直连失败, 尝试使用CORS代理...", e.message);
              const settings = getNovelAISettings();
              let corsProxy = settings.cors_proxy === 'custom' ? settings.custom_proxy_url : settings.cors_proxy;
              if (!corsProxy || corsProxy === '') corsProxy = 'https://corsproxy.io/?';
              const proxiedUrl = corsProxy + encodeURIComponent(imageUrl);
              response = await fetch(proxiedUrl);
            }

            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            blob = await response.blob();
          }
          zip.file(filename, blob, {
            binary: true
          }); 
        } catch (e) {
          console.error(`下载图片失败: ${imageUrl}`, e);
          failedDownloads++;
        }
      })();
      downloadPromises.push(promise);
    });

   
    await Promise.all(downloadPromises);

    if (failedDownloads === keys.size) {
      await showCustomAlert("下载失败", "所有图片都下载失败了。这通常是由于网络问题或CORS跨域限制（请检查API设置中的CORS代理是否有效）。");
      return;
    }

    await showCustomAlert("打包中...", "所有图片已准备就绪，正在流式压缩... 下载将自动开始。");

    try {
     
      const fileStream = streamSaver.createWriteStream(`NAI_Gallery_Batch_${Date.now()}.zip`);

     
      const zipStream = zip.generateInternalStream({
        type: "blob",
        streamFiles: true 
      });

     
      const readableStream = new ReadableStream({
        start(controller) {
          zipStream.on('data', (chunk) => {
           
            controller.enqueue(chunk);
          }).on('end', () => {
           
            console.log("ZIP 流生成完毕。");
            controller.close();
          }).on('error', (err) => {
           
            console.error("JSZip 流错误:", err);
            controller.error(err);
          }).resume(); // 启动 JSZip 流
        }
      });

     
      await readableStream.pipeTo(fileStream);

     
      if (failedDownloads > 0) {
        showCustomAlert("部分下载完成", `成功打包 ${keys.size - failedDownloads} 张图片。有 ${failedDownloads} 张图片因网络或CORS限制下载失败。`);
      }

    } catch (error) {
      console.error("流式下载ZIP失败:", error);
      await showCustomAlert("流式下载失败", `创建ZIP流时出错: ${error.message}`);
    }
  }

  async function executeBatchDeleteNaiImages(keysToDelete = null) {
    const keys = keysToDelete || selectedNaiImages;
    if (keys.size === 0) return;

    const confirmed = await showCustomConfirm(
      '确认删除',
      `确定要从【聊天记录和动态】中永久删除这 ${keys.size} 张NAI图片吗？此操作不可恢复。`, {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", "正在执行删除操作...");

    let deletedCount = 0;
    const chatsToUpdate = new Map();
    const postsToDelete = new Set();
    const postsToModify = new Map();


    const postIdsToFetch = new Set();
    for (const key of keys) {
      if (key.startsWith('qzone_')) {
        const parts = key.split('_');
        const postId = parseInt(parts[1]); // qzone ID 不会包含 '_'
        if (!isNaN(postId)) {
          postIdsToFetch.add(postId);
        }
      }
    }
    const postsCache = new Map();
    if (postIdsToFetch.size > 0) {
      const posts = await db.qzonePosts.where('id').anyOf(Array.from(postIdsToFetch)).toArray();
      posts.forEach(post => postsCache.set(post.id, post));
    }


    for (const key of keys) {

    

      const parts = key.split('_');
      if (parts.length < 3) {
        console.warn("跳过格式错误的NAI图片Key:", key);
        continue;
      }

      const sourceType = parts[0];
      const identifier = parts.pop(); 
      const id = parts.slice(1).join('_'); 

      if (sourceType === 'chat') {
        const chatId = id;
        const msgTimestamp = parseInt(identifier);

        if (!chatsToUpdate.has(chatId)) {
         
          const chatData = await db.chats.get(chatId);
          if (chatData) {
            chatsToUpdate.set(chatId, chatData);
          } else {
            console.warn(`未找到 chatID: ${chatId}，跳过...`);
            continue;
          }
        }

        const chat = chatsToUpdate.get(chatId);
        if (chat && chat.history) {
          const originalLength = chat.history.length;
          chat.history = chat.history.filter(msg => msg.timestamp !== msgTimestamp);
          if (chat.history.length < originalLength) {
            deletedCount++;
            chatsToUpdate.set(chatId, chat); // 标记此chat需要被更新
          if (state.chats[chatId]) {
                state.chats[chatId].history = chat.history;
            }
          }
        }
      } else if (sourceType === 'qzone') {
        const postId = parseInt(id);
        const imageIndex = parseInt(identifier);

        const post = postsToModify.get(postId) || postsCache.get(postId);
        if (!post) {
          console.warn(`未找到 postID: ${postId}，跳过...`);
          continue;
        }

        const urls = post.imageUrls || (post.imageUrl ? [post.imageUrl] : []);

        if (urls.length <= 1) {
         
          postsToDelete.add(postId);
          if (postsToModify.has(postId)) {
            postsToModify.delete(postId); 
          }
        } else {
          
          const urlToRemove = urls[imageIndex];
          post.imageUrls = post.imageUrls.filter(url => url !== urlToRemove);

          if (post.prompt && Array.isArray(post.prompt) && post.prompt[imageIndex]) {
            post.prompt.splice(imageIndex, 1);
          }
          post.imageUrl = post.imageUrls[0] || null; 
          postsToModify.set(postId, post);
        }
        deletedCount++;
      }
    }

    try {
      await db.transaction('rw', db.chats, db.qzonePosts, async () => {
        if (chatsToUpdate.size > 0) {
          await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
        }
        if (postsToModify.size > 0) {
          await db.qzonePosts.bulkPut(Array.from(postsToModify.values()));
        }
        if (postsToDelete.size > 0) {
          await db.qzonePosts.bulkDelete(Array.from(postsToDelete));
        }
      });

      
      toggleNaiGalleryManagementMode();
      keys.forEach(key => { 
          naiGalleryCache.local = naiGalleryCache.local.filter(item => {
              const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
              return itemKey !== key;
          });
          naiGalleryCache.cloud = naiGalleryCache.cloud.filter(item => {
              const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
              return itemKey !== key;
          });
      });

      
      naiGalleryRenderCount[activeNaiGalleryTab] = 0;
      document.getElementById(`nai-gallery-grid-${activeNaiGalleryTab}`).innerHTML = '';
      
     
      loadMoreNaiGalleryImages();
      await showCustomAlert('删除成功', `已成功删除 ${deletedCount} 张图片。`);

     
      if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        renderChatInterface(state.activeChatId);
      }
      if (document.getElementById('qzone-screen').classList.contains('active')) {
        renderQzonePosts();
      }

    } catch (error) {
      console.error("批量删除NAI图片时出错:", error);
      await showCustomAlert('删除失败', `操作失败: ${error.message}`);
    }
  }


async function executeBatchUploadNaiImagesToImgBB() {
 
    if (!state.apiConfig.imgbbEnable || !state.apiConfig.imgbbApiKey) {
        await showCustomAlert("功能未开启", "请先在“API设置”中开启 ImgBB 自动图床功能并填写 API Key。");
        return;
    }

   
    const itemsToUpload = Array.from(selectedNaiImages)
        .map(key => document.querySelector(`.nai-gallery-item[data-key="${key}"]`))
        .filter(item => item && item.dataset.imageUrl && item.dataset.imageUrl.startsWith('data:image'));

    if (itemsToUpload.length === 0) {
        await showCustomAlert("无需上传", "你选择的图片中没有需要上传的本地图片（它们可能已经是网络链接了）。");
        return;
    }

   
    const confirmed = await showCustomConfirm(
        '确认上传？',
        `即将把 ${itemsToUpload.length} 张本地图片上传到 ImgBB，并永久替换其在数据库中的地址。此操作不可逆！\n\n（上传期间请勿关闭页面）`,
        { confirmButtonClass: 'btn-danger', confirmText: '确认上传' }
    );

    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在开始上传 ${itemsToUpload.length} 张图片...`);

    
    let successCount = 0;
    let failCount = 0;
    const chatsToUpdate = new Map();
    const postsToUpdate = new Map();
    const keysToUpdateInCache = new Map(); 
  
    for (const item of itemsToUpload) {
        const key = item.dataset.key;
        const base64Url = item.dataset.imageUrl;

        try {
            
            const newUrl = await uploadImageToImgBB(base64Url);
            
            
            if (newUrl === base64Url) {
                throw new Error("上传函数返回了原始Base64，可能上传失败或被跳过。");
            }
            
          
            const parts = key.split('_');
            if (parts.length < 3) throw new Error(`Key格式错误: ${key}`);
            
            const sourceType = parts[0];
            const identifier = parts.pop();
            const id = parts.slice(1).join('_'); 

            
            if (sourceType === 'chat') {
                const chatId = id;
                const msgTimestamp = parseInt(identifier);
                
                let chat = chatsToUpdate.get(chatId);
                if (!chat) chat = await db.chats.get(chatId); // 从DB获取最新
                
                if (chat && chat.history) {
                    const msg = chat.history.find(m => m.timestamp === msgTimestamp);
                    if (msg && msg.imageUrl === base64Url) {
                        msg.imageUrl = newUrl;
                        chatsToUpdate.set(chatId, chat);
                        keysToUpdateInCache.set(key, newUrl);
                        successCount++;
                    } else {
                        throw new Error(`未在聊天 ${chatId} 中找到时间戳为 ${msgTimestamp} 且匹配Base64的消息。`);
                    }
                }
                
            
            } else if (sourceType === 'qzone') {
                const postId = parseInt(id);
                const imageIndex = parseInt(identifier);

                let post = postsToUpdate.get(postId);
                if (!post) post = await db.qzonePosts.get(postId);
                
                if (post && post.imageUrls && post.imageUrls[imageIndex] === base64Url) {
                    post.imageUrls[imageIndex] = newUrl;
                    
                   
                    if (imageIndex === 0) {
                        post.imageUrl = newUrl;
                    }
                    
                    postsToUpdate.set(postId, post);
                    keysToUpdateInCache.set(key, newUrl);
                    successCount++;
                } else {
                    throw new Error(`未在动态 ${postId} 的第 ${imageIndex} 张图中找到匹配的Base64。`);
                }
            }

        } catch (error) {
            failCount++;
            console.error(`上传失败 (Key: ${key}):`, error.message);
        }
    }

   
    try {
        if (chatsToUpdate.size > 0 || postsToUpdate.size > 0) {
            await db.transaction('rw', db.chats, db.qzonePosts, async () => {
                if (chatsToUpdate.size > 0) {
                    await db.chats.bulkPut(Array.from(chatsToUpdate.values()));
                }
                if (postsToUpdate.size > 0) {
                    await db.qzonePosts.bulkPut(Array.from(postsToUpdate.values()));
                }
            });
        }
    } catch (dbError) {
        console.error("批量更新数据库失败:", dbError);
        await showCustomAlert("数据库更新失败", `图片上传完成，但在保存到数据库时出错: ${dbError.message}`);
        return;
    }

   
    keysToUpdateInCache.forEach((newUrl, key) => {
        const cacheEntry = naiGalleryCache.find(item => {
            const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
            return itemKey === key;
        });
        if (cacheEntry) {
            cacheEntry.imageUrl = newUrl;
        }
        
        const domItem = document.querySelector(`.nai-gallery-item[data-key="${key}"]`);
        if (domItem) {
            domItem.dataset.imageUrl = newUrl; 
            domItem.querySelector('.nai-image-container').style.backgroundImage = `url(${newUrl})`;
        }
    });

   const updatedLocal = [];
    const updatedCloud = [];
    
    naiGalleryCache.local.forEach(item => {
        const itemKey = `${item.sourceType}_${item.chatId || item.postId}_${item.msgTimestamp || item.imageIndex}`;
        if (keysToUpdateInCache.has(itemKey)) {
            
            item.imageUrl = keysToUpdateInCache.get(itemKey);
            updatedCloud.push(item);
        } else {
          
            updatedLocal.push(item);
        }
    });
    
   
    naiGalleryCache.cloud.push(...updatedCloud);
    naiGalleryCache.local = updatedLocal;
    
    
    naiGalleryRenderCount = { local: 0, cloud: 0 };
    let resultMessage = `批量上传完成！\n\n成功: ${successCount} 张\n失败: ${failCount} 张`;
    if (failCount > 0) {
        resultMessage += "\n\n失败的图片请检查控制台（Console）中的错误日志。";
    }
    await showCustomAlert("操作完成", resultMessage);

    
    toggleNaiGalleryManagementMode();
} 
  function generateFilenameForNai(prompt) {
  
    const title = prompt || 'NAI_Image';

  
    let cleanTitle = title
      .replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g, '_') 
      .replace(/\s+/g, '_') 
      .substring(0, 30);

    if (!cleanTitle) {
      cleanTitle = 'NAI_Image';
    }

   
    const timestamp = new Date().toISOString()
      .replace(/[-:]/g, '')
      .replace('T', '_')
      .split('.')[0]; // 格式：20250124_123045

    
    return `${cleanTitle}_${timestamp}.png`;
  }
 
  function openQuickReplyModal() {
    // 打开弹窗时，标记需要刷新DOM，因为可能上次关闭后数据变了
    const tabsContainer = document.getElementById('quick-reply-tabs');
    if(tabsContainer) tabsContainer.dataset.needsRefresh = 'true';
    
    renderQuickReplyList(true); 
    document.getElementById('quick-reply-modal').classList.add('visible');
}

 
  // --- 快捷回复分类功能区 ---

// 1. [核心修改] 渲染快捷回复列表 (支持分类和Tabs)
// [优化版] 渲染快捷回复列表 (解决闪烁问题)
async function renderQuickReplyList(rerenderTabs = true) {
    const listEl = document.getElementById('quick-reply-list');
    const tabsContainer = document.getElementById('quick-reply-tabs');
    listEl.innerHTML = '';

    // 1. 渲染标签栏 (核心优化：只有在 rerenderTabs 为 true 时才重建DOM)
    // 如果只是切换分类，不需要重建DOM，只需要更新 active 类
    if (rerenderTabs) {
        // 检查是否真的需要重建 (例如：刚打开弹窗时，或者添加/删除分类后)
        // 如果 tabsContainer 是空的，说明必须重建
        // 如果 tabsContainer 已有内容，且我们只是想更新样式，就不清空它
        
        // 这里我们稍微改一下策略：
        // 如果是“切换分类”操作触发的重绘，我们不传 rerenderTabs=true，或者在内部判断
        
        const categories = await db.quickReplyCategories.toArray();
        
        // 如果标签栏是空的，或者确实需要强制刷新 (比如增删了分类)，则重建
        if (tabsContainer.children.length === 0 || tabsContainer.dataset.needsRefresh === 'true') {
            tabsContainer.innerHTML = '';
            tabsContainer.dataset.needsRefresh = 'false'; // 重置标记

            // 辅助函数：创建标签
            const createTab = (id, name) => {
                const btn = document.createElement('button');
                btn.className = 'sticker-category-tab'; // 初始不加 active
                if (activeQuickReplyCategoryId === id) btn.classList.add('active');
                
                btn.textContent = name;
                btn.dataset.categoryId = id;
                
                // 点击事件：只更新 active 类，不重建 DOM
                btn.onclick = () => switchQuickReplyCategory(id);
                return btn;
            };

            tabsContainer.appendChild(createTab('all', '全部'));
            categories.forEach(cat => {
                tabsContainer.appendChild(createTab(cat.id, cat.name));
            });
            tabsContainer.appendChild(createTab('uncategorized', '未分类'));
        } else {
            // 如果不需要重建，仅更新 active 样式 (解决闪烁的核心)
            const tabs = tabsContainer.querySelectorAll('.sticker-category-tab');
            tabs.forEach(tab => {
                // 注意：dataset.categoryId 是字符串，activeQuickReplyCategoryId 可能是数字
                // 所以用 == 比较，或者都转字符串
                if (String(tab.dataset.categoryId) === String(activeQuickReplyCategoryId)) {
                    tab.classList.add('active');
                    // 自动滚动到选中的标签 (提升体验)
                    tab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                } else {
                    tab.classList.remove('active');
                }
            });
        }
    }

    // 2. 筛选数据 (保持不变)
    let repliesToShow;
    if (activeQuickReplyCategoryId === 'all') {
        repliesToShow = state.quickReplies;
    } else if (activeQuickReplyCategoryId === 'uncategorized') {
        repliesToShow = state.quickReplies.filter(r => !r.categoryId);
    } else {
        repliesToShow = state.quickReplies.filter(r => r.categoryId == activeQuickReplyCategoryId);
    }

    // 3. 渲染列表内容 (保持不变)
    if (!repliesToShow || repliesToShow.length === 0) {
        const tipText = activeQuickReplyCategoryId === 'all' 
            ? '你还没有添加任何快捷回复。<br>点击右上角“+”号添加第一条吧！'
            : '这个分类下还没有回复哦~';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${tipText}</p>`;
        return;
    }

    // 修改 renderQuickReplyList 函数中的 item.innerHTML 部分
    repliesToShow.forEach(reply => {
        const item = document.createElement('div');
        item.className = 'quick-reply-item';
        
        // --- 新增：判断是否选中 ---
        const isSelected = selectedQuickReplies.has(reply.id);
        if (isSelected) item.classList.add('selected');

        item.innerHTML = `
            <input type="checkbox" class="quick-reply-checkbox" ${isSelected ? 'checked' : ''}>
            
            <span class="quick-reply-text" data-text="${escapeHTML(reply.text)}">${escapeHTML(reply.text)}</span>
            <div class="quick-reply-actions">
                <button class="quick-reply-edit-btn" data-id="${reply.id}" title="编辑">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button class="quick-reply-delete-btn" data-id="${reply.id}" title="删除">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            </div>
        `;
        
        // --- 修改点击事件 ---
        item.addEventListener('click', (e) => {
            // 如果是管理模式
            if (isQuickReplyManagementMode) {
                // 如果点的是文本区域或整行，触发选中
                if (!e.target.closest('.quick-reply-actions')) {
                     toggleQuickReplySelection(reply.id);
                     // 手动更新 checkbox 视觉
                     const cb = item.querySelector('.quick-reply-checkbox');
                     if(cb) cb.checked = !cb.checked;
                }
            } else {
                // 原有逻辑：发送
                const textEl = e.target.closest('.quick-reply-text');
                const editBtn = e.target.closest('.quick-reply-edit-btn');
                const deleteBtn = e.target.closest('.quick-reply-delete-btn');

                if (textEl) {
                    selectQuickReply(textEl.dataset.text);
                } else if (editBtn) {
                    editQuickReply(reply.id);
                } else if (deleteBtn) {
                    deleteQuickReply(reply.id);
                }
            }
        });

        listEl.appendChild(item);
    });
}
// 切换快捷回复管理模式
function toggleQuickReplyManagementMode() {
    isQuickReplyManagementMode = !isQuickReplyManagementMode;
    const listEl = document.getElementById('quick-reply-list');
    const actionBar = document.getElementById('quick-reply-action-bar');
    const normalFooter = document.getElementById('quick-reply-normal-footer');
    const batchBtn = document.getElementById('batch-quick-reply-btn');

    if (isQuickReplyManagementMode) {
        listEl.classList.add('management-mode');
        actionBar.style.display = 'flex';
        normalFooter.style.display = 'none';
        batchBtn.textContent = "完成";
        batchBtn.style.color = "var(--accent-color)";
    } else {
        listEl.classList.remove('management-mode');
        actionBar.style.display = 'none';
        normalFooter.style.display = 'flex';
        batchBtn.textContent = "批量";
        batchBtn.style.color = "";
        selectedQuickReplies.clear(); // 退出时清空
        updateQuickReplyActionBar();
        renderQuickReplyList(false); // 刷新去除选中样式
    }
}

// 切换单个选中
function toggleQuickReplySelection(id) {
    if (selectedQuickReplies.has(id)) {
        selectedQuickReplies.delete(id);
    } else {
        selectedQuickReplies.add(id);
    }
    updateQuickReplyActionBar();
    
    // 更新DOM样式
    const items = document.querySelectorAll('#quick-reply-list .quick-reply-item');
    items.forEach(item => {
        // 这里的逻辑比较简单粗暴，也可以优化为只找对应ID的元素
        // 但由于 render 时没有给 item 加 id dataset，这里重新 render 最稳
        // 为了性能，建议给 item 加 data-id
    });
    // 简单起见，重新渲染列表当前页(不重绘Tab)
    renderQuickReplyList(false);
}

// 更新操作栏按钮文字
function updateQuickReplyActionBar() {
    const count = selectedQuickReplies.size;
    document.getElementById('move-selected-quick-replies-btn').textContent = `移动 (${count})`;
    document.getElementById('delete-selected-quick-replies-btn').textContent = `删除 (${count})`;
}

// 全选
function handleSelectAllQuickReplies() {
    const isChecked = document.getElementById('select-all-quick-replies-checkbox').checked;
    
    // 获取当前视图下的所有回复
    let currentViewReplies;
    if (activeQuickReplyCategoryId === 'all') {
        currentViewReplies = state.quickReplies;
    } else if (activeQuickReplyCategoryId === 'uncategorized') {
        currentViewReplies = state.quickReplies.filter(r => !r.categoryId);
    } else {
        currentViewReplies = state.quickReplies.filter(r => r.categoryId == activeQuickReplyCategoryId);
    }

    if (isChecked) {
        currentViewReplies.forEach(r => selectedQuickReplies.add(r.id));
    } else {
        selectedQuickReplies.clear();
    }
    
    updateQuickReplyActionBar();
    renderQuickReplyList(false);
}

// 批量移动快捷回复
async function executeBatchMoveQuickReplies() {
    if (selectedQuickReplies.size === 0) return alert("请先选择回复。");

    const categories = await db.quickReplyCategories.toArray();
    const options = [
        { text: '未分类', value: 'uncategorized' },
        ...categories.map(c => ({ text: c.name, value: c.id }))
    ];

    const targetCategoryId = await showChoiceModal("移动到分类", options);
    if (!targetCategoryId) return;

    const finalCategoryId = targetCategoryId === 'uncategorized' ? null : parseInt(targetCategoryId);

    await db.transaction('rw', db.quickReplies, async () => {
        for (const id of selectedQuickReplies) {
            await db.quickReplies.update(id, { categoryId: finalCategoryId });
            const r = state.quickReplies.find(item => item.id === id);
            if (r) r.categoryId = finalCategoryId;
        }
    });

    await showCustomAlert("成功", `已移动 ${selectedQuickReplies.size} 条回复。`);
    toggleQuickReplyManagementMode(); // 退出管理模式
    renderQuickReplyList(false);
}

// 批量删除快捷回复
async function executeBatchDeleteQuickReplies() {
    if (selectedQuickReplies.size === 0) return alert("请先选择回复。");

    const confirmed = await showCustomConfirm("确认删除", `确定要删除选中的 ${selectedQuickReplies.size} 条回复吗？`);
    if (!confirmed) return;

    const ids = Array.from(selectedQuickReplies);
    await db.quickReplies.bulkDelete(ids);
    
    // 更新内存
    state.quickReplies = state.quickReplies.filter(r => !selectedQuickReplies.has(r.id));
    
    await showCustomAlert("成功", "已删除选中回复。");
    toggleQuickReplyManagementMode();
    renderQuickReplyList(false);
}
// 2. 切换分类
function switchQuickReplyCategory(categoryId) {
    activeQuickReplyCategoryId = categoryId;
    renderQuickReplyList(true); // 重新渲染Tabs以更新active状态
}

// 3. [修改] 添加新回复 (自动归入当前分类)
async function addNewQuickReply() {
    const text = await showCustomPrompt("添加快捷回复", "请输入要添加的回复内容：", "", "textarea");

    if (text && text.trim()) {
        // 确定分类ID
        let targetCategory = null;
        if (activeQuickReplyCategoryId !== 'all' && activeQuickReplyCategoryId !== 'uncategorized') {
            targetCategory = activeQuickReplyCategoryId;
        }

        const newReply = {
            text: text.trim(),
            categoryId: targetCategory // 保存分类ID
        };
    
        const newId = await db.quickReplies.add(newReply);
        
        // 更新内存
        state.quickReplies.push({
            id: newId,
            ...newReply
        });

        renderQuickReplyList(false); // 不用重绘Tabs
    } else if (text !== null) {
        alert("内容不能为空！");
    }
}

// 4. 打开分类管理器
async function openQuickReplyCategoryManager() {
    await renderQuickReplyCategoriesInManager();
    document.getElementById('quick-reply-category-manager-modal').classList.add('visible');
}

// 5. 渲染分类管理列表
async function renderQuickReplyCategoriesInManager() {
    const listEl = document.getElementById('existing-quick-reply-categories-list');
    const categories = await db.quickReplyCategories.toArray();
    listEl.innerHTML = '';
    
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
        return;
    }
    
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item'; // 复用样式
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        // 绑定删除事件
        item.querySelector('.delete-group-btn').onclick = () => deleteQuickReplyCategory(cat.id);
        listEl.appendChild(item);
    });
}

// 6. 添加新分类
async function addNewQuickReplyCategory() {
    const input = document.getElementById('new-quick-reply-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.quickReplyCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.quickReplyCategories.add({ name });
    input.value = '';
    await renderQuickReplyCategoriesInManager();
    document.getElementById('quick-reply-tabs').dataset.needsRefresh = 'true';
}

// 7. 删除分类
async function deleteQuickReplyCategory(categoryId) {
    const category = await db.quickReplyCategories.get(categoryId);
    if (!category) return;

    const confirmed = await showCustomConfirm(
        '确认删除分类',
        `删除分类《${category.name}》后，该分类下的回复将变为“未分类”。确定吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 1. 删除分类
        await db.quickReplyCategories.delete(categoryId);
        
        // 2. 将该分类下的回复移到未分类 (categoryId = null)
        const repliesToUpdate = state.quickReplies.filter(r => r.categoryId == categoryId);
        for (const reply of repliesToUpdate) {
            reply.categoryId = null;
            await db.quickReplies.put(reply);
        }
        
        // 3. 刷新界面
        await renderQuickReplyCategoriesInManager();
        
        // 如果当前正好在这个分类下，切回全部
        if (activeQuickReplyCategoryId == categoryId) {
            activeQuickReplyCategoryId = 'all';
        }
        document.getElementById('quick-reply-tabs').dataset.needsRefresh = 'true';
        await renderQuickReplyList(true);
    }
}

 
  function selectQuickReply(text) {
    const chatInput = document.getElementById('chat-input');
    chatInput.value = text;
    // document.getElementById('send-btn').click();
    document.getElementById('quick-reply-modal').classList.remove('visible');
    chatInput.focus(); 
  }

 
  


  async function editQuickReply(id) {
    const reply = await db.quickReplies.get(id);
    if (!reply) return;

    const newText = await showCustomPrompt("修改快捷回复", "请修改回复内容：", reply.text, "textarea");

    if (newText && newText.trim()) {
      
      await db.quickReplies.update(id, {
        text: newText.trim()
      });

      
      const stateReply = state.quickReplies.find(r => r.id === id);
      if (stateReply) stateReply.text = newText.trim();

      
      renderQuickReplyList();
    } else if (newText !== null) {
      alert("内容不能为空！");
    }
  }


  async function deleteQuickReply(id) {
    const confirmed = await showCustomConfirm(
      '确认删除',
      '确定要删除这条快捷回复吗？', {
        confirmButtonClass: 'btn-danger'
      }
    );

    if (confirmed) {
    
      await db.quickReplies.delete(id);

    
      state.quickReplies = state.quickReplies.filter(r => r.id !== id);

    
      renderQuickReplyList();
    }
  }
async function handleCharBilibiliSearch() {
    const input = document.getElementById('char-bilibili-search-input');
    const query = input.value.trim();
    if (!query) return;

    const listEl = document.getElementById('char-bilibili-list');
    listEl.innerHTML = '<div class="spinner"></div>'; // 显示加载中

    // 定义延时函数
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    try {
        const maxResults = 15; // 想要获取的条数
        let videos = [];

        // 核心修改：使用 for 循环 + await 实现“一个一个搜”
        for (let i = 1; i <= maxResults; i++) {
            // 1. 定义原始 API 地址，n 动态变化
            const targetUrl = `https://api.52vmy.cn/api/query/bilibili/video?msg=${encodeURIComponent(query)}&n=${i}`;
            
            // 2. 使用 CORS 代理
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

            let retryCount = 0;
            let success = false;
            const maxRetries = 3; // 单个请求最大重试次数

            // 添加重试机制，处理偶发的限流或网络波动
            while (!success && retryCount < maxRetries) {
                try {
                    const res = await fetch(proxyUrl);
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                    
                    // 关键修改：先作为文本读取，防止返回“访问过快”时 JSON 解析炸裂
                    const text = await res.text();

                    // 检查是否被限流 (处理截图中 "访问过快..." 的情况)
                    if (text.includes("访问过快") || text.includes("频繁") || text.includes("Too Many Requests")) {
                        console.warn(`⚠️ 获取第 ${i} 条触发限流，等待冷却...`);
                        await delay(1500 + (retryCount * 1000)); // 动态增加等待时间
                        retryCount++;
                        continue; // 重试
                    }

                    // 尝试解析 JSON
                    let json;
                    try {
                        json = JSON.parse(text);
                    } catch (e) {
                        console.warn(`第 ${i} 条返回格式错误:`, text.substring(0, 50));
                        retryCount++;
                        continue;
                    }

                    // 收集数据
                    if (json.data) {
                        if (Array.isArray(json.data)) {
                            videos.push(...json.data);
                        } else {
                            videos.push(json.data);
                        }
                    } else if (json.title) {
                        videos.push(json);
                    } else if (json.code === 200 && json.data) { 
                         if (Array.isArray(json.data)) {
                            videos.push(...json.data);
                         } else {
                            videos.push(json.data);
                         }
                    }

                    success = true; // 标记成功，退出 while 循环

                } catch (err) {
                    console.warn(`获取第 ${i} 条视频网络错误:`, err);
                    retryCount++;
                    await delay(1000); // 网络错误稍作等待
                }
            }

            // 每次请求后强制休息一下，这是防止再次被限流的关键！
            await delay(800); 
        }

        // 去重处理
        const uniqueVideos = [];
        const seenUrls = new Set();
        videos.forEach(v => {
            const url = v.url || v.arcurl; 
            if (url && !seenUrls.has(url)) {
                seenUrls.add(url);
                uniqueVideos.push(v);
            }
        });

        listEl.innerHTML = '';
        if (uniqueVideos.length === 0) {
            listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">未找到相关视频，或接口暂时不可用</p>';
            return;
        }

        // 渲染结果
        uniqueVideos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'bilibili-item';
            item.innerHTML = `
                <div class="bili-cover" style="position: relative; overflow: hidden;">
                    <img src="${video.img_url || video.pic}" referrerpolicy="no-referrer" style="width: 100%; height: 100%; object-fit: cover; position: absolute; top: 0; left: 0; z-index: 1;">
                    <div class="bili-duration" style="position: absolute; z-index: 2;">▶</div>
                </div>
                <div class="bili-info">
                    <div class="bili-title">${video.title}</div>
                    <div class="bili-author">UP: ${video.user || video.author}</div>
                </div>
            `;
            item.onclick = () => playCharBilibiliVideo(video);
            listEl.appendChild(item);
        });

    } catch (error) {
        console.error('Bilibili search error:', error);
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">搜索出错，请稍后再试</p>';
    }
}

function playCharBilibiliVideo(videoData) {
    const playerScreen = document.getElementById('char-bilibili-player-screen');
    const videoEl = document.getElementById('char-bilibili-video');
    const titleEl = document.getElementById('char-bilibili-player-title');
    const authorEl = document.getElementById('char-bilibili-player-author');
    const descEl = document.getElementById('char-bilibili-player-desc');

    videoEl.src = videoData.url;
    titleEl.textContent = videoData.title;
    authorEl.textContent = `UP主: ${videoData.user}`;
    descEl.textContent = videoData.desc || '暂无简介';

    switchToCharScreen('char-bilibili-player-screen');
    videoEl.play().catch(e => console.log("Autoplay blocked", e));
}

function closeCharBilibiliPlayer() {
    const videoEl = document.getElementById('char-bilibili-video');
    videoEl.pause();
    videoEl.src = '';
    switchToCharScreen('char-bilibili-screen');
}

window.closeCharBilibiliPlayer = function() {
    const videoEl = document.getElementById('char-bilibili-video');
    if(videoEl) {
        videoEl.pause();
        videoEl.src = '';
    }
    switchToCharScreen('char-bilibili-screen');
}
let lockScreenState = {
      passwordBuffer: '',
      isLocked: false
  };

  function initLockScreen() {
      const lockScreen = document.getElementById('lock-screen');
      
      // 初始化检查：如果启用了锁屏，则立即显示
      if (state.globalSettings.lockScreenEnabled) {
          // 设置壁纸
          if (state.globalSettings.lockScreenWallpaper) {
              lockScreen.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
          } else {
              lockScreen.style.backgroundImage = 'linear-gradient(135deg, #1c1c1e, #3a3a3c)'; // 默认深色背景
          }
          
          lockScreenState.isLocked = true;
          lockScreen.classList.add('active');
          updateLockScreenClock();
          
          // 启动锁屏时钟更新
          setInterval(updateLockScreenClock, 1000);
      }
      
      // 绑定设置界面的事件
      const lockToggle = document.getElementById('lock-screen-toggle');
      const lockDetail = document.getElementById('lock-screen-settings-detail');
      const passwordInput = document.getElementById('lock-screen-password-input');
      const wallpaperPreview = document.getElementById('lock-wallpaper-preview');

      // 回显设置
      if (lockToggle) {
          lockToggle.checked = state.globalSettings.lockScreenEnabled || false;
          lockDetail.style.display = lockToggle.checked ? 'block' : 'none';
          
          lockToggle.addEventListener('change', (e) => {
              lockDetail.style.display = e.target.checked ? 'block' : 'none';
          });
      }
      
      if (passwordInput) {
          passwordInput.value = state.globalSettings.lockScreenPassword || '';
      }

      if (state.globalSettings.lockScreenWallpaper) {
          wallpaperPreview.style.backgroundImage = `url(${state.globalSettings.lockScreenWallpaper})`;
          wallpaperPreview.textContent = '';
      }
  }

  function updateLockScreenClock() {
      if (!lockScreenState.isLocked) return;
      
      const now = new Date();
      const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
      const dateString = now.toLocaleDateString('zh-CN', { month: 'long', day: 'numeric', weekday: 'long' });
      
      document.getElementById('lock-time').textContent = timeString;
      document.getElementById('lock-date').textContent = dateString;
  }

  function showPasswordInput() {
      const lockScreen = document.getElementById('lock-screen');
      const passwordArea = document.getElementById('lock-password-area');
      
      lockScreen.classList.add('input-mode');
      passwordArea.style.display = 'flex';
      lockScreenState.passwordBuffer = '';
      updateDots();
  }

  function hidePasswordInput() {
      const lockScreen = document.getElementById('lock-screen');
      const passwordArea = document.getElementById('lock-password-area');
      
      lockScreen.classList.remove('input-mode');
      passwordArea.style.display = 'none';
      lockScreenState.passwordBuffer = '';
  }

  function updateDots() {
      const dots = document.querySelectorAll('.lock-dots .dot');
      const len = lockScreenState.passwordBuffer.length;
      dots.forEach((dot, index) => {
          if (index < len) dot.classList.add('filled');
          else dot.classList.remove('filled');
      });
  }

  function handleKeypadInput(num) {
      if (lockScreenState.passwordBuffer.length < 4) {
          lockScreenState.passwordBuffer += num;
          updateDots();
          
          if (lockScreenState.passwordBuffer.length === 4) {
              setTimeout(checkLockPassword, 200);
          }
      }
  }

  function deleteKeypadInput() {
      if (lockScreenState.passwordBuffer.length > 0) {
          lockScreenState.passwordBuffer = lockScreenState.passwordBuffer.slice(0, -1);
          updateDots();
      }
  }

  function checkLockPassword() {
      const correctPassword = state.globalSettings.lockScreenPassword;
      
      if (lockScreenState.passwordBuffer === correctPassword) {
          // 解锁成功
          const lockScreen = document.getElementById('lock-screen');
          lockScreen.classList.add('unlocking');
          lockScreenState.isLocked = false;
          
          setTimeout(() => {
              lockScreen.classList.remove('active');
              lockScreen.classList.remove('unlocking');
              hidePasswordInput(); // 重置状态以备下次锁定
          }, 500);
      } else {
          // 解锁失败
          const dots = document.querySelector('.lock-dots');
          dots.classList.add('shake-animation');
          if(navigator.vibrate) navigator.vibrate(200); // 震动反馈
          
          setTimeout(() => {
              dots.classList.remove('shake-animation');
              lockScreenState.passwordBuffer = '';
              updateDots();
          }, 400);
      }
  }

  const lockSwipeArea = document.getElementById('lock-swipe-area');
  const lockScreen = document.getElementById('lock-screen');

  // 封装解锁触发逻辑
  function handleUnlockTrigger() {
      // 如果已经在输入密码模式，就不重复触发
      if (lockScreen.classList.contains('input-mode')) return;

      if (state.globalSettings.lockScreenPassword) {
          showPasswordInput();
      } else {
          // 如果没有设置密码，直接滑动解锁
          lockScreen.classList.add('unlocking');
          lockScreenState.isLocked = false;
          setTimeout(() => {
              lockScreen.classList.remove('active');
              lockScreen.classList.remove('unlocking');
          }, 500);
      }
  }

  // 1. 保留点击底部横条解锁 (兼容鼠标点击)
  if (lockSwipeArea) {
      lockSwipeArea.addEventListener('click', handleUnlockTrigger);
  }

  // 2. 新增：全屏上滑解锁监听
  if (lockScreen) {
      let touchStartY = 0;
      let touchEndY = 0;
      
      // 触摸开始
      lockScreen.addEventListener('touchstart', (e) => {
          // 记录起始Y坐标
          touchStartY = e.changedTouches[0].screenY;
      }, { passive: true }); // passive: true 优化滚动性能

      // 触摸结束
      lockScreen.addEventListener('touchend', (e) => {
          // 记录结束Y坐标
          touchEndY = e.changedTouches[0].screenY;
          
          // 计算滑动距离
          const swipeDistance = touchStartY - touchEndY;
          
          // 阈值：向上滑动超过 50px 则触发解锁
          if (swipeDistance > 50) {
              handleUnlockTrigger();
          }
      });
  }

  document.querySelectorAll('.lock-keypad .key').forEach(key => {
      key.addEventListener('click', (e) => {
          e.stopPropagation();
          const action = key.dataset.action;
          if (action === 'delete') {
              deleteKeypadInput();
          } else if (key.dataset.num) {
              handleKeypadInput(key.dataset.num);
          }
      });
  });

  const lockCancelBtn = document.querySelector('.lock-cancel-btn');
  if (lockCancelBtn) {
      lockCancelBtn.addEventListener('click', hidePasswordInput);
  }

  // 锁屏壁纸上传处理
  const lockWallpaperInput = document.getElementById('lock-wallpaper-input');
  if (lockWallpaperInput) {
      lockWallpaperInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (file) {
              const base64Url = await new Promise(resolve => {
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.readAsDataURL(file);
              });
              
              const preview = document.getElementById('lock-wallpaper-preview');
              preview.style.backgroundImage = `url(${base64Url})`;
              preview.textContent = '';
              
              // 临时存储到 input 的 dataset 中，以便保存时使用
              preview.dataset.tempUrl = base64Url;
              
              // 如果开启了 ImgBB，自动上传 (可选逻辑，复用之前的)
               if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
                  (async () => {
                      try {
                           await showCustomAlert("请稍候...", "正在上传锁屏壁纸到 ImgBB...");
                           const imageUrl = await uploadImageToImgBB(base64Url);
                           preview.dataset.tempUrl = imageUrl;
                           await showCustomAlert("成功", "锁屏壁纸已上传！");
                      } catch (e) {
                          console.error(e);
                      }
                  })();
               }
          }
          event.target.value = null;
      });
  }
  
  document.getElementById('upload-lock-wallpaper-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("网络图片", "请输入锁屏壁纸的URL", "", "url");
      if (url && url.trim()) {
          const preview = document.getElementById('lock-wallpaper-preview');
          preview.style.backgroundImage = `url(${url})`;
          preview.textContent = '';
          preview.dataset.tempUrl = url;
      }
  });

// --- GitHub 备份功能模块 (并发优化版) ---

// 解决中文 Base64 编码问题的辅助函数
function utf8_to_b64(str) {
    return window.btoa(unescape(encodeURIComponent(str)));
}

function b64_to_utf8(str) {
    return decodeURIComponent(escape(window.atob(str)));
}

async function uploadToGitHub(isSilent = false) {
    let loadingToast = null;
    // --- 1. 基础配置检查 ---
    if (!state.apiConfig.githubEnable) {
        if (!isSilent) await showCustomAlert("未开启", "请先在“API设置” -> “GitHub 云备份”中开启此功能。");
        return;
    }

    const username = state.apiConfig.githubUsername;
    const repo = state.apiConfig.githubRepo;
    const token = state.apiConfig.githubToken;
    const baseFilename = (state.apiConfig.githubFilename || 'ephone_backup').replace(/\.json$/i, '');

    if (!username || !repo || !token) {
        if (!isSilent) await showCustomAlert("配置缺失", "请先在设置中保存 GitHub 用户名、仓库名和 Token！");
        return;
    }

    // --- 2. 确认提示 ---
    if (!isSilent) {
        const confirmed = await showCustomConfirm(
            '确认上传备份',
            `即将备份数据到 GitHub 仓库：<br><strong>${username}/${repo}</strong><br><br>采用<strong style="color:green">流式上传</strong> 模式。<br>速度将显著提升。<br>确定要立即上传吗？`,
            { confirmText: '开始极速上传' }
        );
        if (!confirmed) return;
        await showCustomAlert("准备中...", "正在初始化并发上传...");
    } else {
        console.log("⏳ [自动备份] 开始后台静默备份到 GitHub...");
       
        loadingToast = showToast('正在云端备份...', 'loading');
    }

    try {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
        const folderPath = `backups/${dateStr}/`; 

        // 【核心设置】
        const RAW_SIZE_LIMIT = 15 * 1024 * 1024; 
        
        // 2. 增大数据库读取批次：加快读取速度
        const DB_BATCH_SIZE = 50; 
        
        // 3. 增加并发数：同时上传 6 个分片 (GitHub API 通常允许较高并发)
        const MAX_CONCURRENT_UPLOADS = 4;

        let currentSliceIndex = 1;
        let currentSliceData = {}; 
        let currentSliceRawSize = 0; 
        
        // 并发控制队列
        const activeUploads = new Set();
        const errors = []; // 收集错误

        // --- 内部函数：执行单个分片上传 (独立作用域) ---
        const triggerUploadTask = async (partIndex, dataSnapshot) => {
            const partFilename = `${baseFilename}_part${partIndex}.json`;
            const finalPath = `${folderPath}${partFilename}`;
            
            // 构造分片对象
            const fileContentObj = {
                version: 4,
                timestamp: Date.now(),
                type: 'slice',
                part: partIndex,
                data: dataSnapshot
            };

            const contentString = JSON.stringify(fileContentObj);
            const contentBase64 = utf8_to_b64(contentString);
            const uploadSizeMB = (contentBase64.length / 1024 / 1024).toFixed(2);
            
            if (!isSilent) {
                // 更新 UI 显示当前正在进行的任务数量
                const modalBody = document.getElementById('custom-modal-body');
                if (modalBody) {
                    modalBody.innerHTML = `<div class="spinner" style="margin: 20px auto;"></div>
                    <p style="text-align:center;">
                        正在并发上传中...<br>
                        当前队列: <b>${activeUploads.size + 1}</b> / ${MAX_CONCURRENT_UPLOADS}<br>
                        正在处理分片: #${partIndex} (${uploadSizeMB} MB)
                    </p>`;
                }
            } else {
                console.log(`[GitHub] 开始上传分片 #${partIndex}...`);
            }

            // API URL
            let apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${finalPath}`;
            if (state.apiConfig.githubProxyEnable && state.apiConfig.githubProxyUrl) {
                const relativePath = apiUrl.replace("https://api.github.com", "");
                apiUrl = state.apiConfig.githubProxyUrl.replace(/\/$/, '') + relativePath;
            }

            // --- 步骤 A: 获取 SHA ---
            let sha = null;
            try {
                const checkUrl = `${apiUrl}${apiUrl.includes('?') ? '&' : '?'}t=${Date.now()}`;
                const getRes = await fetch(checkUrl, {
                    method: 'GET',
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (getRes.ok) {
                    const fileData = await getRes.json();
                    sha = fileData.sha;
                }
            } catch (e) { console.warn(`分片 #${partIndex} 获取SHA失败(可能是新文件)，继续上传`, e); }

            // --- 步骤 B: 上传 (带重试) ---
            let retryCount = 0;
            const maxRetries = 3;
            let success = false;
            let lastError = null;

            while (!success && retryCount < maxRetries) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 180000); // 3分钟超时

                try {
                    const putRes = await fetch(apiUrl, {
                        method: 'PUT',
                        headers: { 'Authorization': `token ${token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: `Auto Backup: ${dateStr} (Part ${partIndex})`,
                            content: contentBase64,
                            sha: sha || undefined
                        }),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    if (!putRes.ok) {
                        const err = await putRes.json();
                        throw new Error(err.message || putRes.statusText);
                    }
                    
                    success = true;
                    console.log(`✅ [GitHub] 分片 #${partIndex} 上传成功`);

                } catch (err) {
                    clearTimeout(timeoutId);
                    lastError = err;
                    retryCount++;
                    console.warn(`⚠️ 分片 #${partIndex} 第 ${retryCount} 次重试...`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }

            if (!success) {
                throw new Error(`分片 #${partIndex} 最终失败: ${lastError.message}`);
            }
        };

        // --- 3. 流式遍历数据库 ---
        const tablesToBackup = db.tables.map(t => t.name);

        for (const tableName of tablesToBackup) {
            const totalCount = await db.table(tableName).count();
            if (totalCount === 0) continue;

            let offset = 0;
            
            while (offset < totalCount) {
                const batch = await db.table(tableName).offset(offset).limit(DB_BATCH_SIZE).toArray();
                
                for (const record of batch) {
                    const recordStr = JSON.stringify(record);
                    const recordSize = recordStr.length + tableName.length + 5; 

                    // 检查是否需要切片
                    if (currentSliceRawSize + recordSize > RAW_SIZE_LIMIT) {
                        
                        // --- 核心并发逻辑 ---
                        // 1. 创建当前数据的快照 (深拷贝或直接引用，这里直接用引用因为下面会重置变量)
                        const dataSnapshot = currentSliceData; 
                        const indexSnapshot = currentSliceIndex;

                        // 2. 创建 Promise 任务
                        const taskPromise = triggerUploadTask(indexSnapshot, dataSnapshot).catch(err => {
                            console.error(err);
                            errors.push(err.message);
                        });

                        // 3. 加入队列
                        activeUploads.add(taskPromise);
                        // 任务完成后从队列移除
                        taskPromise.finally(() => activeUploads.delete(taskPromise));

                        // 4. 如果队列满了，等待最早的一个完成 (Promise.race)
                        if (activeUploads.size >= MAX_CONCURRENT_UPLOADS) {
                            await Promise.race(activeUploads);
                        }

                        // 5. 如果有错误，立即停止
                        if (errors.length > 0) break;

                        // 6. 重置容器
                        currentSliceData = {};
                        currentSliceRawSize = 0;
                        currentSliceIndex++;
                    }

                    if (!currentSliceData[tableName]) {
                        currentSliceData[tableName] = [];
                    }
                    currentSliceData[tableName].push(record);
                    currentSliceRawSize += recordSize;
                }
                
                if (errors.length > 0) break;
                offset += DB_BATCH_SIZE;
            }
            if (errors.length > 0) break;
        }

        // --- 4. 处理最后一个分片 ---
        if (currentSliceRawSize > 0 && errors.length === 0) {
            const taskPromise = triggerUploadTask(currentSliceIndex, currentSliceData).catch(err => {
                errors.push(err.message);
            });
            activeUploads.add(taskPromise);
        }

        // --- 5. 等待所有剩余任务完成 ---
        if (!isSilent) {
             const modalBody = document.getElementById('custom-modal-body');
             if (modalBody) modalBody.innerHTML += `<p style="color:blue">正在等待最后 ${activeUploads.size} 个分片完成...</p>`;
        }
        
        await Promise.all(activeUploads);

        // --- 6. 结果处理 ---
        if (errors.length > 0) {
            throw new Error(`上传过程中出现错误:\n${errors.join('\n')}`);
        }

        if (!isSilent) {
            await showCustomAlert(
                "✅ 备份成功", 
                `全量数据并发上传完成！<br>共上传 ${currentSliceIndex} 个分片。<br><strong>路径：</strong> ${folderPath}`
            );
        } else {
            console.log(`✅ [自动备份] 成功！`);
            if (loadingToast) {
                loadingToast.classList.remove('visible');
                setTimeout(() => loadingToast.remove(), 400);
            }
            showToast('云端备份已完成', 'success');
        }

    } catch (error) {
        console.error("GitHub 上传失败:", error);
        let errorMsg = error.message;
        if (error.name === 'AbortError') errorMsg = "上传超时 (网络较慢或代理不稳定)。";
        
        if (!isSilent) {
            await showCustomAlert("❌ 备份失败", `上传中断：\n${errorMsg}`);
        } else {
            // 【修改点 4】: 失败时显示警告图标，但不打断用户
            if (loadingToast) {
                loadingToast.classList.remove('visible');
                setTimeout(() => loadingToast.remove(), 400);
            }
            showToast('备份失败: 网络错误', 'error');
        }
    }
}
async function restoreFromGitHub() {
    if (!state.apiConfig.githubEnable) {
        alert("请先开启 GitHub 云备份功能。");
        return;
    }

    const username = state.apiConfig.githubUsername;
    const repo = state.apiConfig.githubRepo;
    const token = state.apiConfig.githubToken;

    if (!username || !repo || !token) {
        alert("请先保存 GitHub 配置！");
        return;
    }

    const modalBody = document.getElementById('custom-modal-body');
    const confirmBtn = document.getElementById('custom-modal-confirm');
    const cancelBtn = document.getElementById('custom-modal-cancel');

    const showProgress = (text) => {
        const modal = document.getElementById('custom-modal-overlay');
        document.getElementById('custom-modal-title').textContent = "GitHub 恢复";
        modalBody.innerHTML = `<div class="spinner" style="margin: 20px auto;"></div><p style="text-align:center;">${text}</p>`;
        confirmBtn.style.display = 'none';
        cancelBtn.style.display = 'none';
        modal.classList.add('visible');
    };

    // 通用 Fetch
    const ghFetch = async (path) => {
        let url = `https://api.github.com/repos/${username}/${repo}/contents/${path}`;
        if (state.apiConfig.githubProxyEnable && state.apiConfig.githubProxyUrl) {
             const relativePath = url.replace("https://api.github.com", "");
             url = state.apiConfig.githubProxyUrl.replace(/\/$/, '') + relativePath;
        }
        const res = await fetch(url, {
            headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
        });
        if (!res.ok) {
            if (res.status === 404) return [];
            throw new Error(`GitHub API Error: ${res.status}`);
        }
        return await res.json();
    };

    try {
        showProgress("正在搜索备份...");

        // 1. 浏览备份目录
        let rootPath = "";
        const backupsDir = await ghFetch("backups");
        
        if (backupsDir.length > 0) {
            const dateFolders = backupsDir.filter(item => item.type === 'dir');
            if (dateFolders.length > 0) {
                document.getElementById('custom-modal-overlay').classList.remove('visible');
                dateFolders.sort((a, b) => b.name.localeCompare(a.name));
                const dateChoices = dateFolders.map(f => ({ text: `📅 ${f.name}`, value: f.path }));
                const selectedPath = await showChoiceModal('请选择备份日期', dateChoices);
                if (!selectedPath) return;
                rootPath = selectedPath;
                showProgress(`正在读取 ${rootPath} ...`);
            }
        }

        // 2. 获取文件列表
        const files = await ghFetch(rootPath);
        
        // 3. 智能分组
        const backupSets = new Map(); 
        files.forEach(file => {
            if (!file.name.endsWith('.json')) return;
            // 匹配 _partX.json 格式
            const partMatch = file.name.match(/^(.*)_part(\d+)\.json$/);
            if (partMatch) {
                const baseName = partMatch[1]; // 组名
                const partNum = parseInt(partMatch[2]);
                if (!backupSets.has(baseName)) {
                    backupSets.set(baseName, { type: 'multipart', display: baseName, parts: [] });
                }
                backupSets.get(baseName).parts.push({ num: partNum, name: file.name, path: file.path });
            } else {
                // 旧版单文件
                backupSets.set(file.name, { type: 'single', display: file.name, name: file.name, path: file.path });
            }
        });

        if (backupSets.size === 0) throw new Error("未找到备份文件。");

        document.getElementById('custom-modal-overlay').classList.remove('visible');
        const choices = [];
        backupSets.forEach((info, key) => {
            let text = info.display;
            if (info.type === 'multipart') text += ` (${info.parts.length} 个分片)`;
            choices.push({ text: text, value: key });
        });

        const selectedKey = await showChoiceModal('请选择要恢复的档案', choices);
        if (!selectedKey) return;

        const targetSet = backupSets.get(selectedKey);
        const confirmRestore = await showCustomConfirm('最后确认', `即将恢复数据。本地数据将被覆盖。确定吗？`, { confirmButtonClass: 'btn-danger', confirmText: '恢复' });
        if (!confirmRestore) return;

        showProgress("正在下载并恢复数据...");

        // 4. 清空数据库 (一次性清空，避免分片恢复时数据冲突)
        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                await table.clear();
            }
        });

        // 5. 定义下载和处理单个文件的逻辑
        const processFile = async (filePath) => {
             let url = `https://api.github.com/repos/${username}/${repo}/contents/${filePath}`;
             if (state.apiConfig.githubProxyEnable && state.apiConfig.githubProxyUrl) {
                 const relativePath = url.replace("https://api.github.com", "");
                 url = state.apiConfig.githubProxyUrl.replace(/\/$/, '') + relativePath;
             }
             const res = await fetch(url, {
                headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3.raw' }
            });
            if (!res.ok) throw new Error(`下载失败: ${res.status}`);
            
            const text = await res.text();
            let json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                // 尝试 Base64 解码 (兼容旧逻辑)
                const decoded = decodeURIComponent(escape(window.atob(text.replace(/\s/g, ''))));
                json = JSON.parse(decoded);
            }

            // 核心：根据格式决定如何导入
            const dataPart = json.data || json; // 兼容 {version:.., data:{...}} 和 直接 {...}
            
            // 写入数据库
            for (const tableName of Object.keys(dataPart)) {
                const records = dataPart[tableName];
                if (Array.isArray(records) && records.length > 0) {
                    await db.table(tableName).bulkPut(records);
                }
            }
        };

        // 6. 执行恢复
        if (targetSet.type === 'multipart') {
            targetSet.parts.sort((a, b) => a.num - b.num);
            for (let i = 0; i < targetSet.parts.length; i++) {
                const part = targetSet.parts[i];
                modalBody.innerHTML = `<div class="spinner"></div><p style="text-align:center;">正在处理分片 ${i+1}/${targetSet.parts.length}...</p>`;
                await processFile(part.path);
                // 强制垃圾回收建议（通过断开引用）
                await new Promise(r => setTimeout(r, 50)); 
            }
        } else {
            await processFile(targetSet.path);
        }

        // 7. 恢复 API 配置 (防止覆盖后丢失 Key)
        try {
            const restoredApiConfig = await db.apiConfig.get('main');
            if (restoredApiConfig) {
                 if (restoredApiConfig.imgbbApiKey) localStorage.setItem('imgbb-api-key', restoredApiConfig.imgbbApiKey);
                 if (restoredApiConfig.imgbbEnable !== undefined) localStorage.setItem('imgbb-enabled', restoredApiConfig.imgbbEnable);
                 if (restoredApiConfig.minimaxApiKey) localStorage.setItem('minimax-api-key', restoredApiConfig.minimaxApiKey);
                 if (restoredApiConfig.minimaxGroupId) localStorage.setItem('minimax-group-id', restoredApiConfig.minimaxGroupId);
                 // 恢复 GitHub 配置，否则下次无法备份
                 if (restoredApiConfig.githubToken) state.apiConfig.githubToken = restoredApiConfig.githubToken;
            }
        } catch(e) {}

        confirmBtn.style.display = ''; 
        await showCustomAlert("恢复成功", "所有分片已处理完毕，数据已恢复！点击确定刷新页面。");
        setTimeout(() => window.location.reload(), 500);

    } catch (error) {
        console.error(error);
        confirmBtn.style.display = ''; 
        await showCustomAlert("恢复失败", error.message);
    }
}
   let backupIntervalId = null;

    // 修改函数定义，接收 intervalMinutes 参数
    function startAutoBackupTimer(intervalMinutes) {
        if (backupIntervalId) clearInterval(backupIntervalId);
        
        // 如果没传参数，尝试从 storage 读取，或者默认 30
        if (!intervalMinutes) {
            const saved = localStorage.getItem('github-backup-interval');
            intervalMinutes = saved ? parseInt(saved) : 30;
        }

        console.log(`✅ 自动备份定时器已启动 (每 ${intervalMinutes} 分钟)`);

        backupIntervalId = setInterval(async () => {
            const isEnabled = localStorage.getItem('github-enabled') === 'true';
            const isAuto = localStorage.getItem('github-auto-backup') === 'true';
            
            if (isEnabled && isAuto) {
                console.log("⏰ 触发定时自动备份...");
                await uploadToGitHub(true); 
            }
        }, intervalMinutes * 60 * 1000); // 转换为毫秒
    }

    // 初始化调用也要改一下
    const savedGhEnabled = localStorage.getItem('github-enabled') === 'true';
    const savedGhAuto = localStorage.getItem('github-auto-backup') === 'true';
    
    if (savedGhEnabled && savedGhAuto) {
        startAutoBackupTimer(); // 这里它会自动去读 localStorage
    }
    

    function stopAutoBackupTimer() {
        if (backupIntervalId) {
            clearInterval(backupIntervalId);
            backupIntervalId = null;
            console.log("🛑 自动备份定时器已停止");
        }
    }

    
    
    // 将这两个函数暴露给全局，以便 save 按钮调用 (虽然在闭包里，但可以直接在上面的 save 按钮逻辑里用)
    window.startAutoBackupTimer = startAutoBackupTimer;
    window.stopAutoBackupTimer = stopAutoBackupTimer;
// --- Open-Meteo 天气功能模块 ---

// 1. WMO 天气代码转文字
function getWeatherDescription(code) {
    const codes = {
        0: "晴朗 (Clear sky)",
        1: "大部晴朗 (Mainly clear)", 2: "多云 (Partly cloudy)", 3: "阴天 (Overcast)",
        45: "有雾 (Fog)", 48: "结霜雾 (Depositing rime fog)",
        51: "轻微毛毛雨 (Drizzle: Light)", 53: "中度毛毛雨 (Drizzle: Moderate)", 55: "大毛毛雨 (Drizzle: Dense)",
        61: "小雨 (Rain: Slight)", 63: "中雨 (Rain: Moderate)", 65: "大雨 (Rain: Heavy)",
        71: "小雪 (Snow fall: Slight)", 73: "中雪 (Snow fall: Moderate)", 75: "大雪 (Snow fall: Heavy)",
        80: "阵雨 (Rain showers)", 81: "中度阵雨", 82: "暴雨",
        95: "雷雨 (Thunderstorm)", 96: "雷雨伴有冰雹", 99: "重度雷雨伴有冰雹"
    };
    return codes[code] || "未知天气";
}

// 2. 搜索真实城市 (Geocoding API)
async function searchCityGeo(cityName) {
    try {
        const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(cityName)}&count=1&language=zh&format=json`);
        const data = await response.json();
        if (data.results && data.results.length > 0) {
            return data.results[0]; // 返回 {name, latitude, longitude, country...}
        }
        return null;
    } catch (e) {
        console.error("城市搜索失败:", e);
        return null;
    }
}

// 3. 获取天气数据
async function fetchWeather(lat, lon) {
    if (!lat || !lon) return null;
    try {
        // 获取当前天气：温度、天气代码、白天/黑夜、风速
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,is_day,wind_speed_10m&timezone=auto`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.current) {
            const c = data.current;
            const desc = getWeatherDescription(c.weather_code);
            const dayState = c.is_day ? "白天" : "夜晚";
            return `气温 ${c.temperature_2m}°C, 湿度 ${c.relative_humidity_2m}%, ${desc}, ${dayState}, 风速 ${c.wind_speed_10m}km/h`;
        }
        return null;
    } catch (e) {
        console.error("获取天气失败:", e);
        return null;
    }
}

// 4. 生成 Prompt 注入文本
async function getWeatherContextForPrompt(chat) {
    const wSettings = chat.settings.weather || {};
    if (!wSettings.enabled) return "";

    let context = "\n# 【实时环境与天气同步】\n";
    let hasData = false;

    // 获取用户天气
    if (wSettings.userLat && wSettings.userLon) {
        const userWeather = await fetchWeather(wSettings.userLat, wSettings.userLon);
        if (userWeather) {
            const locationName = wSettings.userVirtualCity || "所在地";
            context += `- 用户(${chat.settings.myNickname || '我'})当前在【${locationName}】: ${userWeather}。\n`;
            hasData = true;
        }
    }

    // 获取角色天气
    if (wSettings.charLat && wSettings.charLon) {
        const charWeather = await fetchWeather(wSettings.charLat, wSettings.charLon);
        if (charWeather) {
            const locationName = wSettings.charVirtualCity || "所在地";
            context += `- 你(${chat.name})当前在【${locationName}】: ${charWeather}。\n`;
            hasData = true;
        }
    }

    if (!hasData) return "";

    context += "请根据上述天气和时间状态（如是否下雨、是白天还是夜晚）来调整你的描写氛围、角色的行动（如撑伞、避暑、添衣）以及对话内容。";
    return context;
}
let userBalance = 0;
const BLACK_GOLD_THRESHOLD = 10000; // 黑金会员阈值：1万

async function initUserWallet() {
    try {
        let wallet = await db.userWallet.get('main');

        // 如果没有钱包，或者余额变成了 NaN/null/undefined，强制修复
        if (!wallet || typeof wallet.balance !== 'number' || isNaN(wallet.balance)) {
            console.warn("检测到钱包数据异常 (NaN 或 不存在)，正在重置...");
            
            // 尝试保留旧的亲属卡数据，只重置余额
            const oldKinship = (wallet && wallet.kinshipCards) ? wallet.kinshipCards : [];
            
            wallet = { 
                id: 'main', 
                balance: 0, // 强制重置为 0
                kinshipCards: oldKinship, 
                lastResetMonth: '' 
            };
            
            await db.userWallet.put(wallet);
            userBalance = 0;
        } else {
            // 数据正常，读取余额
            userBalance = wallet.balance;
            
            // 补全可能缺失的字段
            if (!wallet.kinshipCards) {
                wallet.kinshipCards = [];
                await db.userWallet.put(wallet);
            }
        }

        // 每月自动重置亲属卡额度逻辑 (保持不变)
        const now = new Date();
        const currentMonthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
        if (wallet.lastResetMonth !== currentMonthKey) {
            if (wallet.kinshipCards && wallet.kinshipCards.length > 0) {
                wallet.kinshipCards.forEach(card => { card.spent = 0; });
                await db.userWallet.put(wallet);
            }
            wallet.lastResetMonth = currentMonthKey;
            await db.userWallet.put(wallet);
        }

        console.log("用户钱包初始化完成，当前余额:", userBalance);
        
        // 立即更新界面上的显示（如果正在显示的话）
        const displayEl = document.getElementById('alipay-balance-display');
        if(displayEl) displayEl.textContent = userBalance.toFixed(2);

    } catch (e) {
        console.error("初始化钱包失败:", e);
        userBalance = 0;
    }
}


// --- 核心修复：强制数字运算，防止字符串拼接或NaN ---
async function processTransaction(amount, type, description) {
    // 1. 强制转为数字，防止 "100" + 50 变成 "10050"
    let safeAmount = parseFloat(amount);
    if (isNaN(safeAmount) || safeAmount <= 0) {
        console.error("记账失败：金额无效", amount);
        return false; 
    }

    try {
        // 2. 获取钱包，如果不存在则初始化
        let wallet = await db.userWallet.get('main');
        if (!wallet) {
            wallet = { id: 'main', balance: 0, kinshipCards: [] };
        }
        
        // 确保余额是数字
        if (typeof wallet.balance !== 'number') wallet.balance = 0;

        // 3. 执行加减
        if (type === 'expense') {
            if (wallet.balance < safeAmount) {
                await showCustomAlert("支付失败", `余额不足！当前: ${wallet.balance.toFixed(2)}`);
                return false;
            }
            wallet.balance -= safeAmount;
        } else if (type === 'income') {
            wallet.balance += safeAmount;
        }

        // 4. 保存钱包
        await db.userWallet.put(wallet);
        
        // 同步全局变量
        window.userBalance = wallet.balance;

        // 5. 写入账单流水 (UserTransactions)
        const transaction = {
            timestamp: Date.now(),
            type: type,
            amount: safeAmount,
            description: description || '未知交易'
        };
        await db.userTransactions.add(transaction);

        console.log(`✅ [钱包] 交易成功: ${type} ¥${safeAmount.toFixed(2)}. 新余额: ${wallet.balance.toFixed(2)}`);
        return true;

    } catch (e) {
        console.error("写入钱包数据库失败:", e);
        alert("系统错误：账单写入失败，请检查控制台。");
        return false;
    }
}

async function openAlipayScreen() {
    // 【关键修复】每次打开时，强制从数据库重新读取最新余额
    // 这样能保证显示的不是 NaN
    await initUserWallet(); 
    
    // 更新余额显示
    const balanceEl = document.getElementById('alipay-balance-display');
    if(balanceEl) {
        // 双重保险，如果是 NaN 就显示 0.00
        const safeBalance = isNaN(userBalance) ? 0 : userBalance;
        balanceEl.textContent = safeBalance.toFixed(2);
    }
    
    // 检查是否启用黑金主题
    const alipayScreen = document.getElementById('alipay-screen');
    const statusTag = document.getElementById('alipay-status-tag');
    
    if (userBalance >= BLACK_GOLD_THRESHOLD) {
        alipayScreen.classList.add('theme-blackgold');
        if(statusTag) statusTag.textContent = '黑金会员';
    } else {
        alipayScreen.classList.remove('theme-blackgold');
        if(statusTag) statusTag.textContent = '标准会员';
    }
    
    // 渲染亲属卡区域 (逻辑保持不变)
    const oldWrapper = document.getElementById('alipay-kinship-section-wrapper');
    if (oldWrapper) oldWrapper.remove();
    const container = document.querySelector('.alipay-card-container');
    const wallet = await db.userWallet.get('main');
    const kinshipCards = wallet?.kinshipCards || [];

    const kinshipWrapper = document.createElement('div');
    kinshipWrapper.id = 'alipay-kinship-section-wrapper'; 
    kinshipWrapper.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; padding: 0 5px;">
            <span class="kinship-section-title">亲属卡 / 亲密付</span>
            <span id="add-kinship-btn" style="font-size:22px; color:#1677ff; cursor:pointer; line-height:1;">+</span>
        </div>
    `;
    const scrollContainer = document.createElement('div');
    scrollContainer.id = 'alipay-kinship-section';

    if (kinshipCards.length === 0) {
        scrollContainer.innerHTML = `
            <div class="kinship-empty-state" style="background:white; width:100%; border-radius:12px; padding:20px; text-align:center; color:#999; box-shadow:0 2px 8px rgba(0,0,0,0.03);">
                <p style="margin:0; font-size:13px;">暂无亲属卡，快去邀请TA吧</p>
            </div>`;
    } else {
        kinshipCards.forEach(card => {
            const chat = state.chats[card.chatId];
            const providerName = chat ? chat.name : '未知角色';
            const providerAvatar = chat ? (chat.settings.aiAvatar || defaultAvatar) : defaultAvatar;
            const remaining = card.limit - (card.spent || 0);
            
            const cardEl = document.createElement('div');
            cardEl.className = 'kinship-card-entry';
            cardEl.innerHTML = `
                <button class="alipay-unbind-btn" data-chat-id="${card.chatId}">解绑</button>
                <div class="kinship-top">
                    <div class="kinship-provider">
                        <img src="${providerAvatar}">
                        <span>${providerName} (赠)</span>
                    </div>
                    <span style="font-size:11px; opacity:0.8;">消费对方可见</span>
                </div>
                <div class="kinship-label">本月剩余额度</div>
                <div class="kinship-limit">¥ ${remaining.toFixed(2)}</div>
            `;
            scrollContainer.appendChild(cardEl);
        });
    }

    kinshipWrapper.appendChild(scrollContainer);
    container.appendChild(kinshipWrapper);

    const addBtn = kinshipWrapper.querySelector('#add-kinship-btn');
    if(addBtn) addBtn.onclick = openKinshipSelector;
    
    // 渲染账单列表
    if (typeof initBillListUI === 'function') {
        await initBillListUI(); 
    }
    
    showScreen('alipay-screen');
}
async function renderTransactionList() {
    // 检查当前是否在支付宝页面，如果在，则刷新列表
    const alipayScreen = document.getElementById('alipay-screen');
    if (alipayScreen && alipayScreen.classList.contains('active')) {
        await loadBills(true);
    }
}
// --- 新版支付宝账单逻辑 ---

// 初始化/重置账单列表 UI
async function initBillListUI() {
    const container = document.getElementById('alipay-transaction-list'); // 注意：这是原来的容器ID
    
    // 重置容器样式以适应新布局
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.height = '100%';
    container.style.overflow = 'hidden';
    container.innerHTML = '';

    // 1. 渲染筛选头部
    const header = document.createElement('div');
    header.className = 'bill-filter-header';
    
    // 获取当前月份作为默认值 (或者留空显示全部)
    // billState.filterDate = new Date().toISOString().slice(0, 7); 

    header.innerHTML = `
        <div class="bill-date-picker-wrapper">
            <input type="month" id="bill-date-input" class="bill-date-input" value="${billState.filterDate}">
        </div>
        <div class="bill-type-tabs">
            <span class="bill-type-tab active" data-type="all">全部</span>
            <span class="bill-type-tab" data-type="expense">支出</span>
            <span class="bill-type-tab" data-type="income">收入</span>
        </div>
    `;
    container.appendChild(header);

    // 2. 渲染滚动列表容器
    const scrollList = document.createElement('div');
    scrollList.id = 'bill-scroll-list';
    container.appendChild(scrollList);

    // 3. 渲染底部加载提示
    const loader = document.createElement('div');
    loader.id = 'bill-loader';
    loader.className = 'bill-loading-more hidden';
    loader.textContent = '正在加载更多...';
    scrollList.appendChild(loader);

    // 4. 绑定事件
    bindBillEvents();

    // 5. 初始加载数据
    await loadBills(true);
}

// 绑定筛选和滚动事件
function bindBillEvents() {
    // 日期筛选
    const dateInput = document.getElementById('bill-date-input');
    dateInput.addEventListener('change', (e) => {
        billState.filterDate = e.target.value;
        loadBills(true); // 重置并重新加载
    });

    // 类型筛选
    const tabs = document.querySelectorAll('.bill-type-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', (e) => {
            // UI 切换
            tabs.forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            
            // 逻辑切换
            billState.filterType = e.target.dataset.type;
            loadBills(true);
        });
    });

    // 滚动加载 (Infinite Scroll)
    const scrollList = document.getElementById('bill-scroll-list');
    scrollList.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = scrollList;
        // 距离底部 50px 时触发加载
        if (scrollHeight - scrollTop <= clientHeight + 50) {
            if (billState.hasMore && !billState.isLoading) {
                loadBills(false);
            }
        }
    });
}

// 核心：加载账单数据
async function loadBills(isReset = false) {
    if (billState.isLoading) return;
    
    const scrollList = document.getElementById('bill-scroll-list');
    const loader = document.getElementById('bill-loader');
    
    billState.isLoading = true;
    loader.classList.remove('hidden');

    if (isReset) {
        billState.page = 0;
        billState.hasMore = true;
        // 清空列表（保留loader）
        const items = scrollList.querySelectorAll('.bill-item, .bill-month-separator, .bill-empty-msg');
        items.forEach(el => el.remove());
        scrollList.scrollTop = 0;
    }

    try {
        // --- 构建 Dexie 查询 ---
        let collection = db.userTransactions.orderBy('timestamp').reverse();

        // 1. 内存过滤 (因为 IndexedDB 复杂查询比较麻烦，取出来再筛性能通常足够)
        // 如果数据量极大，建议先用 compound index，但这里我们假设数据量在万级以内
        let allMatches = await collection.toArray();

        // 2. 应用类型过滤
        if (billState.filterType !== 'all') {
            allMatches = allMatches.filter(t => t.type === billState.filterType);
        }

        // 3. 应用日期过滤
        if (billState.filterDate) {
            const [year, month] = billState.filterDate.split('-');
            allMatches = allMatches.filter(t => {
                const d = new Date(t.timestamp);
                return d.getFullYear() === parseInt(year) && (d.getMonth() + 1) === parseInt(month);
            });
        }

        // 4. 手动分页
        const start = billState.page * billState.pageSize;
        const end = start + billState.pageSize;
        const pageData = allMatches.slice(start, end);

        // 更新状态
        if (pageData.length < billState.pageSize) {
            billState.hasMore = false;
            loader.textContent = '— 没有更多记录了 —';
            loader.classList.remove('hidden'); // 保持显示底线
        } else {
            loader.textContent = '加载中...';
        }

        if (pageData.length === 0 && isReset) {
            scrollList.insertAdjacentHTML('afterbegin', 
                '<div class="bill-empty-msg" style="text-align:center; padding:40px; color:#999;">暂无相关账单</div>'
            );
        } else {
            renderBillItems(pageData, scrollList, loader);
        }

        billState.page++;

    } catch (error) {
        console.error("加载账单失败:", error);
        loader.textContent = '加载失败';
    } finally {
        billState.isLoading = false;
        if (billState.hasMore) loader.classList.add('hidden'); // 如果还有更多，先隐藏loading，等滚动再显示
    }
}

// 渲染列表项 (带月份分组) - 修复版：防止 amount 为空导致崩溃
function renderBillItems(transactions, container, loaderEl) {
    let lastMonthStr = '';
    
    // 如果不是第一页，尝试获取列表中最后一个月份标题
    const existingSeparators = container.querySelectorAll('.bill-month-separator');
    if (existingSeparators.length > 0) {
        lastMonthStr = existingSeparators[existingSeparators.length - 1].textContent;
    }

    const fragment = document.createDocumentFragment();

    transactions.forEach(t => {
        // --- 【核心修复开始】 ---
        // 强制将金额转换为数字，如果是 undefined/null/NaN，则默认为 0
        let safeAmount = Number(t.amount);
        if (isNaN(safeAmount)) {
            console.warn("检测到异常账单数据 (金额无效):", t);
            safeAmount = 0;
        }
        // --- 【核心修复结束】 ---

        const date = new Date(t.timestamp);
        const monthStr = `${date.getFullYear()}年${date.getMonth() + 1}月`;
        
        // 如果月份变化，插入分割线
        if (monthStr !== lastMonthStr) {
            const separator = document.createElement('div');
            separator.className = 'bill-month-separator';
            separator.textContent = monthStr;
            fragment.appendChild(separator);
            lastMonthStr = monthStr;
        }

        // 渲染单条记录
        const timeStr = `${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}`;
        const isIncome = t.type === 'income';
        const sign = isIncome ? '+' : '-';
        const colorClass = isIncome ? 'income' : 'expense';

        const item = document.createElement('div');
        item.className = 'bill-item';
        item.innerHTML = `
            <div class="bill-info">
                <div class="bill-title">${t.description || '未知交易'}</div>
                <div class="bill-time">${timeStr}</div>
            </div>
            <div class="bill-amount ${colorClass}">${sign}${safeAmount.toFixed(2)}</div>
        `;
        fragment.appendChild(item);
    });

    // 插入到 loader 之前
    container.insertBefore(fragment, loaderEl);
}

// 5. 用户充值
async function handleUserTopUp() {
    const amountStr = await showCustomPrompt("充值", "请输入充值金额 (CNY):", "", "number");
    if (!amountStr) return;
    
    const amount = parseFloat(amountStr);
    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额");
        return;
    }

    await processTransaction(amount, 'income', '余额充值');
    // 刷新界面
    openAlipayScreen(); 
    await showCustomAlert("充值成功", `成功充值 ¥${amount.toFixed(2)}`);
}

// 暴露给 HTML 调用
window.openAlipayScreen = openAlipayScreen;
window.handleUserTopUp = handleUserTopUp;
// 变量存储当前选中的角色ID
let selectedKinshipCharId = null;

async function openKinshipSelector() {
    const characters = Object.values(state.chats).filter(c => !c.isGroup);
    if (characters.length === 0) return alert("没有可绑定的角色");

    const modal = document.getElementById('kinship-creation-modal');
    const listEl = document.getElementById('kinship-char-list');
    const limitInput = document.getElementById('kinship-limit-input');
    
    // --- 新增：获取或创建类型选择容器 ---
    let typeContainer = document.getElementById('kinship-type-container');
    if (!typeContainer) {
        // 如果HTML里没有，动态创建一个插入到金额输入框前面
        typeContainer = document.createElement('div');
        typeContainer.id = 'kinship-type-container';
        typeContainer.style.cssText = "margin-bottom: 15px; display: flex; gap: 10px; justify-content: center;";
        
        const inputGroup = limitInput.parentElement; // 获取金额输入框的父容器
        inputGroup.parentElement.insertBefore(typeContainer, inputGroup); // 插在输入框前面
    }
    
    // 渲染两个选项按钮
    typeContainer.innerHTML = `
        <label class="radio-btn-wrapper" style="flex:1;">
            <input type="radio" name="kinship-type" value="grant" checked>
            <div class="radio-btn-content" style="text-align:center; padding:10px; border:1px solid #ddd; border-radius:8px; cursor:pointer;">
                <div style="font-weight:bold; color:#ff5252;">我送TA</div>
                <div style="font-size:12px; color:#666;">(花我的钱)</div>
            </div>
        </label>
        <label class="radio-btn-wrapper" style="flex:1;">
            <input type="radio" name="kinship-type" value="request">
            <div class="radio-btn-content" style="text-align:center; padding:10px; border:1px solid #ddd; border-radius:8px; cursor:pointer;">
                <div style="font-weight:bold; color:#1677ff;">问TA要</div>
                <div style="font-size:12px; color:#666;">(花TA的钱)</div>
            </div>
        </label>
    `;
    
    // 添加简单的点击样式切换逻辑
    const radios = typeContainer.querySelectorAll('input[name="kinship-type"]');
    const updateStyles = () => {
        radios.forEach(radio => {
            const content = radio.nextElementSibling;
            if (radio.checked) {
                content.style.borderColor = radio.value === 'grant' ? '#ff5252' : '#1677ff';
                content.style.backgroundColor = radio.value === 'grant' ? '#fff0f0' : '#f0f7ff';
            } else {
                content.style.borderColor = '#ddd';
                content.style.backgroundColor = '#fff';
            }
        });
    };
    radios.forEach(r => r.addEventListener('change', updateStyles));
    updateStyles(); // 初始化样式

    // --- 重置状态 ---
    listEl.innerHTML = '';
    selectedKinshipCharId = null;
    limitInput.value = ''; 

    // 渲染角色列表
    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'clear-posts-item'; 
        item.dataset.id = char.id;
        
        item.onclick = () => {
            listEl.querySelectorAll('.clear-posts-item').forEach(el => {
                el.classList.remove('selected');
                const cb = el.querySelector('.checkbox');
                if(cb) cb.classList.remove('selected');
            });
            
            item.classList.add('selected');
            const cb = item.querySelector('.checkbox');
            cb.classList.add('selected');
            
            selectedKinshipCharId = char.id;
        };

        const avatar = char.settings.aiAvatar || defaultAvatar;
        
        item.innerHTML = `
            <div class="checkbox" style="pointer-events: none;"></div>
            <img src="${avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px; object-fit: cover;">
            <span class="name" style="font-weight: 500; font-size: 16px;">${char.name}</span>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}



// 2. 发送申请消息 (支持双向)
// type: 'grant' (我送TA) | 'request' (问TA要)
async function sendKinshipRequest(chatId, limit, type = 'grant') {
    const chat = state.chats[chatId];
    const myNickname = chat.settings.myNickname || '我';

    // 1. 构造用户消息 (显示在聊天界面)
    let userContentText = "";
    if (type === 'grant') {
        userContentText = `[我为你开通了“亲属卡”，每月额度 ¥${limit}]`;
    } else {
        userContentText = `[我向你发起了“亲属卡”代付申请，每月额度 ¥${limit}]`;
    }

    const userMsg = {
        role: 'user',
        type: 'kinship_request',
        content: userContentText,
        limit: limit,
        status: 'pending',
        requestType: type, // 记录类型，方便后续处理
        timestamp: Date.now()
    };
    chat.history.push(userMsg);

    // 2. 构造系统提示 (给 AI 看的逻辑)
    let systemContentText = "";
    
    if (type === 'grant') {
        // --- 情况 A: 我送 AI (AI 被包养) ---
        systemContentText = `[系统提示：用户(${myNickname})为你开通了支付宝“亲属卡”（亲密付），每月额度 ¥${limit}。这意味着你的消费将由用户买单。请根据你们的关系（是否愿意接受对方的馈赠）决定接受还是拒绝。请使用 'kinship_response' 指令进行回应。]`;
    } else {
        // --- 情况 B: 我问 AI 要 (求包养) ---
        systemContentText = `[系统提示：用户(${myNickname})向你申请开通支付宝“亲属卡”（亲密付），每月额度 ¥${limit}。这意味着用户的消费将由你买单。请根据你的经济状况和对用户的宠爱程度，决定接受还是拒绝。请使用 'kinship_response' 指令进行回应。]`;
    }

    const systemMsg = {
        role: 'system',
        content: systemContentText,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(systemMsg);

    await db.chats.put(chat);
    
    if(state.activeChatId === chatId) {
        appendMessage(userMsg, chat);
        // 触发 AI 思考
        triggerAiResponse();
    } else {
        openChat(chatId);
    }      
}



// ==========================================
// ▼▼▼ 基金理财模块完整逻辑 (修复整合版) ▼▼▼
// ==========================================

// 1. 初始化基金数据
async function initFunds() {
    const count = await db.funds.count();
    if (count === 0) {
        const initialFunds = [
            { id: 'f01', code: '001001', name: '招财进宝混合', riskLevel: 'medium', currentNav: 1.520, lastDayNav: 1.510, history: [] },
            { id: 'f02', code: '002088', name: '科技先锋成长', riskLevel: 'high', currentNav: 2.305, lastDayNav: 2.280, history: [] },
            { id: 'f03', code: '003099', name: '稳健债基A', riskLevel: 'low', currentNav: 1.050, lastDayNav: 1.049, history: [] },
            { id: 'f04', code: '005666', name: '新能源精选', riskLevel: 'high', currentNav: 3.100, lastDayNav: 3.200, history: [] },
            { id: 'f05', code: '008888', name: '消费红利指数', riskLevel: 'medium', currentNav: 1.880, lastDayNav: 1.885, history: [] },
            { id: 'f06', code: '110022', name: '全球医疗医药', riskLevel: 'high', currentNav: 0.950, lastDayNav: 0.940, history: [] }
        ];
        await db.funds.bulkAdd(initialFunds);
    }
    // 补全钱包字段
    const wallet = await db.userWallet.get('main');
    if (wallet && !wallet.fundHoldings) {
        wallet.fundHoldings = [];
        await db.userWallet.put(wallet);
    }
}

// 2. 全局主题检查 (核心：余额变动自动切换黑金/蓝色)
function checkThemeStatus() {
    const threshold = 10000; // 黑金阈值
    const isGold = userBalance >= threshold;
    
    // 同步 Alipay 和 Fund 两个屏幕
    const screens = ['alipay-screen', 'fund-screen'];
    
    screens.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            if (isGold) {
                el.classList.add('theme-blackgold');
            } else {
                el.classList.remove('theme-blackgold');
            }
        }
    });

    // 更新首页标签
    const statusTag = document.getElementById('alipay-status-tag');
    if (statusTag) {
        if (isGold) {
            statusTag.textContent = '黑金会员';
            statusTag.style.color = '#d4af37';
            statusTag.style.borderColor = '#d4af37';
        } else {
            statusTag.textContent = '标准会员';
            statusTag.style.color = 'white';
            statusTag.style.borderColor = 'white';
        }
    }
    // 更新首页余额
    const balanceDisplay = document.getElementById('alipay-balance-display');
    if (balanceDisplay) balanceDisplay.textContent = userBalance.toFixed(2);
}

// 3. 模拟市场波动
// 3. 模拟市场波动 (升级版：记录历史走势)
async function simulateFundMarket() {
    const funds = await db.funds.toArray();
    const updates = [];
    
    // 市场整体情绪 (-0.02 ~ +0.02)
    const marketSentiment = (Math.random() - 0.45) * 0.05; 

    for (const fund of funds) {
        // 1. 补全历史数据 (如果是新基金，先伪造 15 个历史点，让图表有东西画)
        if (!fund.history || fund.history.length === 0) {
            fund.history = [];
            let mockNav = fund.currentNav;
            for(let i=0; i<15; i++) {
                // 倒推历史数据
                mockNav = mockNav * (1 - (Math.random() - 0.5) * 0.02);
                fund.history.unshift(parseFloat(mockNav.toFixed(4)));
            }
        }

        // 2. 计算今日波动
        let volatility = 0.01; // 低风险波动小
        if (fund.riskLevel === 'medium') volatility = 0.03;
        if (fund.riskLevel === 'high') volatility = 0.06; // 高风险波动大

        const individualChange = (Math.random() - 0.5) * volatility;
        const changePercent = marketSentiment + individualChange;
        
        // 3. 记录旧净值到历史 (用于画图)
        // 保持 history 最多存 20 个点，防止数据库无限膨胀
        if (fund.history.length >= 20) fund.history.shift();
        fund.history.push(fund.currentNav);

        // 4. 更新当前净值
        const oldNav = fund.currentNav;
        let newNav = oldNav * (1 + changePercent);
        if (newNav < 0.1) newNav = 0.1; // 防止跌成负数

        fund.lastDayNav = oldNav; // 昨日净值
        fund.currentNav = parseFloat(newNav.toFixed(4)); // 今日净值
        
        updates.push(fund);
    }
    await db.funds.bulkPut(updates);
}

// 4. 打开基金页面
async function openFundScreen() {
    // 移除 Math.random 判断，每次打开都模拟一次波动，营造“实时行情”的感觉
    // 或者保留 await simulateFundMarket(); 
    await simulateFundMarket(); 
    
    checkThemeStatus(); 
    await renderFundScreen();
    showScreen('fund-screen');
}

// 5. 渲染基金主界面
let activeFundTab = 'market'; // 默认选中市场

async function renderFundScreen() {
    const funds = await db.funds.toArray();
    const wallet = await db.userWallet.get('main');
    const holdings = wallet.fundHoldings || [];
    
    let totalAssets = 0;
    let totalProfit = 0;
    let yesterdayProfit = 0;

    holdings.forEach(h => {
        const fund = funds.find(f => f.id === h.fundId);
        if (fund) {
            const marketValue = h.units * fund.currentNav;
            const costValue = h.units * h.cost;
            const yesterdayValue = h.units * fund.lastDayNav;
            
            totalAssets += marketValue;
            totalProfit += (marketValue - costValue);
            yesterdayProfit += (marketValue - yesterdayValue);
        }
    });

    document.getElementById('fund-total-assets').textContent = totalAssets.toFixed(2);
    
    const totalProfitEl = document.getElementById('fund-total-profit');
    totalProfitEl.textContent = (totalProfit >= 0 ? "+" : "") + totalProfit.toFixed(2);
    totalProfitEl.style.color = totalProfit >= 0 ? '#ff9c9c' : '#a0f0a0';

    const yesterdayProfitEl = document.getElementById('fund-yesterday-profit');
    yesterdayProfitEl.textContent = (yesterdayProfit >= 0 ? "+" : "") + yesterdayProfit.toFixed(2);
    
    // 根据当前 Tab 渲染列表
    if (activeFundTab === 'market') {
        renderFundMarketList(funds);
    } else {
        renderFundMyList(funds, holdings);
    }
}
// --- 辅助函数：生成迷你走势图 SVG ---
function generateMiniChartSvg(dataPoints, isUp) {
    if (!dataPoints || dataPoints.length < 2) return '';

    const width = 60;  // 图表宽
    const height = 20; // 图表高
    const color = isUp ? '#ff3b30' : '#4cd964'; // 红涨绿跌
    
    // 找出最大最小值，用于归一化
    const min = Math.min(...dataPoints);
    const max = Math.max(...dataPoints);
    const range = max - min || 1; // 防止除以0

    // 生成路径点
    // 坐标系：X轴均匀分布，Y轴根据价格计算 (价格越高，Y越小/越靠上)
    const points = dataPoints.map((val, index) => {
        const x = (index / (dataPoints.length - 1)) * width;
        const y = height - ((val - min) / range) * height; 
        return `${x},${y}`;
    }).join(' ');

    // 返回 SVG 字符串
    return `
        <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="overflow:visible;">
            <polyline fill="none" stroke="${color}" stroke-width="2" points="${points}" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    `;
}
// 渲染市场列表 (带走势图版)
function renderFundMarketList(funds) {
    const listEl = document.getElementById('fund-market-list');
    listEl.style.display = 'block';
    document.getElementById('fund-my-list').style.display = 'none';
    listEl.innerHTML = '';

    funds.forEach(fund => {
        const changeRate = ((fund.currentNav - fund.lastDayNav) / fund.lastDayNav) * 100;
        const isUp = changeRate >= 0;
        const colorClass = isUp ? 'fund-up' : 'fund-down';
        const sign = isUp ? '+' : '';
        
        // 风险标签
        let riskColorBg, riskColorText, riskText;
        if (fund.riskLevel === 'high') {
             riskColorBg = '#fff1f0'; riskColorText = '#ff4d4f'; riskText = '高风险';
        } else if (fund.riskLevel === 'medium') {
             riskColorBg = '#fff7e6'; riskColorText = '#fa8c16'; riskText = '中风险';
        } else {
             riskColorBg = '#f6ffed'; riskColorText = '#52c41a'; riskText = '稳健';
        }
        
        const riskTag = `<span class="fund-tag" style="background:${riskColorBg}; color:${riskColorText};">${riskText}</span>`;

        // ▼▼▼ 生成走势图 ▼▼▼
        // 把历史数据和当前数据合并起来画图
        const chartData = [...(fund.history || []), fund.currentNav];
        const chartSvg = generateMiniChartSvg(chartData, isUp);

        const item = document.createElement('div');
        item.className = 'fund-item';
        item.onclick = () => openFundTradeModal('buy', fund); 

        // 重新布局：左边信息，中间图表，右边数据
        item.innerHTML = `
            <div class="fund-info" style="flex: 1.2;">
                <h4 style="margin-bottom:6px; font-size:15px;">${fund.name}</h4>
                <div class="fund-tags">
                    <span class="fund-tag" style="background:#f5f5f5; color:#999;">${fund.code}</span>
                    ${riskTag}
                </div>
            </div>
            
            <div class="fund-chart" style="flex: 1; display:flex; justify-content:center; align-items:center; opacity:0.8;">
                ${chartSvg}
            </div>

            <div class="fund-data" style="flex: 1; text-align:right;">
                <div class="fund-change ${colorClass}" style="font-size:18px; font-weight:bold;">${sign}${changeRate.toFixed(2)}%</div>
                <div class="fund-nav" style="font-size:11px; color:#999; margin-top:4px;">净值 ${fund.currentNav.toFixed(4)}</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

// 渲染持仓列表
function renderFundMyList(funds, holdings) {
    const listEl = document.getElementById('fund-my-list');
    listEl.style.display = 'block';
    document.getElementById('fund-market-list').style.display = 'none';
    listEl.innerHTML = '';

    if (holdings.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">暂无持仓</div>';
        return;
    }

    holdings.forEach(h => {
        const fund = funds.find(f => f.id === h.fundId);
        if (!fund) return;
        
        const marketValue = h.units * fund.currentNav;
        const costValue = h.units * h.cost;
        const profit = marketValue - costValue;
        const profitRate = (profit / costValue) * 100;
        
        const isUp = profit >= 0;
        const colorClass = isUp ? 'fund-up' : 'fund-down';
        const sign = isUp ? '+' : '';

        const item = document.createElement('div');
        item.className = 'fund-item';
        item.onclick = () => openFundTradeModal('sell', fund, h); // 点击卖出
        item.innerHTML = `
            <div class="fund-info">
                <h4>${fund.name}</h4>
                <div style="font-size:12px; color:#666;">持有 ${h.units.toFixed(2)} 份</div>
            </div>
            <div class="fund-data">
                <div class="fund-change ${colorClass}">${sign}${profit.toFixed(2)}</div>
                <div class="fund-nav" style="font-size:11px;">${sign}${profitRate.toFixed(2)}%</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

// 切换 Tab
function switchFundTab(tab) {
    activeFundTab = tab;
    // 更新 CSS 类
    document.querySelectorAll('.frame-tab').forEach(el => el.classList.remove('active'));
    document.getElementById(`tab-fund-${tab}`).classList.add('active');
    renderFundScreen();
}

// 6. 交易相关
let currentTradeContext = null;

async function openFundTradeModal(type, fund, holding = null) {
    currentTradeContext = { type, fund, holding };
    const modal = document.getElementById('fund-trade-modal');
    
    // 获取余额
    const wallet = await db.userWallet.get('main');
    const balance = wallet.balance || 0;

    document.getElementById('fund-trade-name').textContent = fund.name;
    document.getElementById('fund-trade-code').textContent = fund.code;
    document.getElementById('fund-trade-nav').textContent = fund.currentNav.toFixed(4);
    
    const changeRate = ((fund.currentNav - fund.lastDayNav) / fund.lastDayNav) * 100;
    const changeEl = document.getElementById('fund-trade-change');
    changeEl.textContent = (changeRate >= 0 ? "+" : "") + changeRate.toFixed(2) + "%";
    changeEl.className = changeRate >= 0 ? 'fund-up' : 'fund-down';

    const inputEl = document.getElementById('fund-trade-amount');
    inputEl.value = '';
    const confirmBtn = document.getElementById('fund-confirm-btn');
    const titleEl = document.getElementById('fund-trade-title');
    const labelEl = document.getElementById('fund-trade-label');
    const infoEl = document.getElementById('fund-trade-info');

    if (type === 'buy') {
        titleEl.textContent = '买入基金';
        labelEl.innerHTML = `买入金额 (余额: ¥<span id="fund-wallet-balance">${balance.toFixed(2)}</span>)`;
        infoEl.textContent = "费率 0.00%";
        confirmBtn.textContent = "确认买入";
        confirmBtn.style.backgroundColor = "#1677ff";
        currentTradeContext.maxAmount = balance;
    } else {
        titleEl.textContent = '卖出基金';
        const holdingVal = holding.units * fund.currentNav;
        labelEl.innerHTML = `卖出金额 (持有: ¥<span id="fund-wallet-balance">${holdingVal.toFixed(2)}</span>)`;
        infoEl.textContent = `持有份额: ${holding.units.toFixed(2)} 份`;
        confirmBtn.textContent = "确认卖出";
        confirmBtn.style.backgroundColor = "#ff9800";
        currentTradeContext.maxAmount = holdingVal;
    }

    modal.classList.add('visible');
}

// 确认交易 (绑定在HTML onclick)
window.handleFundTradeConfirm = async function() {
    if (!currentTradeContext) return;
    const amount = parseFloat(document.getElementById('fund-trade-amount').value);
    
    if (isNaN(amount) || amount <= 0) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert("提示", "请输入有效金额");
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }
    if (amount > currentTradeContext.maxAmount) {
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        await showCustomAlert("失败", "余额或份额不足");
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        return;
    }

    const { type, fund } = currentTradeContext;
    const wallet = await db.userWallet.get('main');
    let holdings = wallet.fundHoldings || [];

    if (type === 'buy') {
        const success = await processTransaction(amount, 'expense', `基金买入-${fund.name}`);
        if (!success) return;

        const existing = holdings.find(h => h.fundId === fund.id);
        const newUnits = amount / fund.currentNav;
        
        if (existing) {
            const totalCost = (existing.units * existing.cost) + amount;
            existing.units += newUnits;
            existing.cost = totalCost / existing.units;
        } else {
            holdings.push({ fundId: fund.id, units: newUnits, cost: fund.currentNav });
        }
        await showCustomAlert("成功", "买入成功！");
    } else {
        const idx = holdings.findIndex(h => h.fundId === fund.id);
        if (idx === -1) return;
        
        const unitsToSell = amount / fund.currentNav;
        holdings[idx].units -= unitsToSell;
        if (holdings[idx].units < 0.01) holdings.splice(idx, 1);

        await processTransaction(amount, 'income', `基金卖出-${fund.name}`);
        await showCustomAlert("成功", "卖出成功！");
    }

    wallet.fundHoldings = holdings;
    await db.userWallet.put(wallet);

    // 交易后立即检查主题
    checkThemeStatus();

    document.getElementById('fund-trade-modal').classList.remove('visible');
    renderFundScreen();
};

// 暴露给全局
window.openFundScreen = openFundScreen;
window.switchFundTab = switchFundTab; // 这次补上了！
window.refreshFundMarket = async () => {
    await showCustomAlert("刷新中", "正在更新行情...");
    await simulateFundMarket();
    await renderFundScreen();
};
let auctionState = {
    isActive: false,
    item: null,
    currentPrice: 0,
    timer: 30,
    timerId: null,
    npcIntervalId: null,
    lastBidder: null, // { name: string, type: 'user'|'npc'|'char', id: string }
    bidHistory: []
};

// 1. 打开拍卖行
async function openAuctionScreen() {
    showScreen('auction-screen');
    // 如果当前没有活动拍卖，或者拍卖已结束，生成一个新的预览
    if (!auctionState.isActive) {
        document.getElementById('auction-item-img').style.display = 'none';
        document.getElementById('auction-loading').style.display = 'block';
        document.getElementById('auction-item-name').textContent = "正在搜寻黑市...";
        document.getElementById('auction-item-desc').textContent = "";
        
        // 自动开始生成
        generateNewAuctionItem();
    }
}


async function generateNewAuctionItem() {
    const btn = document.querySelector('#auction-screen .action-btn');
    btn.style.pointerEvents = 'none';
    btn.textContent = '进货中...';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey) {
        alert("请先配置API！");
        btn.style.pointerEvents = 'auto';
        btn.textContent = '新拍品';
        return;
    }

    // --- 1. 智能设定判定逻辑 ---
    let auctionContext = "";
    
    // 尝试寻找包含 "黑市" 或 "拍卖" 的世界书
    const auctionBook = state.worldBooks.find(wb => wb.name.includes('黑市') || wb.name.includes('拍卖'));

    if (auctionBook) {
        console.log("✅ 找到专属拍卖设定书:", auctionBook.name);
        const contentPreview = auctionBook.content
            .filter(e => e.enabled !== false)
            .map(e => e.content).join('; ');
        // 如果有世界书，强制 AI 遵守世界书
        auctionContext = `
    【当前拍卖行特殊世界观 (最高优先级)】: 
    ${contentPreview}
    
    (请根据上述特殊世界观生成符合设定的拍品和NPC，忽略现实世界的限制)
    `;
    } else {
        console.log("ℹ️ 未找到专属设定，使用默认豪奢设定");
        auctionContext = `
    【默认拍品类别清单】:
    1. 顶级珠宝：稀有钻石项链、红蓝宝石戒指、皇冠、手镯（适合送给恋人）。
    2. 传世古董：明清瓷器、欧洲中世纪古物、绝版名表、玉玺。
    3. 艺术珍品：世界名画（虚构的真迹）、著名雕塑。
    4. 奢华资产：海岛契约、私人飞机、顶级豪车、庄园钥匙。
    5. 游戏抽卡：珍稀游戏道具、绝版皮肤账号。
    
    (请仅从上述 5 个类别中选择一种生成)
    `;
    }

    // 2. 获取角色列表 (用于 AI 预判谁会买)
    const charList = Object.values(state.chats).filter(c => !c.isGroup).map(c => {
        return `${c.name}(${c.settings.aiPersona.substring(0, 50)}...)`;
    }).join('\n');

    const systemPrompt = `
    你是一位顶级拍卖行的首席拍卖官。
    
    # 核心任务
    请根据下面的【设定来源】，完成两个任务：
    1. 生成一件极具价值的拍品。
    2. 生成一批符合该世界观背景的“路人NPC竞拍者”。
    
    ${auctionContext}
    
    # 任务 B：买家意向分析
    下面是今天的受邀宾客名单（用户的重要角色）：
    ${charList}
    请分析这件拍品对哪些宾客有吸引力？
    
    # 回复格式铁律
    回复【必须且只能】是一个JSON对象：
    {
        "item": {
            "name": "物品名称 (中文，名字要霸气或优雅)",
            "description": "一段精彩的描述，强调其稀有度、历史价值或特殊功能（50字以内，中文）",
            "basePrice": 初始价格(数字, 建议 10000 以上),
            "image_prompt": "物品的英文视觉描述, high quality, cinematic lighting, detailed, clean background"
        },
        "interested_bidders": ["宾客A的名字", "宾客B的名字"],
        "world_npcs": ["NPC名字1", "NPC名字2", "NPC名字3", "NPC名字4", "NPC名字5"]
    }
    
    注意：
    1. image_prompt 必须全是英文单词。
    2. interested_bidders 数组里只能填上面“受邀宾客名单”里出现过的名字。
    3. world_npcs 是你根据世界观生成的路人。例如：如果是修仙世界，生成"青云门长老"、"散修大能"；如果是赛博世界，生成"荒坂公司高管"、"夜之城中间人"。如果是默认设定，生成"石油王子"、"神秘收藏家"等。
    `;

    try {
        let isGemini = proxyUrl.includes('generativelanguage');
        let config = toGeminiRequestData(model, apiKey, systemPrompt, [{role:'user', content:'生成一件拍品'}]);
        
        const response = isGemini ? 
            await fetch(config.url, config.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: [{role:'system', content:systemPrompt}, {role:'user', content:'生成一件拍品'}], temperature: 1.0 })
            });

        if (!response.ok) throw new Error("API请求失败");
        const data = await response.json();
        const text = getGeminiResponseText(data);
        const json = JSON.parse(text.replace(/^```json\s*/, '').replace(/```$/, ''));

        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(json.item.image_prompt)}`;
        const limitMultiplier = 1.5 + Math.random() * 2.0; 
        
        auctionState.item = json.item;
        auctionState.basePrice = json.item.basePrice;
        auctionState.limitPrice = json.item.basePrice * limitMultiplier;
        auctionState.currentPrice = json.item.basePrice;
        auctionState.isActive = true;
        auctionState.timer = 20; 
        auctionState.lastBidder = null; 
        auctionState.bidHistory = [];
        
        auctionState.interestedChars = json.interested_bidders || [];
        // 【核心新增】保存生成的 NPC 列表
        auctionState.worldNPCs = json.world_npcs || [];

        console.log("对本拍品感兴趣的角色:", auctionState.interestedChars);
        console.log("本场路人NPC:", auctionState.worldNPCs);

        // 更新UI
        document.getElementById('auction-item-name').textContent = json.item.name;
        document.getElementById('auction-item-desc').textContent = json.item.description;
        document.getElementById('auction-current-price').textContent = `¥ ${json.item.basePrice.toLocaleString()}`;
        
        const imgEl = document.getElementById('auction-item-img');
        imgEl.src = imageUrl;
        imgEl.style.display = 'block';
        document.getElementById('auction-loading').style.display = 'none';
        
        document.getElementById('auction-log').innerHTML = '<div style="color:#666; padding:5px;">拍卖开始！底价 ¥' + json.item.basePrice + '</div>';

        startAuctionLoop();

    } catch (e) {
        console.error(e);
        alert("进货失败，请重试");
    } finally {
        btn.style.pointerEvents = 'auto';
        btn.textContent = '新拍品';
    }
}

// 新增：拍卖师喊话状态
let auctioneerState = 0; 

function startAuctionLoop() {
    if (auctionState.timerId) clearInterval(auctionState.timerId);
    if (auctionState.npcIntervalId) clearInterval(auctionState.npcIntervalId);

    const timerEl = document.getElementById('auction-timer');
    const logEl = document.getElementById('auction-log'); // 获取日志区域
    auctioneerState = 0; // 重置喊话

    // 倒计时逻辑
    auctionState.timerId = setInterval(() => {
        auctionState.timer--;
        
        // 格式化倒计时显示
        timerEl.textContent = `${auctionState.timer.toFixed(1)}s`;
        
        // 视觉警告
        if (auctionState.timer <= 5) {
            timerEl.style.color = '#ff0055'; // 红色紧迫
            timerEl.style.textShadow = '0 0 10px #ff0055';
        } else {
            timerEl.style.color = '#f0ad4e';
            timerEl.style.textShadow = 'none';
        }

        // --- 玩法增强：拍卖师喊话 ---
        if (auctionState.timer <= 10 && auctioneerState === 0) {
            addAuctionLog("System", `🔨 ${auctionState.currentPrice} 第一次！`);
            auctioneerState = 1;
        }
        if (auctionState.timer <= 5 && auctioneerState === 1) {
            addAuctionLog("System", `🔨 ${auctionState.currentPrice} 第二次！还有人加价吗？`);
            auctioneerState = 2;
        }
        if (auctionState.timer <= 2 && auctioneerState === 2) {
            addAuctionLog("System", `🔨 ${auctionState.currentPrice} 第三次！即将成交...`);
            auctioneerState = 3;
        }

        if (auctionState.timer <= 0) {
            endAuction();
        }
    }, 1000); // 这里其实可以改成 100ms 增加平滑度，但 1000ms 够用了

    // NPC 出价逻辑 (稍微加快频率)
    auctionState.npcIntervalId = setInterval(() => {
        if (!auctionState.isActive) return;
        
        // 增加随机性：不是每次tick都检查，而是更随机
        if (Math.random() < 0.7) { 
            npcBid();
        }
    }, 800); 
}

// 4. NPC/熟人 出价逻辑 (修复版：更智能、有机会赢)
// 4. NPC/熟人 出价逻辑 (AI互搏版)
function npcBid() {
    // 【核心修改1】删除了 "if (lastBidder !== 'user') return" 这行代码
    // 现在允许 AI 之间互相竞价，不需要等玩家
    
    // 1. 价格封顶检查 (防止无限互刷)
    if (auctionState.currentPrice >= auctionState.limitPrice) {
        // 超过估值上限后，90%概率停止，10%概率“上头”继续跟
        if (Math.random() > 0.1) return; 
    }

    // 2. 计算出价概率 (价格越高，跟拍越犹豫)
    const premiumRatio = auctionState.currentPrice / auctionState.basePrice;
    const bidChance = 0.8 / (premiumRatio * premiumRatio); // 稍微调高了系数，让后期也敢跟
    if (Math.random() > bidChance) return;

    // 3. 确定本次谁想出价 (30% 角色 vs 70% NPC)
    let candidate = null;
    
    // 获取感兴趣的角色列表
    const allCharacters = Object.values(state.chats).filter(c => !c.isGroup);
    const interestedCandidates = allCharacters.filter(c => 
        auctionState.interestedChars && auctionState.interestedChars.includes(c.name)
    );

    // 骰子判定：本次是熟人出手(30%) 还是 土豪路人出手(70%)
    if (interestedCandidates.length > 0 && Math.random() < 0.3) {
        const char = interestedCandidates[Math.floor(Math.random() * interestedCandidates.length)];
        candidate = { name: char.name, type: 'char', id: char.id };
    } else {
        // --- NPC 池 ---
        let npcName = "神秘买家";
        
        // 优先从生成的列表里找，并且尽量找一个“不是当前最高出价者”的人
        if (auctionState.worldNPCs && auctionState.worldNPCs.length > 0) {
            // 过滤掉当前正在领先的人，制造“竞争”感
            const rivals = auctionState.worldNPCs.filter(n => 
                !auctionState.lastBidder || n !== auctionState.lastBidder.name
            );
            
            if (rivals.length > 0) {
                npcName = rivals[Math.floor(Math.random() * rivals.length)];
            } else {
                npcName = auctionState.worldNPCs[0];
            }
        } else {
            // 兜底名单
            const richNames = ["神秘买家", "苏富比VIP", "迪拜王室成员", "华尔街投资人", 
            "地产大亨", "低调的收藏家", "某上市公司CEO", "港岛名媛", "石油王子"];
            npcName = richNames[Math.floor(Math.random() * richNames.length)];
        }
        
        candidate = { name: npcName, type: 'npc' };
    }

    // 【核心修改2】防自己顶自己
    // 如果想出价的人，已经是当前最高出价者了，那就不出了，等别人顶
    if (auctionState.lastBidder && auctionState.lastBidder.name === candidate.name) {
        return;
    }

    // 4. 决定加价幅度
    let increasePercent = 0.05; // 默认加 5%

    // 【核心修改3】NPC 更有钱逻辑
    // 如果是 NPC，有 30% 的概率“财大气粗”，直接加价 10%~15%，压制全场
    if (candidate.type === 'npc' && Math.random() < 0.3) {
        increasePercent = 0.15; 
    }

    const newPrice = Math.floor(auctionState.currentPrice * (1 + increasePercent));
    updateAuctionState(newPrice, candidate);
}

// 5. 用户出价逻辑
async function placeBid(multiplier) {
    if (!auctionState.isActive) return;

    let bidAmount = 0;
    if (multiplier === 'custom') {
        const input = await showCustomPrompt("手动出价", "输入金额 (不能低于当前价)", auctionState.currentPrice + 100, 'number');
        if (!input) return;
        bidAmount = parseFloat(input);
    } else {
        bidAmount = Math.floor(auctionState.currentPrice * multiplier);
    }

    if (bidAmount <= auctionState.currentPrice) {
        alert("出价必须高于当前价格！");
        return;
    }

    // 检查余额 (预检查，虽然不扣款，但要防止乱点)
    const wallet = await db.userWallet.get('main');
    const totalAssets = wallet.balance + (wallet.kinshipCards || []).reduce((sum, c) => sum + (c.limit - (c.spent||0)), 0);
    
    if (totalAssets < bidAmount) {
        // 震动反馈
        if(navigator.vibrate) navigator.vibrate(200);
        showCustomAlert("资金不足", "你的资产总额不足以支付此价格！");
        return;
    }

    const user = { name: state.qzoneSettings.nickname || '我', type: 'user', id: 'user' };
    updateAuctionState(bidAmount, user);
}

// 辅助函数：统一添加日志
function addAuctionLog(type, text) {
    const logEl = document.getElementById('auction-log');
    const div = document.createElement('div');
    
    if (type === 'System') {
        div.innerHTML = `<span style="color:#00f3ff; font-weight:bold;">[拍卖官]</span> ${text}`;
    } else {
        div.innerHTML = text; // 普通出价日志
    }
    
    if (type === 'bid-me') div.className = 'bid-me';
    if (type === 'bid-friend') div.className = 'bid-friend';
    
    logEl.appendChild(div); // 改为 appendChild，加在最下面
    logEl.scrollTop = logEl.scrollHeight;
}

// 修改原有的 updateAuctionState
function updateAuctionState(newPrice, bidder) {
    auctionState.currentPrice = newPrice;
    auctionState.lastBidder = bidder;
    auctionState.bidHistory.push(bidder); // 记录

    // --- 玩法增强：加时机制 ---
    // 如果剩余时间少于 10 秒，有人出价则回血到 10~15 秒
    if (auctionState.timer < 10) {
        const bonusTime = Math.floor(Math.random() * 5) + 10; // 随机回血
        auctionState.timer = bonusTime;
        // 视觉反馈：重置喊话状态
        auctioneerState = 0; 
        
        // 视觉反馈：闪烁一下倒计时
        const timerEl = document.getElementById('auction-timer');
        timerEl.style.color = '#00ff00'; // 绿色表示时间增加
        setTimeout(() => timerEl.style.color = '#f0ad4e', 300);
        
        addAuctionLog("System", "⏱️ 有人出价，时间延长！");
    }

    // 更新价格 UI
    const priceEl = document.getElementById('auction-current-price');
    priceEl.textContent = `¥ ${newPrice.toLocaleString()}`;
    priceEl.classList.remove('shake-animation');
    void priceEl.offsetWidth; 
    priceEl.classList.add('shake-animation');

    // 构造出价日志内容
    let content = "";
    let logType = "bid-npc";
    
    if (bidder.type === 'user') {
        content = `🚩 <b>你</b> 出价 ¥${newPrice.toLocaleString()}`;
        logType = "bid-me";
        // 震动反馈 (如果设备支持)
        if(navigator.vibrate) navigator.vibrate(50);
    } else if (bidder.type === 'char') {
        content = `🔥 <b>${bidder.name}</b> 举牌 ¥${newPrice.toLocaleString()}!`;
        logType = "bid-friend";
    } else {
        content = `${bidder.name} 出价 ¥${newPrice.toLocaleString()}`;
    }
    
    // 写入日志
    const logEl = document.getElementById('auction-log');
    const div = document.createElement('div');
    div.innerHTML = content;
    div.className = logType;
    logEl.appendChild(div); 
    logEl.scrollTop = logEl.scrollHeight;
}

// 7. 拍卖结束结算 - 修复版
async function endAuction() {
    clearInterval(auctionState.timerId);
    clearInterval(auctionState.npcIntervalId);
    auctionState.isActive = false;
    
    const winner = auctionState.lastBidder;
    const finalPrice = auctionState.currentPrice;
    const item = auctionState.item;

    document.getElementById('auction-timer').textContent = "结束";
    document.getElementById('auction-item-image-container').classList.remove('auction-win-anim');

    // 情况1：根本没人出价（流拍）
    if (!winner) {
        await showCustomAlert("拍卖结束", "无人出价，该拍品已流拍。");
        return;
    }

    // 情况2：用户获胜
    if (winner.type === 'user') {
        document.getElementById('auction-item-image-container').classList.add('auction-win-anim');
        
        // 获取钱包
        const wallet = await db.userWallet.get('main');
        const balance = wallet.balance || 0;
        const kinshipCards = wallet.kinshipCards || [];

        const paymentOptions = [];
        if (balance >= finalPrice) {
            paymentOptions.push({ 
                text: `<span style="color:#1677ff;font-weight:bold;">余额支付</span> (剩余 ¥${balance.toFixed(2)})`, 
                value: 'balance' 
            });
        }
        kinshipCards.forEach(card => {
            const remaining = card.limit - (card.spent || 0);
            if (remaining >= finalPrice) {
                const chat = state.chats[card.chatId];
                paymentOptions.push({
                    text: `<span style="color:#ff5252;font-weight:bold;">亲属卡 - ${chat.name}</span> (剩余 ¥${remaining.toFixed(2)})`,
                    value: `kinship_${card.chatId}`
                });
            }
        });

        if (paymentOptions.length === 0) {
             await showCustomAlert("竞拍成功但支付失败", "你赢了竞拍，但资金不足以支付！");
             return;
        }

        // 提升弹窗层级
        document.getElementById('custom-modal-overlay').style.zIndex = 3002;
        const method = await showChoiceModal(`竞拍成功！支付 ¥${finalPrice}`, paymentOptions);
        document.getElementById('custom-modal-overlay').style.zIndex = '';
        
        if (!method) {
             await showCustomAlert("交易取消", "你放弃了支付。");
             return;
        }

        // 扣款
        let providerChatId = null;
        if (method === 'balance') {
            await processTransaction(finalPrice, 'expense', `黑市购买-${item.name}`);
        } else {
            // 【修复】使用 replace 提取完整的 chatId (例如 chat_123456)
            const chatId = method.replace('kinship_', ''); 
            
            providerChatId = chatId;
            const cardIndex = wallet.kinshipCards.findIndex(c => c.chatId === chatId);
            
            if (cardIndex > -1) {
                // 1. 更新额度
                wallet.kinshipCards[cardIndex].spent = (wallet.kinshipCards[cardIndex].spent || 0) + finalPrice;
                await db.userWallet.put(wallet);
                
                // 2. 写入账单
                await db.userTransactions.add({
                    timestamp: Date.now(),
                    type: 'expense',
                    amount: finalPrice,
                    description: `亲属卡黑市-${item.name}`
                });
                
                console.log(`[黑市] 亲属卡扣款成功: -${finalPrice}`);
            } else {
                console.error(`[黑市] 扣款失败：找不到ID为 ${chatId} 的亲属卡`);
                alert("支付异常：未找到对应的亲属卡记录。");
                return;
            }
        }

        // 入库
        await db.inventory.add({
            name: item.name,
            type: 'treasure',
            description: item.description,
            image: item.image_prompt,
            acquiredPrice: finalPrice,
            acquiredTime: Date.now()
        });

        const giftConfirmed = await showCustomConfirm(
            "竞拍成功！", 
            `你已成功拍下【${item.name}】！\n\n要现在就把它作为礼物，送给某位角色吗？`,
            { confirmText: '🎁 立即赠送', cancelText: '放入仓库' }
        );

        if (giftConfirmed) {
            await openAuctionGiftSelector(item, finalPrice);
        } else {
            await showCustomAlert("已入库", "物品已安全存入你的库存。");
        }

        // 触发记忆和通知
        if (providerChatId) {
            const providerChat = state.chats[providerChatId];
            if (providerChat) {
                const msg = {
                    role: 'system',
                    content: `[消费通知：用户使用你的亲属卡在黑市拍卖行消费了 ¥${finalPrice}，购买了“${item.name}”。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                providerChat.history.push(msg);
                await db.chats.put(providerChat);
            }
        }
        
        // 通知在场的熟人
        const uniqueBidders = [...new Set(auctionState.bidHistory.filter(b => b.type === 'char').map(b => b.id))];
        for (const charId of uniqueBidders) {
            if (charId === providerChatId) continue;
            const char = state.chats[charId];
            if (char) {
                const msg = {
                    role: 'system',
                    content: `[系统提示：在刚才的黑市拍卖中，用户以 ¥${finalPrice} 的价格击败了在场的竞拍者（包括你），赢得了“${item.name}”。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                char.history.push(msg);
                await db.chats.put(char);
            }
        }

    } else {
        // --- Char 或 NPC 获胜 ---
        
        if (winner.type === 'char') {
            // 如果是我们的角色赢了
            const chat = state.chats[winner.id];
            if (chat) {
                await showCustomAlert("竞拍结束", `恭喜！您的好友【${winner.name}】以 ¥${finalPrice.toLocaleString()} 成功拍得宝物！`);
                
                // 触发 AI 决策：是否送给用户
                // 我们不直接弹窗问用户，而是发送一条隐藏的系统消息给 AI，让 AI 自己决定
                const systemPrompt = `
                [系统提示：你刚刚在拍卖会上斥资 ¥${finalPrice.toLocaleString()} 拍下了“${item.name}”(${item.description})。
                请根据你的人设和与用户的关系，决定怎么处理这个物品。
                你可以：
                1. 送给用户作为惊喜 (使用 'gift' 指令)。
                2. 自己收藏，并向用户炫耀 (使用 'text' 或 'ai_image' 指令)。
                3. 抱怨太贵了 (使用 'text' 指令)。
                请开始你的表演。]
                `;
                
                chat.history.push({
                    role: 'system',
                    content: systemPrompt,
                    timestamp: Date.now(),
                    isHidden: true
                });
                await db.chats.put(chat);
                
                // 如果当前没在聊天界面，就不强制跳转，只在后台触发
                // 如果想更明显，可以强制跳转：
                const confirmJump = await showCustomConfirm("去看看？", `${winner.name} 似乎有话对你说。`, {confirmText:"前往聊天"});
                if (confirmJump) {
                    openChat(winner.id);
                    triggerAiResponse(); // 触发 AI 回复
                } else {
                    // 只是后台触发，下次进聊天能看到
                    // 注意：这里需要手动调用一次 API，但因为不在聊天界面，可能需要谨慎处理
                    // 简单起见，建议就用上面的跳转逻辑
                }
            }
        } else {
            // 纯路人 NPC 赢了
            await showCustomAlert("拍卖结束", `很遗憾，被【${winner.name}】以 ¥${finalPrice.toLocaleString()} 拍走了。`);
        }
    }
}
// 新增：打开送礼对象选择器 (滚动列表修复版)
async function openAuctionGiftSelector(item, price) {
    const characters = Object.values(state.chats).filter(c => !c.isGroup);
    if (characters.length === 0) return alert("没有可赠送的角色");

    // 获取模态框元素
    const modal = document.getElementById('custom-modal-overlay');
    const titleEl = document.getElementById('custom-modal-title');
    const bodyEl = document.getElementById('custom-modal-body');
    const footerEl = document.querySelector('#custom-modal .custom-modal-footer');

    // 1. 设置标题
    titleEl.textContent = `将“${item.name}”送给...`;

    // 2. 重置 Footer 样式 (清除之前 showChoiceModal 可能留下的分页按钮和样式)
    footerEl.innerHTML = '';
    footerEl.style.flexDirection = 'row'; // 恢复横向布局
    footerEl.style.justifyContent = 'center';
    footerEl.style.maxHeight = ''; // 清除高度限制
    footerEl.style.overflowY = ''; // 清除滚动

    // 添加一个简单的取消按钮
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = '取消';
    cancelBtn.style.color = '#666';
    cancelBtn.onclick = () => modal.classList.remove('visible');
    footerEl.appendChild(cancelBtn);

    // 3. 构建滚动列表 (渲染在 Body 中)
    bodyEl.innerHTML = '';
    
    const listContainer = document.createElement('div');
    // 样式：最大高度限制 + 垂直滚动
    listContainer.style.cssText = `
        max-height: 60vh; 
        overflow-y: auto; 
        display: flex; 
        flex-direction: column; 
        text-align: left;
        margin: 0 -16px; /* 抵消 modal-body 的内边距，让列表贴边 */
        border-top: 1px solid #eee;
    `;

    // 按名称排序，方便查找
    characters.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));

    characters.forEach(char => {
        const row = document.createElement('div');
        // 单个选项样式
        row.style.cssText = `
            display: flex;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid #f5f5f5;
            cursor: pointer;
            transition: background-color 0.2s;
        `;
        
        const avatar = char.settings.aiAvatar || defaultAvatar;
        
        row.innerHTML = `
            <img src="${avatar}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 15px; object-fit: cover; border: 1px solid #eee;">
            <div style="flex-grow: 1;">
                <div style="font-weight: 500; font-size: 16px; color: var(--text-primary);">${char.name}</div>
            </div>
            <div style="color: #ccc;">›</div>
        `;

        // 点击事件
        row.onclick = async () => {
            // 视觉反馈
            row.style.backgroundColor = '#f0f0f0';
            setTimeout(async () => {
                modal.classList.remove('visible');
                await sendAuctionGiftToChat(char.id, item, price);
            }, 100);
        };

        listContainer.appendChild(row);
    });

    bodyEl.appendChild(listContainer);
    
    // 4. 显示模态框
    modal.classList.add('visible');
}

// 新增：发送礼物消息到聊天
async function sendAuctionGiftToChat(chatId, item, price) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 构造礼物图片URL
    // 如果是 AI 生的图，尝试提取 prompt 重新构造链接，或者直接用默认图
    let imageUrl = 'https://i.postimg.cc/Hs7BLh76/alipay.png'; 
    if (item.image_prompt) {
        imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image_prompt)}`;
    }

    // 2. 构造礼物消息
    const giftMessage = {
        role: 'user',
        type: 'gift',
        timestamp: Date.now(),
        items: [{
            name: `[稀世珍宝] ${item.name}`,
            price: price,
            imageUrl: imageUrl,
            quantity: 1
        }],
        total: price,
        recipients: null // 单聊不需要 recipients
    };

    chat.history.push(giftMessage);

    // 3. 添加系统提示，让AI知道这是刚拍下来的
    const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户刚刚在黑市拍卖会上，斥巨资（¥${price.toLocaleString()}）拍下了稀世珍宝“${item.name}”并直接送给了你。物品描述：${item.description}。这是极其贵重的礼物，请根据你的人设做出强烈的反应（惊讶、感动、或是责怪乱花钱）。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);

    // 4. 跳转并触发 AI 回复
    await showCustomAlert("赠送成功", `礼物已送达给 ${chat.name}！正在前往聊天界面...`);
    
    // 切换屏幕
    showScreen('chat-list-screen'); // 先切到列表刷新状态
    setTimeout(() => {
        openChat(chatId); // 打开聊天
        triggerAiResponse(); // 触发 AI 回复
    }, 300);
}
// 辅助：记录出价历史
const originalUpdateAuctionState = updateAuctionState;
updateAuctionState = function(newPrice, bidder) {
    auctionState.bidHistory.push(bidder); // 记录所有出价者
    originalUpdateAuctionState(newPrice, bidder); // 调用原逻辑
}
window.openAuctionScreen = openAuctionScreen;
window.generateNewAuctionItem = generateNewAuctionItem;
window.placeBid = placeBid;
// --- 黑市仓库功能 ---

// 1. 打开仓库
async function openInventoryModal() {
    const modal = document.getElementById('inventory-modal');
    const listEl = document.getElementById('inventory-list');
    
    modal.classList.add('visible');
    listEl.innerHTML = '<div class="spinner"></div>'; // 显示加载动画

    try {
        // 从数据库读取藏品，按时间倒序
        const items = await db.inventory.orderBy('acquiredTime').reverse().toArray();
        
        listEl.innerHTML = '';
        if (items.length === 0) {
            listEl.innerHTML = '<div style="text-align:center; color:#666; margin-top:50px;">仓库空空如也<br>快去竞拍点好东西吧</div>';
            return;
        }

        items.forEach(item => {
            const div = document.createElement('div');
            div.className = 'inventory-item';
            
            // 图片处理：兼容 Pollinations 和普通 URL
            let imageUrl = 'https://i.postimg.cc/Hs7BLh76/alipay.png'; 
            if (item.image) {
                if (item.image.startsWith('http') || item.image.startsWith('data:')) {
                     imageUrl = item.image;
                } else {
                     // 如果是 prompt，转换成链接
                     imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(item.image)}`;
                }
            }

            div.innerHTML = `
                <img src="${imageUrl}" class="inventory-img" loading="lazy">
                <div class="inventory-info">
                    <div class="inventory-name">${item.name}</div>
                    <div class="inventory-desc">${item.description || '稀世珍宝'}</div>
                    <div class="inventory-price">入手价: ¥${(item.acquiredPrice || 0).toLocaleString()}</div>
                </div>
                <button class="inventory-use-btn">赠送</button>
            `;

            // 绑定赠送按钮
            const btn = div.querySelector('.inventory-use-btn');
            btn.onclick = () => handleGiftFromInventory(item);

            listEl.appendChild(div);
        });

    } catch (e) {
        console.error(e);
        listEl.innerHTML = '<div style="text-align:center; color:#ff3b30;">加载失败</div>';
    }
}

// 2. 关闭仓库
function closeInventoryModal() {
    document.getElementById('inventory-modal').classList.remove('visible');
}

// 3. 从仓库赠送
async function handleGiftFromInventory(item) {
    // 关闭仓库弹窗
    closeInventoryModal();

    // 构造赠送对象
    const giftItem = {
        name: item.name,
        description: item.description,
        image_prompt: item.image 
    };

    // 调用现有的赠送选择器 (复用 openAuctionGiftSelector)
    // 传入入手价作为礼物的价值
    await openAuctionGiftSelector(giftItem, item.acquiredPrice || 9999);
}

// 暴露给全局使用
window.openInventoryModal = openInventoryModal;
window.closeInventoryModal = closeInventoryModal;
// === 完整版 playSynthScore 函数 (支持节奏 + 全乐器) ===
let globalPolySynth = null;

async function playSynthScore(btnElement, notesJson, instrumentType = 'piano') {
    let notes = [];
    try {
        // 1. 解析乐谱数据
        // 兼容旧版纯字符串数组 ["C4", "E4"] 和新版对象数组 [{"n":"C4","d":"4n"}]
        const rawNotes = (typeof notesJson === 'string') ? JSON.parse(notesJson) : notesJson;
        
        // 统一格式化为新版对象 {n: 音高, d: 时长}
        notes = rawNotes.map(item => {
            if (typeof item === 'string') {
                return { n: item, d: '8n' }; // 旧版数据默认8分音符
            }
            return { n: item.n, d: item.d || '4n' }; // 新版数据，默认4分音符
        });

    } catch(e) { console.error("乐谱解析失败", e); return; }

    if (!notes || notes.length === 0) return;

    // 2. 启动音频引擎
    await Tone.start();

    // 初始化合成器 (单例模式)
    if (!globalPolySynth) {
        globalPolySynth = new Tone.PolySynth(Tone.Synth).toDestination();
    }
    
    // 重置基础音量
    globalPolySynth.volume.value = -8;

    // 3. 配置乐器音色 (Switch Case)
    switch (instrumentType) {
        case 'chiptune': // 8-bit 游戏风
            globalPolySynth.set({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
            });
            break;
            
        case 'synth': // 电子合成器
            globalPolySynth.set({
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 2 }
            });
            break;

        case 'guitar': // 吉他 (清脆拨弦)
            globalPolySynth.set({
                oscillator: { type: "triangle" }, 
                envelope: { 
                    attack: 0.01, decay: 0.3, sustain: 0.1, release: 1.0 
                }
            });
            globalPolySynth.volume.value = -5; // 补偿音量
            break;

        case 'violin': // 小提琴 (缓慢起音，绵长延音)
            globalPolySynth.set({
                oscillator: { type: "sawtooth" },
                envelope: { 
                    attack: 0.2, decay: 0.1, sustain: 0.8, release: 1.5 
                }
            });
            globalPolySynth.volume.value = -10; // 弦乐较响，降低音量
            break;

        case 'flute': // 笛子 (纯净正弦波)
            globalPolySynth.set({
                oscillator: { type: "sine" },
                envelope: { 
                    attack: 0.1, decay: 0.1, sustain: 0.9, release: 0.5 
                }
            });
            break;

        case 'guzheng': // 古筝 (尖锐拨弦，快速衰减)
            globalPolySynth.set({
                oscillator: { type: "triangle" },
                envelope: { 
                    attack: 0.005, decay: 0.4, sustain: 0, release: 1.5 
                }
            });
            globalPolySynth.volume.value = -5;
            break;

        case 'kalimba': // 拇指琴 (可爱，空灵)
            globalPolySynth.set({
                oscillator: { type: "sine" },
                envelope: { 
                    attack: 0.001, decay: 0.1, sustain: 0, release: 1.2 
                }
            });
            break;

        case 'piano': // 默认钢琴
        default:
            globalPolySynth.set({
                oscillator: { type: "triangle" },
                envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1 }
            });
            break;
    }

    // 4. 更新 UI 状态
    btnElement.textContent = "❚❚";
    btnElement.classList.add('playing');
    btnElement.disabled = true;

    // 5. 【核心】按节奏播放逻辑
    const now = Tone.now();
    let accumulatedTime = 0; // 累计时间轴，用于计算下一个音符的播放时间点

    notes.forEach((noteObj) => {
        // 简单的正则检查音符格式 (如 C4, D#5)
        if (noteObj.n && /^[A-G][#b]?[0-9]$/.test(noteObj.n)) {
            // 计算当前音符的时长 (秒)
            const durationInSeconds = Tone.Time(noteObj.d).toSeconds();
            
            // 在当前累计的时间点触发声音
            // triggerAttackRelease(音高, 持续时间, 触发时间点)
            globalPolySynth.triggerAttackRelease(noteObj.n, noteObj.d, now + accumulatedTime);
            
            // 累加时间，让下一个音符排在后面
            accumulatedTime += durationInSeconds;
        }
    });

    // 6. 播放结束重置
    // 等待总时长 + 0.5秒余音后，恢复按钮
    setTimeout(() => {
        btnElement.textContent = "▶";
        btnElement.classList.remove('playing');
        btnElement.disabled = false;
    }, accumulatedTime * 1000 + 500);
}
// 暴露给全局
window.playSynthScore = playSynthScore;
// --- To-Do List 逻辑开始 ---

function getTodoDateString(date) {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
}

async function openTodoList() {
    if (!state.activeChatId) return;
    
    // 重置到今天
    currentTodoDate = new Date();
    updateTodoDateDisplay();
    await renderTodoList();
    
    showScreen('todo-list-screen');
}

function updateTodoDateDisplay() {
    const displayEl = document.getElementById('todo-current-date-display');
    const now = new Date();
    const dateStr = getTodoDateString(currentTodoDate);
    const todayStr = getTodoDateString(now);
    
    if (dateStr === todayStr) {
        displayEl.textContent = "今天";
    } else {
        displayEl.textContent = dateStr;
    }
}

function changeTodoDate(days) {
    currentTodoDate.setDate(currentTodoDate.getDate() + days);
    updateTodoDateDisplay();
    renderTodoList();
}

// 1. 修改 renderTodoList
async function renderTodoList() {
    const container = document.getElementById('todo-list-container');
    container.innerHTML = '';
    
    const chat = state.chats[state.activeChatId];
    if (!chat) return;
    
    const targetDateStr = getTodoDateString(currentTodoDate);
    const todos = chat.todoList || [];
    
    // 筛选当天的任务
    const dayTodos = todos.filter(t => t.date === targetDateStr);
    
    // 排序
    dayTodos.sort((a, b) => {
        if (a.status === b.status) {
            return (a.time || '00:00').localeCompare(b.time || '00:00');
        }
        return a.status === 'completed' ? 1 : -1;
    });

    if (dayTodos.length === 0) {
        container.innerHTML = `<div class="todo-empty-state">📅 ${targetDateStr}<br>暂无待办事项</div>`;
        return;
    }

    // --- 核心修改：存入缓存，重置计数，调用分批加载 ---
    todoCache = dayTodos;
    todoRenderCount = 0;
    loadMoreTodos();
}

// 2. 新增 loadMoreTodos
function loadMoreTodos() {
    if (isLoadingMoreTodos) return;

    const container = document.getElementById('todo-list-container');
    if (!container) return;

    if (todoRenderCount >= todoCache.length) return;

    isLoadingMoreTodos = true;
    const BATCH_SIZE = 30; // 每次加载30条
    const nextSliceEnd = todoRenderCount + BATCH_SIZE;
    const itemsToRender = todoCache.slice(todoRenderCount, nextSliceEnd);

    const fragment = document.createDocumentFragment();

    itemsToRender.forEach(todo => {
        const item = document.createElement('div');
        const isUser = (todo.creator === 'user' || !todo.creator);
        const creatorClass = isUser ? 'is-user' : 'is-char';
        
        item.className = `todo-item ${todo.status} ${creatorClass}`;
        item.dataset.id = todo.id;
        
        const colorMap = {
            '日常': '#8e8e93', '工作': '#007aff', '重要': '#ff3b30', 
            '生活': '#34c759', '约会': '#af52de', '学习': '#ff9500','记账': '#ffc107'
        };
        const tagColor = colorMap[todo.type] || '#8e8e93';

        item.innerHTML = `
            <div class="todo-checkbox"></div>
            <div class="todo-info">
                <div class="todo-content">${escapeHTML(todo.content)}</div>
                <div class="todo-meta">
                    <span class="todo-tag" style="--tag-color: ${tagColor};">${todo.type || '日常'}</span>
                    ${todo.time ? `<span class="todo-time">⏰ ${todo.time}</span>` : ''}
                </div>
            </div>
            <button class="todo-delete-btn">×</button>
        `;
        
        item.querySelector('.todo-checkbox').addEventListener('click', (e) => {
            e.stopPropagation();
            toggleTodoStatus(todo.id);
        });

        item.querySelector('.todo-delete-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            deleteTodo(todo.id);
        });
        
        item.addEventListener('click', () => openTodoEditor(todo));

        fragment.appendChild(item);
    });

    container.appendChild(fragment);
    todoRenderCount += itemsToRender.length;
    isLoadingMoreTodos = false;
}

async function toggleTodoStatus(id) {
    const chat = state.chats[state.activeChatId];
    const todo = chat.todoList.find(t => t.id === id);
    
    if (todo) {
        // 1. 切换状态
        const isCompleting = todo.status !== 'completed';
        todo.status = isCompleting ? 'completed' : 'pending';
        
        // 2. 【核心】只保留记录系统提示，删除了 triggerAiResponse
        if (isCompleting) { 
            const myNickname = chat.settings.myNickname || '我';
            
            // 构造系统提示词，只作为记忆植入
            const systemHint = `[系统提示：用户(${myNickname}) 刚刚在待办清单中勾选完成了：“${todo.content}”。]`;

            // 插入隐藏消息
            const hiddenMsg = {
                role: 'system',
                content: systemHint,
                timestamp: Date.now(),
                isHidden: true // 用户看不见，AI下次生成时能看见
            };
            
            chat.history.push(hiddenMsg);
        }

        // 3. 保存并刷新界面
        await db.chats.put(chat);
        renderTodoList(); 
    }
}

async function deleteTodo(id) {
    const confirmed = await showCustomConfirm("删除事项", "确定要删除这条待办事项吗？");
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.todoList = chat.todoList.filter(t => t.id !== id);
        await db.chats.put(chat);
        renderTodoList();
    }
}

function openTodoEditor(todo = null) {
    const modal = document.getElementById('todo-editor-modal');
    const titleEl = document.getElementById('todo-editor-title');
    
    editingTodoId = todo ? todo.id : null;
    titleEl.textContent = todo ? '编辑事项' : '添加事项';
    
    document.getElementById('todo-content-input').value = todo ? todo.content : '';
    document.getElementById('todo-date-input').value = todo ? todo.date : getTodoDateString(currentTodoDate);
    document.getElementById('todo-time-input').value = todo ? todo.time : '';
    
    // 重置并设置类型选中
    const typeOptions = document.querySelectorAll('.todo-type-option');
    typeOptions.forEach(opt => opt.classList.remove('active'));
    const targetType = todo ? todo.type : '日常';
    const activeOption = Array.from(typeOptions).find(opt => opt.dataset.value === targetType);
    if (activeOption) activeOption.classList.add('active');
    
    modal.classList.add('visible');
}

async function saveTodo() {
    const content = document.getElementById('todo-content-input').value.trim();
    const date = document.getElementById('todo-date-input').value;
    const time = document.getElementById('todo-time-input').value;
    const typeEl = document.querySelector('.todo-type-option.active');
    const type = typeEl ? typeEl.dataset.value : '日常';

    if (!content || !date) {
        alert("内容和日期不能为空！");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat.todoList) chat.todoList = [];

    if (editingTodoId) {
        const todo = chat.todoList.find(t => t.id === editingTodoId);
        if (todo) {
            todo.content = content;
            todo.date = date;
            todo.time = time;
            todo.type = type;
        }
    } else {
        chat.todoList.push({
            id: Date.now(),
            content,
            date,
            time,
            type,
            status: 'pending',
            creator: 'user',
            timestamp: Date.now()
        });
    }

    await db.chats.put(chat);
    
    // 如果日记日期变了，跳转到该日期
    const newDate = new Date(date);
    if (!isNaN(newDate.getTime())) {
         currentTodoDate = newDate;
         updateTodoDateDisplay();
    }

    document.getElementById('todo-editor-modal').classList.remove('visible');
    renderTodoList();
}
// --- To-Do List 逻辑结束 ---
// ==========================================
// ▼▼▼ 绿江 (Green River) 同人创作模块 ▼▼▼
// ==========================================

let grState = {
    activeStoryId: null,
    isGenerating: false
};

// 默认作者预设
const DEFAULT_AUTHORS = [
    { name: "细腻情感", style: "侧重心理描写，文笔细腻，擅长捕捉人物间微妙的情感流动，氛围感强。", maxOutput: 600 },
    { name: "正剧剧情", style: "注重剧情逻辑，节奏紧凑，对白干练，擅长推动故事情节发展。", maxOutput: 800 },
    { name: "轻松日常", style: "幽默风趣，轻松愉快，多用生动的对话和有趣的细节描写，治愈系。", maxOutput: 500 },
    { name: "意识流", style: "大量使用隐喻和象征，句式优美复杂，着重于意象和哲学思考，弱化具体情节。", maxOutput: 400 }
];

// 1. 初始化数据 (在 openGreenRiverScreen 时调用)
async function initGreenRiverData() {
    const count = await db.grAuthors.count();
    if (count === 0) {
        await db.grAuthors.bulkAdd(DEFAULT_AUTHORS);
    }
}

// 2. 打开主界面
async function openGreenRiverScreen() {
    await initGreenRiverData();
    showScreen('green-river-screen');
    renderBookList();
}

// 3. 渲染书架
// 找到 renderBookList 函数，替换整个函数
async function renderBookList() {
    const listEl = document.getElementById('gr-book-list');
    listEl.innerHTML = '';
    
    const stories = await db.grStories.orderBy('lastUpdated').reverse().toArray();
    const authors = await db.grAuthors.toArray();
    const authorMap = new Map(authors.map(a => [a.id, a.name]));
    
    // 获取已关联的书籍ID集合
    const existingBooks = await db.readingLibrary.toArray();
    const linkedIds = new Set(existingBooks.map(b => b.linkedStoryId).filter(id => id));

    if (stories.length === 0) {
        listEl.innerHTML = '<p style="grid-column:1/-1; text-align:center; color:var(--gr-text-sub); margin-top:50px;">书架是空的，点击右上角新建一部作品吧。</p>';
        return;
    }

    stories.forEach(story => {
        const authorName = authorMap.get(story.authorId) || '未知作者';
        const div = document.createElement('div');
        div.className = 'gr-book-card';
        
        const wordCount = story.chapters.reduce((acc, ch) => acc + ch.content.length, 0);
        
        // 【核心逻辑修改】
        const isAdded = linkedIds.has(story.id);
        // 如果已加入，显示“已在书架”，点击触发移除；否则显示“加入”，点击触发加入
        const btnText = isAdded ? '已在书架' : '加入共读';
        const btnClass = isAdded ? 'gr-add-shelf-btn added' : 'gr-add-shelf-btn';
        const actionFn = isAdded ? 'removeGreenRiverFromShelf' : 'addGreenRiverToShelf';
        
        div.innerHTML = `
            <div>
                <div class="gr-book-title">${story.title}</div>
                <div class="gr-book-meta">
                    <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                    ${authorName}
                </div>
            </div>
            <div class="gr-book-meta" style="justify-content: space-between; margin-top:15px; align-items: flex-end;">
                <div style="display:flex; flex-direction:column; gap:2px;">
                    <span>${story.chapters.length} 章</span>
                    <span>${(wordCount/1000).toFixed(1)}k 字</span>
                </div>
                <button class="${btnClass}" onclick="event.stopPropagation(); ${actionFn}(${story.id}, this);">
                    ${isAdded ? '✓ ' : '+ '}${btnText}
                </button>
            </div>
        `;
        
        div.onclick = (e) => {
            if(e.target.tagName !== 'BUTTON') openReader(story.id);
        };
        
        addLongPressListener(div, async () => {
             if(confirm(`确定要删除作品《${story.title}》吗？`)) {
                 await db.grStories.delete(story.id);
                 renderBookList();
             }
        });
        
        listEl.appendChild(div);
    });
}

// 4. 作者管理
// --- 绿江作者管理重构 (修复布局和编辑功能) ---

let editingAuthorId = null; // 用于记录当前正在编辑的作者ID

// 1. 打开作者管理列表 (渲染界面)
async function openAuthorManager() {
    showScreen('gr-author-screen');
    const listEl = document.getElementById('gr-author-list');
    listEl.innerHTML = '';
    
    const authors = await db.grAuthors.toArray();
    
    if (authors.length === 0) {
         listEl.innerHTML = '<p style="text-align:center; color:#999; margin-top:50px;">还没有设定作者，点击右上角“+”添加。</p>';
         return;
    }

    authors.forEach(author => {
        const div = document.createElement('div');
        div.className = 'gr-author-item';
        div.innerHTML = `
            <div class="gr-author-info" style="flex-grow: 1; padding-right: 10px; min-width: 0;">
                <h3 style="margin: 0 0 5px 0; font-size: 16px; font-weight: 600; color: #1C1C1E;">${author.name}</h3>
                <p style="margin: 0; font-size: 13px; color: #8E8E93; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; line-height: 1.5;">${author.style}</p>
            </div>
            <div class="gr-author-actions">
                <button class="gr-icon-btn" onclick="openAuthorEditor(${author.id})" title="编辑">
                   <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button class="gr-icon-btn" style="color:#ff3b30;" onclick="deleteAuthor(${author.id})" title="删除">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                </button>
            </div>
        `;
        listEl.appendChild(div);
    });
}

// 2. 打开编辑/添加弹窗
// 如果传入 id，则是编辑模式；否则是添加模式
async function openAuthorEditor(id = null) {
    editingAuthorId = id;
    const modal = document.getElementById('gr-author-editor-modal');
    const titleEl = document.getElementById('gr-author-editor-title');
    const nameInput = document.getElementById('gr-author-name-input');
    const styleInput = document.getElementById('gr-author-style-input');

    if (id) {
        // 编辑模式：回显数据
        const author = await db.grAuthors.get(id);
        if (author) {
            titleEl.textContent = "编辑作者";
            nameInput.value = author.name;
            styleInput.value = author.style;
        }
    } else {
        // 添加模式：清空数据
        titleEl.textContent = "添加作者";
        nameInput.value = "";
        styleInput.value = "";
    }

    modal.classList.add('visible');
}

// 3. 保存作者 (由弹窗内的保存按钮调用)
async function saveAuthor() {
    const name = document.getElementById('gr-author-name-input').value.trim();
    const style = document.getElementById('gr-author-style-input').value.trim();

    if (!name || !style) {
        alert("名称和风格描述都不能为空！");
        return;
    }

    if (editingAuthorId) {
        // 更新
        await db.grAuthors.update(editingAuthorId, { name, style });
    } else {
        // 新增
        await db.grAuthors.add({ name, style, maxOutput: 600 });
    }

    // 关闭弹窗并刷新列表
    document.getElementById('gr-author-editor-modal').classList.remove('visible');
    openAuthorManager();
}

// 4. 删除作者
async function deleteAuthor(id) {
    const confirmed = await showCustomConfirm("确认删除", "确定删除这位作者设定吗？\n(这不会影响已生成的章节内容)", { confirmButtonClass: 'btn-danger' });
    if(confirmed) {
        await db.grAuthors.delete(id);
        openAuthorManager();
    }
}

// 5. 绑定头部“+”按钮到新的编辑器逻辑
// (这个函数名与HTML中的onclick="addAuthor()"对应，我们将其重定向到openAuthorEditor)
function addAuthor() {
    openAuthorEditor(null);
}

// 6. 绑定保存按钮事件 (在初始化时执行一次即可，防止重复绑定)
const saveBtn = document.getElementById('gr-save-author-btn');
if (saveBtn) {
    // 使用 cloneNode 移除旧的监听器 (如果有的话)
    const newBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newBtn, saveBtn);
    newBtn.onclick = saveAuthor;
}

// 暴露给全局
window.openAuthorManager = openAuthorManager;
window.openAuthorEditor = openAuthorEditor;
window.addAuthor = addAuthor;
window.deleteAuthor = deleteAuthor;

// 5. 新建作品 (设置页)
async function createNewStory() {
    grState.activeStoryId = null; // 标记为新建
    document.getElementById('gr-story-title').value = '';
    await loadStorySettingsUI();
    document.getElementById('gr-settings-modal').classList.add('visible');
}

async function openStorySettings() {
    if(!grState.activeStoryId) return;
    const story = await db.grStories.get(grState.activeStoryId);
    if(!story) return;

    document.getElementById('gr-story-title').value = story.title;
    await loadStorySettingsUI(story.settings, story.authorId);
    
    document.getElementById('gr-settings-modal').classList.add('visible');
}

// 加载设置弹窗中的选项
// 加载设置弹窗中的选项 (修复版：增加字数和条数的回显)
async function loadStorySettingsUI(settings = {}, selectedAuthorId = null) {
    // 1. 加载作者列表
    const authorSelect = document.getElementById('gr-author-select');
    authorSelect.innerHTML = '';
    const authors = await db.grAuthors.toArray();
    authors.forEach(a => {
        const opt = document.createElement('option');
        opt.value = a.id;
        opt.textContent = a.name;
        if(selectedAuthorId === a.id) opt.selected = true;
        authorSelect.appendChild(opt);
    });

    // 2. 加载角色列表 (Chats + NPCs)
    const charList = document.getElementById('gr-char-list');
    charList.innerHTML = '';
    const chars = Object.values(state.chats); 
    const npcs = await db.npcs.toArray();
    
    const allEntities = [
        ...chars.map(c => ({ id: c.id, name: c.name, type: c.isGroup ? '群聊' : '角色' })),
        ...npcs.map(n => ({ id: `npc_${n.id}`, name: n.name, type: 'NPC' }))
    ];

    allEntities.forEach(item => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        // 回显：检查是否在已保存的列表中
        const isChecked = settings.charIds && settings.charIds.includes(item.id);
        div.innerHTML = `<input type="checkbox" value="${item.id}" ${isChecked?'checked':''}> <span>${item.name} <small style="color:#999">(${item.type})</small></span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        charList.appendChild(div);
    });

    // 3. 加载世界书列表
    const wbList = document.getElementById('gr-worldbook-list');
    wbList.innerHTML = '';
    const books = await db.worldBooks.toArray();
    books.forEach(book => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        // 回显：检查是否在已保存的列表中
        const isChecked = settings.bookIds && settings.bookIds.includes(book.id);
        div.innerHTML = `<input type="checkbox" value="${book.id}" ${isChecked?'checked':''}> <span>${book.name}</span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        wbList.appendChild(div);
    });
    
    // 4. 加载User预设
    const userSelect = document.getElementById('gr-user-persona-select');
    userSelect.innerHTML = '<option value="">当前默认</option>';
    const presets = await db.personaPresets.toArray();
    presets.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.persona.substring(0, 20) + '...';
        // 回显：选中已保存的 User Persona
        if(settings.userPersonaId === p.id) opt.selected = true;
        userSelect.appendChild(opt);
    });

    // 5. 【核心修复】：回显字数和上下文条数
    // 如果 settings 里有值，就用 settings 里的；如果没有（新建时），就用默认值 500 和 20
    document.getElementById('gr-output-length').value = settings.outputLength || 500;
    document.getElementById('gr-context-limit').value = settings.contextLimit || 20;
    document.getElementById('gr-macro-world-view').value = settings.macroWorldView || '';
    // 绑定按钮事件
    const saveBtn = document.getElementById('gr-save-story-btn');
    const cancelBtn = document.getElementById('gr-cancel-settings-btn');
    
    // 使用 cloneNode 清除旧的监听器，防止多次点击
    const newSaveBtn = saveBtn.cloneNode(true);
    const newCancelBtn = cancelBtn.cloneNode(true);
    
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

    newSaveBtn.onclick = () => saveStorySettings();
    newCancelBtn.onclick = () => document.getElementById('gr-settings-modal').classList.remove('visible');
}

// 5. 修复版：保存作品设置
async function saveStorySettings() {
    // 获取 DOM 元素
    const titleInput = document.getElementById('gr-story-title');
    const authorSelect = document.getElementById('gr-author-select');
    const userPersonaSelect = document.getElementById('gr-user-persona-select');
    const outputLengthInput = document.getElementById('gr-output-length'); // 检查HTML ID是否一致
    const contextLimitInput = document.getElementById('gr-context-limit'); // 检查HTML ID是否一致
    const macroWorldViewInput = document.getElementById('gr-macro-world-view');
    const title = titleInput.value.trim();
    const authorId = parseInt(authorSelect.value);
    
    const charIds = Array.from(document.querySelectorAll('#gr-char-list input:checked')).map(cb => cb.value);
    const bookIds = Array.from(document.querySelectorAll('#gr-worldbook-list input:checked')).map(cb => cb.value);
    const userPersonaId = userPersonaSelect.value;
    
    // 【核心修复】：确保这里取到的是数字，并且有默认值
    const outputLength = parseInt(outputLengthInput.value) || 500;
    const contextLimit = parseInt(contextLimitInput.value) || 20;
    const macroWorldView = macroWorldViewInput.value.trim();
    if (!title) return alert("请输入书名");
    if (charIds.length === 0) return alert("请至少选择一个角色或群聊");

    const settings = { 
        charIds, 
        bookIds, 
        userPersonaId, 
        outputLength, // 这里的名字要和 prompt 里的对应
        contextLimit,
        macroWorldView 
    };

    if (grState.activeStoryId) {
        // 更新现有作品
        await db.grStories.update(grState.activeStoryId, { title, authorId, settings });
    } else {
        // 新建作品
        const newStory = {
            title,
            authorId,
            settings,
            chapters: [],
            lastUpdated: Date.now()
        };
        grState.activeStoryId = await db.grStories.add(newStory);
    }
    
    document.getElementById('gr-settings-modal').classList.remove('visible');
    
    // 打开阅读器，并定位到最新一章
    const story = await db.grStories.get(grState.activeStoryId);
    const lastIndex = Math.max(0, story.chapters.length - 1);
    openReader(grState.activeStoryId, lastIndex);
}

// 6. 阅读器逻辑 - 分页版 (Jinjiang Style)
async function openReader(storyId, chapterIndex = 0) {
    grState.activeStoryId = storyId;
    const story = await db.grStories.get(storyId);
    if (!story) return;

    // 确保索引合法
    const totalChapters = story.chapters.length;
    if (totalChapters > 0 && chapterIndex >= totalChapters) chapterIndex = totalChapters - 1;
    if (chapterIndex < 0) chapterIndex = 0;
    
    grState.currentChapterIndex = chapterIndex;

    // 更新顶部标题
    document.getElementById('gr-book-name-display').textContent = story.title;
    
    const contentArea = document.getElementById('gr-reader-content');
    contentArea.innerHTML = '';

    // --- 场景 A: 尚未开始 (没有章节) ---
    if (totalChapters === 0) {
        document.getElementById('gr-chapter-title-display').textContent = "序章";
        contentArea.innerHTML = `
            <div style="text-align:center; padding-top:100px; color:#888;">
                <p>故事尚未开始。</p>
                <p>请在下方输入第一章的剧情走向，点击“续写”开始创作。</p>
            </div>
        `;
        // 显示写作控制栏，隐藏翻页栏
        document.getElementById('gr-pagination-controls').style.display = 'none';
        document.getElementById('gr-writing-controls').style.display = 'flex';
        
        // 绑定生成按钮
        updateGenButtonBinding();
        showScreen('gr-reader-screen');
        return;
    }

    // --- 场景 B: 显示特定章节 ---
    const chapter = story.chapters[chapterIndex];
    const chapterTitle = chapter.title || `第 ${chapterIndex + 1} 章`; // 如果没有标题，使用默认
    
    document.getElementById('gr-chapter-title-display').textContent = chapterTitle;

    // 1. 顶部：前情提要 (Context)
    if (chapter.prevSummary) {
        contentArea.innerHTML += `
            <details class="gr-summary-box top-summary">
                <summary>📖 上文提要 (Context)</summary>
                <div class="gr-summary-content" style="font-size:12px; color:#888;">${chapter.prevSummary}</div>
            </details>
        `;
    }

    // 2. 章节大标题
    contentArea.innerHTML += `<div class="gr-chapter-title-large">${chapterTitle}</div>`;

    // 3. 正文
    contentArea.innerHTML += `<div class="gr-chapter-text">${chapter.content.replace(/\n/g, '<br>')}</div>`;

    // 4. 底部：本章摘要 (可编辑)
    const summaryHtml = `
            <div class="gr-summary-card editable">
                <div class="gr-summary-header">
                    <span class="gr-summary-title">Chapter Checkpoint · 剧情存档</span>
                    <button class="gr-mini-btn save-summary-btn" data-index="${chapterIndex}">保存修改</button>
                </div>
                <textarea class="gr-summary-input" data-index="${chapterIndex}" placeholder="在此处概括本章关键剧情点，供AI记忆...">${chapter.summary || ''}</textarea>
                 <div class="gr-summary-footer">
                    * AI续写时将读取此框内容作为唯一记忆依据。
                </div>
            </div>
        `;
        contentArea.innerHTML += summaryHtml;
        contentArea.innerHTML += `<div style="height: 100px;"></div>`;

    // 绑定保存摘要按钮
    contentArea.querySelectorAll('.save-summary-btn').forEach(btn => {
        btn.onclick = (e) => {
            const idx = parseInt(e.target.dataset.index);
            const textarea = contentArea.querySelector(`.gr-summary-input[data-index="${idx}"]`);
            saveChapterSummary(storyId, idx, textarea.value);
            e.target.textContent = "已保存";
            setTimeout(() => e.target.style.display = 'none', 1000);
        };
    });

    // 5. 更新底部导航栏状态
    const prevBtn = document.getElementById('gr-prev-chapter-btn');
    const nextBtn = document.getElementById('gr-next-chapter-btn');
    const paginationDiv = document.getElementById('gr-pagination-controls');
    const writingDiv = document.getElementById('gr-writing-controls');
    const rerollBtn = document.getElementById('gr-reroll-btn');

    // 总是显示分页栏，写作栏只在最后一页显示
    paginationDiv.style.display = 'flex';
    
    prevBtn.disabled = (chapterIndex === 0);
    prevBtn.onclick = () => openReader(storyId, chapterIndex - 1);

    if (chapterIndex < totalChapters - 1) {
        // 如果不是最后一章
        nextBtn.textContent = "下一章";
        nextBtn.onclick = () => openReader(storyId, chapterIndex + 1);
        writingDiv.style.display = 'none'; // 隐藏写作栏
    } else {
        // 如果是最后一章
        nextBtn.textContent = "续写下一章";
        nextBtn.onclick = () => {
             // 点击下一章按钮时，显示写作栏，并自动滚动到底部
             writingDiv.style.display = 'flex';
             contentArea.scrollTop = contentArea.scrollHeight;
             document.getElementById('gr-direction-input').focus();
        };
        // 默认也显示写作栏
        writingDiv.style.display = 'flex';
        
        // 绑定重写按钮
        rerollBtn.onclick = async () => {
             const confirmed = await showCustomConfirm("重写本章", "确定要删除当前章节并重新生成吗？", {confirmText:"重写", confirmButtonClass:"btn-danger"});
             if (confirmed) handleGenerateStoryContent(true);
        };
    }
    
    // 绑定生成按钮
    updateGenButtonBinding();
    
    showScreen('gr-reader-screen');
    contentArea.scrollTop = 0;
}

// 辅助：绑定生成按钮
function updateGenButtonBinding() {
    const genBtn = document.getElementById('gr-generate-btn');
    // 使用克隆节点来移除旧的监听器
    const newBtn = genBtn.cloneNode(true);
    genBtn.parentNode.replaceChild(newBtn, genBtn);
    newBtn.onclick = () => handleGenerateStoryContent(false);
}

// 辅助：更新底部控制栏
function updateControlPanel(story) {
    const controlPanel = document.querySelector('.gr-control-panel');
    // 清空旧内容，重新构建
    controlPanel.innerHTML = `
        <div style="display:flex; gap:10px; align-items:center; width:100%;">
            <div class="gr-input-group" style="flex-grow:1;">
                <input type="text" id="gr-direction-input" class="gr-input" placeholder="输入剧情走向 (留空则自由续写)...">
            </div>
            
            ${story.chapters.length > 0 ? `
            <button id="gr-reroll-btn" class="gr-main-btn" style="background-color:#F4F4F5; color:#666; border:1px solid #ddd;" title="不满当前章？重写！">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
            </button>
            ` : ''}

            <button id="gr-generate-btn" class="gr-main-btn">
                <span id="gr-gen-text">续写</span>
                <svg id="gr-gen-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path></svg>
            </button>
        </div>
    `;

    // 绑定事件
    document.getElementById('gr-generate-btn').onclick = () => handleGenerateStoryContent(false); // false = 不是重写
    
    const rerollBtn = document.getElementById('gr-reroll-btn');
    if (rerollBtn) {
        rerollBtn.onclick = async () => {
            const confirmed = await showCustomConfirm("重写本章", "确定要删除当前最新章节并重新生成吗？\n(如果你刚才修改了摘要，重写后需要重新修改)", {confirmText:"重写", confirmButtonClass:"btn-danger"});
            if (confirmed) {
                handleGenerateStoryContent(true); // true = 是重写
            }
        };
    }
}

// 辅助：保存修改后的摘要
async function saveChapterSummary(storyId, chapterIndex, newSummary) {
    const story = await db.grStories.get(storyId);
    if (story && story.chapters[chapterIndex]) {
        story.chapters[chapterIndex].summary = newSummary;
        await db.grStories.put(story);
        console.log("摘要已手动更新");
    }
}
// 7. 核心生成逻辑 (The Writer) - 字数强力修正版
async function handleGenerateStoryContent(isReroll = false) {
    if (grState.isGenerating) return;
    
    let story = await db.grStories.get(grState.activeStoryId);
    
    // --- 重写逻辑 ---
    if (isReroll && story.chapters.length > 0) {
        story.chapters.pop();
        await db.grStories.put(story);
        openReader(story.id, Math.max(0, story.chapters.length - 1));
    }

    const author = await db.grAuthors.get(story.authorId);
    const directionInput = document.getElementById('gr-direction-input');
    const userDirection = directionInput.value.trim();
    
    const genBtn = document.getElementById('gr-generate-btn');
    const btnText = document.getElementById('gr-gen-text'); // 获取文字标签
    grState.isGenerating = true;
    
    if(genBtn) {
        genBtn.disabled = true;
        // 【核心修复】：加了判断，只有当文字标签存在时才修改文字，否则只禁用按钮
        if (btnText) btnText.textContent = "撰写中..."; 
    }

    try {
        // 获取目标字数，并做一个“溢价”处理
        // 如果用户设置 500，我们告诉 AI 写 800，这样它偷懒打折后刚好是 500
        const settingValue = parseInt(story.settings.outputLength) || 500;
        const targetWordCount = Math.floor(settingValue * 1.5); 
        
        const historyLimit = story.settings.contextLimit || 20;

        // --- 构建上下文 ---
        let charsContext = "";
        for (const id of story.settings.charIds) {
            if (id.startsWith('npc_')) {
                const npcId = parseInt(id.replace('npc_', ''));
                const npc = await db.npcs.get(npcId);
                if (npc) charsContext += `- NPC ${npc.name}: ${npc.persona}\n`;
            } else {
                const chat = state.chats[id];
                if (chat) {
                    const memories = (chat.longTermMemory || [])
                        .map(m => `  * ${m.content}`)
                        .join('\n');

                    const history = chat.history.slice(-historyLimit).map(m => {
                        if(m.role === 'system' || m.type === 'red_packet' || m.type === 'waimai_request' || m.type === 'transfer') return null;
                        let content = String(m.content);
                        if(content.includes("红包") || content.includes("手机") || content.includes("转账")) return null; 
                        return `  > ${m.senderName}: ${content.substring(0, 50)}`;
                    }).filter(Boolean).join('\n');
                    
                    charsContext += `### 角色: ${chat.name}\n- **核心人设**: ${chat.settings.aiPersona}\n`;
                    if (memories) charsContext += `- **【重要：长期记忆】**:\n${memories}\n`;
                    if (history) charsContext += `- **【语气参考 (最近聊天)】**:\n${history}\n`;
                    charsContext += `\n`;
                }
            }
        }

        let userPersonaText = "普通用户";
        if (story.settings.userPersonaId) {
            const preset = await db.personaPresets.get(story.settings.userPersonaId);
            if (preset) userPersonaText = preset.persona;
        } else if (state.chats[Object.keys(state.chats)[0]]) {
             userPersonaText = state.chats[Object.keys(state.chats)[0]].settings.myPersona;
        }

        let worldBookText = "";
        for (const bid of story.settings.bookIds) {
            const wb = await db.worldBooks.get(bid);
            if (wb) worldBookText += `- 《${wb.name}》设定: ${wb.content.filter(e=>e.enabled).map(e=>e.content).join(';')}\n`;
        }

        let prevSummary = "这是故事的开始。";
        if (story.chapters && story.chapters.length > 0) {
            const lastChapter = story.chapters[story.chapters.length - 1];
            if (lastChapter && lastChapter.summary) {
                prevSummary = lastChapter.summary;
            }
        }
let macroContext = "";
    if (story.settings.macroWorldView) {
        macroContext = `
# 【🔥 核心世界观 / IF线设定 (最高优先级)】
注意：这是一条IF线或特殊背景故事。**你必须优先遵循以下设定**，如果以下设定与角色的原始人设或记忆冲突，**请以以下设定为准并进行适配**！
---
${story.settings.macroWorldView}
---
`;
    }
        // E. Prompt 强力优化 (字数扩充 + 标题生成)
        const systemPrompt = `
# 身份
你现在是【${author.name}】。文风特点: ${author.style}

# 核心任务
续写这篇小说的新一章。
${macroContext}
# 【最高优先级：字数扩充指令】
你必须输出 **${targetWordCount} 字** 以上的内容。
为了达到这个字数，你**必须**执行以下操作：
1.  **拒绝流水账**：不要只写“他做了什么”，要写“他如何做、什么表情、心里想了什么、周围环境如何”。
2.  **细节描写**：增加环境描写（光影、气味、声音）、微表情描写、肢体动作描写。
3.  **心理活动**：大幅增加角色的内心独白和纠结。
4.  **慢镜头**：将关键动作拆解，放慢叙事节奏。

# 数据使用指南
1. **世界观**: ${worldBookText ? "必须严格遵守以下设定：" + worldBookText : "请根据角色设定自行判断。"}
2. **时代净化**: 严禁出现不符合世界观的现代物品。
3. **长期记忆**: 必须遵守角色档案中的记忆事实。

# 设定资料
- **"我" (User) 的设定**: ${userPersonaText}
- **登场角色档案**:
${charsContext}

# 当前进度
- **前情提要**: ${prevSummary}
- **用户指示**: ${userDirection || "（无指示，请顺其自然地发展剧情，重点是写够字数！）"}

# 输出格式 (JSON)
回复必须且只能是一个JSON对象：
\`\`\`json
{
  "title": "四字或多字标题 (如：月下对酌、危机四伏)",
  "content": "正文内容 (必须使用${author.style}风格，**强制写满 ${targetWordCount} 字**，多用换行符\\n增加阅读感)",
  "summary": "用陈述句概括本章关键事实（谁、在哪里、做了什么），供下一章记忆使用。"
}
\`\`\`
`;
        
        // API 调用
        const { proxyUrl, apiKey, model } = state.apiConfig;
        const messages = [{role: 'user', content: `请开始写作，请务必写够 ${targetWordCount} 字！`}];
        
        let response;
        if (proxyUrl.includes('generativelanguage')) {
            let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messages);
            response = await fetch(geminiConfig.url, geminiConfig.data);
        } else {
            response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        ...messages
                    ],
                    temperature: 0.9 // 提高温度，让它更啰嗦一点
                })
            });
        }
        
        if (!response.ok) {
             const errText = await response.text();
             throw new Error(`API 请求失败 (${response.status}): ${errText}`);
        }
        
        const data = await response.json();
        const aiText = getGeminiResponseText(data);
        
        // 1. 提取 JSON 部分
        let jsonStr = aiText;
        const jsonMatch = aiText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
            jsonStr = jsonMatch[0];
        } else {
            throw new Error("AI未返回有效JSON格式");
        }

        let result;
        try {
            // 2. 尝试直接解析
            result = JSON.parse(jsonStr);
        } catch (e) {
            console.warn("JSON解析初次失败，尝试修复转义字符...", e);
            
            // 3. 【核心修复】: 自动修复错误的转义字符
            // 正则含义：查找所有反斜杠，如果它后面跟的不是 json 允许的转义符( " \ / b f n r t u )，就把它替换为双反斜杠
            const fixedStr = jsonStr.replace(/\\([^"\\\/bfnrtu])/g, '\\\\$1');
            
            try {
                result = JSON.parse(fixedStr);
                console.log("JSON自动修复成功！");
            } catch (e2) {
                // 如果还是失败，抛出异常
                throw new Error("JSON解析失败: " + e.message);
            }
        }
        
        const newChapter = {
            title: result.title || `第 ${story.chapters.length + 1} 章`,
            content: result.content,
            summary: result.summary, 
            prevSummary: prevSummary, 
            timestamp: Date.now()
        };
        
        // 并发安全获取
        story = await db.grStories.get(grState.activeStoryId);
        story.chapters.push(newChapter);
        story.lastUpdated = Date.now();
        await db.grStories.put(story);
        
        openReader(story.id, story.chapters.length - 1);
        document.getElementById('gr-direction-input').value = ''; 

    } catch (e) {
        console.error("绿江生成失败:", e);
        alert("生成失败: " + e.message);
    } finally {
        grState.isGenerating = false;
        if(genBtn) {
            genBtn.disabled = false;
            // 【核心修复】：同样只在文字标签存在时才恢复文字
            if (btnText) btnText.textContent = "续写";
        }
    }
}
// 8. 侧边栏目录功能
function openChapterList() {
    const sidebar = document.getElementById('gr-chapter-sidebar');
    const overlay = document.getElementById('gr-sidebar-overlay');
    const listContainer = document.getElementById('gr-chapter-list-content');
    const countEl = document.getElementById('gr-total-chapters');
    
    if (!grState.activeStoryId) return;
    
    db.grStories.get(grState.activeStoryId).then(story => {
        listContainer.innerHTML = '';
        countEl.textContent = `共 ${story.chapters.length} 章`;
        
        story.chapters.forEach((ch, index) => {
            const div = document.createElement('div');
            div.className = 'gr-sidebar-item';
            if(index === grState.currentChapterIndex) div.classList.add('active');
            
            div.innerHTML = `
                <div style="display:flex; justify-content:space-between;">
                    <span>${index + 1}. ${ch.title || '无题'}</span>
                    <span style="font-size:12px; color:#999;">${new Date(ch.timestamp).toLocaleTimeString()}</span>
                </div>
                <div style="font-size:12px; color:#999; margin-left:10px; margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${(ch.summary || '').substring(0, 20)}...</div>
            `;
            
            div.onclick = () => {
                openReader(story.id, index);
                closeChapterList();
            };
            listContainer.appendChild(div);
        });
        
        sidebar.classList.add('visible');
        overlay.classList.add('visible');
    });
}

function closeChapterList() {
    document.getElementById('gr-chapter-sidebar').classList.remove('visible');
    document.getElementById('gr-sidebar-overlay').classList.remove('visible');
}
// 暴露给 HTML onclick
window.openChapterList = openChapterList;
window.closeChapterList = closeChapterList;
// 暴露全局
window.openGreenRiverScreen = openGreenRiverScreen;
window.openAuthorManager = openAuthorManager;
window.createNewStory = createNewStory;
window.openStorySettings = openStorySettings;
window.addAuthor = addAuthor;
window.deleteAuthor = deleteAuthor;
// ==========================================
// ▼▼▼ 邮箱 (Mail) 功能模块 ▼▼▼
// ==========================================

let mailState = {
    currentEmailId: null,
    isEditMode: false,
    selectedEmails: new Set()
};

// 1. 打开邮箱应用
async function openEmailApp() {
    showScreen('email-screen');
    await renderEmailList();
}

// 2. 渲染邮件列表
async function renderEmailList() {
    const listEl = document.getElementById('email-list');
    listEl.innerHTML = '';
    
    const emails = await db.emails.orderBy('timestamp').reverse().toArray();

    if (emails.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:50px; color:#8E8E93;">No Mail</div>';
        return;
    }

    const searchTerm = document.getElementById('mail-search-input').value.toLowerCase();

    emails.forEach(email => {
        if (searchTerm && !email.subject.toLowerCase().includes(searchTerm) && !email.content.toLowerCase().includes(searchTerm)) {
            return;
        }

        const div = document.createElement('div');
        // 如果当前在编辑模式，保持 editing 类
        const itemClass = `mail-item ${email.isRead ? '' : 'unread'} ${mailState.isEditMode ? 'editing' : ''}`;
        div.className = itemClass;
        div.dataset.id = email.id; // 绑定ID方便查找
        
        // 检查是否已被选中
        if (mailState.selectedEmails.has(email.id)) {
            div.classList.add('selected');
        }
        
        const date = new Date(email.timestamp);
        const timeStr = date.toLocaleDateString() === new Date().toLocaleDateString() 
            ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) 
            : date.toLocaleDateString();

        // 【关键】添加 mail-select-checkbox 结构
        div.innerHTML = `
            <div class="mail-select-checkbox"></div>
            <div class="mail-item-header">
                <span class="mail-sender">${escapeHTML(email.sender)}</span>
                <span class="mail-date">${timeStr}</span>
            </div>
            <div class="mail-subject">${escapeHTML(email.subject)}</div>
            <div class="mail-preview">${escapeHTML(email.content).replace(/\n/g, ' ').substring(0, 80)}</div>
        `;
        
        div.onclick = () => {
            if (mailState.isEditMode) {
                // 编辑模式：切换选中状态
                handleEmailSelection(div, email.id);
            } else {
                // 普通模式：打开详情
                openEmailDetail(email.id);
            }
        };
        listEl.appendChild(div);
    });
}

function handleEmailSelection(element, id) {
    if (mailState.selectedEmails.has(id)) {
        mailState.selectedEmails.delete(id);
        element.classList.remove('selected');
    } else {
        mailState.selectedEmails.add(id);
        element.classList.add('selected');
    }
    updateMailDeleteButton();
}

function updateMailDeleteButton() {
    const btn = document.getElementById('mail-delete-selected-btn');
    const count = mailState.selectedEmails.size;
    btn.textContent = count > 0 ? `删除 (${count})` : '删除';
    btn.disabled = count === 0;
}
async function executeBatchDeleteEmails() {
    const count = mailState.selectedEmails.size;
    if (count === 0) return;

    const confirmed = await showCustomConfirm(
        '删除邮件', 
        `确定要删除这 ${count} 封邮件吗？此操作无法撤销。`,
        { confirmButtonClass: 'btn-danger', confirmText: '删除' }
    );

    if (confirmed) {
        const idsToDelete = Array.from(mailState.selectedEmails);
        await db.emails.bulkDelete(idsToDelete);
        
        // 清空选中状态
        mailState.selectedEmails.clear();
        updateMailDeleteButton();
        
        // 重新渲染列表（此时还是编辑模式，所以列表会保持右移状态）
        await renderEmailList();
        
        // 可选：如果删完想自动退出编辑模式，调用 toggleEmailEditMode();
    }
}
function handleSelectAllEmails() {
    const listEl = document.getElementById('email-list');
    const allItems = listEl.querySelectorAll('.mail-item');
    
    // 如果当前已选数量等于总数，则视为“取消全选”，否则“全选”
    const isSelectingAll = mailState.selectedEmails.size < allItems.length;

    allItems.forEach(item => {
        const id = parseInt(item.dataset.id);
        if (isSelectingAll) {
            mailState.selectedEmails.add(id);
            item.classList.add('selected');
        } else {
            mailState.selectedEmails.delete(id);
            item.classList.remove('selected');
        }
    });
    updateMailDeleteButton();
}
// 3. 打开邮件详情 (更新版：绑定头部按钮)
async function openEmailDetail(id) {
    const email = await db.emails.get(id);
    if (!email) return;
    
    mailState.currentEmailId = id;

    // 标记为已读
    if (!email.isRead) {
        await db.emails.update(id, { isRead: true });
    }

    document.getElementById('mail-detail-subject').textContent = email.subject;
    document.getElementById('mail-detail-from').textContent = email.sender;
    document.getElementById('mail-detail-to').textContent = email.recipient || 'Me';
    document.getElementById('mail-detail-time').textContent = new Date(email.timestamp).toLocaleString();
    
    // 头像首字母
    const avatarEl = document.getElementById('mail-detail-avatar');
    avatarEl.textContent = email.sender.charAt(0).toUpperCase();
    
    // 正文 (处理换行)
    document.getElementById('mail-detail-body').innerHTML = email.content.replace(/\n/g, '<br>');
    
    // 绑定头部右上角的按钮事件
    
    // 1. 转发按钮
    const forwardBtn = document.getElementById('forward-email-btn');
    // 移除旧监听器 (使用 cloneNode)
    const newForwardBtn = forwardBtn.cloneNode(true);
    forwardBtn.parentNode.replaceChild(newForwardBtn, forwardBtn);
    newForwardBtn.onclick = () => forwardEmailToChat(email);

    // 2. 删除按钮 (新增在右上角)
    const deleteBtn = document.getElementById('delete-email-btn');
    if (deleteBtn) {
        const newDeleteBtn = deleteBtn.cloneNode(true);
        deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
        newDeleteBtn.onclick = () => deleteCurrentEmail();
    }

    showScreen('email-detail-screen');
}

function closeEmailDetail() {
    showScreen('email-screen');
    renderEmailList(); // 刷新状态
}

// 4. 切换编辑模式
function toggleEmailEditMode() {
    mailState.isEditMode = !mailState.isEditMode;
    const btn = document.getElementById('mail-edit-btn');
    const actionBar = document.getElementById('mail-action-bar');
    const listEl = document.getElementById('email-list');
    
    if (mailState.isEditMode) {
        // 进入编辑模式
        btn.textContent = '完成'; // 按钮变文字
        btn.style.color = 'var(--mail-accent)';
        btn.style.fontWeight = '600';
        btn.innerHTML = '完成'; // 覆盖掉之前的“编辑”文字或图标
        
        actionBar.style.display = 'flex';
        mailState.selectedEmails.clear();
        updateMailDeleteButton();
        
        // 给列表项添加样式类
        listEl.querySelectorAll('.mail-item').forEach(item => item.classList.add('editing'));
        
    } else {
        // 退出编辑模式
        btn.innerHTML = '编辑'; // 恢复文字
        btn.style.color = 'currentColor';
        btn.style.fontWeight = 'normal';
        
        actionBar.style.display = 'none';
        mailState.selectedEmails.clear();
        
        // 移除样式类
        listEl.querySelectorAll('.mail-item').forEach(item => {
            item.classList.remove('editing', 'selected');
        });
    }
}

async function deleteEmail(id) {
    if(confirm("确定要删除这封邮件吗？")) {
        await db.emails.delete(id);
        renderEmailList();
    }
}

async function deleteCurrentEmail() {
    if(mailState.currentEmailId) {
        await deleteEmail(mailState.currentEmailId);
        closeEmailDetail();
    }
}

// 5. 打开生成器配置
function saveMailConfig() {
    const config = {
        userMask: document.getElementById('mail-user-mask').value.trim(),
        worldContext: document.getElementById('mail-world-context').value.trim(),
        personaId: document.getElementById('mail-user-persona-select').value,
        allowRandom: document.getElementById('mail-allow-random-npc').checked,
        genCount: document.getElementById('mail-gen-count').value,
        // 保存选中的发件人名字数组
        selectedSenders: Array.from(document.querySelectorAll('#mail-sender-list input:checked')).map(cb => cb.value),
        // 保存选中的世界书ID数组
        selectedBookIds: Array.from(document.querySelectorAll('#mail-context-list input:checked')).map(cb => cb.value)
    };
    localStorage.setItem('ephone_mail_config', JSON.stringify(config));
    console.log("邮箱配置已保存:", config);
    return config;
}

// 2. [新功能] 加载邮箱配置
function loadMailConfig() {
    const saved = localStorage.getItem('ephone_mail_config');
    return saved ? JSON.parse(saved) : null;
}

// 3. [修改] 打开设置弹窗 (原 openEmailGenerator)
// 改名为 openEmailSettings 更贴切，同时在打开时回填数据
async function openEmailSettings() {
    // 先渲染列表（保持原有逻辑）
    const personaSelect = document.getElementById('mail-user-persona-select');
    if (personaSelect) {
        personaSelect.innerHTML = '<option value="">-- 仅使用下方关键词 (无详细人设) --</option>';
        if (state.activeChatId) {
            const currentChat = state.chats[state.activeChatId];
            if (currentChat && currentChat.settings.myPersona) {
                 const opt = document.createElement('option');
                 opt.value = 'current_chat';
                 opt.textContent = `当前聊天设定: ${currentChat.settings.myPersona.substring(0, 15).replace(/\n/g, ' ')}...`;
                 personaSelect.appendChild(opt);
            }
        }
        if (state.personaPresets && state.personaPresets.length > 0) {
            state.personaPresets.forEach((p, index) => {
                const opt = document.createElement('option');
                opt.value = p.id;
                const summary = p.persona ? p.persona.substring(0, 20).replace(/\n/g, ' ') : `预设 ${index + 1}`;
                opt.textContent = `人设库: ${summary}...`;
                personaSelect.appendChild(opt);
            });
        }
    }
    
    // 渲染发件人列表
    const listEl = document.getElementById('mail-sender-list');
    listEl.innerHTML = '';
    const chars = Object.values(state.chats).filter(c => !c.isGroup);
    const npcs = await db.npcs.toArray();
    [...chars, ...npcs].forEach(c => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        div.innerHTML = `<input type="checkbox" value="${c.name}" data-type="${c.id ? 'char' : 'npc'}"> <span>${c.name}</span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        listEl.appendChild(div);
    });

    // 渲染世界书列表
    const wbList = document.getElementById('mail-context-list');
    wbList.innerHTML = '';
    const books = await db.worldBooks.toArray();
    books.forEach(book => {
        const div = document.createElement('div');
        div.className = 'gr-checkbox-item';
        div.innerHTML = `<input type="checkbox" value="${book.id}"> <span>${book.name}</span>`;
        div.onclick = (e) => { if(e.target.tagName!=='INPUT') div.querySelector('input').click(); };
        wbList.appendChild(div);
    });

    // --- 核心：回填已保存的数据 ---
    const config = loadMailConfig();
    if (config) {
        if(config.userMask) document.getElementById('mail-user-mask').value = config.userMask;
        if(config.worldContext) document.getElementById('mail-world-context').value = config.worldContext;
        if(config.personaId) personaSelect.value = config.personaId;
        if(config.genCount) document.getElementById('mail-gen-count').value = config.genCount;
        document.getElementById('mail-allow-random-npc').checked = config.allowRandom !== false; // 默认 true

        // 回填复选框
        if (config.selectedSenders) {
            config.selectedSenders.forEach(val => {
                const cb = document.querySelector(`#mail-sender-list input[value="${val}"]`);
                if(cb) cb.checked = true;
            });
        }
        if (config.selectedBookIds) {
            config.selectedBookIds.forEach(val => {
                const cb = document.querySelector(`#mail-context-list input[value="${val}"]`);
                if(cb) cb.checked = true;
            });
        }
    }

    document.getElementById('email-generator-modal').classList.add('visible');
}

// 4. [新增] 一键接收功能
async function handleQuickReceiveMail() {
    const config = loadMailConfig();
    
    // 如果没有配置，强制打开设置窗口
    if (!config || !config.userMask) {
        await showCustomAlert("提示", "请先点击旁边的齿轮图标⚙️，配置您的收件人身份和背景。");
        openEmailSettings();
        return;
    }

    await showCustomAlert("正在接收...", `正在根据保存的配置 (${config.userMask}) 生成邮件...`);
    
    // 调用核心生成函数
    await executeEmailGeneration(config);
}
// 5. [核心提取] 将生成逻辑封装为独立函数
async function executeEmailGeneration(config) {
    // 解构配置
    const { userMask, worldContext, allowRandom, personaId, selectedSenders, selectedBookIds } = config;
    let genCount = parseInt(config.genCount) || 3;
    if (genCount > 10) genCount = 10;

    // 获取详细人设文本
    let detailedPersona = "";
    if (personaId === 'current_chat' && state.activeChatId) {
         const chat = state.chats[state.activeChatId];
         detailedPersona = chat.settings.myPersona || "";
    } else if (personaId) {
         const preset = state.personaPresets.find(p => p.id === personaId);
         if (preset) detailedPersona = preset.persona;
    }

    // 构建上下文 (世界书 + 角色记忆)
    let worldBookText = "";
    for (const bid of (selectedBookIds || [])) {
        const wb = await db.worldBooks.get(bid);
        if (wb) worldBookText += `- 《${wb.name}》: ${wb.content.filter(e=>e.enabled).map(e=>e.content).join('; ')}\n`;
    }

    let characterContext = "";
    if (selectedSenders && selectedSenders.length > 0) {
        const activeChars = Object.values(state.chats).filter(c => !c.isGroup && selectedSenders.includes(c.name));
        if (activeChars.length > 0) {
            characterContext = "\n# 【重要】指定发件人的详细档案\n";
            activeChars.forEach(chat => {
                const memory = (chat.longTermMemory && chat.longTermMemory.length > 0) ? chat.longTermMemory.map(m => m.content).join('; ') : '暂无';
                const recentHistory = chat.history.filter(m => !m.isHidden).slice(-5).map(m => `${m.role === 'user' ? '我' : chat.name}: ${String(m.content).substring(0, 50)}`).join('\n');
                characterContext += `## 发件人: ${chat.name}\n- **人设**: ${chat.settings.aiPersona.substring(0, 200)}...\n- **长期记忆**: ${memory}\n- **最近对话**: \n${recentHistory}\n\n`;
            });
        }
    }

    // Prompt
    const systemPrompt = `
# 角色：邮件系统生成器
请根据以下设定生成 **${genCount}** 封邮件。

# 收件人档案
- **身份**: ${userMask}
${detailedPersona ? `- **详细背景**: ${detailedPersona.replace(/\n/g, ' ')}` : ""}
- **世界观**: ${worldContext || "现代职场/生活"}
${worldBookText ? "- **世界书规则**: \n" + worldBookText : ""}

${characterContext}

# 发件人候选
${selectedSenders && selectedSenders.length > 0 ? "- 指定发件人: " + selectedSenders.join(', ') : ""}
${allowRandom ? "- 允许生成随机路人/广告/通知" : ""}

# 输出格式 (JSON Only)
\`\`\`json
[
  {
    "sender": "发件人姓名",
    "subject": "邮件标题",
    "content": "邮件正文 (支持换行符\\n)",
    "timestamp_offset": 0 (距离现在的分钟数，负数表示过去)
  }
]
\`\`\`
`;

    // API 调用
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let apiConfig = toGeminiRequestData(model, apiKey, systemPrompt, [{role:'user', content:`Generate ${genCount} emails`}]);
        
        const response = isGemini ? 
            await fetch(apiConfig.url, apiConfig.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: [{role:'system', content:systemPrompt}, {role:'user', content:`Generate ${genCount} emails`}], temperature: 1.0 })
            });

        if (!response.ok) throw new Error("API请求失败");
        const data = await response.json();
        const text = getGeminiResponseText(data);
        const jsonStr = text.replace(/^```json\s*/, '').replace(/```$/, '');
        const emails = JSON.parse(jsonStr);

        const now = Date.now();
        const newEmails = emails.map(e => ({
            sender: e.sender,
            senderType: 'gen',
            recipient: userMask,
            subject: e.subject,
            content: e.content,
            timestamp: now - (e.timestamp_offset || 0) * 60000,
            isRead: false
        }));

        await db.emails.bulkAdd(newEmails);
        
        // 刷新列表
        await renderEmailList();
        // 提示成功
        await showCustomAlert("接收成功", `收到 ${newEmails.length} 封新邮件。`);

    } catch (e) {
        console.error(e);
        alert("生成失败: " + e.message);
    }
}



// 7. 把新函数暴露给全局

// 6. 核心生成逻辑 (增强版：支持记忆读取 + 自定义条数)
document.getElementById('start-generate-email-btn').addEventListener('click', async () => {
    // --- 1. 获取基础输入 ---
    const userMask = document.getElementById('mail-user-mask').value.trim();
    const worldContext = document.getElementById('mail-world-context').value.trim();
    const allowRandom = document.getElementById('mail-allow-random-npc').checked;
    
    // 获取自定义数量，默认为 3
    let genCount = parseInt(document.getElementById('mail-gen-count').value);
    if (isNaN(genCount) || genCount < 1) genCount = 3;
    if (genCount > 10) genCount = 10; // 限制最大10条防止超时

    // 获取详细人设 (上一步修改的功能)
    const personaSelect = document.getElementById('mail-user-persona-select');
    let detailedPersona = "";
    if (personaSelect && personaSelect.value) {
        if (personaSelect.value === 'current_chat' && state.activeChatId) {
             const chat = state.chats[state.activeChatId];
             detailedPersona = chat.settings.myPersona || "";
        } else {
             const preset = state.personaPresets.find(p => p.id === personaSelect.value);
             if (preset) detailedPersona = preset.persona;
        }
    }

    // 获取选中的发件人名字
    const selectedSenders = Array.from(document.querySelectorAll('#mail-sender-list input:checked')).map(cb => cb.value);
    const selectedBookIds = Array.from(document.querySelectorAll('#mail-context-list input:checked')).map(cb => cb.value);

    if (!userMask) return alert("请设置收件人身份");
    
    const btn = document.getElementById('start-generate-email-btn');
    const originalBtnText = btn.textContent; 
    btn.textContent = "读取记忆中...";
    btn.disabled = true;

    // --- 2. 构建世界书上下文 ---
    let worldBookText = "";
    for (const bid of selectedBookIds) {
        const wb = await db.worldBooks.get(bid);
        if (wb) worldBookText += `- 《${wb.name}》: ${wb.content.filter(e=>e.enabled).map(e=>e.content).join('; ')}\n`;
    }

    // --- 3. 【核心新增】构建角色详细上下文 (记忆+对话) ---
    let characterContext = "";
    if (selectedSenders.length > 0) {
        // 在所有聊天中查找选中的发件人
        const activeChars = Object.values(state.chats).filter(c => !c.isGroup && selectedSenders.includes(c.name));
        
        if (activeChars.length > 0) {
            characterContext = "\n# 【重要】指定发件人的详细档案 (请根据这些信息生成个性化邮件)\n";
            
            activeChars.forEach(chat => {
                // 提取长期记忆
                const memory = (chat.longTermMemory && chat.longTermMemory.length > 0) 
                    ? chat.longTermMemory.map(m => m.content).join('; ') 
                    : '暂无';
                
                // 提取最近 5 条对话 (用于捕捉当前关系状态，如吵架、热恋、陌生)
                const recentHistory = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-5)
                    .map(m => `${m.role === 'user' ? '我' : chat.name}: ${String(m.content).substring(0, 50)}`)
                    .join('\n');

                characterContext += `## 发件人: ${chat.name}\n`;
                characterContext += `- **核心人设**: ${chat.settings.aiPersona.substring(0, 200)}...\n`; // 截取一部分防止Token溢出
                characterContext += `- **长期记忆**: ${memory}\n`;
                characterContext += `- **最近对话状态**: \n${recentHistory || '(无最近对话)'}\n`;
                characterContext += `> 指导: 请根据该角色的性格和你们最近的对话状态（例如是否刚吵过架、是否有未完成的约定）来撰写邮件。\n\n`;
            });
        }
    }

    // --- 4. 构建 Prompt ---
    const systemPrompt = `
# 角色：邮件系统生成器
请根据以下设定生成 **${genCount}** 封邮件。

# 收件人档案
- **当前身份(User Mask)**: ${userMask}
${detailedPersona ? `- **详细人设背景**: ${detailedPersona.replace(/\n/g, ' ')}` : ""}
- **所在世界观**: ${worldContext || "现代职场/生活"}
${worldBookText ? "- **世界书规则**: \n" + worldBookText : ""}

${characterContext}

# 发件人候选池
${selectedSenders.length > 0 ? "- 指定发件人列表: " + selectedSenders.join(', ') : ""}
${allowRandom ? "- 允许生成随机路人/系统通知/垃圾邮件 (如: 银行账单, 广告, 神秘邀请, 工作通告)" : ""}

# 核心要求
1. **连贯性**: 如果发件人是上述“指定发件人”中的角色，邮件内容**必须**与你们的“最近对话状态”和“长期记忆”相符。
   - *例子*: 如果最近对话在吵架，邮件可能是道歉信或冷淡的通知；如果最近在热恋，邮件可能是情书。
2. **沉浸感**: 邮件内容必须符合收件人身份和世界观。
3. **多样性**: 包含不同类型的邮件（正式、非正式、垃圾邮件、紧急通知）。
4. **格式**: 返回一个JSON数组。

# 输出格式 (JSON Only)
\`\`\`json
[
  {
    "sender": "发件人姓名",
    "subject": "邮件标题",
    "content": "邮件正文 (支持换行符\\n)",
    "timestamp_offset": 0 (距离现在的分钟数，负数表示过去，例如 60 表示一小时前收到)
  }
]
\`\`\`
`;

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        btn.textContent = "生成中...";
        
        let isGemini = proxyUrl.includes('generativelanguage');
        let config = toGeminiRequestData(model, apiKey, systemPrompt, [{role:'user', content:`Generate ${genCount} emails`}]);
        
        const response = isGemini ? 
            await fetch(config.url, config.data) : 
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: [{role:'system', content:systemPrompt}, {role:'user', content:`Generate ${genCount} emails`}], temperature: 1.0 })
            });

        if (!response.ok) throw new Error("API请求失败");
        const data = await response.json();
        const text = getGeminiResponseText(data);
        const jsonStr = text.replace(/^```json\s*/, '').replace(/```$/, '');
        const emails = JSON.parse(jsonStr);

        // 保存到数据库
        const now = Date.now();
        const newEmails = emails.map(e => ({
            sender: e.sender,
            senderType: 'gen',
            recipient: userMask,
            subject: e.subject,
            content: e.content,
            timestamp: now - (e.timestamp_offset || 0) * 60000,
            isRead: false
        }));

        await db.emails.bulkAdd(newEmails);
        
        document.getElementById('email-generator-modal').classList.remove('visible');
        await renderEmailList();
        await showCustomAlert("接收成功", `收到 ${newEmails.length} 封新邮件。`);

    } catch (e) {
        console.error(e);
        alert("接收失败: " + e.message);
    } finally {
        btn.textContent = originalBtnText;
        btn.disabled = false;
    }
});

// 7. 转发到聊天 (卡片版)
async function forwardEmailToChat(email) {
    // 弹出选择聊天对象的弹窗 (复用现有的)
    await openShareTargetPicker();
    
    const confirmBtn = document.getElementById('confirm-share-target-btn');
    
    // 使用 cloneNode 移除旧监听器
    const newBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
    
    newBtn.onclick = async () => {
        const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
            .map(cb => cb.dataset.chatId);

        if (selectedTargetIds.length === 0) return alert("请选择要转发到的聊天。");

        // 【核心修改】：不再拼接字符串，而是创建一个结构化消息对象
        const emailCardMsg = {
            role: 'user',
            type: 'forwarded_email', // 新增的类型
            timestamp: Date.now(),
            content: `[邮件] ${email.subject}`, // 简略文本，用于预览
            emailData: {
                subject: email.subject,
                sender: email.sender,
                date: new Date(email.timestamp).toLocaleString(),
                preview: email.content.replace(/\n/g, ' ').substring(0, 100), // 提取前100字做预览
                fullContent: email.content // 保存完整内容供点击查看
            }
        };

        // 给 AI 的系统提示 (保持不变，让 AI 理解邮件内容)
        const forwardContentForAI = `
📧 **转发邮件**
**发件人:** ${email.sender}
**收件人:** ${email.recipient || '我'}
**主题:** ${email.subject}
----------------
${email.content}
`;

        for (const targetId of selectedTargetIds) {
            const targetChat = state.chats[targetId];
            if (targetChat) {
                // 1. 推送卡片消息
                targetChat.history.push(emailCardMsg);
                
            
                const isSelfEmail = (email.sender === targetChat.name) || (email.sender === targetChat.originalName);
                
                let systemHintText = "";
                
                if (isSelfEmail) {
                    // 如果是AI自己发的，强调这是“回顾”
                    systemHintText = `[系统提示：用户把你【之前发给TA的这封邮件】转发回给你了。请注意：这封邮件是**你自己写**的，不是用户写的。用户可能是想和你讨论邮件里的内容，或者对你的邮件表示回应。请以“邮件作者”的身份进行回复。]`;
                } else {
                    // 如果是别人发的，保持原样
                    systemHintText = `[系统提示：用户转发了一封邮件给你。这封邮件是【${email.sender}】写的。请根据内容和你们的关系做出反应。]`;
                }

                // 2. 推送系统提示 (隐藏)
                targetChat.history.push({
                    role: 'system',
                    content: `${systemHintText}\n\n--- 邮件详情 ---\n${forwardContentForAI}`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                });
              
                
                await db.chats.put(targetChat);
            }
        }

        document.getElementById('share-target-modal').classList.remove('visible');
        await showCustomAlert("转发成功", "邮件已以卡片形式发送。");
        
        // 如果当前就在该聊天，刷新显示
        if (state.activeChatId && selectedTargetIds.includes(state.activeChatId)) {
             renderChatInterface(state.activeChatId);
        }
    };
}

// 搜索框事件绑定
document.getElementById('mail-search-input').addEventListener('input', renderEmailList);

// 暴露给全局
window.openEmailApp = openEmailApp;
window.openEmailSettings = openEmailSettings;      
window.handleQuickReceiveMail = handleQuickReceiveMail;
window.toggleEmailEditMode = toggleEmailEditMode;
window.closeEmailDetail = closeEmailDetail;
window.deleteCurrentEmail = deleteCurrentEmail;
// --- 新增：紧急重置外观功能 (不删除预设) ---
async function handleEmergencyAppearanceReset() {
    const confirmed = await showCustomConfirm(
        "确认重置外观？",
        "此操作将把当前的壁纸、主题、CSS、图标和字体恢复为默认状态。\n\n✅ 你的【预设库】不会被删除。\n✅ 此功能用于修复因 CSS 错误导致无法打开外观设置的问题。\n\n确定要执行吗？", 
        { confirmButtonClass: 'btn-danger', confirmText: '立即重置' }
    );

    if (!confirmed) return;

    await showCustomAlert("处理中...", "正在重置外观配置...");

    try {
        // 1. 重置内存中的 state.globalSettings 到默认值 (仅外观相关)
        // 注意：保留 API Key 等其他设置
        
        // 恢复默认图标对象
        const defaultAppIcons = { ...DEFAULT_APP_ICONS };
        const defaultCPhoneIcons = { ...DEFAULT_CPHONE_ICONS };

        state.globalSettings.wallpaper = 'linear-gradient(135deg, #89f7fe, #66a6ff)';
        state.globalSettings.cphoneWallpaper = 'linear-gradient(135deg, #f6d365, #fda085)';
        state.globalSettings.globalChatBackground = ''; // 清除全局聊天背景
        state.globalSettings.globalCss = ''; // 【核心】清空 CSS
        state.globalSettings.fontUrl = '';   // 清空字体
        state.globalSettings.theme = 'light'; // 恢复亮色模式
        state.globalSettings.appIcons = defaultAppIcons;
        state.globalSettings.cphoneAppIcons = defaultCPhoneIcons;
        
        // 恢复交互开关
        state.globalSettings.showStatusBar = false;
        state.globalSettings.showPhoneFrame = false;
        state.globalSettings.detachStatusBar = false;
        state.globalSettings.enableMinimalChatUI = false;
        state.globalSettings.alwaysShowMusicIsland = false;
        
        // 清空自定义按钮排序
        state.globalSettings.chatActionButtonsOrder = null;

        // 2. 保存到数据库
        await db.globalSettings.put(state.globalSettings);
        
        // 3. 立即应用更改 (刷新 UI)
        localStorage.setItem('ephone-theme', 'light');
        applyTheme('light');
        
        applyGlobalWallpaper();
        applyCPhoneWallpaper();
        
        applyGlobalCss(''); // 立即移除 CSS 样式
        applyCustomFont(''); // 移除字体
        
        applyAppIcons();
        applyCPhoneAppIcons();
        
        applyStatusBarVisibility();
        applyPhoneFrame(false);
        applyDetachStatusBarMode(false);
        applyMinimalChatUI(false);
        
        // 重置按钮排序
        if (typeof resetButtonOrder === 'function') {
            await resetButtonOrder(); // 这是一个现有的函数，复用它
        }

        await showCustomAlert("重置成功", "外观已恢复默认状态！\n现在你应该可以正常打开外观设置页面了。");

    } catch (error) {
        console.error("重置外观失败:", error);
        await showCustomAlert("错误", `重置失败: ${error.message}`);
    }
}
// --- 新增：恢复出厂设置 (初始化所有内容) ---
async function handleFactoryReset() {
    // --- 防误触机制 第1层：弹窗警告 ---
    const confirmed = await showCustomConfirm(
        "☠️ 严重警告：初始化应用",
        "此操作将【永久删除】本地存储的所有数据，包括：\n\n❌ 所有聊天记录和设定\n❌ 所有图片、表情包、预设\n❌ 所有API配置和外观设置\n\n应用将变回刚安装时的样子。数据一旦删除无法恢复！\n\n确定要继续吗？", 
        { 
            confirmButtonClass: 'btn-danger', 
            confirmText: '我明白，继续' 
        }
    );

    if (!confirmed) return;

    // --- 防误触机制 第2层：强制输入验证 ---
    // 要求用户手动输入特定文字，防止手滑连点
    const verificationText = "立即重置";
    const userInput = await showCustomPrompt(
        "最终确认",
        `为了确认这不是误操作，请在下方框中准确输入“${verificationText}”四个字：`,
        "",
        "text"
    );

    if (userInput !== verificationText) {
        await showCustomAlert("操作取消", "验证文字输入错误，初始化已取消。");
        return;
    }

    // --- 执行清理 ---
    await showCustomAlert("正在重置...", "正在销毁所有数据，应用即将重启...");

    try {
        // 1. 清空 IndexedDB 所有表
        // 我们不使用 db.delete() 是为了避免重连数据库的复杂性，直接清空表内容效果一样且更稳
        await db.transaction('rw', db.tables, async () => {
            for (const table of db.tables) {
                console.log(`正在清空表: ${table.name}`);
                await table.clear();
            }
        });

        // 2. 清空 LocalStorage (包括主题、语言、未读计数、临时缓存等)
        localStorage.clear();

        // 3. 强制刷新页面
        // 延迟一下让用户看到提示，然后刷新重载整个应用
        setTimeout(() => {
            window.location.reload(true);
        }, 1000);

    } catch (error) {
        console.error("初始化失败:", error);
        await showCustomAlert("错误", `重置过程中发生错误: ${error.message}\n请尝试手动清除浏览器缓存。`);
    }
}
// --- 新增：简易图片放大查看器 (独立于相册) ---
function openSimpleImageZoom(src) {
    // 1. 检查页面上是否已经有这个遮罩层，没有就创建
    let overlay = document.getElementById('simple-image-zoom-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'simple-image-zoom-overlay';
        overlay.innerHTML = '<img src="" alt="Zoomed Image">';
        
        // 点击遮罩层任意位置关闭
        overlay.addEventListener('click', () => {
            overlay.classList.remove('visible');
            setTimeout(() => { overlay.style.display = 'none'; }, 250);
        });
        
        document.body.appendChild(overlay);
    }

    // 2. 设置图片并显示
    const img = overlay.querySelector('img');
    img.src = src;
    
    overlay.style.display = 'flex';
    // 强制重绘以触发 transition
    void overlay.offsetWidth; 
    overlay.classList.add('visible');
}
// --- Reddit 功能模块 ---

async function handleRedditSearch(query = '') {
    const listEl = document.getElementById('char-reddit-list');
    listEl.innerHTML = '<div class="spinner"></div>'; // 加载中

    let targetUrl;
    if (query === 'popular' || !query) {
        targetUrl = `https://www.reddit.com/r/popular.json?limit=30&raw_json=1`;
    } else {
        targetUrl = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=30&raw_json=1&sort=relevance`;
    }

    // 使用 CORS 代理绕过跨域限制
    const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error("网络请求失败");
        
        const json = await response.json();
        const posts = json.data.children;
        
        renderRedditList(posts);
    } catch (error) {
        console.error("Reddit API Error:", error);
        listEl.innerHTML = '<p style="text-align:center; padding:20px; color:#999;">无法连接到 Reddit，请检查网络或代理。</p>';
    }
}
// [Modify] openRedditDetail to handle cross-screen navigation
async function openRedditDetail(post) {
    // 1. Detect if we are opening from the Chat Interface
    const isFromChat = document.getElementById('chat-interface-screen').classList.contains('active');

    const titleEl = document.getElementById('char-article-title');
    const contentEl = document.getElementById('char-article-content');
    const backBtn = document.querySelector('#char-browser-article-screen .back-btn');
    
    // Header actions setup
    let headerActions = document.querySelector('#char-browser-article-screen .header .header-actions');
    if (!headerActions) {
        const header = document.querySelector('#char-browser-article-screen .header');
        headerActions = document.createElement('div');
        headerActions.className = 'header-actions';
        header.appendChild(headerActions);
    }

    // UI Loading State
    titleEl.textContent = "加载中...";
    contentEl.innerHTML = '<div class="spinner" style="margin-top:50px;"></div>';
    
    // 2. Critical Fix: Switch Main Screen if coming from Chat
    if (isFromChat) {
        showScreen('character-phone-screen');
    }
    
    // Switch Sub-screen
    switchToCharScreen('char-browser-article-screen');

    // 3. Configure Back Button based on source
    const newBackBtn = backBtn.cloneNode(true);
    backBtn.parentNode.replaceChild(newBackBtn, backBtn);
    newBackBtn.onclick = () => {
        if (isFromChat) {
            // If from chat, go back to chat
            showScreen('chat-interface-screen');
        } else {
            // If from app list, go back to app list
            switchToCharScreen('char-reddit-screen');
        }
    };
    
    // 4. Setup Forward Button
    headerActions.innerHTML = '';
    const forwardBtn = document.createElement('span');
    forwardBtn.className = 'action-btn';
    forwardBtn.innerHTML = `
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"></line>
            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>`;
    forwardBtn.title = "转发给TA";
    headerActions.appendChild(forwardBtn);

    // 5. Handle Inner Links
    contentEl.onclick = async (e) => {
        const link = e.target.closest('a.reddit-inner-link');
        if (link) {
            e.preventDefault();
            const href = link.href;
            const redditMatch = href.match(/reddit\.com\/r\/[^\/]+\/comments\/([a-zA-Z0-9]+)/);
            if (redditMatch) {
                const urlObj = new URL(href);
                const permalink = urlObj.pathname; 
                // Recursively open, preserving context logic is tricky, so we treat inner links as internal nav
                await openRedditDetail({ permalink: permalink });
            } else {
                window.open(href, '_blank');
            }
        }
    };

    try {
        // 6. Fetch Data
        const permalink = post.permalink;
        if (!permalink) throw new Error("无效的帖子链接");

        const targetUrl = `https://www.reddit.com${permalink}.json?raw_json=1`;
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
        
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error("无法加载帖子详情");

        const json = await response.json();
        const fullPostData = json[0].data.children[0].data;
        const commentsData = json[1].data.children;
        
        // Forward Logic Data Object
        const postObjForForward = {
            id: fullPostData.id,
            title: fullPostData.title,
            subreddit_name_prefixed: fullPostData.subreddit_name_prefixed,
            author: fullPostData.author,
            score: fullPostData.score,
            num_comments: fullPostData.num_comments,
            permalink: fullPostData.permalink,
            selftext: fullPostData.selftext || '',
            thumbnail: (fullPostData.preview && fullPostData.preview.images[0]) ? fullPostData.preview.images[0].source.url.replace(/&amp;/g, '&') : (fullPostData.thumbnail && fullPostData.thumbnail.startsWith('http') ? fullPostData.thumbnail : null),
            url: fullPostData.url
        };
        
        forwardBtn.onclick = () => {
            forwardRedditPost(null, postObjForForward); 
        };

        // Render Title
        titleEl.textContent = fullPostData.subreddit_name_prefixed;

        let htmlContent = '';

        // A. Header
        htmlContent += `
            <div style="margin-bottom: 15px;">
                <h2 style="font-size: 20px; font-weight: bold; margin: 0 0 8px 0;">${escapeHTML(fullPostData.title)}</h2>
                <div style="color: #888; font-size: 12px;">
                    u/${fullPostData.author} • ${new Date(fullPostData.created_utc * 1000).toLocaleString()}
                </div>
            </div>
        `;

        // B. Media
        const ytMatch = fullPostData.url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/|youtube\.com\/shorts\/)([^"&?\/\s]{11})/);
        
        if (ytMatch) {
            const videoId = ytMatch[1];
            htmlContent += `
                <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px; margin-bottom: 10px; background: #000;">
                    <iframe src="https://www.youtube-nocookie.com/embed/${videoId}?rel=0&modestbranding=1&playsinline=1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" frameborder="0" allowfullscreen></iframe>
                </div>`;
        } else if (fullPostData.is_video && fullPostData.media && fullPostData.media.reddit_video) {
            htmlContent += `
    <video controls playsinline poster="${fullPostData.thumbnail}" style="width: 100%; border-radius: 8px; margin-bottom: 5px; background: #000;">
        <source src="${fullPostData.media.reddit_video.fallback_url}" type="video/mp4">
    </video>
    <div style="font-size:12px; color:#999; margin-bottom:15px;">
        ⚠️ 注：Reddit原生视频可能无声，<a href="${fullPostData.url}" target="_blank" style="color:#007aff;">点击此处跳转原网页观看</a>
    </div>`;
        } else if (fullPostData.url && fullPostData.url.match(/\.(jpg|jpeg|png|gif)$/i)) {
            htmlContent += `<img src="${fullPostData.url}" style="width:100%; border-radius:8px; margin-bottom:15px;">`;
        } else if (fullPostData.preview && fullPostData.preview.images && fullPostData.preview.images.length > 0) {
            const imgUrl = fullPostData.preview.images[0].source.url.replace(/&amp;/g, '&');
            htmlContent += `<img src="${imgUrl}" style="width:100%; border-radius:8px; margin-bottom:15px;">`;
        }

        // C. Text
        if (fullPostData.selftext) {
            let processedText = escapeHTML(fullPostData.selftext);
            processedText = processedText.replace(/\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g, '<a href="$2" class="reddit-inner-link" style="color:#007aff; text-decoration:none;">$1</a>');
            processedText = processedText.replace(/(^|\s)(https?:\/\/[^\s<]+)/g, '$1<a href="$2" class="reddit-inner-link" style="color:#007aff; text-decoration:none;">🔗 Link</a>');
            processedText = processedText.replace(/\n/g, '<br>');
            htmlContent += `<div style="line-height:1.6; font-size:15px; color:#333; margin-bottom:20px; word-break: break-word;">${processedText}</div>`;
        } 

        // D. Data Bar
        const score = fullPostData.score > 1000 ? (fullPostData.score/1000).toFixed(1) + 'k' : fullPostData.score;
        htmlContent += `
            <div style="display:flex; gap:20px; padding:10px 0; border-top:1px solid #eee; border-bottom:1px solid #eee; margin-bottom:15px; font-size:13px; color:#555; align-items:center;">
                <span style="display:flex; align-items:center; gap:4px;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:#ff4500;">
                        <path d="M12 19V5M5 12l7-7 7 7"/>
                    </svg> 
                    ${score} 赞
                </span>
                <span style="display:flex; align-items:center; gap:4px;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                    </svg>
                    ${fullPostData.num_comments} 评论
                </span>
            </div>
        `;

        // E. Comments
        htmlContent += `<div style="font-weight:bold; margin-bottom:10px;">评论</div>`;
        if (commentsData.length === 0) {
            htmlContent += `<div style="text-align:center; color:#999; padding:20px;">暂无评论</div>`;
        } else {
            commentsData.forEach(child => {
                const c = child.data;
                if (!c.body) return;
                htmlContent += `
                    <div class="reddit-comment-item" style="margin-bottom:15px; padding-bottom:15px; border-bottom:1px solid #f9f9f9;">
                        <div style="font-size:12px; color:#888; margin-bottom:4px; display:flex; justify-content:space-between;">
                            <span style="color: #1c1c1e; font-weight: 500;">${c.author}</span>
                            <span>${c.score} pts</span>
                        </div>
                        <div style="font-size:14px; line-height:1.5; color:#333;">${escapeHTML(c.body).replace(/\n/g, '<br>')}</div>
                    </div>
                `;
            });
        }

        contentEl.innerHTML = htmlContent;
        contentEl.scrollTop = 0;

    } catch (error) {
        console.error("Reddit Detail Error:", error);
        contentEl.innerHTML = `
            <div style="padding:20px; text-align:center;">
                <h3>加载失败</h3>
                <p style="color:#888; font-size:14px;">${error.message}</p>
            </div>
        `;
    }
}
function renderRedditList(posts) {
    const listEl = document.getElementById('char-reddit-list');
    listEl.innerHTML = '';

    if (!posts || posts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; padding:20px; color:#999;">未找到内容</p>';
        return;
    }

    posts.forEach(child => {
        const post = child.data;
        
        // 图片提取逻辑
        let previewImage = '';
        if (post.preview && post.preview.images && post.preview.images.length > 0) {
            previewImage = post.preview.images[0].source.url.replace(/&amp;/g, '&');
        } else if (post.thumbnail && post.thumbnail.startsWith('http')) {
            previewImage = post.thumbnail;
        }

        const item = document.createElement('div');
        item.className = 'reddit-post-item';
        
        // 分数显示优化
        const score = post.score > 1000 ? (post.score/1000).toFixed(1) + 'k' : post.score;

        item.innerHTML = `
            <div class="reddit-vote-box">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: #ff4500;">
                    <path d="M12 19V5M5 12l7-7 7 7"/>
                </svg>
                <span style="font-weight:bold; margin-top:2px;">${score}</span>
            </div>
            <div class="reddit-content-box">
                <div class="reddit-meta">
                    <div class="reddit-sub-icon"></div>
                    <strong>${post.subreddit_name_prefixed}</strong>
                    <span>• u/${post.author}</span>
                </div>
                <div class="reddit-title">${post.title}</div>
                ${previewImage ? `<img src="${previewImage}" class="reddit-preview-img" loading="lazy">` : ''}
                
                <button class="reddit-forward-btn">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    转发给TA
                </button>
            </div>
        `;
        
        // 缓存数据以便转发使用
        if (!window.redditPostCache) window.redditPostCache = new Map();
        window.redditPostCache.set(post.id, post);

        // --- 【关键修改 1】点击卡片整体 -> 打开详情页 ---
        item.addEventListener('click', () => {
            openRedditDetail(post);
        });

        // --- 【关键修改 2】点击转发按钮 -> 触发转发 (并阻止冒泡) ---
        const forwardBtn = item.querySelector('.reddit-forward-btn');
        forwardBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // 阻止触发详情页跳转
            forwardRedditPost(post.id); // 直接调用函数
        });

        listEl.appendChild(item);
    });
}

// [修改] 转发 Reddit 帖子 (支持选人 + 不立即回复)
// 参数: postId (从列表点击时传入), directData (从详情页点击时直接传入数据对象)
async function forwardRedditPost(postId, directData = null) {
    // 1. 获取帖子数据
    let post;
    if (directData) {
        post = directData;
    } else {
        // 列表模式：从缓存获取
        if (!window.redditPostCache) window.redditPostCache = new Map();
        post = window.redditPostCache.get(postId);
    }

    if (!post) {
        alert("无法获取帖子数据");
        return;
    }

    // 2. 弹出选择器 (复用现有的 Share Picker)
    await openShareTargetPicker();
    
    const confirmBtn = document.getElementById('confirm-share-target-btn');
    
    // 使用 cloneNode 移除旧监听器，防止重复绑定
    const newBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newBtn, confirmBtn);
    
    newBtn.onclick = async () => {
        // 3. 获取选中的聊天对象
        const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
            .map(cb => cb.dataset.chatId);

        if (selectedTargetIds.length === 0) return alert("请选择要转发到的聊天。");

        // 4. 构造用户卡片消息 (User View)
        const redditMsg = {
            role: 'user',
            type: 'reddit_share',
            timestamp: Date.now(),
            redditData: {
                title: post.title,
                subreddit: post.subreddit_name_prefixed,
                author: post.author,
                score: post.score,
                num_comments: post.num_comments,
                permalink: post.permalink,
                // 处理图片链接
                image: post.thumbnail || (post.preview && post.preview.images[0] ? post.preview.images[0].source.url.replace(/&amp;/g, '&') : null),
                selftext: post.selftext ? post.selftext.substring(0, 150) + '...' : ''
            }
        };
        
        document.getElementById('share-target-modal').classList.remove('visible');
        
        // 5. 后台抓取完整内容 (给 AI 看) - 这部分需要一点时间
        // 为了体验，先显示"正在发送"，实际上是后台异步处理
        await showCustomAlert("转发中...", "正在生成预览并发送，请稍候...");
        
        // 构建 AI 上下文
        let fullContextForAI = `标题: "${post.title}"\n来自: ${post.subreddit_name_prefixed}\n`;
        if (post.selftext) {
             fullContextForAI += `\n[内容摘要]: ${post.selftext.substring(0, 500)}...\n`;
        }
        
        // 尝试异步获取更多详情 (可选)
        try {
            const targetUrl = `https://www.reddit.com${post.permalink}.json?raw_json=1`;
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
            const res = await fetch(proxyUrl);
            if (res.ok) {
                const json = await res.json();
                const comments = json[1].data.children;
                // 补充前3条热评
                if (comments.length > 0) {
                    fullContextForAI += `\n[热门评论 (Top 3)]:\n`;
                    comments.slice(0, 3).forEach((c, i) => {
                        if (c.data.body) {
                            fullContextForAI += `${i+1}. ${c.data.author}: ${c.data.body.substring(0, 150)}\n`;
                        }
                    });
                }
            }
        } catch (e) {
            console.warn("抓取详情失败，仅使用基本信息", e);
        }

        // 6. 循环发送给选中的聊天
        for (const targetId of selectedTargetIds) {
            const targetChat = state.chats[targetId];
            if (targetChat) {
                // A. 推送卡片消息
                targetChat.history.push(redditMsg);
                
                // B. 推送系统提示 (隐藏消息，给AI看)
                const hiddenSystemMsg = {
                    role: 'system',
                    content: `[系统提示：用户转发了一个 Reddit 帖子给你。
请你阅读以下帖子详情和网友评论。
注意：**用户还没有对此发表看法**，TA可能正在打字。请你**先不要回复**，耐心等待用户接下来的消息。
---
${fullContextForAI}
---]`,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                targetChat.history.push(hiddenSystemMsg);
                await db.chats.put(targetChat);
            }
        }

        // 7. 跳转逻辑
        // 隐藏提示框
        document.querySelector('#custom-modal-overlay').classList.remove('visible');
        
        // 如果只选了一个人，直接跳转到那个人的聊天窗口
        if (selectedTargetIds.length === 1) {
            const targetId = selectedTargetIds[0];
            showScreen('chat-interface-screen'); // 切到聊天界面容器
            openChat(targetId); // 加载具体聊天
            
            // 【核心修改】：这里不再调用 triggerAiResponse()
            // 并且让输入框获得焦点，方便用户继续说话
            setTimeout(() => {
                const input = document.getElementById('chat-input');
                if (input) input.focus();
            }, 500);
            
        } else {
            // 如果选了多个人，提示发送成功并停留在当前页或回列表
            alert(`已转发给 ${selectedTargetIds.length} 位好友。`);
        }
    };
}
window.forwardRedditPost = forwardRedditPost;
// --- [更新版] 根据人设生成 Reddit 推荐流 (支持15-20个关键词 + 稳定搜索) ---
async function handleGenerateSimulatedReddit() {
    if (!activeCharacterId) return;
    const chat = state.chats[activeCharacterId];
    if (!chat) return;

    await showCustomAlert("请稍候...", `正在深度分析“${chat.name}”的兴趣网络...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好API信息。');
        return;
    }

    // 1. 准备上下文数据
    const userDisplayNameForAI = (state.qzoneSettings.nickname === '{{user}}' || !state.qzoneSettings.nickname) ? '用户' : state.qzoneSettings.nickname;
    
    const maxMemory = chat.settings.maxMemory || 10;
    const recentHistory_RAW = chat.history.slice(-maxMemory);
    // 确保 filterHistoryWithDoNotSendRules 可用，如果报错请检查该函数是否定义
    const filteredHistory = await filterHistoryWithDoNotSendRules(recentHistory_RAW, activeCharacterId);
    const recentHistoryWithUser = filteredHistory.map(msg => `${msg.role === 'user' ? userDisplayNameForAI : chat.name}: ${String(msg.content).substring(0, 30)}...`).join('\n');
    
    const longTermMemoryContext = chat.longTermMemory && chat.longTermMemory.length > 0 ?
      chat.longTermMemory.map(mem => `- ${mem.content}`).join('\n') : '无';

    const worldBookContext = (chat.settings.linkedWorldBookIds || [])
      .map(bookId => state.worldBooks.find(wb => wb.id === bookId))
      .filter(Boolean)
      .map(book => `\n## 世界书《${book.name}》:\n${book.content.filter(e => e.enabled).map(e => `- ${e.content}`).join('\n')}`)
      .join('');

    // 2. 构建 Prompt (修改了数量要求)
    const systemPrompt = `
# 你的任务
你是一个虚拟用户画像分析师。你的任务是扮演角色“${chat.name}”，根据TA的人设、所处的世界观、长期记忆、以及与用户（${userDisplayNameForAI}）的最近互动，**推测TA现在最可能在 Reddit 上浏览或搜索的关键词**。

# 核心规则
1.  **语言策略**: 
    - 请根据角色的人设和想看的内容决定语言。
    - 如果角色想看国际新闻、技术文档、迷因 (Memes) 或特定外语内容，请生成【英文】关键词。
    - 如果角色想看中文圈的讨论、华语新闻或特定中文话题，请生成【中文】关键词。
2.  **深度人设绑定**: 关键词必须紧扣角色的性格、职业、爱好以及**世界观设定**。
3.  **多样性与数量 (关键)**: 请生成 **15到20个** 不同的关键词，涵盖角色兴趣的各个方面（从核心爱好到潜意识的好奇）。
4.  **格式铁律**: 
    - 你的回复【必须且只能】是一个JSON数组格式的字符串。
    - 数组中的每个元素都是一个**字符串**。
    - 示例: \`["keyword1", "r/China_irl", "coding help", "猫咪", ...]\`

# 供你参考的详细上下文
- **角色人设**: ${chat.settings.aiPersona}
- **用户(${userDisplayNameForAI})的人设**: ${chat.settings.myPersona || '无'}
- **长期记忆**: 
${longTermMemoryContext}
${worldBookContext} 
- **最近对话**:
${recentHistoryWithUser}

现在，请生成这组详细的 Reddit 搜索关键词。`;

    try {
        // 3. 调用 LLM
        const messagesForApi = [{ role: 'user', content: "请生成Reddit关键词列表。" }];
        let isGemini = proxyUrl.includes('generativelanguage');
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi);

        const response = isGemini ?
            await fetch(geminiConfig.url, geminiConfig.data) :
            await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                    // 使用全局设置的温度，如果没有则默认 1.0
                    temperature: state.globalSettings.apiTemperature || 1.0, 
                })
            });

        if (!response.ok) throw new Error(`API 错误: ${response.statusText}`);

        const data = await response.json();
        const aiResponseContent = getGeminiResponseText(data);
        const cleanedJson = aiResponseContent.replace(/^```json\s*/, '').replace(/```$/, '');
        
        let keywords;
        try {
            keywords = JSON.parse(cleanedJson);
        } catch (e) {
            throw new Error("AI返回格式错误，无法解析JSON");
        }

        if (!Array.isArray(keywords) || keywords.length === 0) throw new Error("AI没有返回有效的关键词数组。");

        // 4. [核心修改] 逐个搜索关键词 (串行+延迟，防止封号)
        await showCustomAlert("搜索中...", `AI 生成了 ${keywords.length} 个兴趣关键词，正在聚合全网内容... (这一步可能需要十几秒，请耐心等待)`);
        
        const listEl = document.getElementById('char-reddit-list');
        listEl.innerHTML = '<div class="spinner" style="margin-top:50px;"></div>';

        // 不再截取 slice(0, 4)，使用全部关键词 (keywords)
        const queries = keywords; 
        let aggregatedPosts = [];

        // 定义延时函数
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // 定义单个搜索函数
        const fetchRedditData = async (query) => {
            try {
                let targetUrl;
                // 针对 r/xxx 优化
                if (query.startsWith('r/')) {
                    // limit=5, 稍微减少单次请求量，因为我们总请求次数变多了
                    targetUrl = `https://www.reddit.com/${query}/hot.json?limit=5&raw_json=1`;
                } else {
                    targetUrl = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=5&raw_json=1&sort=relevance`;
                }
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;
                
                const res = await fetch(proxyUrl);
                if(!res.ok) return [];
                const json = await res.json();
                return json.data.children; 
            } catch (e) {
                console.warn(`搜索关键词 ${query} 失败:`, e);
                return [];
            }
        };

        // [修改] 使用 for...of 循环串行请求，而不是 Promise.all 并行
        // 这样虽然慢一点，但能保证 20 个词都能搜完而不炸接口
        for (const [index, query] of queries.entries()) {
            // 在控制台打印进度，方便调试
            console.log(`[Reddit生成流] 正在搜索 (${index + 1}/${queries.length}): ${query}`);
            
            const posts = await fetchRedditData(query);
            if (posts && posts.length > 0) {
                aggregatedPosts.push(...posts);
            }
            
            // 每次请求间隔 600ms
            await delay(600);
        }

        if (aggregatedPosts.length === 0) {
            throw new Error("所有关键词都未能搜索到内容，可能是网络问题或关键词太偏门。");
        }

        // 5. 去重与打乱 (洗牌算法)
        const uniquePosts = [];
        const seenIds = new Set();
        
        // 洗牌
        for (let i = aggregatedPosts.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [aggregatedPosts[i], aggregatedPosts[j]] = [aggregatedPosts[j], aggregatedPosts[i]];
        }

        // 去重
        aggregatedPosts.forEach(item => {
            const post = item.data;
            if (!seenIds.has(post.id)) {
                seenIds.add(post.id);
                uniquePosts.push(item);
            }
        });

        // 截取前 30 条显示 (呼应你之前的需求)
        const finalFeed = uniquePosts.slice(0, 30);

        // 6. 保存数据到数据库 (持久化)
        chat.simulatedRedditFeed = finalFeed; 
        await db.chats.put(chat);             
        console.log(`Reddit 推荐流已保存，共 ${finalFeed.length} 条`);

        // 7. 渲染
        renderRedditList(finalFeed);
        
        // 更新弹窗提示完成
        // (showCustomAlert 默认有确认按钮，为了体验可以不弹新的，或者自动关闭旧的)
        // 这里我们直接让界面显示出来即可

    } catch (error) {
        console.error("生成 Reddit 推荐失败:", error);
        await showCustomAlert("生成失败", `无法生成推荐内容。\n错误: ${error.message}`);
        // 失败时回退到热门
        handleRedditSearch('popular');
    }
}
  async function init() {

    initLanguage();
 
    async function handleWorldBookImport(file) {
      if (!file) return;

      try {
        const text = await file.text();
        const data = JSON.parse(text);

        if (data.type === 'EPhoneWorldBookBackup') {

          console.log("检测到 EPhone 备份文件，执行标准导入...");
          await importWorldBooks(data);
        } else if (data.entries && typeof data.entries === 'object') {

          console.log("检测到 世界书文件，需要激活码...");


          try {
            
            await requirePinActivation();

           
            await importTavernWorldBook(data, file.name);

          } catch (error) {
           
            console.warn("世界书导入被取消:", error.message);
          }


        } else {
          throw new Error("文件格式无法识别。请确保您选择的是有效的 EPhone 世界书备份或 Tavern AI 世界书文件。");
        }

      } catch (error) {
        console.error("导入世界书时出错:", error);
        await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
      }
    }

 
    async function importTavernWorldBook(tavernData, fileName) {
      const bookNameSuggestion = fileName.replace(/\.json$/i, '');

      const newBookName = await showCustomPrompt(
        "导入 Tavern AI 世界书",
        "请为这本设定集命名：",
        bookNameSuggestion
      );

      if (!newBookName || !newBookName.trim()) {
        alert("导入已取消，因为未提供书名。");
        return;
      }

      const newEntries = Object.values(tavernData.entries).map(entry => {

        return {
          keys: entry.key || [],
          comment: entry.comment || '无备注',
          content: entry.content || '',
          enabled: !entry.disable
        };
      }).filter(entry => entry.content);

      if (newEntries.length === 0) {
        alert("这个 Tavern AI 世界书中没有找到任何有效的条目。");
        return;
      }

      const newWorldBook = {
        id: 'wb_' + Date.now(),
        name: newBookName.trim(),
        content: newEntries,
        categoryId: null
      };

      await db.worldBooks.add(newWorldBook);
      state.worldBooks.push(newWorldBook);
      await renderWorldBookScreen();

      await showCustomAlert('导入成功！', `已成功从 Tavern AI 文件导入设定集《${newBookName}》。`);
    }


    async function exportWorldBooks() {
      try {
        const books = await db.worldBooks.toArray();
        const categories = await db.worldBookCategories.toArray();

        if (books.length === 0 && categories.length === 0) {
          alert("没有可导出的世界书数据。");
          return;
        }

        const backupData = {
          type: 'EPhoneWorldBookBackup',
          version: 1,
          timestamp: Date.now(),
          books: books,
          categories: categories
        };

        const blob = new Blob(
          [JSON.stringify(backupData, null, 2)], {
            type: 'application/json'
          }
        );
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `EPhone-WorldBooks-${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);

        await showCustomAlert('导出成功', '所有世界书数据已成功导出！');

      } catch (error) {
        console.error("导出世界书时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
      }
    }


    async function importWorldBooks(data) {

      try {
        if (data.type !== 'EPhoneWorldBookBackup' || !data.books) {
          throw new Error("文件格式不正确，这不是一个有效的世界书备份文件。");
        }

        const confirmed = await showCustomConfirm(
          '导入世界书',
          '这将用文件中的数据【完全覆盖】您当前所有的世界书和分类。此操作不可撤销！', {
            confirmButtonClass: 'btn-danger',
            confirmText: '确认覆盖'
          }
        );

        if (!confirmed) return;

        await db.transaction('rw', db.worldBooks, db.worldBookCategories, async () => {
          await db.worldBooks.clear();
          await db.worldBookCategories.clear();

          if (Array.isArray(data.books)) {
            await db.worldBooks.bulkPut(data.books);
          }
          if (Array.isArray(data.categories)) {
            await db.worldBookCategories.bulkPut(data.categories);
          }
        });


        state.worldBooks = await db.worldBooks.toArray();
        await renderWorldBookScreen();

        await showCustomAlert('导入成功', '世界书数据已成功恢复！');

      } catch (error) {
        console.error("导入世界书时出错:", error);
        await showCustomAlert('导入失败', `文件解析或应用失败: ${error.message}`);
      }
    }



    const lastActiveTimestamp = localStorage.getItem('ephoneLastActiveTimestamp');
    if (lastActiveTimestamp) {
      const minutesOffline = (Date.now() - parseInt(lastActiveTimestamp)) / (1000 * 60);

      if (minutesOffline > 5) {


        simulateBackgroundActivity(minutesOffline);
      }
    }

    setupCharPlayerControls();

    window.showScreen = showScreen;
    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.handleListenTogetherClick = handleListenTogetherClick;

    window.openCharacterSelector = openCharacterSelector;
    window.openCharApp = openCharApp;
    window.switchToMyPhone = switchToMyPhone;
    window.openCharWallet = openCharWallet;
    window.switchToCharHomeScreen = switchToCharHomeScreen;
    window.openNpcEditor = openNpcEditor;
    window.openMyPhone = openMyPhone;
    window.openMyApp = openMyApp;
    window.switchToMyHomeScreen = switchToMyHomeScreen;
    window.switchToMyScreen = switchToMyScreen;

  // ========== MyPhone 相关函数 ==========
  
  function openMyPhone() {
    console.log("打开 MyPhone");
    showScreen('my-phone-screen');
    switchToMyHomeScreen();
  }
  
  function switchToMyHomeScreen() {
    switchToMyScreen('my-home-screen');
  }
  
  function switchToMyScreen(screenId) {
    document.querySelectorAll('#my-phone-screen .char-screen').forEach(s => s.classList.remove('active'));
    const targetScreen = document.getElementById(screenId);
    if (targetScreen) {
      targetScreen.classList.add('active');
    }
  }
  
  async function openMyApp(appName) {
    console.log(`打开 MyPhone 应用: ${appName}`);
    
    // 这里复用CPhone的逻辑，但使用my-前缀的元素ID
    switch(appName) {
      case 'qq':
        switchToMyScreen('my-qq-screen');
        // 可以在这里添加加载QQ数据的逻辑
        break;
      case 'album':
        switchToMyScreen('my-album-screen');
        // 可以在这里添加加载相册数据的逻辑
        break;
      case 'browser':
        switchToMyScreen('my-browser-screen');
        // 可以在这里添加加载浏览器历史的逻辑
        break;
      case 'taobao':
        switchToMyScreen('my-taobao-screen');
        // 可以在这里添加加载淘宝订单的逻辑
        break;
      case 'memo':
        switchToMyScreen('my-memo-screen');
        // 可以在这里添加加载备忘录的逻辑
        break;
      case 'diary':
        switchToMyScreen('my-diary-screen');
        // 可以在这里添加加载日记的逻辑
        break;
      case 'amap':
        switchToMyScreen('my-amap-screen');
        // 可以在这里添加加载地图足迹的逻辑
        break;
      case 'usage':
        switchToMyScreen('my-usage-screen');
        // 可以在这里添加加载APP使用记录的逻辑
        break;
      case 'music':
        switchToMyScreen('my-music-screen');
        // 可以在这里添加加载音乐歌单的逻辑
        break;
      case 'bilibili':
        switchToMyScreen('my-bilibili-screen');
        // 可以在这里添加加载B站推荐的逻辑
        break;
      case 'reddit':
        switchToMyScreen('my-reddit-screen');
        // 可以在这里添加加载Reddit内容的逻辑
        break;
      default:
        console.log(`未知的应用: ${appName}`);
    }
  }



    const stickerActionBar = document.createElement('div');
    stickerActionBar.id = 'sticker-action-bar';
    stickerActionBar.innerHTML = `
       <input type="checkbox" id="select-all-stickers-checkbox" style="margin-right: 10px;">
      <button id="delete-selected-stickers-btn" class="form-button-secondary">删除 (0)</button>
   `;
    document.getElementById('sticker-panel').appendChild(stickerActionBar);
   const exportStickersBtn = document.createElement('button');
   exportStickersBtn.id = 'export-selected-stickers-btn';
   exportStickersBtn.textContent = '导出 (0)';
   exportStickersBtn.className = 'form-button'; // 使用主按钮样式
   exportStickersBtn.style.marginLeft = '10px';
   
   stickerActionBar.appendChild(exportStickersBtn);
   
   exportStickersBtn.addEventListener('click', executeBatchExportStickers);
    const globalCssStyleTag = document.createElement('style');
    globalCssStyleTag.id = 'global-custom-style';
    document.head.appendChild(globalCssStyleTag);


    qzoneStickerPanelState.panelEl = document.getElementById('qzone-sticker-panel');
    qzoneStickerPanelState.gridEl = document.getElementById('qzone-sticker-grid');

    const savedTheme = localStorage.getItem('ephone-theme') || 'light';
    applyTheme(savedTheme);



    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);



    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);




    applyScopedCss('', '#chat-messages', 'custom-bubble-style');
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style');

    window.openRenderingRulesScreen = openRenderingRulesScreen;
    window.showScreen = showScreen;
    window.renderChatListProxy = renderChatList;
    window.renderApiSettingsProxy = renderApiSettings;
    window.renderWallpaperScreenProxy = renderWallpaperScreen;
    window.renderWorldBookScreenProxy = renderWorldBookScreen;

    await loadAllDataFromDB();
    await initFunds();
    applyStatusBarVisibility();
    applyPhoneFrame(state.globalSettings.showPhoneFrame);
    applyDetachStatusBarMode(state.globalSettings.detachStatusBar);
    applyMinimalChatUI(state.globalSettings.enableMinimalChatUI);
    await migrateOldRedPacketData();


    applyGlobalCss(state.globalSettings.globalCss);



    const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
    updateUnreadIndicator(storedCount);



    if (state.globalSettings && state.globalSettings.fontUrl) {
      applyCustomFont(state.globalSettings.fontUrl);
    }

    updateClock();
    setInterval(updateClock, 1000 * 30);
    applyGlobalWallpaper();
    initBatteryManager();

    applyAppIcons();
    applyWidgetData();





    document.getElementById('rules-tabs').addEventListener('click', (e) => {
      if (e.target.classList.contains('rules-tab')) {
        switchRuleCategory(e.target.dataset.categoryId);
      }
    });



    document.getElementById('add-new-rule-btn').addEventListener('click', () => openRuleEditor(null));
    document.getElementById('cancel-rule-editor-btn').addEventListener('click', () => {
      document.getElementById('rule-editor-modal').classList.remove('visible');
    });
    document.getElementById('save-rule-btn').addEventListener('click', saveRenderingRule);



    document.getElementById('pat-btn').addEventListener('click', async () => {

      if (state.activeChatId && !state.chats[state.activeChatId].isGroup) {
        const chat = state.chats[state.activeChatId];

        // 弹出选择框：拍自己还是拍对方
        const choice = await showChoiceModal('拍一拍', [
          { text: '拍对方', value: 'pat_other' },
          { text: '拍自己', value: 'pat_self' }
        ]);

        if (choice === 'pat_other') {
          handleUserPat(chat.id, chat.originalName);
        } else if (choice === 'pat_self') {
          handleUserPatSelf(chat.id);
        }
      }
    });


    let activeAnnouncementId = null;

 
    function showAnnouncementActions(annoId) {
      activeAnnouncementId = annoId;
      const chat = state.chats[state.activeChatId];
      const announcement = chat.announcements.find(a => a.id === annoId);
      if (!announcement) return;

      const pinButton = document.getElementById('announcement-action-pin');

      pinButton.textContent = announcement.isPinned ? '取消置顶' : '置顶公告';

      document.getElementById('announcement-actions-modal').classList.add('visible');
    }

 
    async function handlePinAnnouncement() {
      if (!activeAnnouncementId) return;
      const chat = state.chats[state.activeChatId];
      const announcement = chat.announcements.find(a => a.id === activeAnnouncementId);
      if (announcement) {
        announcement.isPinned = !announcement.isPinned;
        await db.chats.put(chat);
        showAnnouncementBoard();
      }
      document.getElementById('announcement-actions-modal').classList.remove('visible');
    }

  
    async function handleDeleteAnnouncement() {
      if (!activeAnnouncementId) return;

      const confirmed = await showCustomConfirm("确认删除", "确定要删除这条公告吗？此操作不可恢复。", {
        confirmButtonClass: 'btn-danger'
      });

      if (confirmed) {
        const chat = state.chats[state.activeChatId];

        chat.announcements = chat.announcements.filter(a => a.id !== activeAnnouncementId);
        await db.chats.put(chat);
        showAnnouncementBoard();
      }
      document.getElementById('announcement-actions-modal').classList.remove('visible');
    }

    document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
    document.getElementById('custom-modal-overlay').addEventListener('click', (e) => {
      if (e.target === modalOverlay) hideCustomModal();
    });
    document.getElementById('export-data-btn').addEventListener('click', async () => {

      const choice = await showChoiceModal('选择导出方式', [{
          text: '分片导出 (推荐，打包为ZIP，解压每个切片选择增量导入)',
          value: 'slice'
        },
        {
          text: '智能导出 (单个大文件，太大可能会导致导入不了)',
          value: 'stream'
        },
        {
          text: '传统导出 (兼容旧版或内存小的浏览器)',
          value: 'blob'
        }
      ]);


      if (choice === 'slice') {
        exportDataAsSlicedZip();
      } else if (choice === 'stream') {
        exportDataAsStream();
      } else if (choice === 'blob') {
        exportDataAsBlob();
      }

    });



    document.getElementById('cleanup-data-btn').addEventListener('click', cleanupRedundantData);

    document.getElementById('offline-mode-toggle').addEventListener('change', (e) => {

      document.getElementById('offline-mode-options').style.display = e.target.checked ? 'block' : 'none';
    });
    document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
    document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
      document.getElementById('time-zone-group').style.display = e.target.checked ? 'block' : 'none';
    });

    document.getElementById('import-data-input').addEventListener('change', e => handleSmartImport(e.target.files[0]));
    document.getElementById('import-card-input').addEventListener('change', handleCardImport);
    // ============================================================
    // ▼▼▼ 全局安全返回与变量清理系统 (防炸群/防串台) ▼▼▼
    // ============================================================

    // 1. 定义通用清理函数 (所有“退出/返回”操作都应该调用它)
    function forceGlobalCleanup() {
        console.log("执行全局变量清理...");
        
        // A. 清理回复/引用状态
        if (typeof cancelReplyMode === 'function') cancelReplyMode();
        currentReplyContext = null;

        // B. 清理多选/编辑模式
        if (typeof exitSelectionMode === 'function') exitSelectionMode();
        
        // C. 清理定时器 (防止外卖/游戏倒计时在后台报错)
        if (typeof cleanupWaimaiTimers === 'function') cleanupWaimaiTimers();
        if (typeof stopAutoBackupTimer === 'function') stopAutoBackupTimer(); // 如果有自动备份

        // D. 强制关闭悬浮层/面板
        const gomokuOverlay = document.getElementById('gomoku-overlay');
        if (gomokuOverlay) {
             gomokuOverlay.classList.remove('visible');
             // 重置五子棋状态，防止下次打开卡死
             if(state.activeChatId && gomokuState[state.activeChatId]) {
                 gomokuState[state.activeChatId].isActive = false; 
             }
        }
        
        const stickerPanel = document.getElementById('sticker-panel');
        if (stickerPanel) stickerPanel.classList.remove('visible');

        const musicPanel = document.getElementById('music-playlist-panel');
        if (musicPanel) musicPanel.classList.remove('visible');

        // E. 清理全局临时变量 (最重要的一步！)
        ruleCache = {}; 
        activeMessageTimestamp = null; 
        activeTransferTimestamp = null; 
        //lastRawAiResponse = ''; 
        //lastResponseTimestamps = [];
        
        // F. 重置 UI 样式
        applyScopedCss('', '#chat-messages', 'custom-bubble-style');
        applyScopedCss('', '#settings-preview-area', 'preview-bubble-style');
        
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) typingIndicator.style.display = 'none';
        
        // G. 核心：解除当前聊天绑定
        state.activeChatId = null;
    }

    // 2. 绑定：聊天界面 -> 返回列表
    document.getElementById('back-to-list-btn').addEventListener('click', () => {
        forceGlobalCleanup(); // 执行清理
        showScreen('chat-list-screen'); // 切换画面
    });

    // 3. 绑定：狼人杀 -> 退出游戏
    document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
        const confirmed = await showCustomConfirm('退出游戏', '确定要退出当前这局狼人杀吗？游戏进度将不会被保存。', {
            confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
            werewolfGameState.isActive = false;
            
            // 如果是群聊模式，返回聊天界面（不清理activeChatId，因为还在群里）
            if (werewolfGameState.chatId) {
                showScreen('chat-interface-screen');
            } else {
                // 如果是全局模式，返回主页（执行清理！）
                forceGlobalCleanup();
                showScreen('home-screen');
            }
        }
    });

    // 4. 绑定：绿江/支付宝/设置 -> 返回主页 (自动查找并绑定)
    // 因为这些按钮在HTML里没有ID，我们用选择器批量绑定“安全锁”
    const safeBackSelectors = [
        '#green-river-screen .gr-icon-btn', // 绿江返回
        '#alipay-screen .back-btn',         // 支付宝返回
        '#api-settings-screen .back-btn',   // API设置返回
        '#wallpaper-screen .back-btn',      // 外观设置返回
        '#font-settings-screen .back-btn',  // 字体设置返回
        '#tutorial-screen .back-btn'        // 教程返回
    ];

    safeBackSelectors.forEach(selector => {
        const btn = document.querySelector(selector);
        if (btn) {
            // 移除旧的 inline onclick (如果有冲突的话)，或者直接追加
            // 这里我们追加一个清理操作，它会在 onclick 跳转之前或同时执行
            btn.addEventListener('click', () => {
                forceGlobalCleanup();
                // 注意：原本的 showScreen('home-screen') 写在 HTML onclick 里，依然会执行
                // 这里只是额外加了一道保险
            });
        }
    });

    // ============================================================


    document.getElementById('add-chat-btn').addEventListener('click', async () => {

      const choice = await showChoiceModal('创建新聊天', [{
          text: '手动创建角色',
          value: 'manual'
        },
        {
          text: '从角色卡导入 (.json/.png)',
          value: 'import_card'
        }
      ]);

      if (choice === 'manual') {

        const remarkName = await showCustomPrompt('创建新聊天 (第1/2步)', '请输入你想为Ta设置的【备注名】(例如: 哥哥)');
        if (!remarkName || !remarkName.trim()) return;

        const originalName = await showCustomPrompt('创建新聊天 (第2/2步)', '请输入Ta的【本名】(例如: 李星辰，这个名字将用于AI识别)');
        if (!originalName || !originalName.trim()) return;


        const newChatId = 'chat_' + Date.now();
        const newChat = {
          id: newChatId,
          name: remarkName.trim(),
          originalName: originalName.trim(),
          isGroup: false,
          isPinned: false,
          unreadCount: 0,
          relationship: {
            status: 'friend',
            blockedTimestamp: null,
            applicationReason: ''
          },
          status: {
            text: '在线',
            lastUpdate: Date.now(),
            isBusy: false
          },
          settings: {
            aiPersona: '这是一个通过手动创建的角色。',
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            aiAvatar: defaultAvatar,
            myAvatar: defaultAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            aiAvatarLibrary: [],
            myAvatarLibrary: [],
            enableBackgroundActivity: true,
            actionCooldownMinutes: 15,
            enableTimePerception: true,
            isOfflineMode: false,
            offlineMinLength: 100,
            offlineMaxLength: 300,
            offlinePresetId: null,
            timeZone: 'Asia/Shanghai'
          },
          history: [],
          musicData: {
            totalTime: 0
          },
          longTermMemory: [],
          thoughtsHistory: []
        };
        state.chats[newChatId] = newChat;
        await db.chats.put(newChat);
        renderChatList();

      } else if (choice === 'import_card') {
     
        try {
          
          await requirePinActivation();

        
          document.getElementById('import-card-input').click();

        } catch (error) {
        
          console.warn("角色卡导入被取消:", error.message);
        }
       
      }
    });



    document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);

    document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
    document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

    document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
    document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
    document.getElementById('music-return-btn').addEventListener('click', returnToChat);
    document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
    document.getElementById('music-next-btn').addEventListener('click', playNext);
    document.getElementById('music-prev-btn').addEventListener('click', playPrev);
    document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
    document.getElementById('music-playlist-btn').addEventListener('click', () => {
      updatePlaylistUI();
      document.getElementById('music-playlist-panel').classList.add('visible');
    });
    document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
    document.getElementById('manage-playlist-btn').addEventListener('click', togglePlaylistManagementMode);
    document.getElementById('select-all-playlist-checkbox').addEventListener('change', handleSelectAllPlaylistItems);
    document.getElementById('upload-selected-to-catbox-btn').addEventListener('click', executeBatchUploadToCatbox);
    document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
    document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
    document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);

    document.getElementById('playlist-body').addEventListener('click', (e) => {
      const target = e.target;
      const trackIndex = parseInt(target.dataset.index);

      if (isNaN(trackIndex)) return;

      if (target.classList.contains('album-art-btn')) {
        handleChangeAlbumArt(trackIndex);
      } else if (target.classList.contains('lyrics-btn')) {
        handleManualLrcImport(trackIndex);
      } else if (target.classList.contains('bg-btn')) {
        handleChangeBackground(trackIndex);
      } else if (target.classList.contains('delete-track-btn')) {
        deleteTrack(trackIndex);
      }
    });

    audioPlayer.addEventListener('ended', async () => { // 1. 在这里添加 async
  document.getElementById('vinyl-view').classList.remove('spinning');
  
  // 2. 保持 playNext(true) 不变，这样它就不会发送“用户切歌”的错误提示
  playNext(true); 

  // 3. 等待 playNext 执行完毕，确保 musicState.currentIndex 已经更新
  //    (注意：playNext 不是异步的，但 playSong 是。不过 playNext 会同步更新 currentIndex)
  //    为了保险起见，我们稍微等待一下确保状态已更新。
  await new Promise(resolve => setTimeout(resolve, 50)); 

  // 4. 手动添加一条“自动换歌”的系统提示
  const track = musicState.playlist[musicState.currentIndex]; 
  if (track && musicState.isActive && musicState.activeChatId) {
    const chat = state.chats[musicState.activeChatId];
    if (chat) {
      const systemMessage = {
        role: 'system',
        content: `[系统提示：上一首歌曲播放完毕，已自动为你切换到《${track.name}》 - ${track.artist}]`,
        timestamp: Date.now(),
        isHidden: true // 这条消息用户看不见，但AI在下次回复时会读到
      };
      chat.history.push(systemMessage);
      await db.chats.put(chat); // 异步保存到数据库
    }
  }
});





    const chatInput = document.getElementById('chat-input');


    document.getElementById('send-btn').addEventListener('click', () => {
      playSilentAudio();
      const content = chatInput.value.trim();
      if (!content || !state.activeChatId) return;

      const chat = state.chats[state.activeChatId];
      if (content.startsWith('/n ') || content.startsWith('/旁白 ')) {
        const narrationText = content.replace(/^\/n\s+|^\/旁白\s+/, '');
        
        const msg = {
            role: 'system', // 设为 system 居中显示
            type: 'narration',
            content: narrationText,
            timestamp: Date.now()
        };
        
        // 保存并渲染
        chat.history.push(msg);
        db.chats.put(chat);
        appendMessage(msg, chat);
        
        chatInput.value = '';
        chatInput.style.height = 'auto';
        chatInput.focus();
        return; // 阻止发送普通消息
    }
      const msg = {
        role: 'user',
        content,
        timestamp: Date.now()
      };

      if (currentReplyContext) {
        msg.quote = currentReplyContext;
      }


      appendMessage(msg, chat);


      (async () => {
        chat.history.push(msg);
        await db.chats.put(chat);
        renderChatList();

      })();


      chatInput.value = '';
      chatInput.style.height = 'auto';
      chatInput.focus();
      cancelReplyMode();
      document.body.classList.remove('chat-actions-expanded');
    });
    document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-btn').click();
      }
    });


    document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    
    const base64Url = await new Promise((res, rej) => {
      const reader = new FileReader();
      reader.onload = () => res(reader.result);
      reader.onerror = () => rej(reader.error);
      reader.readAsDataURL(file);
    });

   
    newWallpaperBase64 = base64Url;

  
    renderWallpaperScreen(); 

  
    if (state.apiConfig.imgbbEnable && state.apiConfig.imgbbApiKey) {
        
        (async () => {
            try {
                console.log("[ImgBB] 后台开始上传壁纸...");
                
                const imageUrl = await uploadImageToImgBB(base64Url);

               
                if (newWallpaperBase64 === base64Url) {
                    newWallpaperBase64 = imageUrl; // 悄悄地将变量更新为 URL
                    console.log("[ImgBB] 后台壁纸上传成功，临时变量已更新为 URL。");
                } else {
                    console.log("[ImgBB] 后台壁纸上传完成，但用户已更改选择，放弃更新。");
                }
            } catch (uploadError) {
             
                console.error("后台壁纸上传失败:", uploadError.message);
                
            }
        })(); 
    }

  
    event.target.value = null; 
  }
});

    document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {

      if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
      }




      state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
      state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
      state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;

      state.globalSettings.showPhoneFrame = document.getElementById('phone-frame-toggle-switch').checked;
      state.globalSettings.enableMinimalChatUI = document.getElementById('minimal-chat-ui-switch').checked;
      state.globalSettings.alwaysShowMusicIsland = document.getElementById('dynamic-island-music-toggle-switch').checked;
      state.globalSettings.detachStatusBar = document.getElementById('detach-status-bar-switch').checked;
      state.globalSettings.lockScreenEnabled = document.getElementById('lock-screen-toggle').checked;
      state.globalSettings.lockScreenPassword = document.getElementById('lock-screen-password-input').value.trim();
      
      const lockPreview = document.getElementById('lock-wallpaper-preview');
      if (lockPreview.dataset.tempUrl) {
          state.globalSettings.lockScreenWallpaper = lockPreview.dataset.tempUrl;
      }
      await db.globalSettings.put(state.globalSettings);


      applyGlobalWallpaper();
      applyCPhoneWallpaper();
      newWallpaperBase64 = null;

      applyAppIcons();
      applyCPhoneAppIcons();

      applyGlobalCss(state.globalSettings.globalCss);
      applyStatusBarVisibility();
      applyMinimalChatUI(state.globalSettings.enableMinimalChatUI);
      initLockScreen();
      alert('外观设置已保存并应用！');
      showScreen('home-screen');
    });


    const messagesView = document.getElementById('messages-view');
    messagesView.addEventListener('scroll', () => {

      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = messagesView;



      if (scrollHeight - scrollTop - clientHeight < clientHeight) {

        if (!isLoadingMoreChats) {

          loadMoreChats();
        }
      }
    });


    document.getElementById('save-api-settings-btn').addEventListener('click', async () => {

      state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim();
      state.apiConfig.apiKey = document.getElementById('api-key').value.trim();
      state.apiConfig.model = document.getElementById('model-select').value;
      state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
      state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
      state.apiConfig.minimaxModel = document.getElementById('minimax-model-select').value;
      const domainSelect = document.getElementById('minimax-domain-select');
      if (domainSelect) {
          state.apiConfig.minimaxDomain = domainSelect.value;
          localStorage.setItem('minimax-domain', domainSelect.value);
      }
      localStorage.setItem('minimax-group-id', state.apiConfig.minimaxGroupId);
      localStorage.setItem('minimax-api-key', state.apiConfig.minimaxApiKey);
      localStorage.setItem('minimax-model', state.apiConfig.minimaxModel);
      state.apiConfig.secondaryProxyUrl = document.getElementById('secondary-proxy-url').value.trim();
      state.apiConfig.secondaryApiKey = document.getElementById('secondary-api-key').value.trim();
      state.apiConfig.secondaryModel = document.getElementById('secondary-model-select').value;
      const imgbbEnable = document.getElementById('imgbb-enable-switch').checked;
      const imgbbApiKey = document.getElementById('imgbb-api-key').value.trim();
      const catboxEnable = document.getElementById('catbox-enable-switch').checked;
      const catboxUserHash = document.getElementById('catbox-userhash').value.trim();

      
      state.apiConfig.imgbbEnable = imgbbEnable;
      state.apiConfig.imgbbApiKey = imgbbApiKey;
      state.apiConfig.catboxEnable = catboxEnable;
      state.apiConfig.catboxUserHash = catboxUserHash;

      
      localStorage.setItem('imgbb-enabled', imgbbEnable);
      localStorage.setItem('imgbb-api-key', imgbbApiKey);
      localStorage.setItem('catbox-enabled', catboxEnable);
      localStorage.setItem('catbox-userhash', catboxUserHash);
      const githubEnable = document.getElementById('github-enable-switch').checked;
      const githubAutoBackup = document.getElementById('github-auto-backup-switch').checked;
      let backupInterval = parseInt(document.getElementById('github-backup-interval').value);
      if (isNaN(backupInterval) || backupInterval < 1) backupInterval = 30;
        state.apiConfig.githubEnable = githubEnable;
       state.apiConfig.githubAutoBackup = githubAutoBackup;
       const githubProxyEnable = document.getElementById('github-proxy-switch').checked;
        const githubProxyUrl = document.getElementById('github-proxy-url').value.trim();
        
        state.apiConfig.githubProxyEnable = githubProxyEnable;
        state.apiConfig.githubProxyUrl = githubProxyUrl;
        
        localStorage.setItem('github-proxy-enabled', githubProxyEnable);
        localStorage.setItem('github-proxy-url', githubProxyUrl);
        state.apiConfig.githubUsername = document.getElementById('github-username').value.trim();
        state.apiConfig.githubRepo = document.getElementById('github-repo').value.trim();
        state.apiConfig.githubToken = document.getElementById('github-token').value.trim();
        state.apiConfig.githubFilename = document.getElementById('github-filename').value.trim() || 'ephone_backup.json';
        localStorage.setItem('github-username', state.apiConfig.githubUsername);
        localStorage.setItem('github-repo', state.apiConfig.githubRepo);
        localStorage.setItem('github-token', state.apiConfig.githubToken);
        localStorage.setItem('github-filename', state.apiConfig.githubFilename);
        state.apiConfig.novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
      state.apiConfig.novelaiModel = document.getElementById('novelai-model').value;
      state.apiConfig.novelaiEnabled = document.getElementById('novelai-switch').checked;
      // 保存备份间隔
      state.apiConfig.githubBackupInterval = backupInterval;
        // 保存开关状态到 localStorage
        localStorage.setItem('github-enabled', githubEnable);
      localStorage.setItem('github-auto-backup', githubAutoBackup);
      localStorage.setItem('github-backup-interval', backupInterval);

      if (githubEnable && githubAutoBackup) {
        // 传入动态的时间间隔
        startAutoBackupTimer(backupInterval); 
    } else {
        stopAutoBackupTimer();
    }
      await db.apiConfig.put(state.apiConfig);


      const backgroundSwitch = document.getElementById('background-activity-switch');
      const intervalInput = document.getElementById('background-interval-input');
      const cooldownInput = document.getElementById('block-cooldown-input');

      state.globalSettings.enableBackgroundActivity = backgroundSwitch.checked;
      state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
      state.globalSettings.blockCooldownHours = parseFloat(cooldownInput.value) || 1;
      state.globalSettings.enableAiDrawing = document.getElementById('enable-ai-drawing-switch').checked;
      
      // 新增：保存心声和动态功能开关
      state.globalSettings.enableThoughts = document.getElementById('global-enable-thoughts-switch').checked;
      state.globalSettings.enableQzoneActions = document.getElementById('global-enable-qzone-actions-switch').checked;
      
      state.globalSettings.chatRenderWindow = parseInt(document.getElementById('chat-render-window-input').value) || 50;
      state.globalSettings.chatListRenderWindow = parseInt(document.getElementById('chat-list-render-window-input').value) || 30;
      state.globalSettings.apiTemperature = parseFloat(document.getElementById('api-temperature-slider').value);
      await db.globalSettings.put(state.globalSettings);

      stopBackgroundSimulation();
      if (state.globalSettings.enableBackgroundActivity) {
        startBackgroundSimulation();
        console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
      } else {
        console.log("后台活动模拟已停止。");
      }

      // 保存NovelAI配置到localStorage
      const novelaiEnabled = document.getElementById('novelai-switch').checked;
      const novelaiModel = document.getElementById('novelai-model').value;
      const novelaiApiKey = document.getElementById('novelai-api-key').value.trim();
      localStorage.setItem('novelai-enabled', novelaiEnabled);
      localStorage.setItem('novelai-model', novelaiModel);
      localStorage.setItem('novelai-api-key', novelaiApiKey);

      alert('所有API与后台设置已保存!');
    });



    const ApiKeyInput = document.getElementById('api-key')
    ApiKeyInput.addEventListener('focus', (e) => {
      e.target.setAttribute('type', 'text')
    })
    ApiKeyInput.addEventListener('blur', (e) => {
      e.target.setAttribute('type', 'password')
    })





    async function fetchModels(urlInputId, keyInputId, selectId) {
      const url = document.getElementById(urlInputId).value.trim();
      const key = document.getElementById(keyInputId).value.trim();
      if (!url || !key) return alert('请先填写对应的反代地址和密钥');

      try {
        let isGemini = url === GEMINI_API_URL;
        const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`, isGemini ? undefined : {
          headers: {
            'Authorization': `Bearer ${key}`
          }
        });
        if (!response.ok) throw new Error('无法获取模型列表');
        const data = await response.json();
        let models = isGemini ? data.models.map(model => ({
          id: model.name.split('/')[1] || model.name
        })) : data.data;

        const modelSelect = document.getElementById(selectId);
        modelSelect.innerHTML = '';

        const savedModel = selectId === 'model-select' ? state.apiConfig.model : state.apiConfig.secondaryModel;

        models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.id;
          option.textContent = model.id;
          if (model.id === savedModel) option.selected = true;
          modelSelect.appendChild(option);
        });
        alert('模型列表已更新');
      } catch (error) {
        alert(`拉取模型失败: ${error.message}`);
      }
    }


    document.getElementById('fetch-models-btn').addEventListener('click', () => {
      fetchModels('proxy-url', 'api-key', 'model-select');
    });


    document.getElementById('fetch-secondary-models-btn').addEventListener('click', () => {
      fetchModels('secondary-proxy-url', 'secondary-api-key', 'secondary-model-select');
    });

    document.getElementById('add-world-book-btn').addEventListener('click', async () => {
      const name = await showCustomPrompt('创建世界书', '请输入书名');
      if (name && name.trim()) {
        const newBook = {
          id: 'wb_' + Date.now(),
          name: name.trim(),
          content: ''
        };
        await db.worldBooks.add(newBook);
        state.worldBooks.push(newBook);
        renderWorldBookScreen();
        openWorldBookEditor(newBook.id);
      }
    });

    document.getElementById('save-world-book-btn').addEventListener('click', async () => {
      if (!editingWorldBookId) return;
      const book = state.worldBooks.find(wb => wb.id === editingWorldBookId);
      if (!book) return;


      const newName = document.getElementById('world-book-name-input').value.trim();
      if (!newName) {
        alert('书名不能为空！');
        return;
      }
      book.name = newName;
      const categoryId = document.getElementById('world-book-category-select').value;
      book.categoryId = categoryId ? parseInt(categoryId) : null;

      const entriesContainer = document.getElementById('world-book-entries-container');
      const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
      const newEntries = [];

      entryBlocks.forEach(block => {
        const keysInput = block.querySelector('.entry-keys-input').value.trim();
        const content = block.querySelector('.entry-content-textarea').value.trim();
        const isEnabled = block.querySelector('.entry-enabled-switch').checked;
        if (content) {
          newEntries.push({
            comment: block.querySelector('.entry-comment-input').value.trim(),
            keys: keysInput ? keysInput.split(',').map(k => k.trim()).filter(k => k) : [],
            content: content,
            enabled: isEnabled
          });
        }
      });
      book.content = newEntries;


      await db.worldBooks.put(book);
      document.getElementById('world-book-editor-title').textContent = newName;
      editingWorldBookId = null;


      showScreen('world-book-screen');


      await renderWorldBookScreen();
    });


    document.getElementById('chat-messages').addEventListener('click', async (e) => {
             if (e.target.tagName === 'IMG') {
            // 检查是否是聊天里的图片类名
            if (e.target.classList.contains('chat-image') || 
               
                e.target.classList.contains('realimag-image') ||
                e.target.classList.contains('naiimag-image')) {
                
                e.stopPropagation(); // 阻止气泡被选中等其他事件

                // --- 核心修复逻辑：检测连击 ---
                
                // 如果这是一个快速的第二次或第三次点击 (detail > 1)，
                // 说明用户可能在尝试三击下载，或者是双击。
                // 此时我们要取消掉还没执行的“放大”操作，并不做任何放大处理。
                if (e.detail > 1) {
                    if (window.simpleZoomTimer) {
                        clearTimeout(window.simpleZoomTimer);
                        window.simpleZoomTimer = null;
                    }
                    return; // 直接退出，把舞台留给三击下载逻辑
                }

                // 如果是第一次点击，我们不要立刻放大，而是等 250ms
                // 如果 250ms 内没有第二次点击，才执行放大。
                window.simpleZoomTimer = setTimeout(() => {
                    openSimpleImageZoom(e.target.src);
                    window.simpleZoomTimer = null;
                }, 250); // 250毫秒延迟，既不影响体感，又能避开连击
                
                return;
            }
        }
     
      // 1. 修复下载按钮 (带转圈动画)
      const downloadBtn = e.target.closest('.nai-save-local-btn');
        if (downloadBtn) {
            e.stopPropagation(); 
            
            // --- 新增：让它转起来 ---
            downloadBtn.classList.add('loading'); // 添加转圈样式
            downloadBtn.disabled = true;          // 防止连点
            
            const bubble = downloadBtn.closest('.message-bubble');
            const img = bubble ? bubble.querySelector('img.chat-image, img.realimag-image, img.naiimag-image') : null;
            
            if (img && img.src) {
                addVisualFeedback(img); 
                const filename = generateFilename(img);
                downloadImage(img.src, filename);
            }
            
            // --- 新增：转一会儿后停止 (800毫秒后恢复) ---
            // 因为下载是浏览器接管的，JS无法知道确切结束时间，给个视觉反馈时间即可
            setTimeout(() => {
                downloadBtn.classList.remove('loading');
                downloadBtn.disabled = false;
            }, 800);
            
            return;
        }
       // --- 修复上传图床按钮 (原本漏掉了这个监听) ---
      const naiUploadBtn = e.target.closest('.nai-upload-imgbb-btn');
      if (naiUploadBtn) {
        e.stopPropagation();
        const bubble = e.target.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          if (!isNaN(timestamp)) {
            // 调用已有的 NAI 上传处理函数
            await handleSilentUploadNaiImage(timestamp, naiUploadBtn);
          }
        }
        return;
      }
      const regenBtn = e.target.closest('.nai-regenerate-btn');
      if (regenBtn) {
        e.stopPropagation();
        const bubble = e.target.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          if (!isNaN(timestamp)) {
            await handleRegenerateNaiImage(timestamp, regenBtn);
          }
        }
        return;
      }
      const userUploadBtn = e.target.closest('.user-upload-imgbb-btn');
            if (userUploadBtn) {
                e.stopPropagation();
                const bubble = e.target.closest('.message-bubble');
                if (bubble) {
                    const timestamp = parseInt(bubble.dataset.timestamp);
                    if (!isNaN(timestamp)) {
                        await handleSilentUploadUserImage(timestamp, userUploadBtn);
                    }
                }
                return;
            }
      const voiceBody = e.target.closest('.voice-message-body[data-text]');
      if (voiceBody) {

        const chat = state.chats[state.activeChatId];
        if (!chat) return;


        toggleVoiceTranscript(voiceBody);


        const bubble = voiceBody.closest('.message-bubble');
        const transcriptEl = bubble ? bubble.querySelector('.voice-transcript') : null;


        if (voiceBody.dataset.voiceId && transcriptEl && transcriptEl.style.display === 'block') {


          if (chat.isGroup) {
            console.log("这是一条群聊语音消息，已禁止发起TTS请求。");
            return;
          }
          if (chat.settings.enableTts === false) {
            console.log(`“${chat.name}”的TTS功能已关闭，已禁止发起TTS请求。`);
            return;
          }


          playTtsAudio(voiceBody);
        }

        return;
      }

      const detailsBtn = e.target.closest('.waimai-details-btn');
      if (detailsBtn) {
        const bubble = detailsBtn.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          if (!isNaN(timestamp)) {
            showWaimaiDetails(timestamp);
            return;
          }
        }
      }



      const choiceBtn = e.target.closest('.waimai-user-actions button');
      if (choiceBtn) {
        const bubble = choiceBtn.closest('.message-bubble');
        if (bubble) {
          const timestamp = parseInt(bubble.dataset.timestamp);
          const choice = choiceBtn.dataset.choice;
          if (!isNaN(timestamp) && choice) {
            await handleWaimaiResponse(timestamp, choice);
            return;
          }
        }
      }


      const deletedPostPlaceholder = e.target.closest('.post-deleted-placeholder');
      if (deletedPostPlaceholder) {
        const postId = parseInt(deletedPostPlaceholder.dataset.postId);
        if (!isNaN(postId)) {
          const post = await db.qzonePosts.get(postId);
          if (post) {
            let originalContent = '';
            const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');

            if (post.type === 'shuoshuo') {
              originalContent = post.content;
            } else {
              originalContent = post.publicText || '';
              if (post.imageUrl) originalContent += `\n[图片]`;
              if (post.hiddenContent) originalContent += `\n[文字图内容: ${post.hiddenContent}]`;
            }

            showCustomAlert(
              `来自 ${authorName} 的已删除动态`,
              originalContent.replace(/\n/g, '<br>')
            );
          } else {
            showCustomAlert('提示', '这条动态的原始数据已被彻底清除。');
          }
        }
        return;
      }

      const aiImage = e.target.closest('.ai-generated-image');
      if (aiImage) {
        const description = aiImage.dataset.description;
        if (description) showCustomAlert('照片描述', description);
        return;
      }

      const quoteBlock = e.target.closest('.quoted-message');
      if (quoteBlock && quoteBlock.dataset.originalTimestamp) {
        const originalTimestamp = parseInt(quoteBlock.dataset.originalTimestamp);
        if (!isNaN(originalTimestamp)) {
          scrollToOriginalMessage(originalTimestamp);
        }
      }

      const giftCard = e.target.closest('.gift-card');
      if (giftCard) {
        const bubble = giftCard.closest('.message-bubble');
        if (bubble) {
          showGiftReceipt(parseInt(bubble.dataset.timestamp));
        }
      }

      const packetCard = e.target.closest('.red-packet-card');
      if (packetCard) {
        const messageBubble = packetCard.closest('.message-bubble');
        if (messageBubble && messageBubble.dataset.timestamp) {
          const timestamp = parseInt(messageBubble.dataset.timestamp);
          handlePacketClick(timestamp);
        }
      }

      const pollCard = e.target.closest('.poll-card');
      if (pollCard) {
        const timestamp = parseInt(pollCard.dataset.pollTimestamp);
        if (isNaN(timestamp)) return;

        const optionItem = e.target.closest('.poll-option-item');
        if (optionItem && !pollCard.classList.contains('closed')) {
          handleUserVote(timestamp, optionItem.dataset.option);
          return;
        }

        const actionBtn = e.target.closest('.poll-action-btn');
        if (actionBtn) {
          if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
          } else {
            endPoll(timestamp);
          }
          return;
        }

        if (pollCard.classList.contains('closed')) {
          showPollResults(timestamp);
        }
      }



      const placeholder = e.target.closest('.recalled-message-placeholder');
      if (placeholder) {
        const chat = state.chats[state.activeChatId];
        const wrapper = placeholder.closest('.message-wrapper');
        if (chat && wrapper) {
          const timestamp = parseInt(wrapper.dataset.timestamp);
          const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

          if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;

            if (recalled.originalType === 'text') {
              originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
              originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
          }
        }
      }

      const linkCard = e.target.closest('.link-share-card');
      if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
      }

      const bubble = e.target.closest('.message-bubble');
      if (bubble && bubble.classList.contains('ai') && bubble.classList.contains('is-transfer') && bubble.dataset.status === 'pending') {
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
          showTransferActionModal(timestamp);
        }
      }
    });


    const chatSettingsModal = document.getElementById('chat-settings-modal');
    const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
    const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

    function updateWorldBookSelectionDisplay() {
      const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked');
      const displayText = document.querySelector('.selected-options-text');

      if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
      } else if (checkedBoxes.length > 2) {
        displayText.textContent = `已选择 ${checkedBoxes.length} 本世界书`;
      } else {
        const displayItems = Array.from(checkedBoxes).map(cb => {
          return cb.parentElement.textContent.trim();
        });
        displayText.textContent = displayItems.join(', ');
      }
    }


    worldBookSelectBox.addEventListener('click', (e) => {
      e.stopPropagation();
      worldBookCheckboxesContainer.classList.toggle('visible');
      worldBookSelectBox.classList.toggle('expanded');
    });
    document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
    window.addEventListener('click', (e) => {
      if (!document.querySelector('.custom-multiselect').contains(e.target)) {
        worldBookCheckboxesContainer.classList.remove('visible');
        worldBookSelectBox.classList.remove('expanded');
      }
    });

    // 角色监测按钮事件监听
    document.getElementById('character-monitor-btn')?.addEventListener('click', openCharacterMonitor);
    document.getElementById('monitor-back-btn')?.addEventListener('click', () => showScreen('chat-interface-screen'));
    
    // 日期选择按钮
    document.getElementById('monitor-date-picker-btn')?.addEventListener('click', async () => {
      if (!state.activeChatId) return;
      
      const dateInput = document.createElement('input');
      dateInput.type = 'date';
      dateInput.value = currentMonitorDate || formatMonitorDate(new Date());
      dateInput.style.position = 'absolute';
      dateInput.style.opacity = '0';
      document.body.appendChild(dateInput);
      
      dateInput.addEventListener('change', async () => {
        const selectedDate = dateInput.value;
        await generateMonitorData(state.activeChatId, selectedDate, 'full');
        document.body.removeChild(dateInput);
      });
      
      dateInput.showPicker();
    });
    
    // 设置按钮
    document.getElementById('monitor-settings-btn')?.addEventListener('click', async () => {
      await showCustomAlert('角色监测设置', '功能开发中，敬请期待！');
    });
    
    document.getElementById('monitor-regenerate-btn')?.addEventListener('click', async () => {
      if (!currentMonitorData || !state.activeChatId) return;
      const confirmed = await showCustomConfirm('确认', '是否重新生成所有未编辑的时段？');
      if (confirmed) {
        const unedited = currentMonitorData.timeline.filter(s => !s.isEdited);
        for (const segment of unedited) {
          await regenerateMonitorSegment(segment.timeRange);
        }
      }
    });
    
    document.getElementById('monitor-generate-today-btn')?.addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const today = new Date();
      const todayStr = formatMonitorDate(today);
      await generateMonitorData(state.activeChatId, todayStr, 'full');
    });
    
    document.getElementById('monitor-predict-future-btn')?.addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const today = new Date();
      const todayStr = formatMonitorDate(today);
      await generateMonitorData(state.activeChatId, todayStr, 'full');
    });

    document.getElementById('chat-settings-btn').addEventListener('click', async () => {
      loadThemePresetsDropdown();
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const isGroup = chat.isGroup;

     const weatherSection = document.getElementById('weather-settings-section');
if (isGroup) {
    weatherSection.style.display = 'none';
} else {
    weatherSection.style.display = 'block';
    
    // 读取配置
    const wSettings = chat.settings.weather || {};
    
    const weatherSwitch = document.getElementById('enable-weather-switch');
    const weatherConfigContainer = document.getElementById('weather-config-container');
    
    weatherSwitch.checked = wSettings.enabled || false;
    weatherConfigContainer.style.display = wSettings.enabled ? 'block' : 'none';
    
    // 绑定开关显示隐藏
    weatherSwitch.onclick = (e) => {
        weatherConfigContainer.style.display = e.target.checked ? 'block' : 'none';
    };

    // 回显 User 数据
    document.getElementById('user-virtual-city').value = wSettings.userVirtualCity || '';
    document.getElementById('user-city-lat').value = wSettings.userLat || '';
    document.getElementById('user-city-lon').value = wSettings.userLon || '';
    if (wSettings.userRealCity) {
        document.getElementById('user-city-result').textContent = `已映射: ${wSettings.userRealCity} (${wSettings.userLat}, ${wSettings.userLon})`;
        document.getElementById('user-city-result').style.color = 'green';
    } else {
        document.getElementById('user-city-result').textContent = '未设置映射';
        document.getElementById('user-city-result').style.color = '#007bff';
    }

    // 回显 Char 数据
    document.getElementById('char-virtual-city').value = wSettings.charVirtualCity || '';
    document.getElementById('char-city-lat').value = wSettings.charLat || '';
    document.getElementById('char-city-lon').value = wSettings.charLon || '';
    if (wSettings.charRealCity) {
        document.getElementById('char-city-result').textContent = `已映射: ${wSettings.charRealCity} (${wSettings.charLat}, ${wSettings.charLon})`;
        document.getElementById('char-city-result').style.color = 'green';
    } else {
        document.getElementById('char-city-result').textContent = '未设置映射';
        document.getElementById('char-city-result').style.color = '#007bff';
    }
}
      const switchGreetingGroup = document.getElementById('switch-greeting-group');
      if (!isGroup && chat.settings.alternateGreetings && chat.settings.alternateGreetings.length > 0) {
        switchGreetingGroup.style.display = 'block';
      } else {
        switchGreetingGroup.style.display = 'none';
      }

      document.getElementById('chat-name-group').style.display = 'block';
      document.getElementById('my-persona-group').style.display = 'block';
      document.getElementById('my-avatar-group').style.display = 'block';
      document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('my-nickname-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-original-name-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-voice-id-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('inject-thought-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('todo-list-setting-group').style.display = isGroup ? 'none' : 'flex';
      document.getElementById('offline-mode-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('ai-cooldown-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('group-cooldown-group').style.display = isGroup ? 'block' : 'none';
      document.getElementById('memory-archive-section').style.display = isGroup ? 'none' : 'block';
      document.getElementById('chat-name-input').value = chat.name;
      document.getElementById('my-persona').value = chat.settings.myPersona;
      document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
      document.getElementById('max-memory').value = chat.settings.maxMemory;
      document.getElementById('linked-memory-count').value = chat.settings.linkedMemoryCount || 10;
      const bgPreview = document.getElementById('bg-preview');
      const removeBgBtn = document.getElementById('remove-bg-btn');
      if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
      } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
      }
      document.getElementById('lyrics-position-group').style.display = 'block';

      document.getElementById('single-char-background-activity-group').style.display = isGroup ? 'none' : 'block';
      document.getElementById('group-background-activity-group').style.display = isGroup ? 'block' : 'none';




      const timePerceptionToggle = document.getElementById('time-perception-toggle');
      const timeZoneGroup = document.getElementById('time-zone-group');
      timePerceptionToggle.checked = chat.settings.enableTimePerception;
      timeZoneGroup.style.display = timePerceptionToggle.checked ? 'block' : 'none';


      const timezoneSelect = document.getElementById('time-zone-select');

      const timezones = Intl.supportedValuesOf('timeZone');
      timezoneSelect.innerHTML = '';
      timezones.forEach(tz => {
        const option = document.createElement('option');
        option.value = tz;
        option.textContent = tz;
        timezoneSelect.appendChild(option);
      });

      timezoneSelect.value = chat.settings.timeZone || 'Asia/Shanghai';
      document.getElementById('enable-synth-music-switch').checked = chat.settings.enableSynthMusic || false;
      document.getElementById('narrator-mode-toggle').checked = chat.settings.enableNarratorMode || false;
      if (isGroup) {

        document.getElementById('group-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('group-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;


        document.getElementById('single-char-background-activity-group').style.display = 'none';
        renderGroupMemberSettings(chat.members);
      } else {

        document.getElementById('single-char-background-activity-group').style.display = 'block';
        document.getElementById('enable-todo-list-switch').checked = chat.settings.enableTodoList || false;
        // --- 修复天气设置回显逻辑 ---
        const weatherSection = document.getElementById('weather-settings-section');
        weatherSection.style.display = 'block';

        // 读取当前角色的配置
        const wSettings = chat.settings.weather || {};

        const weatherSwitch = document.getElementById('enable-weather-switch');
        const weatherConfigContainer = document.getElementById('weather-config-container');

        weatherSwitch.checked = wSettings.enabled || false;
        weatherConfigContainer.style.display = wSettings.enabled ? 'block' : 'none';
        
        // 绑定开关显示隐藏 (防止事件重复绑定，先移除再添加，或者依赖 HTML onclick 逻辑)
        weatherSwitch.onclick = (e) => {
            weatherConfigContainer.style.display = e.target.checked ? 'block' : 'none';
        };

        // 1. 回显 User 数据
        document.getElementById('user-virtual-city').value = wSettings.userVirtualCity || '';
        
        // 【关键修复】: 显式设置搜索框的值为已保存的城市名，如果没有则清空
        const userRealCityInput = document.getElementById('user-real-city-search');
        userRealCityInput.value = wSettings.userRealCity || ''; 
        userRealCityInput.dataset.realName = wSettings.userRealCity || ''; // 同步 dataset

        document.getElementById('user-city-lat').value = wSettings.userLat || '';
        document.getElementById('user-city-lon').value = wSettings.userLon || '';

        if (wSettings.userRealCity) {
            document.getElementById('user-city-result').textContent = `已映射: ${wSettings.userRealCity} (${wSettings.userLat}, ${wSettings.userLon})`;
            document.getElementById('user-city-result').style.color = 'green';
        } else {
            document.getElementById('user-city-result').textContent = '未设置映射';
            document.getElementById('user-city-result').style.color = '#007bff';
        }

        // 2. 回显 Char 数据
        document.getElementById('char-virtual-city').value = wSettings.charVirtualCity || '';

        // 【关键修复】: 显式设置搜索框的值为已保存的城市名，如果没有则清空
        const charRealCityInput = document.getElementById('char-real-city-search');
        charRealCityInput.value = wSettings.charRealCity || '';
        charRealCityInput.dataset.realName = wSettings.charRealCity || ''; // 同步 dataset

        document.getElementById('char-city-lat').value = wSettings.charLat || '';
        document.getElementById('char-city-lon').value = wSettings.charLon || '';

        if (wSettings.charRealCity) {
            document.getElementById('char-city-result').textContent = `已映射: ${wSettings.charRealCity} (${wSettings.charLat}, ${wSettings.charLon})`;
            document.getElementById('char-city-result').style.color = 'green';
        } else {
            document.getElementById('char-city-result').textContent = '未设置映射';
            document.getElementById('char-city-result').style.color = '#007bff';
        }
        document.getElementById('char-background-activity-switch').checked = chat.settings.enableBackgroundActivity;
        document.getElementById('inject-thought-toggle').checked = chat.settings.injectLatestThought;
        
        // 新增：读取AI行为控制设置
        const thoughtsSelect = document.getElementById('chat-enable-thoughts-select');
        if (chat.settings.enableThoughts === null || chat.settings.enableThoughts === undefined) {
          thoughtsSelect.value = 'null';
        } else {
          thoughtsSelect.value = String(chat.settings.enableThoughts);
        }
        
        const qzoneSelect = document.getElementById('chat-enable-qzone-actions-select');
        if (chat.settings.enableQzoneActions === null || chat.settings.enableQzoneActions === undefined) {
          qzoneSelect.value = 'null';
        } else {
          qzoneSelect.value = String(chat.settings.enableQzoneActions);
        }
        
        // 更新全局设置状态显示
        document.getElementById('global-thoughts-status').textContent = state.globalSettings.enableThoughts ? '开启' : '关闭';
        document.getElementById('global-qzone-status').textContent = state.globalSettings.enableQzoneActions ? '开启' : '关闭';
        
        const offlineModeToggle = document.getElementById('offline-mode-toggle');
        const offlineModeOptions = document.getElementById('offline-mode-options');
        const offlineMinInput = document.getElementById('offline-min-length-input');
        const offlineMaxInput = document.getElementById('offline-max-length-input');
        offlineModeToggle.checked = chat.settings.isOfflineMode || false;
        offlineModeOptions.style.display = offlineModeToggle.checked ? 'block' : 'none';
        offlineMinInput.value = chat.settings.offlineMinLength || 100;
        offlineMaxInput.value = chat.settings.offlineMaxLength || 300;
        await renderOfflinePresetSelector(chat);
        
        // 加载表情包识图设置
        document.getElementById('enable-sticker-vision-checkbox').checked = chat.settings.enableStickerVision || false;
        
        document.getElementById('ai-original-name-input').value = chat.originalName;
        document.getElementById('ai-voice-id-input').value = chat.settings.minimaxVoiceId || '';
        
        document.getElementById('ai-voice-lang-group').style.display = isGroup ? 'none' : 'block';
        document.getElementById('ai-voice-lang-select').value = chat.settings.ttsLanguage || '';
        document.getElementById('chat-show-seconds-switch').checked = chat.settings.showSeconds !== undefined ? chat.settings.showSeconds : (state.globalSettings.showSeconds || false);
        document.getElementById('enable-tts-switch').checked = chat.settings.enableTts !== false;
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('my-nickname-input').value = chat.settings.myNickname || '我';
        document.getElementById('ai-action-cooldown-input').value = chat.settings.actionCooldownMinutes || 10;
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>';
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
          const option = document.createElement('option');
          option.value = group.id;
          option.textContent = group.name;
          if (chat.groupId === group.id) option.selected = true;
          select.appendChild(option);
        });
        const lyricsPos = chat.settings.lyricsPosition || {
          vertical: 'top',
          horizontal: 'center',
          offset: 10
        };
        document.getElementById('lyrics-vertical-pos').value = lyricsPos.vertical;
        document.getElementById('lyrics-horizontal-pos').value = lyricsPos.horizontal;
        document.getElementById('lyrics-offset-input').value = lyricsPos.offset;
      }



      const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
      worldBookCheckboxesContainer.innerHTML = '';

      const [allCategories, allBooks] = await Promise.all([
        db.worldBookCategories.toArray(),
        db.worldBooks.toArray()
      ]);

      const linkedBookIds = new Set(chat.settings.linkedWorldBookIds || []);

      if (allBooks.length === 0) {
        worldBookCheckboxesContainer.innerHTML = '<p style="text-align:center; color: #8a8a8a;">还没有创建任何世界书</p>';
      } else {

        allCategories.forEach(cat => {
          const booksInCategory = allBooks.filter(book => book.categoryId === cat.id);
          if (booksInCategory.length > 0) {
            const categoryHeader = document.createElement('h4');
            categoryHeader.textContent = cat.name;
            categoryHeader.style.cssText = 'margin: 10px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
            worldBookCheckboxesContainer.appendChild(categoryHeader);

            booksInCategory.forEach(book => {
              const isChecked = linkedBookIds.has(book.id);
              const label = document.createElement('label');

              label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
              worldBookCheckboxesContainer.appendChild(label);
            });
          }
        });


        const uncategorizedBooks = allBooks.filter(book => !book.categoryId);
        if (uncategorizedBooks.length > 0) {
          const bookHeader = document.createElement('h4');
          bookHeader.textContent = '未分类';
          bookHeader.style.cssText = 'margin: 15px 0 5px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 3px;';
          worldBookCheckboxesContainer.appendChild(bookHeader);

          uncategorizedBooks.forEach(book => {
            const isChecked = linkedBookIds.has(book.id);
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="book_${book.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
            worldBookCheckboxesContainer.appendChild(label);
          });
        }
      }


      updateWorldBookSelectionDisplay();

      const linkMemoryToggle = document.getElementById('link-memory-toggle');
      const linkedMemorySelection = document.getElementById('linked-memory-selection');
      const linkedChatsContainer = document.getElementById('linked-chats-checkboxes-container');
      const linkedMemoryIds = chat.settings.linkedMemoryChatIds || [];
      linkMemoryToggle.checked = linkedMemoryIds.length > 0;
      linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none';
      linkedChatsContainer.innerHTML = '';
      Object.values(state.chats).forEach(c => {
        if (c.id === chat.id) return;
        const isChecked = linkedMemoryIds.includes(c.id);
        const prefix = c.isGroup ? '[群聊]' : '[私聊]';
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''}> ${prefix} ${c.name}`;
        linkedChatsContainer.appendChild(label);
      });

      function updateLinkedMemorySelectionDisplay() {
        const checkedBoxes = linkedChatsContainer.querySelectorAll('input:checked');
        const displayText = linkedMemorySelection.querySelector('.selected-options-text');
        if (checkedBoxes.length === 0) {
          displayText.textContent = '-- 点击选择 --';
        } else if (checkedBoxes.length > 2) {
          displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
        } else {
          displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', ');
        }
      }
      updateLinkedMemorySelectionDisplay();
      linkMemoryToggle.addEventListener('change', () => {
        linkedMemorySelection.style.display = linkMemoryToggle.checked ? 'block' : 'none';
      });
      const linkedMemorySelectBox = linkedMemorySelection.querySelector('.select-box');
      const newLinkedMemorySelectBox = linkedMemorySelectBox.cloneNode(true);
      linkedMemorySelectBox.parentNode.replaceChild(newLinkedMemorySelectBox, linkedMemorySelectBox);
      newLinkedMemorySelectBox.addEventListener('click', (e) => {
        e.stopPropagation();
        linkedChatsContainer.classList.toggle('visible');
        newLinkedMemorySelectBox.classList.toggle('expanded');
      });
      linkedChatsContainer.addEventListener('change', updateLinkedMemorySelectionDisplay);
      const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
      if (themeRadio) themeRadio.checked = true;
      const fontSizeSlider = document.getElementById('font-size-slider');
      fontSizeSlider.value = chat.settings.fontSize || 13;
      document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
      const customCssInput = document.getElementById('custom-css-input');
      customCssInput.value = chat.settings.customCss || '';
      updateSettingsPreview();
      document.getElementById('auto-memory-toggle').checked = chat.settings.enableAutoMemory || false;
      document.getElementById('auto-memory-interval').value = chat.settings.autoMemoryInterval || 20;
      document.getElementById('show-hidden-msg-toggle').checked = chat.settings.showHiddenMessages || false;
      setTimeout(() => {
        updateTokenCountDisplay(); 

        const inputsToWatch = [
          'ai-persona', 'my-persona', 'max-memory',
          'linked-memory-count', 'auto-memory-toggle', 'auto-memory-interval',
          'offline-mode-toggle', 'offline-min-length-input',
          'offline-max-length-input', 'offline-preset-select'
        ];

        inputsToWatch.forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('input', updateTokenCountDisplay);
          }
        });

        // 为多选框容器添加事件监听
        document.getElementById('world-book-checkboxes-container').addEventListener('change', updateTokenCountDisplay);
        document.getElementById('linked-chats-checkboxes-container').addEventListener('change', updateTokenCountDisplay);
        document.getElementById('link-memory-toggle').addEventListener('change', updateTokenCountDisplay);
      }, 100);
      
      // 渲染记忆库列表
      renderMemoryArchiveList();
      
      showScreen('chat-settings-screen');
    });



    function renderGroupMemberSettings(members) {
      const container = document.getElementById('group-members-settings');
      container.innerHTML = '';
      members.forEach(member => {
        const div = document.createElement('div');
        div.className = 'member-editor';
        div.dataset.memberId = member.id;




        const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);

        div.innerHTML = `<img src="${memberAvatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
        div.addEventListener('click', () => openMemberEditor(member.id));
        container.appendChild(div);
      });
    }



    document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
      if (!editingMemberId) return;
      const chat = state.chats[state.activeChatId];
      const member = chat.members.find(m => m.id === editingMemberId);
      if (!member) return;

      const newNickname = document.getElementById('member-name-input').value.trim();
      if (!newNickname) {
        alert("群昵称不能为空！");
        return;
      }
      member.groupNickname = newNickname;
      member.persona = document.getElementById('member-persona-input').value;

      const newAvatarUrl = document.getElementById('member-avatar-preview').src;



      member.avatar = newAvatarUrl;


      const characterProfile = state.chats[member.id];
      if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
      }


      await db.chats.put(chat);


      renderGroupMemberSettings(chat.members);
      document.getElementById('member-settings-modal').classList.remove('visible');
      editingMemberId = null;
    });



    function openMemberEditor(memberId) {
      editingMemberId = memberId;
      const chat = state.chats[state.activeChatId];
      const member = chat.members.find(m => m.id === memberId);
      if (!member) return;

      document.getElementById('member-name-input').value = member.groupNickname;
      document.getElementById('member-persona-input').value = member.persona;



      const memberAvatar = member.avatar || (state.chats[member.id] ? state.chats[member.id].settings.aiAvatar : defaultGroupMemberAvatar);
      document.getElementById('member-avatar-preview').src = memberAvatar;

      document.getElementById('member-settings-modal').classList.add('visible');
    }

    document.getElementById('cancel-member-settings-btn').addEventListener('click', () => {
      document.getElementById('member-settings-modal').classList.remove('visible');
      editingMemberId = null;
    });


    document.getElementById('save-member-settings-btn').addEventListener('click', async () => {
      if (!editingMemberId) return;
      const chat = state.chats[state.activeChatId];
      const member = chat.members.find(m => m.id === editingMemberId);
      if (!member) return;

      const newNickname = document.getElementById('member-name-input').value.trim();
      if (!newNickname) {
        alert("群昵称不能为空！");
        return;
      }
      member.groupNickname = newNickname;
      member.persona = document.getElementById('member-persona-input').value;

      const newAvatarUrl = document.getElementById('member-avatar-preview').src;



      member.avatar = newAvatarUrl;


      const characterProfile = state.chats[member.id];
      if (characterProfile) {
        characterProfile.settings.aiAvatar = newAvatarUrl;
        await db.chats.put(characterProfile);
      }


      await db.chats.put(chat);


      renderGroupMemberSettings(chat.members);
      document.getElementById('member-settings-modal').classList.remove('visible');
      editingMemberId = null;
    });

    document.getElementById('reset-theme-btn').addEventListener('click', () => {
      document.getElementById('theme-default').checked = true;
    });



    document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];


      const oldOfflineModeState = chat.settings.isOfflineMode || false;


      const newName = document.getElementById('chat-name-input').value.trim();
      if (!newName) return alert('备注名/群名不能为空！');
      if (!chat.isGroup && newName !== chat.name) {
        if (!chat.nameHistory) chat.nameHistory = [];
        if (!chat.nameHistory.includes(chat.name)) chat.nameHistory.push(chat.name);
      }
      chat.name = newName;
      const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
      chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';
      chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
      chat.settings.customCss = document.getElementById('custom-css-input').value.trim();
      chat.settings.myPersona = document.getElementById('my-persona').value;
      chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
      chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
      chat.settings.linkedMemoryCount = parseInt(document.getElementById('linked-memory-count').value) || 10;

      const checkedBookItems = document.querySelectorAll('#world-book-checkboxes-container input[type="checkbox"]:checked');
      const newLinkedBookIds = [];
      checkedBookItems.forEach(cb => {
        if (cb.value.startsWith('book_')) {
          newLinkedBookIds.push(cb.value.replace('book_', ''));
        }
      });
      chat.settings.linkedWorldBookIds = newLinkedBookIds;

      const linkMemoryToggleChecked = document.getElementById('link-memory-toggle').checked;
      if (linkMemoryToggleChecked) {
        const checkedChats = document.querySelectorAll('#linked-chats-checkboxes-container input:checked');
        chat.settings.linkedMemoryChatIds = Array.from(checkedChats).map(cb => cb.value);
      } else {
        chat.settings.linkedMemoryChatIds = [];
      }
      chat.settings.enableAutoMemory = document.getElementById('auto-memory-toggle').checked;
      chat.settings.autoMemoryInterval = parseInt(document.getElementById('auto-memory-interval').value) || 20;
      chat.settings.showHiddenMessages = document.getElementById('show-hidden-msg-toggle').checked;
      chat.settings.enableTimePerception = document.getElementById('time-perception-toggle').checked;
      chat.settings.timeZone = document.getElementById('time-zone-select').value;
      chat.settings.lyricsPosition = {
          vertical: document.getElementById('lyrics-vertical-pos').value,
          horizontal: document.getElementById('lyrics-horizontal-pos').value,
          offset: parseInt(document.getElementById('lyrics-offset-input').value) || 10
        };
      chat.settings.enableSynthMusic = document.getElementById('enable-synth-music-switch').checked;
      chat.settings.enableNarratorMode = document.getElementById('narrator-mode-toggle').checked;
      if (chat.isGroup) {
        chat.settings.enableBackgroundActivity = document.getElementById('group-background-activity-switch').checked;
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('group-action-cooldown-input').value) || 10;
      } else {
        chat.settings.enableBackgroundActivity = document.getElementById('char-background-activity-switch').checked;
        chat.settings.enableTodoList = document.getElementById('enable-todo-list-switch').checked;
        const newOfflineModeState = document.getElementById('offline-mode-toggle').checked;
        chat.settings.isOfflineMode = newOfflineModeState;
        const weatherEnabled = document.getElementById('enable-weather-switch').checked;
    const weatherSettings = {
        enabled: weatherEnabled,
        userVirtualCity: document.getElementById('user-virtual-city').value.trim(),
        userRealCity: document.getElementById('user-real-city-search').dataset.realName || chat.settings.weather?.userRealCity || '',
        userLat: parseFloat(document.getElementById('user-city-lat').value) || null,
        userLon: parseFloat(document.getElementById('user-city-lon').value) || null,
        
        charVirtualCity: document.getElementById('char-virtual-city').value.trim(),
        charRealCity: document.getElementById('char-real-city-search').dataset.realName || chat.settings.weather?.charRealCity || '',
        charLat: parseFloat(document.getElementById('char-city-lat').value) || null,
        charLon: parseFloat(document.getElementById('char-city-lon').value) || null
    };
    
    chat.settings.weather = weatherSettings;





        if (oldOfflineModeState === true && newOfflineModeState === false) {


          const switchInstruction = {
            role: 'system',
            content: '[系统指令：模式已切换！你现在回到了线上聊天模式。你的回复【必须】严格遵守线上模式的JSON数组格式，例如 [{"type": "text", "content": "你好"}]]',
            timestamp: Date.now(),
            isHidden: true
          };


          chat.history.push(switchInstruction);
          console.log("已成功注入“切换到线上模式”的系统指令。");
        }


        chat.settings.injectLatestThought = document.getElementById('inject-thought-toggle').checked;
        
        // 新增：保存AI行为控制设置
        const thoughtsValue = document.getElementById('chat-enable-thoughts-select').value;
        if (thoughtsValue === 'null') {
          chat.settings.enableThoughts = null;
        } else {
          chat.settings.enableThoughts = thoughtsValue === 'true';
        }
        
        const qzoneValue = document.getElementById('chat-enable-qzone-actions-select').value;
        if (qzoneValue === 'null') {
          chat.settings.enableQzoneActions = null;
        } else {
          chat.settings.enableQzoneActions = qzoneValue === 'true';
        }
        
        chat.settings.offlineMinLength = parseInt(document.getElementById('offline-min-length-input').value) || 100;
        chat.settings.offlineMaxLength = parseInt(document.getElementById('offline-max-length-input').value) || 300;
        chat.settings.offlinePresetId = document.getElementById('offline-preset-select').value || null;

        // 保存表情包识图设置
        chat.settings.enableStickerVision = document.getElementById('enable-sticker-vision-checkbox').checked;

        const newOriginalName = document.getElementById('ai-original-name-input').value.trim();
        if (!newOriginalName) return alert('对方本名不能为空！');
        chat.originalName = newOriginalName;
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.minimaxVoiceId = document.getElementById('ai-voice-id-input').value.trim();
        
        chat.settings.ttsLanguage = document.getElementById('ai-voice-lang-select').value;
        chat.settings.showSeconds = document.getElementById('chat-show-seconds-switch').checked;
        chat.settings.enableTts = document.getElementById('enable-tts-switch').checked;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.myNickname = document.getElementById('my-nickname-input').value.trim() || '我';
        chat.settings.actionCooldownMinutes = parseInt(document.getElementById('ai-action-cooldown-input').value) || 10;
        
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
      }

      await db.chats.put(chat);
      if (!chat.isGroup) {
        await syncCharacterNameInGroups(chat);
        await syncCharacterAvatarInGroups(chat);
      }
      applyLyricsBarPosition(chat);
      applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
      showScreen('chat-interface-screen');
      renderChatInterface(state.activeChatId);
      renderChatList();
    });

    // ==================== 记忆库功能 ====================
    
    // 保存记忆存档
    document.getElementById('save-memory-archive-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      // 弹出输入框让用户命名
      const archiveName = await showCustomPrompt('保存记忆存档', '请为这个存档命名：', '');
      if (!archiveName || !archiveName.trim()) {
        return; // 用户取消或未输入
      }
      
      try {
        // 创建存档对象
        const archive = {
          id: Date.now(),
          name: archiveName.trim(),
          timestamp: Date.now(),
          chatId: chat.id,
          data: {
            // 聊天记录
            history: JSON.parse(JSON.stringify(chat.history)),
            
            // 人设和头像
            settings: {
              aiPersona: chat.settings.aiPersona,
              aiAvatar: chat.settings.aiAvatar,
              myPersona: chat.settings.myPersona,
              myAvatar: chat.settings.myAvatar,
              myNickname: chat.settings.myNickname,
              
              // 长期记忆
              maxMemory: chat.settings.maxMemory,
              linkedMemoryCount: chat.settings.linkedMemoryCount,
              linkedMemoryChatIds: [...(chat.settings.linkedMemoryChatIds || [])],
              enableAutoMemory: chat.settings.enableAutoMemory,
              autoMemoryInterval: chat.settings.autoMemoryInterval,
              
              // 语音通话
              enableTts: chat.settings.enableTts,
              minimaxVoiceId: chat.settings.minimaxVoiceId,
              ttsLanguage: chat.settings.ttsLanguage,
              
              // 预设
              linkedWorldBookIds: [...(chat.settings.linkedWorldBookIds || [])],
              offlinePresetId: chat.settings.offlinePresetId,
              
              // 其他设置
              theme: chat.settings.theme,
              fontSize: chat.settings.fontSize,
              customCss: chat.settings.customCss,
              enableTimePerception: chat.settings.enableTimePerception,
              timeZone: chat.settings.timeZone,
              enableBackgroundActivity: chat.settings.enableBackgroundActivity,
              actionCooldownMinutes: chat.settings.actionCooldownMinutes,
              enableTodoList: chat.settings.enableTodoList,
              isOfflineMode: chat.settings.isOfflineMode,
              weather: chat.settings.weather ? JSON.parse(JSON.stringify(chat.settings.weather)) : null,
              enableSynthMusic: chat.settings.enableSynthMusic,
              enableNarratorMode: chat.settings.enableNarratorMode,
              showSeconds: chat.settings.showSeconds,
              lyricsPosition: chat.settings.lyricsPosition ? JSON.parse(JSON.stringify(chat.settings.lyricsPosition)) : null
            },
            
            // 角色状态
            heartfeltVoice: chat.heartfeltVoice,
            randomJottings: chat.randomJottings,
            status: chat.status ? JSON.parse(JSON.stringify(chat.status)) : null
          }
        };
        
        // 初始化存档数组
        if (!chat.memoryArchives) {
          chat.memoryArchives = [];
        }
        
        // 添加存档
        chat.memoryArchives.push(archive);
        
        // 保存到数据库
        await db.chats.put(chat);
        
        // 刷新存档列表
        renderMemoryArchiveList();
        
        await showCustomAlert('保存成功', `存档"${archiveName}"已保存！`);
      } catch (error) {
        console.error('保存记忆存档失败:', error);
        await showCustomAlert('保存失败', '保存记忆存档时出错，请重试。');
      }
    });
    
    // 渲染记忆存档列表
    function renderMemoryArchiveList() {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const listContainer = document.getElementById('memory-archive-list');
      
      if (!chat.memoryArchives || chat.memoryArchives.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">暂无存档</div>';
        return;
      }
      
      // 按时间倒序排列
      const archives = [...chat.memoryArchives].sort((a, b) => b.timestamp - a.timestamp);
      
      listContainer.innerHTML = archives.map(archive => {
        const date = new Date(archive.timestamp);
        const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        return `
          <div class="memory-archive-item">
            <div class="memory-archive-info">
              <div class="memory-archive-name">${escapeHTML(archive.name)}</div>
              <div class="memory-archive-date">${dateStr}</div>
            </div>
            <div class="memory-archive-actions">
              <button class="memory-archive-btn load" data-archive-id="${archive.id}">读档</button>
              <button class="memory-archive-btn delete" data-archive-id="${archive.id}">删除</button>
            </div>
          </div>
        `;
      }).join('');
      
      // 绑定读档按钮事件
      listContainer.querySelectorAll('.memory-archive-btn.load').forEach(btn => {
        btn.addEventListener('click', async () => {
          const archiveId = parseInt(btn.dataset.archiveId);
          await loadMemoryArchive(archiveId);
        });
      });
      
      // 绑定删除按钮事件
      listContainer.querySelectorAll('.memory-archive-btn.delete').forEach(btn => {
        btn.addEventListener('click', async () => {
          const archiveId = parseInt(btn.dataset.archiveId);
          await deleteMemoryArchive(archiveId);
        });
      });
    }
    
    // 读取记忆存档
    async function loadMemoryArchive(archiveId) {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      const archive = chat.memoryArchives.find(a => a.id === archiveId);
      if (!archive) {
        await showCustomAlert('错误', '找不到该存档');
        return;
      }
      
      const confirmed = await showCustomConfirm(
        '读取存档',
        `确定要读取存档"${archive.name}"吗？\n\n当前的聊天记录和所有设置将被完全覆盖！`,
        { confirmButtonClass: 'btn-danger' }
      );
      
      if (!confirmed) return;
      
      try {
        // 恢复聊天记录
        chat.history = JSON.parse(JSON.stringify(archive.data.history));
        
        // 恢复所有设置
        const savedSettings = archive.data.settings;
        chat.settings.aiPersona = savedSettings.aiPersona;
        chat.settings.aiAvatar = savedSettings.aiAvatar;
        chat.settings.myPersona = savedSettings.myPersona;
        chat.settings.myAvatar = savedSettings.myAvatar;
        chat.settings.myNickname = savedSettings.myNickname;
        chat.settings.maxMemory = savedSettings.maxMemory;
        chat.settings.linkedMemoryCount = savedSettings.linkedMemoryCount;
        chat.settings.linkedMemoryChatIds = [...(savedSettings.linkedMemoryChatIds || [])];
        chat.settings.enableAutoMemory = savedSettings.enableAutoMemory;
        chat.settings.autoMemoryInterval = savedSettings.autoMemoryInterval;
        chat.settings.enableTts = savedSettings.enableTts;
        chat.settings.minimaxVoiceId = savedSettings.minimaxVoiceId;
        chat.settings.ttsLanguage = savedSettings.ttsLanguage;
        chat.settings.linkedWorldBookIds = [...(savedSettings.linkedWorldBookIds || [])];
        chat.settings.offlinePresetId = savedSettings.offlinePresetId;
        chat.settings.theme = savedSettings.theme;
        chat.settings.fontSize = savedSettings.fontSize;
        chat.settings.customCss = savedSettings.customCss;
        chat.settings.enableTimePerception = savedSettings.enableTimePerception;
        chat.settings.timeZone = savedSettings.timeZone;
        chat.settings.enableBackgroundActivity = savedSettings.enableBackgroundActivity;
        chat.settings.actionCooldownMinutes = savedSettings.actionCooldownMinutes;
        chat.settings.enableTodoList = savedSettings.enableTodoList;
        chat.settings.isOfflineMode = savedSettings.isOfflineMode;
        chat.settings.weather = savedSettings.weather ? JSON.parse(JSON.stringify(savedSettings.weather)) : null;
        chat.settings.enableSynthMusic = savedSettings.enableSynthMusic;
        chat.settings.enableNarratorMode = savedSettings.enableNarratorMode;
        chat.settings.showSeconds = savedSettings.showSeconds;
        chat.settings.lyricsPosition = savedSettings.lyricsPosition ? JSON.parse(JSON.stringify(savedSettings.lyricsPosition)) : null;
        
        // 恢复角色状态
        chat.heartfeltVoice = archive.data.heartfeltVoice;
        chat.randomJottings = archive.data.randomJottings;
        chat.status = archive.data.status ? JSON.parse(JSON.stringify(archive.data.status)) : null;
        
        // 保存到数据库
        await db.chats.put(chat);
        
        // 刷新界面
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 如果在设置页面，也刷新设置页面
        const settingsModalElement = document.getElementById('chat-settings-modal');
        if (settingsModalElement && settingsModalElement.classList.contains('visible')) {
          showScreen('chat-interface-screen');
          setTimeout(() => {
            openChatSettings();
          }, 100);
        }
        
        await showCustomAlert('读档成功', `已成功读取存档"${archive.name}"！`);
      } catch (error) {
        console.error('读取记忆存档失败:', error);
        await showCustomAlert('读档失败', '读取记忆存档时出错，请重试。');
      }
    }
    
    // 删除记忆存档
    async function deleteMemoryArchive(archiveId) {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      
      const archive = chat.memoryArchives.find(a => a.id === archiveId);
      if (!archive) {
        await showCustomAlert('错误', '找不到该存档');
        return;
      }
      
      const confirmed = await showCustomConfirm(
        '删除存档',
        `确定要删除存档"${archive.name}"吗？\n\n此操作无法撤销！`,
        { confirmButtonClass: 'btn-danger' }
      );
      
      if (!confirmed) return;
      
      try {
        // 从数组中移除
        chat.memoryArchives = chat.memoryArchives.filter(a => a.id !== archiveId);
        
        // 保存到数据库
        await db.chats.put(chat);
        
        // 刷新列表
        renderMemoryArchiveList();
        
        await showCustomAlert('删除成功', `存档"${archive.name}"已删除！`);
      } catch (error) {
        console.error('删除记忆存档失败:', error);
        await showCustomAlert('删除失败', '删除记忆存档时出错，请重试。');
      }
    }
    
    // ==================== 记忆库功能结束 ====================








    document.getElementById('chat-settings-screen').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('chat');
      }
    });


    document.getElementById('member-settings-modal').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('member');
      }
    });


    const frameModal = document.getElementById('avatar-frame-modal');
    const aiFrameTab = document.getElementById('ai-frame-tab');
    const myFrameTab = document.getElementById('my-frame-tab');
    const aiFrameContent = document.getElementById('ai-frame-content');
    const myFrameContent = document.getElementById('my-frame-content');


    document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);


    document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
      frameModal.classList.remove('visible');
      editingFrameForMember = false;
    });


    aiFrameTab.addEventListener('click', () => {
      aiFrameTab.classList.add('active');
      myFrameTab.classList.remove('active');
      aiFrameContent.style.display = 'block';
      myFrameContent.style.display = 'none';
    });


    myFrameTab.addEventListener('click', () => {
      myFrameTab.classList.add('active');
      aiFrameTab.classList.remove('active');
      myFrameContent.style.display = 'block';
      aiFrameContent.style.display = 'none';
    });


    document.getElementById('clear-chat-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];
      const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        chat.history = [];
        chat.heartfeltVoice = '...';
        chat.randomJottings = '...';
        // 重置角色状态为默认的"在线"
        if (!chat.isGroup && chat.status) {
          chat.status.text = '在线';
          chat.status.isBusy = false;
          chat.status.lastUpdate = Date.now();
        }
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        renderChatList();
        chatSettingsModal.classList.remove('visible');
      }
    });

    const setupFileUpload = (inputId, callback) => {
      document.getElementById(inputId).addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
          const dataUrl = await new Promise((res, rej) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.onerror = () => rej(reader.error);
            reader.readAsDataURL(file);
          });
          callback(dataUrl);
          event.target.value = null;
        }
      });
    };
    setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
    setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
    setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
    setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
    setupFileUpload('bg-input', async (base64) => {
      if (state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 立即保存和显示
        chat.settings.background = base64;
        const bgPreview = document.getElementById('bg-preview');
        bgPreview.src = base64;
        bgPreview.style.display = 'block';
        document.getElementById('remove-bg-btn').style.display = 'inline-block';
        
        await showCustomAlert("成功", "聊天背景已更新！\n\n图片将在后台静默上传到图床... (保存设置后生效)");

        // 2. 启动静默上传
        (async () => {
            await silentlyUpdateDbUrl(
                db.chats,
                chat.id,
                'settings.background',
                base64
            );
        })();
      }
    });
    setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
    document.getElementById('remove-bg-btn').addEventListener('click', () => {
      if (state.activeChatId) {
        state.chats[state.activeChatId].settings.background = '';
        const bgPreview = document.getElementById('bg-preview');
        bgPreview.src = '';
        bgPreview.style.display = 'none';
        document.getElementById('remove-bg-btn').style.display = 'none';
      }
    });

    const stickerPanel = document.getElementById('sticker-panel');
    document.getElementById('open-sticker-panel-btn').addEventListener('click', () => {
      const chat = state.chats[state.activeChatId];
      if (chat && chat.settings.stickerCategoryId) {

        activeStickerCategoryId = chat.settings.stickerCategoryId;
      } else {

        activeStickerCategoryId = 'all';
      }
      renderStickerPanel();
      stickerPanel.classList.add('visible');
    });
    document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));



    document.getElementById('add-sticker-batch-btn').addEventListener('click', openBatchStickerImportModal);






    document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());
    document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = async () => {
        let base64Url = reader.result;
        const name = await showCustomPrompt("命名表情", "请为这个表情命名 (例如：好耶、疑惑)");

        if (name && name.trim()) {
            const trimmedName = name.trim();
            
            const newSticker = {
    id: 'sticker_' + Date.now() + Math.random(), // <-- Add this line
    url: base64Url, 
    name: trimmedName,
    categoryId: (activeStickerCategoryId !== 'all' && activeStickerCategoryId !== 'uncategorized') ? activeStickerCategoryId : null
};
            const newId = await db.userStickers.add(newSticker); // 1. Save to DB
            
            newSticker.id = newId; 
            state.userStickers.push(newSticker); // 2. Update state
            
            renderStickerPanel(); // 3. Render UI
            await showCustomAlert("添加成功！", `表情“${trimmedName}”已添加。\n\n图片将在后台静默上传到图床...`);

            // 4. 【【【已修复的调用】】】
            (async () => {
                await silentlyUpdateDbUrl(
                    db.userStickers, // table
                    newId, // recordId
                    'url', // pathString (指向简单属性)
                    base64Url // base64ToFind
                    // nameToMatch (不需要)
                );
            })();

        } else if (name !== null) {
             alert("表情名不能为空！");
        }
      };
      event.target.value = null;
    });

    document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
   document.getElementById('image-upload-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file || !state.activeChatId) return;
      const reader = new FileReader();
      reader.onload = async (e) => {
        const base64Url = e.target.result;
        const chat = state.chats[state.activeChatId];
        const msg = {
          role: 'user',
          content: [{
            type: 'image_url',
            image_url: {
              url: base64Url
            }
          }],
          timestamp: Date.now()
        };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      };
      reader.readAsDataURL(file);
      event.target.value = null;
    });
    document.getElementById('voice-message-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;

      const text = await showCustomPrompt("发送语音", "请输入你想说的内容：");
      if (text && text.trim()) {
        const chat = state.chats[state.activeChatId];


        const msg = {
          role: 'user',
          type: 'voice_message',
          content: text.trim(),
          timestamp: Date.now()
        };

        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      }
    });
    document.getElementById('send-photo-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片：");
      if (description && description.trim()) {
        const chat = state.chats[state.activeChatId];
        const msg = {
          role: 'user',
          type: 'user_photo',
          content: description.trim(),
          timestamp: Date.now()
        };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        renderChatList();
      }
    });

    const waimaiModal = document.getElementById('waimai-request-modal');


    document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
      waimaiModal.classList.add('visible');
    });


    waimaiModal.addEventListener('click', (e) => {

      if (e.target === waimaiModal) {
        waimaiModal.classList.remove('visible');
      }
    });


    document.getElementById('waimai-order-for-ai-btn').addEventListener('click', sendWaimaiOrderForAI);


    document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;

      const productInfoInput = document.getElementById('waimai-product-info');
      const amountInput = document.getElementById('waimai-amount');

      const productInfo = productInfoInput.value.trim();
      const amount = parseFloat(amountInput.value);

      if (!productInfo || isNaN(amount) || amount <= 0) {
        alert('请填写有效的商品信息和金额！');
        return;
      }

      const chat = state.chats[state.activeChatId];
      const now = Date.now();
      const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

      const msg = {
        role: 'user',
        senderName: myNickname,
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
      };

      chat.history.push(msg);
      await db.chats.put(chat);
      appendMessage(msg, chat);
      renderChatList();

      productInfoInput.value = '';
      amountInput.value = '';
      waimaiModal.classList.remove('visible');
    });
    document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
    document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
    document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
    document.getElementById('manage-persona-preset-btn').addEventListener('click', enterManageMode);
    document.getElementById('select-all-persona-btn').addEventListener('click', selectAllPresets);
    document.getElementById('delete-selected-persona-btn').addEventListener('click', deleteSelectedPresets);
    document.getElementById('cancel-manage-persona-btn').addEventListener('click', exitManageMode);
    document.getElementById('import-tavern-persona-btn').addEventListener('click', importTavernPersonas);
    document.getElementById('import-tavern-persona-input').addEventListener('change', handleTavernPersonaImport);
    document.getElementById('cancel-tavern-import-btn').addEventListener('click', closeTavernPersonaSelector);
    document.getElementById('confirm-tavern-import-btn').addEventListener('click', confirmTavernImport);
    document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);
    document.getElementById('save-persona-preset-btn').addEventListener('click', savePersonaPreset);
    document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
    document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
    document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);

    document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);




    document.getElementById('selection-soft-delete-btn').addEventListener('click', async () => {
      if (selectedMessages.size === 0) return;
      const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这会通知AI这些消息已被删除。`, {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        const chat = state.chats[state.activeChatId];
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
          const msg = chat.history.find(m => m.timestamp === timestamp);
          if (msg && msg.type === 'poll') {
            deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
          }
        }
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        let forgetReason = "一些之前的消息已被用户删除。";
        if (deletedPollsInfo.length > 0) {
          forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
        }
        forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";
        const forgetInstruction = {
          role: 'system',
          content: `[系统提示：${forgetReason}]`,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(forgetInstruction);
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        renderChatList();
      }
    });


    document.getElementById('selection-erase-btn').addEventListener('click', async () => {
      if (selectedMessages.size === 0) return;
      const confirmed = await showCustomConfirm(
        '彻底删除消息',
        `这将从历史记录中【永久抹除】这 ${selectedMessages.size} 条消息，AI将完全遗忘它们的存在。确定吗？`, {
          confirmButtonClass: 'btn-danger',
          confirmText: '确认抹除'
        }
      );
      if (confirmed) {
        const chat = state.chats[state.activeChatId];


        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));


        await db.chats.put(chat);


        renderChatInterface(state.activeChatId);
        renderChatList();
      }
    });


    const fontUrlInput = document.getElementById('font-url-input');
    fontUrlInput.addEventListener('input', () => applyCustomFont(fontUrlInput.value.trim(), true));
    document.getElementById('save-font-btn').addEventListener('click', async () => {
      const newFontUrl = fontUrlInput.value.trim();
      if (!newFontUrl) {
        alert("请输入有效的字体URL。");
        return;
      }
      applyCustomFont(newFontUrl, false);
      state.globalSettings.fontUrl = newFontUrl;
      await db.globalSettings.put(state.globalSettings);
      alert('字体已保存并应用！');
    });
    document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

    document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
      item.addEventListener('click', () => switchToChatListView(item.dataset.view));
    });
    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
    document.getElementById('qzone-nickname').addEventListener('click', async () => {
      const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname);
      if (newNickname && newNickname.trim()) {
        state.qzoneSettings.nickname = newNickname.trim();
        await saveQzoneSettings();
        renderQzoneScreen();
      }
    });
    document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
    document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
    document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise(res => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.readAsDataURL(file);
        });
        state.qzoneSettings.avatar = dataUrl;
        await saveQzoneSettings();
        renderQzoneScreen();
      }
      event.target.value = null;
    });
    document.getElementById('qzone-banner-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise(res => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.readAsDataURL(file);
        });
        state.qzoneSettings.banner = dataUrl;
        await saveQzoneSettings();
        renderQzoneScreen();
      }
      event.target.value = null;
    });


    document.getElementById('create-shuoshuo-btn').addEventListener('click', async () => {

      resetCreatePostModal();
      const modal = document.getElementById('create-post-modal');


      modal.dataset.mode = 'shuoshuo';


      modal.querySelector('.post-mode-switcher').style.display = 'none';
      modal.querySelector('#image-mode-content').style.display = 'none';
      modal.querySelector('#text-image-mode-content').style.display = 'none';


      modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';


      const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
      visibilityGroupsContainer.innerHTML = '';
      const groups = await db.qzoneGroups.toArray();
      if (groups.length > 0) {
        groups.forEach(group => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
          visibilityGroupsContainer.appendChild(label);
        });
      } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
      }
      modal.classList.add('visible');
    });


    document.getElementById('create-post-btn').addEventListener('click', async () => {

      resetCreatePostModal();
      const modal = document.getElementById('create-post-modal');


      modal.dataset.mode = 'complex';


      modal.querySelector('.post-mode-switcher').style.display = 'flex';

      modal.querySelector('#image-mode-content').classList.add('active');

      modal.querySelector('#text-image-mode-content').classList.remove('active');


      modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';


      const visibilityGroupsContainer = document.getElementById('post-visibility-groups');
      visibilityGroupsContainer.innerHTML = '';
      const groups = await db.qzoneGroups.toArray();
      if (groups.length > 0) {
        groups.forEach(group => {
          const label = document.createElement('label');
          label.style.display = 'block';
          label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
          visibilityGroupsContainer.appendChild(label);
        });
      } else {
        visibilityGroupsContainer.innerHTML = '<p style="color: var(--text-secondary);">没有可用的分组</p>';
      }
      modal.classList.add('visible');
    });
    document.getElementById('open-album-btn').addEventListener('click', async () => {
      await renderAlbumList();
      showScreen('album-screen');
    });
    document.getElementById('album-back-btn').addEventListener('click', () => {
      showScreen('chat-list-screen');
      switchToChatListView('qzone-screen');
    });



    document.getElementById('album-photos-back-btn').addEventListener('click', () => {
      state.activeAlbumId = null;
      showScreen('album-screen');
    });

    document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

    document.getElementById('album-photo-input').addEventListener('change', async (event) => {
      if (!state.activeAlbumId) return;
      const files = event.target.files;
      if (!files.length) return;

      const album = await db.qzoneAlbums.get(state.activeAlbumId);

      for (const file of files) {
        const dataUrl = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({
          albumId: state.activeAlbumId,
          url: dataUrl,
          createdAt: Date.now()
        });
      }

      const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
      const updateData = {
        photoCount
      };

      if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if (firstPhoto) updateData.coverUrl = firstPhoto.url;
      }

      await db.qzoneAlbums.update(state.activeAlbumId, updateData);
      await renderAlbumPhotosScreen();
      await renderAlbumList();

      event.target.value = null;
      alert('照片上传成功！');
    });





    document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
      const deleteBtn = e.target.closest('.photo-delete-btn');
      const photoThumb = e.target.closest('.photo-thumb');

      if (deleteBtn) {
        e.stopPropagation();
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
          '删除照片',
          '确定要删除这张照片吗？此操作不可恢复。', {
            confirmButtonClass: 'btn-danger'
          }
        );

        if (confirmed) {
          const deletedPhoto = await db.qzonePhotos.get(photoId);
          if (!deletedPhoto) return;

          await db.qzonePhotos.delete(photoId);

          const album = await db.qzoneAlbums.get(state.activeAlbumId);
          const photoCount = (album.photoCount || 1) - 1;
          const updateData = {
            photoCount
          };

          if (album.coverUrl === deletedPhoto.url) {
            const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
            updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
          }

          await db.qzoneAlbums.update(state.activeAlbumId, updateData);
          await renderAlbumPhotosScreen();
          await renderAlbumList();
          alert('照片已删除。');
        }
      } else if (photoThumb) {

        openPhotoViewer(photoThumb.src);
      }
    });


    document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
    document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
    document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);


    document.addEventListener('keydown', (e) => {
      if (!photoViewerState.isOpen) return;

      if (e.key === 'ArrowRight') {
        showNextPhoto();
      } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
      } else if (e.key === 'Escape') {
        closePhotoViewer();
      }
    });



    document.getElementById('create-album-btn-page').addEventListener('click', async () => {
      const albumName = await showCustomPrompt("创建新相册", "请输入相册名称");
      if (albumName && albumName.trim()) {
        const newAlbum = {
          name: albumName.trim(),
          coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
          photoCount: 0,
          createdAt: Date.now()
        };
        await db.qzoneAlbums.add(newAlbum);
        await renderAlbumList();
        alert(`相册 "${albumName}" 创建成功！`);
      } else if (albumName !== null) {
        alert("相册名称不能为空！");
      }
    });

    document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
    document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
    document.getElementById('post-local-image-input').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          document.getElementById('post-image-preview').src = e.target.result;
          document.getElementById('post-image-preview-container').classList.add('visible');
          document.getElementById('post-image-desc-group').style.display = 'block';
        };
        reader.readAsDataURL(file);
      }
    });
    document.getElementById('post-use-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url");
      if (url) {
        document.getElementById('post-image-preview').src = url;
        document.getElementById('post-image-preview-container').classList.add('visible');
        document.getElementById('post-image-desc-group').style.display = 'block';
      }
    });
    document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
    const imageModeBtn = document.getElementById('switch-to-image-mode');
    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    imageModeBtn.addEventListener('click', () => {
      imageModeBtn.classList.add('active');
      textImageModeBtn.classList.remove('active');
      imageModeContent.classList.add('active');
      textImageModeContent.classList.remove('active');
    });
    textImageModeBtn.addEventListener('click', () => {
      textImageModeBtn.classList.add('active');
      imageModeBtn.classList.remove('active');
      textImageModeContent.classList.add('active');
      imageModeContent.classList.remove('active');
    });


    document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
      const modal = document.getElementById('create-post-modal');
      const mode = modal.dataset.mode;


      const visibilityMode = document.querySelector('input[name="visibility"]:checked').value;
      let visibleGroupIds = null;

      if (visibilityMode === 'include') {
        visibleGroupIds = Array.from(document.querySelectorAll('input[name="visibility_group"]:checked')).map(cb => parseInt(cb.value));
      }

      let newPost = {};
      const basePostData = {
        timestamp: Date.now(),
        authorId: 'user',

        visibleGroupIds: visibleGroupIds,
      };


      if (mode === 'shuoshuo') {
        const content = document.getElementById('post-public-text').value.trim();
        if (!content) {
          alert('说说内容不能为空哦！');
          return;
        }
        newPost = {
          ...basePostData,
          type: 'shuoshuo',
          content: content,
        };

      } else {
        const publicText = document.getElementById('post-public-text').value.trim();
        const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

        if (isImageModeActive) {
          const imageUrl = document.getElementById('post-image-preview').src;
          const imageDescription = document.getElementById('post-image-description').value.trim();
          if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) {
            alert('请先添加一张图片再发布动态哦！');
            return;
          }
          if (!imageDescription) {
            alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
            return;
          }
          newPost = {
            ...basePostData,
            type: 'image_post',
            publicText: publicText,
            imageUrl: imageUrl,
            imageDescription: imageDescription,
          };
        } else {
          const hiddenText = document.getElementById('post-hidden-text').value.trim();
          if (!hiddenText) {
            alert('请输入文字图描述！');
            return;
          }
          newPost = {
            ...basePostData,
            type: 'text_image',
            publicText: publicText,
            hiddenContent: hiddenText,
          };
        }
      }


      const newPostId = await db.qzonePosts.add(newPost);
      let postSummary = newPost.content || newPost.publicText || newPost.imageDescription || newPost.hiddenContent || "（无文字内容）";
      postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');


      for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue;

        let shouldNotify = false;
        const postVisibleGroups = newPost.visibleGroupIds;


        if (!postVisibleGroups || postVisibleGroups.length === 0) {
          shouldNotify = true;
        } else if (chat.groupId && postVisibleGroups.includes(chat.groupId)) {
          shouldNotify = true;
        }


        if (shouldNotify) {

          const historyMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。请你【结合自己的角色设定、世界观和你们的最近聊天内容】，对这条动态发表一条自然的评论。]`,
            timestamp: Date.now(),
            isHidden: true
          };

          chat.history.push(historyMessage);
          await db.chats.put(chat);
        }
      }


      await renderQzonePosts();
      modal.classList.remove('visible');
      alert('动态发布成功！');
    });



    const postsList = document.getElementById('qzone-posts-list');
    let swipeState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      currentX: 0,
      activeContainer: null,
      swipeDirection: null,
      isClick: true
    };

    function resetAllSwipes(exceptThisOne = null) {
      document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
          container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
      });
    }

 
    async function handlePostClick(e) {
      e.stopPropagation();
      const target = e.target;


      const deleteBtn = target.closest('.comment-delete-btn');
      if (deleteBtn) {
        const postContainer = deleteBtn.closest('.qzone-post-container');
        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(deleteBtn.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;

        const post = qzonePostsCache.find(p => p.id === postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;



        const deletedComment = post.comments[commentIndex];

        const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {

          post.comments.splice(commentIndex, 1);
          await db.qzonePosts.update(postId, {
            comments: post.comments
          });




          if (deletedComment && deletedComment.commenterName === state.qzoneSettings.nickname) {
            console.log("用户删除了自己的评论，开始清理AI记忆...");


            const aiToNotifyIds = new Set();
            if (post.authorId !== 'user') {
              aiToNotifyIds.add(post.authorId);
            }
            if (deletedComment.replyTo) {
              const repliedToChat = Object.values(state.chats).find(c => c.originalName === deletedComment.replyTo);
              if (repliedToChat) {
                aiToNotifyIds.add(repliedToChat.id);
              }
            }


            const postSummary = (post.publicText || post.content || '').substring(0, 30);
            const userNickname = state.qzoneSettings.nickname;
            let notificationText;
            const stickerMatch = state.userStickers.find(s => s.url === deletedComment.text);

            if (stickerMatch) {
              notificationText = `用户'${userNickname}'刚刚在你的动态“${postSummary}”下，发送了一个表情评论，意思是：“${stickerMatch.name}”。`;
            } else if (deletedComment.replyTo) {
              const repliedToDisplayName = getDisplayNameByOriginalName(deletedComment.replyTo);
              notificationText = `用户'${userNickname}'刚刚在你的动态“${postSummary}”下，回复了'${repliedToDisplayName}'的评论，内容是：“${deletedComment.text}”。`;
            } else {
              notificationText = `用户'${userNickname}'刚刚评论了你的动态“${postSummary}”，内容是：“${deletedComment.text}”。`;
            }
            const fullSystemContent = `[系统提示：${notificationText}请你对此作出回应。]`;


            for (const aiId of aiToNotifyIds) {
              const chat = state.chats[aiId];
              if (chat) {
                const originalLength = chat.history.length;

                chat.history = chat.history.filter(msg =>
                  !(msg.isHidden && msg.role === 'system' && msg.content === fullSystemContent)
                );

                if (chat.history.length < originalLength) {
                  console.log(`在角色 "${chat.name}" 的记忆中清除了1条关于已删除评论的通知。`);
                  await db.chats.put(chat);
                }
              }
            }
          }


          await updateSinglePostInDOM(postId);
        }

        return;
      }


      const stickerBtn = target.closest('.comment-sticker-btn');
      if (stickerBtn) {
        const postContainer = stickerBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (qzoneStickerPanelState.isOpen && qzoneStickerPanelState.activePostId === postId) {
          closeQzoneStickerPanel();
        } else {
          openQzoneStickerPanel(postId, stickerBtn);
        }
        return;
      }
      const commentItem = target.closest('.comment-item');
      if (commentItem) {
        const postId = parseInt(commentItem.dataset.postId);
        const commenterOriginalName = commentItem.dataset.commenterOriginalName;
        const commenterDisplayName = commentItem.dataset.commenterDisplayName;

        if (!commenterOriginalName || !commenterDisplayName || commenterOriginalName === state.qzoneSettings.nickname) {
          clearQzoneReplyContext(commentItem.closest('.qzone-post-container'));
          return;
        }
        currentQzoneReplyContext = {
          postId,
          replyToName: commenterOriginalName,
          replyToDisplayName: commenterDisplayName
        };
        const postContainer = commentItem.closest('.qzone-post-container');
        const commentInput = postContainer.querySelector('.comment-input');
        commentInput.placeholder = `回复 ${commenterDisplayName}:`;
        commentInput.focus();
        return;
      }
      if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
        return;
      }
      if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
        return;
      }


      const postContainer = target.closest('.qzone-post-container');
      if (!postContainer) return;
      const postId = parseInt(postContainer.dataset.postId);
      if (isNaN(postId)) return;

      if (target.closest('.qzone-post-delete-action')) {
        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', {
          confirmButtonClass: 'btn-danger'
        });
        if (confirmed) {
          postContainer.style.transition = 'all 0.3s ease';
          postContainer.style.transform = 'scale(0.8)';
          postContainer.style.opacity = '0';
          setTimeout(async () => {
            await db.qzonePosts.delete(postId);
            const notificationIdentifier = `(ID: ${postId})`;
            for (const chatId in state.chats) {
              const chat = state.chats[chatId];
              const originalHistoryLength = chat.history.length;
              chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
              if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
            }
            await renderQzonePosts();
            alert('动态已删除。');
          }, 300);
        }
        return;
      }

      const icon = target.closest('.action-icon');
      if (icon) {
        if (icon.classList.contains('repost')) {
          openRepostModal(postId);
          return;
        }
        if (icon.classList.contains('like')) {
          const post = qzonePostsCache.find(p => p.id === postId);
          if (!post) return;
          if (!post.likes) post.likes = [];
          const userOriginalName = state.qzoneSettings.nickname;
          const userLikeIndex = post.likes.indexOf(userOriginalName);
          if (userLikeIndex > -1) {
            post.likes.splice(userLikeIndex, 1);
          } else {
            post.likes.push(userOriginalName);
            icon.classList.add('animate-like');
            icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), {
              once: true
            });
          }
          await db.qzonePosts.update(postId, {
            likes: post.likes
          });
          await updateSinglePostInDOM(postId);
        }
        if (icon.classList.contains('favorite')) {
          const existingFavorite = await db.favorites.where({
            type: 'qzone_post',
            'content.id': postId
          }).first();
          if (existingFavorite) {
            await db.favorites.delete(existingFavorite.id);
            await showCustomAlert('提示', '已取消收藏');
          } else {
            const postToSave = await db.qzonePosts.get(postId);
            if (postToSave) {
              await db.favorites.add({
                type: 'qzone_post',
                content: postToSave,
                timestamp: Date.now()
              });
              await showCustomAlert('提示', '收藏成功！');
            }
          }
          await updateSinglePostInDOM(postId);
        }
        return;
      }

      const sendBtn = target.closest('.comment-send-btn');
      if (sendBtn) {
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('评论内容不能为空哦！');

        const post = qzonePostsCache.find(p => p.id === postId);
        if (!post) return;

        if (!post.comments) post.comments = [];

        const newComment = {
          commenterName: state.qzoneSettings.nickname,
          text: commentText,
          timestamp: Date.now(),
          replyTo: (currentQzoneReplyContext && currentQzoneReplyContext.postId === postId) ? currentQzoneReplyContext.replyToName : null
        };

        post.comments.push(newComment);
        await db.qzonePosts.update(postId, {
          comments: post.comments
        });

        let postSummary = (post.publicText || post.content || '').substring(0, 30);
        const userNickname = state.qzoneSettings.nickname;
        const notifiedAiIds = new Set();
        if (post.authorId !== 'user') notifiedAiIds.add(post.authorId);
        if (newComment.replyTo && newComment.replyTo !== userNickname) {
          const repliedToChat = Object.values(state.chats).find(c => c.originalName === newComment.replyTo);
          if (repliedToChat) notifiedAiIds.add(repliedToChat.id);
        }
        for (const aiId of notifiedAiIds) {
          const chat = state.chats[aiId];
          if (chat && !chat.isGroup) {
            const stickerMatch = state.userStickers.find(s => s.url === commentText);
            let notificationText = stickerMatch ? `用户'${userNickname}'刚刚在你的动态“${postSummary}”下，发送了一个表情评论，意思是：“${stickerMatch.name}”。` :
              newComment.replyTo ? `用户'${userNickname}'刚刚在你的动态“${postSummary}”下，回复了'${currentQzoneReplyContext.replyToDisplayName}'的评论，内容是：“${commentText}”。` :
              `用户'${userNickname}'刚刚评论了你的动态“${postSummary}”，内容是：“${commentText}”。`;
            const historyMessage = {
              role: 'system',
              content: `[系统提示：${notificationText}请你对此作出回应。]`,
              timestamp: Date.now(),
              isHidden: true
            };
            chat.history.push(historyMessage);
            await db.chats.put(chat);
          }
        }

        commentInput.value = '';
        clearQzoneReplyContext(postContainer);
        await updateSinglePostInDOM(postId);
        return;
      }
    }






    const handleSwipeStart = (e) => {
      const target = e.target;

      if (target.closest('.post-footer, .post-feedback-icons, .post-actions-btn, .post-comments-container, .reposted-content-wrapper')) {
        return;
      }
      const targetContainer = e.target.closest('.qzone-post-container');
      if (!targetContainer) return;

      resetAllSwipes(targetContainer);
      swipeState.activeContainer = targetContainer;
      swipeState.isDragging = true;
      swipeState.isClick = true;
      swipeState.swipeDirection = null;
      swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';


      document.addEventListener('mousemove', handleSwipeMove);
      document.addEventListener('mouseup', handleSwipeEnd);
      document.addEventListener('touchmove', handleSwipeMove, {
        passive: false
      });
      document.addEventListener('touchend', handleSwipeEnd);
    };


    const handleSwipeMove = (e) => {
      if (!swipeState.isDragging || !swipeState.activeContainer) return;

      const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
      const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
      const diffX = currentX - swipeState.startX;
      const diffY = currentY - swipeState.startY;

      if (swipeState.isClick && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
        swipeState.isClick = false;
      }

      if (!swipeState.swipeDirection) {
        if (Math.abs(diffX) > Math.abs(diffY)) {
          swipeState.swipeDirection = 'horizontal';
        } else {
          swipeState.swipeDirection = 'vertical';
        }
      }

      if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = Math.min(0, Math.max(-90, diffX));
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
      }
    };


    const handleSwipeEnd = (e) => {

      document.removeEventListener('mousemove', handleSwipeMove);
      document.removeEventListener('mouseup', handleSwipeEnd);
      document.removeEventListener('touchmove', handleSwipeMove);
      document.removeEventListener('touchend', handleSwipeEnd);

      if (!swipeState.isDragging || !swipeState.activeContainer) return;

      const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
      postItem.style.transition = 'transform 0.3s ease';

      if (swipeState.swipeDirection === 'horizontal' && !swipeState.isClick) {
        const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
        const diffX = finalX - swipeState.startX;
        if (diffX < -40) {
          postItem.classList.add('swiped');
        } else {
          postItem.classList.remove('swiped');
        }
      }

      postItem.style.transform = '';


      swipeState.isDragging = false;
      swipeState.activeContainer = null;
      swipeState.swipeDirection = null;
      swipeState.isClick = true;
    };











    postsList.addEventListener('click', handlePostClick);
    postsList.addEventListener('mousedown', handleSwipeStart);
    postsList.addEventListener('touchstart', handleSwipeStart, {
      passive: true
    });



    postsList.addEventListener('click', (e) => {

      if (e.target && e.target.id === 'load-more-qzone-btn') {
        loadMoreQzonePosts();
      }
    });


    document.getElementById('refine-memory-btn-header').addEventListener('click', () => {
      if (state.activeChatId) {
        summarizeExistingLongTermMemory(state.activeChatId);
      }
    });

    document.getElementById('api-preset-select').addEventListener('change', handlePresetSelectionChange);
    document.getElementById('save-api-preset-btn').addEventListener('click', saveApiPreset);
    document.getElementById('delete-api-preset-btn').addEventListener('click', deleteApiPreset);


    document.getElementById('add-world-book-entry-btn').addEventListener('click', () => {
      const container = document.getElementById('world-book-entries-container');

      if (container.querySelector('p')) {
        container.innerHTML = '';
      }
      const newBlock = createWorldBookEntryBlock();
      container.appendChild(newBlock);
      newBlock.querySelector('.entry-content-textarea').focus();
    });


    document.getElementById('switch-greeting-btn').addEventListener('click', handleSwitchGreeting);

    document.getElementById('thoughts-history-list').addEventListener('click', (e) => {
      if (e.target && e.target.id === 'load-more-thoughts-btn') {
        loadMoreThoughts();
      }
    });




    document.getElementById('profile-history-icon-btn').addEventListener('click', showThoughtsHistory);

    document.getElementById('history-back-btn').addEventListener('click', hideThoughtsHistory);
    document.getElementById('character-profile-modal').addEventListener('click', (e) => {

      if (e.target.id === 'character-profile-modal') {
        e.target.classList.remove('visible');
      }
    });

    document.getElementById('manage-stickers-btn').addEventListener('click', toggleStickerManagementMode);
    document.getElementById('delete-selected-stickers-btn').addEventListener('click', executeBatchDeleteStickers);
    document.getElementById('export-selected-stickers-btn').addEventListener('click', executeBatchExportStickers);

    document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
    document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));






    const searchInput = document.getElementById('favorites-search-input');
    const searchClearBtn = document.getElementById('favorites-search-clear-btn');

    searchInput.addEventListener('input', () => {
      const searchTerm = searchInput.value.trim().toLowerCase();


      searchClearBtn.style.display = searchTerm ? 'block' : 'none';

      if (!searchTerm) {
        displayFilteredFavorites(allFavoriteItems);
        return;
      }


      const filteredItems = allFavoriteItems.filter(item => {
        let contentToSearch = '';
        let authorToSearch = '';

        if (item.type === 'qzone_post') {
          const post = item.content;
          contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
          if (post.authorId === 'user') {
            authorToSearch = state.qzoneSettings.nickname;
          } else if (state.chats[post.authorId]) {
            authorToSearch = state.chats[post.authorId].name;
          }
        } else if (item.type === 'chat_message') {
          const msg = item.content;
          if (typeof msg.content === 'string') {
            contentToSearch = msg.content;
          }
          const chat = state.chats[item.chatId];
          if (chat) {
            if (msg.role === 'user') {
              authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            } else {
              authorToSearch = chat.isGroup ? msg.senderName : chat.name;
            }
          }
        }


        return contentToSearch.toLowerCase().includes(searchTerm) ||
          authorToSearch.toLowerCase().includes(searchTerm);
      });

      displayFilteredFavorites(filteredItems);
    });


    searchClearBtn.addEventListener('click', () => {
      searchInput.value = '';
      searchClearBtn.style.display = 'none';
      displayFilteredFavorites(allFavoriteItems);
      searchInput.focus();
    });







    document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
      if (selectedMessages.size === 0) return;
      const chat = state.chats[state.activeChatId];
      if (!chat) return;

      const favoritesToAdd = [];
      const timestampsToFavorite = [...selectedMessages];

      for (const timestamp of timestampsToFavorite) {

        const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();

        if (!existing) {
          const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
          if (messageToSave) {
            favoritesToAdd.push({
              type: 'chat_message',
              content: messageToSave,
              chatId: state.activeChatId,
              timestamp: Date.now(),
              originalTimestamp: messageToSave.timestamp
            });
          }
        }
      }

      if (favoritesToAdd.length > 0) {
        await db.favorites.bulkAdd(favoritesToAdd);
        allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
        await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
      } else {
        await showCustomAlert('提示', '选中的消息均已收藏过。');
      }

      exitSelectionMode();
    });


    const favoritesEditBtn = document.getElementById('favorites-edit-btn');
    const favoritesView = document.getElementById('favorites-view');
    const favoritesActionBar = document.getElementById('favorites-action-bar');
    const mainBottomNav = document.getElementById('chat-list-bottom-nav');
    const favoritesList = document.getElementById('favorites-list');

    favoritesEditBtn.addEventListener('click', () => {
      isFavoritesSelectionMode = !isFavoritesSelectionMode;
      favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

      if (isFavoritesSelectionMode) {

        favoritesEditBtn.textContent = '完成';
        favoritesActionBar.style.display = 'block';
        mainBottomNav.style.display = 'none';
        favoritesList.style.paddingBottom = '80px';
      } else {

        favoritesEditBtn.textContent = '编辑';
        favoritesActionBar.style.display = 'none';
        mainBottomNav.style.display = 'flex';
        favoritesList.style.paddingBottom = '';


        selectedFavorites.clear();
        document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
        document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
      }
    });



    document.getElementById('favorites-list').addEventListener('click', (e) => {
      const target = e.target;
      const card = target.closest('.favorite-item-card');


      if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return;
      }


      if (!isFavoritesSelectionMode) return;


      if (!card) return;

      const favId = parseInt(card.dataset.favid);
      if (isNaN(favId)) return;


      if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
      } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
      }


      document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
    });



    document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
      if (selectedFavorites.size === 0) return;

      const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, {
          confirmButtonClass: 'btn-danger'
        }
      );

      if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');


        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));


        displayFilteredFavorites(allFavoriteItems);


        favoritesEditBtn.click();
      }
    });


    if (state.globalSettings.enableBackgroundActivity) {
      startBackgroundSimulation();
      console.log("后台活动模拟已自动启动。");
    }







    document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
      radio.addEventListener('change', updateSettingsPreview);
    });


    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.addEventListener('input', () => {

      document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;

      updateSettingsPreview();
    });


    const customCssInputForPreview = document.getElementById('custom-css-input');
    customCssInputForPreview.addEventListener('input', updateSettingsPreview);


    document.getElementById('reset-theme-btn').addEventListener('click', () => {
      document.getElementById('theme-default').checked = true;
      updateSettingsPreview();
    });

    document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
      document.getElementById('custom-css-input').value = '';
      updateSettingsPreview();
    });



    document.getElementById('lyrics-vertical-pos').addEventListener('change', updateSettingsPreview);
    document.getElementById('lyrics-horizontal-pos').addEventListener('change', updateSettingsPreview);
    document.getElementById('lyrics-offset-input').addEventListener('input', updateSettingsPreview);

    document.querySelectorAll('input[name="visibility"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
          groupsContainer.style.display = 'block';
        } else {
          groupsContainer.style.display = 'none';
        }
      });
    });



    document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
    document.getElementById('close-group-manager-btn').addEventListener('click', () => {
      document.getElementById('group-management-modal').classList.remove('visible');

      const chatSettingsBtn = document.getElementById('chat-settings-btn');
      if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
        chatSettingsBtn.click();
      }
    });

    document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
    document.getElementById('existing-groups-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
      }
    });




    document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);

    // 翻译按钮事件监听器
    document.getElementById('translate-message-btn').addEventListener('click', translateMessageContent);

    document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);

    document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);


    document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);



    document.getElementById('select-message-btn').addEventListener('click', () => {

      const timestampToSelect = activeMessageTimestamp;
      hideMessageActions();

      if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
      }
    });




    


    document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
    document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
    document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);





    document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
    document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
    document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);




    document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
      showScreen('chat-list-screen');
    });

    document.getElementById('contact-picker-list').addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (!item) return;

      const contactId = item.dataset.contactId;
      item.classList.toggle('selected');

      if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
      } else {
        selectedContacts.add(contactId);
      }
      updateContactPickerConfirmButton();
    });


    document.getElementById('manage-members-btn').addEventListener('click', () => {



      openMemberManagementScreen();
    });



    document.getElementById('back-from-member-management').addEventListener('click', () => {

      showScreen('chat-interface-screen');
      document.getElementById('chat-settings-btn').click();
    });


    document.getElementById('member-management-list').addEventListener('click', (e) => {

      if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
      }
    });

    document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {


      const confirmBtn = document.getElementById('confirm-contact-picker-btn');

      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      newConfirmBtn.addEventListener('click', handleAddMembersToGroup);

      await openContactPickerForAddMember();
    });

    document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);





    document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
    document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);


    document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);
    document.getElementById('minimize-call-btn').addEventListener('click', minimizeVideoCall);
    document.getElementById('video-call-restore-btn').addEventListener('click', restoreVideoCall);
   
    makeDraggable(document.getElementById('video-call-restore-btn'), document.getElementById('video-call-restore-btn'));

    document.getElementById('cancel-call-btn').addEventListener('click', () => {
      videoCallState.isAwaitingResponse = false;
      showScreen('chat-interface-screen');
    });


    document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);



    document.getElementById('decline-call-btn').addEventListener('click', async () => {
      hideIncomingCallModal();
      const chat = state.chats[videoCallState.activeChatId];
      if (!chat) return;


      if (videoCallState.isGroupCall) {
        videoCallState.isUserParticipating = false;


        const systemNote = {
          role: 'system',
          content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);



        await triggerAiResponse();

      } else {
        const declineMessage = {
          role: 'user',
          content: '我拒绝了你的视频通话请求。',
          timestamp: Date.now()
        };
        chat.history.push(declineMessage);
        await db.chats.put(chat);


        showScreen('chat-interface-screen');
        appendMessage(declineMessage, chat);


        triggerAiResponse();
      }


      videoCallState.isAwaitingResponse = false;
    });




    document.getElementById('accept-call-btn').addEventListener('click', async () => {
      hideIncomingCallModal();

      videoCallState.initiator = 'ai';
      videoCallState.isUserParticipating = true;
      videoCallState.activeChatId = state.activeChatId;


      if (videoCallState.isGroupCall) {

        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {

          videoCallState.participants = [requester];
        } else {
          videoCallState.participants = [];
        }
      }


      startVideoCall();
    });





    document.getElementById('user-speak-btn').addEventListener('click', async () => {
      if (!videoCallState.isActive) return;


      const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
      if (userAvatar) {
        userAvatar.classList.add('speaking');
      }

      const userInput = await showCustomPrompt('你说', '请输入你想说的话...');


      if (userAvatar) {
        userAvatar.classList.remove('speaking');
      }

      if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
      }
    });




    document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {

      if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click();
      }
      switchToChatListView('memories-view');
      renderMemoriesScreen();
    });


    document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));




    document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
      const title = document.getElementById('countdown-title-input').value.trim();
      const dateValue = document.getElementById('countdown-date-input').value;

      if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
      }

      const targetDate = new Date(dateValue);
      if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('请输入一个有效的、未来的日期！');
        return;
      }


      const newCountdown = {
        authorId: 'user',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
      };


      await db.memories.add(newCountdown);
      document.getElementById('create-countdown-modal').classList.remove('visible');
      renderMemoriesScreen();
    });


    document.getElementById('block-chat-btn').addEventListener('click', async () => {
      if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

      const chat = state.chats[state.activeChatId];
      const confirmed = await showCustomConfirm(
        '确认拉黑',
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`, {
          confirmButtonClass: 'btn-danger'
        }
      );

      if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();


        const hiddenMessage = {
          role: 'system',
          content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
          timestamp: Date.now() + 1,
          isHidden: true
        };
        chat.history.push(hiddenMessage);


        await db.chats.put(chat);


        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);

        renderChatList();
      }
    });

    document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
      const chat = state.chats[state.activeChatId];
      if (!chat) return;

      if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id);
        return;
      }

      if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;


        const hiddenMessage = {
          role: 'system',
          content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
          timestamp: Date.now(),
          isHidden: true
        };
        chat.history.push(hiddenMessage);


        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse();
      } else if (e.target.id === 'accept-friend-btn') {
        // 【修复】1. 先获取AI的申请理由，防止被清除
        const applicationReason = chat.relationship.applicationReason || '（对方没有留下理由，但我们和好了）'; 

        // 2. 更新状态
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = ''; // 现在可以安全清空了

        // 3. (可选) 保留系统消息
        const systemMessage = {
          role: 'system',
          type: 'pat_message',
          content: `你通过了“${chat.name}”的好友请求`,
          timestamp: Date.now()
        };
        chat.history.push(systemMessage);

        // 4. 【核心修复】将AI的“申请理由”作为它的第一条消息推入历史记录
        const applicationMessage = {
          role: 'assistant',
          senderName: chat.name,
          content: applicationReason, // <-- 使用AI自己生成的理由
          timestamp: Date.now() + 1
        };
        chat.history.push(applicationMessage);

        // 5. 保存并刷新
        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();

        // 6. (可选) 立即触发AI，让它对“被接受”这件事作出回应
       
      } else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
      } else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
          '发送好友申请',
          `请输入你想对“${chat.name}”说的申请理由：`,
          "我们和好吧！"
        );

        if (reason !== null) {

          chat.relationship.status = 'pending_ai_approval';
          chat.relationship.applicationReason = reason;
          await db.chats.put(chat);


          renderChatInterface(chat.id);
          renderChatList();


          triggerAiResponse();
        }
      }
    });




    document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);


    document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
      document.getElementById('red-packet-modal').classList.remove('visible');
    });
    document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
    document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);


    const rpTabGroup = document.getElementById('rp-tab-group');
    const rpTabDirect = document.getElementById('rp-tab-direct');
    const rpContentGroup = document.getElementById('rp-content-group');
    const rpContentDirect = document.getElementById('rp-content-direct');

    rpTabGroup.addEventListener('click', () => {
      rpTabGroup.classList.add('active');
      rpTabDirect.classList.remove('active');
      rpContentGroup.style.display = 'block';
      rpContentDirect.style.display = 'none';
    });
    rpTabDirect.addEventListener('click', () => {
      rpTabDirect.classList.add('active');
      rpTabGroup.classList.remove('active');
      rpContentDirect.style.display = 'block';
      rpContentGroup.style.display = 'none';
    });


    document.getElementById('rp-group-amount').addEventListener('input', (e) => {
      const amount = parseFloat(e.target.value) || 0;
      document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
    });
    document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
      const amount = parseFloat(e.target.value) || 0;
      document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
    });




    




    document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);


    document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
    document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
      document.getElementById('create-poll-modal').classList.remove('visible');
    });
    document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);


    document.getElementById('chat-messages').addEventListener('click', (e) => {
      const pollCard = e.target.closest('.poll-card');
      if (!pollCard) return;

      const timestamp = parseInt(pollCard.dataset.pollTimestamp);
      if (isNaN(timestamp)) return;


      const optionItem = e.target.closest('.poll-option-item');
      if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
      }


      const actionBtn = e.target.closest('.poll-action-btn');
      if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
          showPollResults(timestamp);
        } else {
          endPoll(timestamp);
        }
        return;
      }


      if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
      }
    });



    document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);


    document.getElementById('add-ai-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('ai'));


    document.getElementById('add-group-avatar-batch-btn').addEventListener('click', () => openBatchImportModal('group'));



    document.getElementById('add-ai-avatar-url-btn').addEventListener('click', addAvatarToLibraryFromURL);


    document.getElementById('add-ai-avatar-upload-btn').addEventListener('click', () => {
      document.getElementById('ai-avatar-upload-input').click();
    });


    document.getElementById('ai-avatar-upload-input').addEventListener('change', handleLocalAvatarUpload);

    document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);


    document.getElementById('manage-group-avatar-library-btn').addEventListener('click', openGroupAvatarLibraryModal);



    document.getElementById('add-group-avatar-url-btn').addEventListener('click', addAvatarToGroupLibraryFromURL);


    document.getElementById('add-group-avatar-upload-btn').addEventListener('click', () => {
      document.getElementById('group-avatar-upload-input').click();
    });


    document.getElementById('group-avatar-upload-input').addEventListener('change', handleLocalGroupAvatarUpload);


    document.getElementById('close-group-avatar-library-btn').addEventListener('click', closeGroupAvatarLibraryModal);



    document.getElementById('icon-settings-grid').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
          handleIconChange(iconId, 'ephone', item);
        }
      }
    });




    document.getElementById('chat-messages').addEventListener('click', (e) => {

      const linkCard = e.target.closest('.link-share-card');
      if (linkCard) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        if (!isNaN(timestamp)) {
          openBrowser(timestamp);
        }
      }
    });


    document.getElementById('browser-back-btn').addEventListener('click', () => {
      showScreen('chat-interface-screen');
    });



    qzoneStickerPanelState.panelEl.addEventListener('click', async (e) => {
      const stickerItem = e.target.closest('.sticker-item');
      if (stickerItem && qzoneStickerPanelState.activePostId !== null) {

        const stickerUrl = stickerItem.style.backgroundImage.slice(5, -2);


        const stickerObject = state.userStickers.find(s => s.url === stickerUrl);

        if (stickerObject) {

          await sendQzoneStickerComment(qzoneStickerPanelState.activePostId, stickerObject);
        } else {
          console.warn("在动态评论区点击了表情，但在表情库中未找到对象:", stickerUrl);
        }
      }
    });




    document.addEventListener('click', (e) => {
      if (qzoneStickerPanelState.isOpen &&
        !qzoneStickerPanelState.panelEl.contains(e.target) &&
        !e.target.closest('.comment-sticker-btn')) {
        closeQzoneStickerPanel();
      }
    });



    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);


    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
      document.getElementById('share-link-modal').classList.remove('visible');
    });


    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);



    document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
    document.getElementById('detach-status-bar-switch').addEventListener('change', (e) => {
      applyDetachStatusBarMode(e.target.checked);
    });
    document.getElementById('phone-frame-toggle-switch').addEventListener('change', (e) => {
      applyPhoneFrame(e.target.checked);
    });


    document.getElementById('share-location-btn').addEventListener('click', sendLocationShare);





    document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);


    document.getElementById('call-history-back-btn').addEventListener('click', () => {

      showScreen('chat-list-screen');
    });


    document.getElementById('call-history-list').addEventListener('click', (e) => {
      const card = e.target.closest('.call-record-card');
      if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
      }
    });


    document.getElementById('close-call-transcript-btn').addEventListener('click', () => {
      document.getElementById('call-transcript-modal').classList.remove('visible');
    });





    document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);


    document.getElementById('selection-share-btn').addEventListener('click', () => {
      if (selectedMessages.size > 0) {
        openShareTargetPicker();
      }
    });
    document.getElementById('selection-forward-btn').addEventListener('click', () => {
      if (selectedMessages.size > 0) {
        openForwardTargetPicker();
      }
    });
    document.getElementById('selection-screenshot-btn').addEventListener('click', handleLongScreenshot);

    document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
      const sourceChat = state.chats[state.activeChatId];
      const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
        .map(cb => cb.dataset.chatId);

      if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
      }


      const sharedHistory = [];
      const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
      for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
          sharedHistory.push(msg);
        }
      }


      const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
          sourceChatName: sourceChat.name,
          title: `来自“${sourceChat.name}”的聊天记录`,
          sharedHistory: sharedHistory
        }
      };


      for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
          targetChat.history.push(shareCardMessage);
          await db.chats.put(targetChat);
        }
      }


      document.getElementById('share-target-modal').classList.remove('visible');
      exitSelectionMode();
      await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
      renderChatList();
    });


    document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
      document.getElementById('share-target-modal').classList.remove('visible');
    });

    document.getElementById('confirm-forward-target-btn').addEventListener('click', async () => {
      const sourceChat = state.chats[state.activeChatId];
      const selectedTargetIds = Array.from(document.querySelectorAll('.forward-target-checkbox:checked'))
        .map(cb => cb.dataset.chatId);

      if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要转发的聊天。");
        return;
      }

      const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
      
      for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (!targetChat) continue;

        for (const timestamp of sortedTimestamps) {
          const msg = sourceChat.history.find(m => m.timestamp === timestamp);
          if (!msg) continue;

          const forwardedMessage = {
            role: 'user',
            senderName: targetChat.isGroup ? (targetChat.settings.myNickname || '我') : '我',
            content: msg.content,
            timestamp: Date.now() + sortedTimestamps.indexOf(timestamp),
          };

          if (msg.type) {
            forwardedMessage.type = msg.type;
            if (msg.type === 'voice_message') {
              forwardedMessage.content = msg.content;
            } else if (msg.type === 'ai_image' || msg.type === 'naiimag') {
              forwardedMessage.content = msg.content;
            } else if (msg.type === 'transfer') {
              forwardedMessage.amount = msg.amount;
              forwardedMessage.note = msg.note;
            } else if (msg.type === 'share_link') {
              forwardedMessage.title = msg.title;
              forwardedMessage.description = msg.description;
              forwardedMessage.source_name = msg.source_name;
              forwardedMessage.content = msg.content;
            } else if (msg.type === 'red_packet') {
              forwardedMessage.totalAmount = msg.totalAmount;
              forwardedMessage.count = msg.count;
              forwardedMessage.message = msg.message;
              forwardedMessage.claimed = [];
            } else if (msg.type === 'location_share') {
              forwardedMessage.latitude = msg.latitude;
              forwardedMessage.longitude = msg.longitude;
              forwardedMessage.locationName = msg.locationName;
            }
          }

          targetChat.history.push(forwardedMessage);
        }

        await db.chats.put(targetChat);
      }

      document.getElementById('forward-target-modal').classList.remove('visible');
      exitSelectionMode();
      await showCustomAlert("转发成功", `消息已成功转发到 ${selectedTargetIds.length} 个会话中。`);
      renderChatList();
    });

    document.getElementById('cancel-forward-target-btn').addEventListener('click', () => {
      document.getElementById('forward-target-modal').classList.remove('visible');
    });


    document.getElementById('chat-messages').addEventListener('click', (e) => {



      const shareCard = e.target.closest('.link-share-card[data-timestamp]');
      if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
      }
    });


    document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
      document.getElementById('shared-history-viewer-modal').classList.remove('visible');
    });


    async function openSharedHistoryViewer(timestamp) {
      const chat = state.chats[state.activeChatId];
      if (!chat) return;

      const message = chat.history.find(m => m.timestamp === timestamp);

   

      if (!message) {
        console.error("无法找到分享记录:", timestamp);
        await showCustomAlert("查看失败", "无法找到对应的分享记录或记录已损坏。");
        return;
      }

   
      if (message.type === 'share_link') {
        openBrowser(timestamp);
        return; 
      }

    
      if (message.type === 'share_card') {
        if (!message.payload || !message.payload.sharedHistory) {
          console.error("聊天记录分享卡片数据损坏:", message);
          await showCustomAlert("查看失败", "分享的聊天记录已损坏。");
          return;
        }
      
      } else {
      
        console.error("未知的分享卡片类型:", message.type);
        await showCustomAlert("查看失败", "不支持的分享类型。");
        return;
      }

      const viewerModal = document.getElementById('shared-history-viewer-modal');
      const viewerTitle = document.getElementById('shared-history-viewer-title');
      const viewerContent = document.getElementById('shared-history-viewer-content');

      viewerTitle.textContent = message.payload.title;
      viewerContent.innerHTML = '';

      const fragment = document.createDocumentFragment();
      const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;

      for (const sharedMsg of message.payload.sharedHistory) {
        const bubbleEl = await createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
          fragment.appendChild(bubbleEl);
        }
      }

      viewerContent.appendChild(fragment);
      viewerModal.classList.add('visible');
    }

    audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

    audioPlayer.addEventListener('pause', () => {
      if (musicState.isActive) {
        musicState.isPlaying = false;
        phoneScreenForIsland.classList.remove('dynamic-island-active');
        // --- 新增：暂停时停止旋转 ---
        document.getElementById('vinyl-view').classList.remove('spinning'); 
        updatePlayerUI();
      }
    });
    
    audioPlayer.addEventListener('play', () => {
      if (musicState.isActive) {
        musicState.isPlaying = true;
        // --- 新增：播放时开始旋转 ---
        document.getElementById('vinyl-view').classList.add('spinning');
        updatePlayerUI();
      }
    });



    document.getElementById('playlist-body').addEventListener('click', async (e) => {
      const target = e.target;


      const albumArtBtn = target.closest('.album-art-btn');
      if (albumArtBtn) {
        const index = parseInt(albumArtBtn.dataset.index);
        if (!isNaN(index)) {

          await handleChangeAlbumArt(index);
        }
        return;
      }

      const lyricsBtn = target.closest('.lyrics-btn');
      if (lyricsBtn) {
        const index = parseInt(lyricsBtn.dataset.index);
        if (isNaN(index)) return;



        await handleManualLrcImport(index);

        return;
      }


      const deleteBtn = target.closest('.delete-track-btn');
      if (deleteBtn) {
        const index = parseInt(deleteBtn.dataset.index);
        if (isNaN(index)) return;
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
          deleteTrack(index);
        }
        return;
      }


      const itemInfo = target.closest('.playlist-item-info');
      if (itemInfo) {
        const item = itemInfo.closest('.playlist-item');
        const index = Array.from(item.parentElement.children).indexOf(item);
        if (index > -1) {
          playSong(index);
        }
      }
    });


    document.querySelector('.progress-bar').addEventListener('click', (e) => {
      if (!audioPlayer.duration) return;
      const progressBar = e.currentTarget;
      const barWidth = progressBar.clientWidth;
      const clickX = e.offsetX;
      audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
    });




    document.getElementById('chat-messages').addEventListener('click', (e) => {

     // 【新增/修改】点击邮件卡片查看详情 (固定大小弹窗版)
      const emailCard = e.target.closest('.email-share-card');
      if (emailCard) {
          const jsonStr = decodeURIComponent(emailCard.dataset.emailJson);
          try {
              const data = JSON.parse(jsonStr);
              
              // 1. 获取模态框相关元素
              const overlay = document.getElementById('custom-modal-overlay');
              const modal = document.getElementById('custom-modal');
              const titleEl = document.getElementById('custom-modal-title');
              const bodyEl = document.getElementById('custom-modal-body');
              const footerEl = document.querySelector('#custom-modal .custom-modal-footer');

              // 2. 【核心步骤】临时修改模态框样式 (固定宽高)
              modal.style.width = '320px';        // 宽度加宽
              modal.style.height = '500px';       // 高度固定
              modal.style.maxHeight = '80vh';     // 防止超出屏幕
              
              // 3. 调整 Body 样式以支持内部滚动
              bodyEl.style.flex = '1';            // 撑满剩余空间
              bodyEl.style.overflowY = 'auto';    // 允许垂直滚动
              bodyEl.style.padding = '0';         // 清除默认内边距，由内部容器控制

              // 4. 设置标题
              titleEl.textContent = "邮件详情";
              
              // 5. 构造详情 HTML (优化布局)
              const detailHtml = `
                  <div style="padding: 20px; min-height: 100%; box-sizing: border-box; text-align: left;"> <div style="border-bottom: 1px solid #eee; padding-bottom: 15px; margin-bottom: 15px;">
                          <div style="font-weight: 700; font-size: 18px; color: #111; line-height: 1.4; margin-bottom: 8px; word-break: break-word;">
                              ${escapeHTML(data.subject)}
                          </div>
                          <div style="display: flex; justify-content: space-between; align-items: center; color: #8a8a8a; font-size: 13px;">
                              <span><span style="color:#666;">发件人:</span> ${escapeHTML(data.sender)}</span>
                              <span>${data.date.split(' ')[0]}</span>
                          </div>
                      </div>
                      <div style="white-space: pre-wrap; color: #333; font-size: 15px; line-height: 1.8; font-family: -apple-system, sans-serif; letter-spacing: 0.5px;">${escapeHTML(data.fullContent)}</div>
                  </div>
              `;
              bodyEl.innerHTML = detailHtml;

              // 6. 重写底部按钮 (仅显示一个关闭按钮)
              footerEl.innerHTML = ''; // 清空原有按钮
              const closeBtn = document.createElement('button');
              closeBtn.textContent = '关闭';
              closeBtn.style.cssText = 'width: 100%; border: none; background: transparent; color: var(--accent-color); font-weight: 600; padding: 15px; font-size: 16px; cursor: pointer;';
              
              // 7. 绑定关闭事件 (关键：关闭时必须还原样式！)
              closeBtn.onclick = () => {
                  overlay.classList.remove('visible');
                  
                  // 延迟还原样式，防止视觉跳动
                  setTimeout(() => {
                      modal.style.width = '';       // 还原宽度
                      modal.style.height = '';      // 还原高度
                      modal.style.maxHeight = '';
                      bodyEl.style.flex = '';
                      bodyEl.style.overflowY = '';
                      bodyEl.style.padding = '';
                  }, 300);
              };
              footerEl.appendChild(closeBtn);

              // 8. 显示弹窗
              overlay.classList.add('visible');

          } catch(err) {
              console.error("解析邮件数据失败", err);
          }
          return; // 阻止后续逻辑
      }
      const redditCard = e.target.closest('.reddit-share-card');
    if (redditCard) {
        const bubble = redditCard.closest('.message-bubble');
        if (bubble) {
            const timestamp = parseInt(bubble.dataset.timestamp);
            const chat = state.chats[state.activeChatId];
            // 在历史记录中找到这条消息
            const msg = chat.history.find(m => m.timestamp === timestamp);
            
            if (msg && msg.type === 'reddit_share' && msg.redditData) {
                // 调用你写好的详情页函数
                openRedditDetail(msg.redditData);
            }
        }
        return; 
    }
      const placeholder = e.target.closest('.recalled-message-placeholder');
      if (placeholder) {
        const chat = state.chats[state.activeChatId];
        const wrapper = placeholder.closest('.message-wrapper');
        if (chat && wrapper) {
          const timestamp = parseInt(wrapper.dataset.timestamp);
          const recalledMsg = chat.history.find(m => m.timestamp === timestamp);

          if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;


            switch (recalled.originalType) {
              case 'text':
                originalContentText = `原文: "${recalled.originalContent}"`;
                break;
              case 'user_photo':
              case 'ai_image':
              case 'text_image':
                originalContentText = `[图片/文字图] 描述: "${recalled.originalContent}"`;
                break;
              case 'voice_message':
                originalContentText = `[语音] 内容: "${recalled.originalContent}"`;
                break;
              case 'sticker':

                originalContentText = `[表情] 含义: "${recalled.originalMeaning || '(无)'}" \n URL: ${recalled.originalContent}`;
                break;
              case 'transfer':
                originalContentText = `一条[转账]消息已被撤回。`;
                break;
              default:

                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息。\n内容: ${JSON.stringify(recalled.originalContent)}`;
                break;
            }


            showCustomAlert('已撤回的消息', originalContentText);
          }
        }
      }
    });




    document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
    document.getElementById('close-category-manager-btn').addEventListener('click', () => {
      document.getElementById('world-book-category-manager-modal').classList.remove('visible');
      renderWorldBookScreen();
    });
    document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
    document.getElementById('existing-categories-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteCategory(categoryId);
      }
    });

    document.getElementById('repost-cancel-btn').addEventListener('click', hideRepostModal);
    document.getElementById('repost-confirm-btn').addEventListener('click', handleConfirmRepost);





    document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

    document.getElementById('forward-message-btn').addEventListener('click', () => {
      if (activeMessageTimestamp) {
        hideMessageActions();
        enterSelectionMode(activeMessageTimestamp);
      }
    });

    document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);










    document.getElementById('qzone-posts-list').addEventListener('input', (e) => {
      if (!e.target.matches('.comment-input')) return;

      const commentInput = e.target;
      const postContainer = commentInput.closest('.qzone-post-container');
      if (!postContainer) return;

      const popup = postContainer.querySelector('.at-mention-popup');
      const value = commentInput.value;
      const atMatch = value.match(/@([\p{L}\w]*)$/u);

      if (atMatch) {
        const namesToMention = new Set();
        const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
        if (authorNickname) namesToMention.add(authorNickname);
        postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
          namesToMention.add(nameEl.textContent.replace(':', ''));
        });
        namesToMention.delete(state.qzoneSettings.nickname);

        popup.innerHTML = '';
        if (namesToMention.size > 0) {
          const searchTerm = atMatch[1];
          namesToMention.forEach(name => {
            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
              const item = document.createElement('div');
              item.className = 'at-mention-item';
              item.textContent = name;
              item.addEventListener('mousedown', (evt) => {
                evt.preventDefault();
                const newText = value.substring(0, atMatch.index) + `@${name} `;
                commentInput.value = newText;
                popup.style.display = 'none';
                commentInput.focus();
              });
              popup.appendChild(item);
            }
          });
          popup.style.display = popup.children.length > 0 ? 'block' : 'none';
        } else {
          popup.style.display = 'none';
        }
      } else {
        popup.style.display = 'none';
      }
    });

    document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
      if (e.target.matches('.comment-input')) {
        const postContainer = e.target.closest('.qzone-post-container');
        if (postContainer) {
          const popup = postContainer.querySelector('.at-mention-popup');
          if (popup) {
            setTimeout(() => {
              popup.style.display = 'none';
            }, 200);
          }
        }
      }
    });





    const chatInputForMention = document.getElementById('chat-input');
    const chatMentionPopup = document.getElementById('chat-at-mention-popup');

    chatInputForMention.addEventListener('input', () => {

      if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) {
        chatMentionPopup.style.display = 'none';
        return;
      }

      const chat = state.chats[state.activeChatId];
      const value = chatInputForMention.value;
      const atMatch = value.match(/@([\p{L}\w]*)$/u);

      if (atMatch) {

        const myNickname = chat.settings.myNickname || '我';
        const namesToMention = chat.members
          .map(member => member.groupNickname)
          .filter(name => name !== myNickname);

        chatMentionPopup.innerHTML = '';
        if (namesToMention.length > 0) {
          const searchTerm = atMatch[1];

          namesToMention.forEach(name => {
            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
              const item = document.createElement('div');
              item.className = 'at-mention-item';
              item.textContent = name;

              item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const newText = value.substring(0, atMatch.index) + `@${name} `;
                chatInputForMention.value = newText;
                chatMentionPopup.style.display = 'none';
                chatInputForMention.focus();
              });
              chatMentionPopup.appendChild(item);
            }
          });

          chatMentionPopup.style.display = chatMentionPopup.children.length > 0 ? 'block' : 'none';
        } else {
          chatMentionPopup.style.display = 'none';
        }
      } else {
        chatMentionPopup.style.display = 'none';
      }
    });


    chatInputForMention.addEventListener('blur', () => {
      setTimeout(() => {
        chatMentionPopup.style.display = 'none';
      }, 200);
    });


    document.getElementById('publish-to-announcement-btn').addEventListener('click', publishToAnnouncementBoard);
    document.getElementById('show-announcement-board-btn').addEventListener('click', showAnnouncementBoard);
    document.getElementById('close-announcement-board-btn').addEventListener('click', () => {
      document.getElementById('announcement-board-modal').classList.remove('visible');
    });


    document.getElementById('announcement-board-content').addEventListener('click', (e) => {
      if (e.target.classList.contains('announcement-item-actions')) {
        const annoId = e.target.dataset.annoId;
        if (annoId) {
          showAnnouncementActions(annoId);
        }
      }
    });

    document.getElementById('announcement-action-pin').addEventListener('click', handlePinAnnouncement);
    document.getElementById('announcement-action-delete').addEventListener('click', handleDeleteAnnouncement);
    document.getElementById('announcement-action-cancel').addEventListener('click', () => {
      document.getElementById('announcement-actions-modal').classList.remove('visible');
    });


    document.getElementById('reset-global-css-btn').addEventListener('click', () => {
      document.getElementById('global-css-input').value = '';


    });


    document.getElementById('open-memory-screen-btn').addEventListener('click', openLongTermMemoryScreen);


    document.getElementById('memory-screen-back-btn').addEventListener('click', () => {
      showScreen('chat-interface-screen');
    });


    document.getElementById('add-manual-memory-btn-header').addEventListener('click', handleAddManualMemory);


    document.getElementById('summarize-recent-btn-header').addEventListener('click', handleManualSummary);


    document.getElementById('memory-list-container').addEventListener('click', (e) => {
      const editBtn = e.target.closest('.edit-memory-btn');
      if (editBtn) {
        handleEditMemory(editBtn.dataset.authorId, parseInt(editBtn.dataset.memoryTimestamp));
        return;
      }
      const deleteBtn = e.target.closest('.delete-memory-btn');
      if (deleteBtn) {
        handleDeleteMemory(deleteBtn.dataset.authorId, parseInt(deleteBtn.dataset.memoryTimestamp));
        return;
      }
    });


    document.getElementById('gomoku-btn').addEventListener('click', toggleGomokuBoard);
    document.getElementById('close-gomoku-btn').addEventListener('click', closeGomokuBoard);

    const gomokuCanvas = document.getElementById('gomoku-board');
    gomokuCanvas.addEventListener('mousemove', handleBoardHover);
    gomokuCanvas.addEventListener('mouseout', () => renderGomokuBoard(state.activeChatId));
    gomokuCanvas.addEventListener('click', handleBoardClick);


    document.getElementById('add-countdown-btn').addEventListener('click', () => {

      document.getElementById('countdown-title-input').value = '';
      document.getElementById('countdown-date-input').value = '';

      document.getElementById('create-countdown-modal').classList.add('visible');
    });


    document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
      document.getElementById('create-countdown-modal').classList.remove('visible');
    });



    document.getElementById('edit-call-message-btn').addEventListener('click', openCallMessageEditor);
    document.getElementById('delete-call-message-btn').addEventListener('click', deleteCallMessage);
    document.getElementById('cancel-call-message-action-btn').addEventListener('click', hideCallMessageActions);


    document.getElementById('edit-last-response-btn').addEventListener('click', openAiResponseEditor);
    document.getElementById('cancel-ai-response-editor-btn').addEventListener('click', () => {
      document.getElementById('ai-response-editor-modal').classList.remove('visible');
    });
    document.getElementById('save-ai-response-editor-btn').addEventListener('click', saveEditedAiResponse);
    document.getElementById('add-ai-response-block-btn').addEventListener('click', () => {

      const container = document.getElementById('ai-response-editor-container');
      const newBlock = createAiResponseEditorBlock('{\n  "type": "text",\n  "content": "在这里输入新消息..."\n}');
      container.appendChild(newBlock);
      newBlock.querySelector('textarea').focus();
    });


    document.getElementById('manage-my-avatar-library-btn').addEventListener('click', openMyAvatarLibraryModal);
    document.getElementById('close-my-avatar-library-btn').addEventListener('click', closeMyAvatarLibraryModal);
    document.getElementById('add-my-avatar-url-btn').addEventListener('click', addAvatarToMyLibraryFromURL);
    document.getElementById('add-my-avatar-upload-btn').addEventListener('click', () => {
      document.getElementById('my-avatar-upload-input').click();
    });
    document.getElementById('my-avatar-upload-input').addEventListener('change', handleLocalMyAvatarUpload);
    document.getElementById('add-my-avatar-batch-btn').addEventListener('click', async () => {
      const placeholderText = `请按照以下格式粘贴，一行一个：\n\n焦虑 2a9wte.jpeg\n大惊失色 or8qf4.png\n没有灵感 njwujh.jpeg`;
      const pastedText = await showCustomPrompt('批量导入头像', placeholderText, '', 'textarea');
      if (pastedText && pastedText.trim()) {
        await handleBatchImportForMyAvatar(pastedText);
      }
    });


    document.getElementById('open-shopping-btn').addEventListener('click', openShoppingScreen);
    document.getElementById('shopping-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
    document.getElementById('go-to-cart-btn').addEventListener('click', openCartScreen);
    document.getElementById('cart-back-btn').addEventListener('click', openShoppingScreen);
    document.getElementById('checkout-btn').addEventListener('click', handleCheckout);
    document.getElementById('close-receipt-btn').addEventListener('click', () => {
      document.getElementById('gift-receipt-modal').classList.remove('visible');
    });


    document.getElementById('manage-products-btn').addEventListener('click', () => {
      isProductManagementMode = !isProductManagementMode;
      const btn = document.getElementById('manage-products-btn');
      const actionBar = document.getElementById('shopping-action-bar');
      const gridEl = document.getElementById('product-grid');

      btn.style.color = isProductManagementMode ? 'var(--accent-color)' : 'var(--text-primary)';

      if (isProductManagementMode) {
        actionBar.style.display = 'flex';
        gridEl.style.paddingBottom = '80px';
      } else {
        actionBar.style.display = 'none';
        gridEl.style.paddingBottom = '';

        selectedProducts.clear();
        document.querySelectorAll('.product-item.selected').forEach(item => item.classList.remove('selected'));
        document.getElementById('delete-selected-products-btn').textContent = `删除 (0)`;
        document.getElementById('select-all-products-checkbox').checked = false;
      }


      renderShoppingProducts();
      updateDeleteCategoryButtonVisibility();
    });


    document.getElementById('add-new-product-btn').addEventListener('click', () => {
      if (isProductManagementMode) {
        openProductEditor(null);
      } else {
        alert("请先点击扳手图标进入管理模式，才能添加新商品。");
      }
    });



    document.getElementById('product-grid').addEventListener('click', async e => {
      const productItem = e.target.closest('.product-item');
      if (!productItem) return;
      const productId = parseInt(productItem.dataset.id);
      if (isNaN(productId)) return;


      if (isProductManagementMode) {

        if (e.target.classList.contains('edit-product-btn')) {
          openProductEditor(productId);
          return;
        }

        if (e.target.classList.contains('delete-product-btn')) {
          const product = await db.shoppingProducts.get(productId);
          if (!product) return;
          const confirmed = await showCustomConfirm('删除商品', `确定要永久删除商品 “${product.name}” 吗？`, {
            confirmButtonClass: 'btn-danger'
          });
          if (confirmed) {
            await db.shoppingProducts.delete(productId);
            await renderShoppingProducts();
            alert("商品已删除。");
          }
          return;
        }


        productItem.classList.toggle('selected');
        if (selectedProducts.has(productId)) {
          selectedProducts.delete(productId);
        } else {
          selectedProducts.add(productId);
        }
        document.getElementById('delete-selected-products-btn').textContent = `删除 (${selectedProducts.size})`;
        return;
      }


      if (e.target.classList.contains('add-to-cart-btn')) {
        const product = await db.shoppingProducts.get(productId);
        if (product.variations && product.variations.length > 0) {
          openVariationSelector(productId);
        } else {
          await addToCart(productId);
          await showCustomAlert('成功', '已成功加入购物车！');
        }
        return;
      }


      if (productItem.contains(e.target)) {
        console.log(`点击了商品卡片: ${productId}`);
      }
    });



    document.getElementById('cart-items-list').addEventListener('click', e => {
      const target = e.target;
      if (target.classList.contains('decrease-qty-btn')) {
        updateCartItemQuantity(parseInt(target.dataset.id), -1);
      }
      if (target.classList.contains('increase-qty-btn')) {
        updateCartItemQuantity(parseInt(target.dataset.id), 1);
      }
      if (target.classList.contains('cart-item-checkbox')) {
        updateCartTotal();
      }
    });


    document.getElementById('clear-cart-btn').addEventListener('click', async () => {
      if (shoppingCart.length === 0) return;
      const confirmed = await showCustomConfirm('清空购物车', '确定要清空购物车中的所有商品吗？');
      if (confirmed) {
        shoppingCart = [];
        updateCartCount();
        renderCartItems();
      }
    });


    document.getElementById('select-all-cart-items').addEventListener('change', function(e) {
      document.querySelectorAll('.cart-item-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
      });
      updateCartTotal();
    });


    document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
      document.getElementById('product-editor-modal').classList.remove('visible');
    });
    document.getElementById('save-product-btn').addEventListener('click', saveProduct);
    document.getElementById('product-image-input').addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (re) => {
          document.getElementById('product-image-preview').src = re.target.result;
        };
        reader.readAsDataURL(file);
      }
    });


    document.getElementById('chat-messages').addEventListener('click', e => {
      const giftCard = e.target.closest('.gift-card');
      if (giftCard) {
        const bubble = giftCard.closest('.message-bubble');
        if (bubble) {
          showGiftReceipt(parseInt(bubble.dataset.timestamp));
        }
      }
    });


    document.getElementById('cancel-gift-recipient-btn').addEventListener('click', () => {
      document.getElementById('gift-recipient-modal').classList.remove('visible');
    });


    document.getElementById('confirm-gift-recipient-btn').addEventListener('click', async () => {

      const selectedRecipients = Array.from(document.querySelectorAll('#gift-recipient-list .contact-picker-item.selected'))
        .map(item => item.dataset.recipientName);

      if (selectedRecipients.length === 0) {
        alert("请至少选择一位收礼人。");
        return;
      }


      const selectedItems = shoppingCart.filter(item =>
        document.querySelector(`.cart-item-checkbox[data-id="${item.productId}"]:checked`)
      );


      await sendGiftMessage(selectedItems, selectedRecipients);


      document.getElementById('gift-recipient-modal').classList.remove('visible');
    });


    document.getElementById('gift-recipient-list').addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (item) {
        item.classList.toggle('selected');
      }
    });

    document.getElementById('select-all-recipients').addEventListener('change', function(e) {
      const isChecked = e.target.checked;
      document.querySelectorAll('#gift-recipient-list .contact-picker-item').forEach(item => {
        item.classList.toggle('selected', isChecked);
      });
    });


    document.getElementById('regenerate-btn').addEventListener('click', handleRegenerateResponse);
    document.getElementById('regenerate-call-btn').addEventListener('click', handleRegenerateCallResponse);


    document.getElementById('propel-btn').addEventListener('click', handlePropelAction);






    document.getElementById('test-sound-btn').addEventListener('click', () => {
      const player = document.getElementById('notification-sound-player');
      const url = document.getElementById('notification-sound-url-input').value.trim() || DEFAULT_NOTIFICATION_SOUND;
      player.src = url;
      player.play().catch(e => alert('播放失败，请检查URL是否正确或浏览器是否支持该格式。'));
    });

    document.getElementById('reset-sound-btn').addEventListener('click', () => {
      document.getElementById('notification-sound-url-input').value = '';
      alert('已重置为默认提示音，点击“保存所有外观设置”后生效。');
    });

    document.getElementById('home-screen').addEventListener('click', (e) => {
      const target = e.target;

      if (target.classList.contains('editable-text')) {
        handleEditText(target);
      }

      if (target.classList.contains('editable-image')) {
        handleEditImage(target);
      }
    });

    document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

    document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
      document.getElementById('music-search-results-modal').classList.remove('visible');
    });


    document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

    document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
      document.getElementById('music-search-results-modal').classList.remove('visible');
    });


    document.getElementById('select-all-music-search').addEventListener('change', function(e) {
      document.querySelectorAll('#search-results-list .music-search-checkbox').forEach(cb => {
        cb.checked = e.target.checked;
      });
    });


    document.getElementById('search-results-list').addEventListener('click', (e) => {
      const item = e.target.closest('.search-result-item');
      if (item) {
        const checkbox = item.querySelector('.music-search-checkbox');
        if (checkbox) {

          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
          }
        }
      }
    });


    document.getElementById('add-selected-music-btn').addEventListener('click', async () => {
      const selectedItems = document.querySelectorAll('.music-search-checkbox:checked');
      if (selectedItems.length === 0) {
        alert("请先选择要添加的歌曲。");
        return;
      }

      document.getElementById('music-search-results-modal').classList.remove('visible');
      await showCustomAlert("请稍候...", `正在批量添加 ${selectedItems.length} 首歌曲...`);

      const songDataList = Array.from(selectedItems).map(cb => JSON.parse(cb.closest('.search-result-item').dataset.songJson));

      let successCount = 0;
      let failedNames = [];


      const songDetailPromises = songDataList.map(songData => getPlayableSongDetails(songData));
      const fullSongObjects = await Promise.all(songDetailPromises);

      fullSongObjects.forEach((songObject, index) => {
        if (songObject) {
          musicState.playlist.push(songObject);
          successCount++;
        } else {
          failedNames.push(songDataList[index].name);
        }
      });

      if (successCount > 0) {
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === -1) {
          musicState.currentIndex = musicState.playlist.length - successCount;
          updatePlayerUI();
        }
      }

      let resultMessage = `添加完成！\n\n成功添加 ${successCount} 首歌曲。`;
      if (failedNames.length > 0) {
        resultMessage += `\n\n${failedNames.length} 首歌曲获取失败:\n- ${failedNames.join('\n- ')}`;
      }
      await showCustomAlert("操作结果", resultMessage);
    });



    document.getElementById('music-visual-container').addEventListener('click', () => {
      document.getElementById('music-visual-container').classList.toggle('lyrics-active');
    });



    document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);
    document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
      document.getElementById('music-search-results-modal').classList.remove('visible');
    });

    document.getElementById('search-results-list').addEventListener('click', (e) => {
      const item = e.target.closest('.search-result-item');
      if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
      }
    });



    document.getElementById('cleanup-songs-btn').addEventListener('click', cleanupInvalidSongs);
    document.getElementById('toggle-blur-btn').addEventListener('click', toggleBackgroundBlur);
    document.getElementById('toggle-fullscreen-btn').addEventListener('click', togglePlayerFullscreen);
    document.getElementById('show-avatars-btn').addEventListener('click', toggleMusicPlayerAvatars);


    document.getElementById('status-bar-toggle-switch').addEventListener('change', () => {

      state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
      applyStatusBarVisibility();
    });


    document.getElementById('qzone-more-actions-btn').addEventListener('click', openClearPostsSelectorModal);


    document.getElementById('cancel-clear-posts-btn').addEventListener('click', () => {
      document.getElementById('clear-posts-modal').classList.remove('visible');
    });
    document.getElementById('confirm-clear-posts-btn').addEventListener('click', handleConfirmClearPosts);


    document.getElementById('clear-posts-list').addEventListener('click', (e) => {
      const item = e.target.closest('.clear-posts-item');
      if (item) {
        item.classList.toggle('selected');
      }
    });

    document.getElementById('global-bg-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(file);
        });

        // 1. 立即保存和显示
        state.globalSettings.globalChatBackground = dataUrl;
        renderWallpaperScreen();
        await showCustomAlert("成功", "全局聊天背景已更新！\n\n图片将在后台静默上传到图床... (保存设置后生效)");

        // 2. 启动静默上传
        (async () => {
            await silentlyUpdateDbUrl(
                db.globalSettings,
                'main',
                'globalChatBackground',
                dataUrl
            );
        })();
      }
      event.target.value = null;
    });

    document.getElementById('remove-global-bg-btn').addEventListener('click', () => {

      state.globalSettings.globalChatBackground = '';
      renderWallpaperScreen();
    });


    document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {

      if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
      }



      state.globalSettings.globalCss = document.getElementById('global-css-input').value.trim();
      state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
      state.globalSettings.showStatusBar = document.getElementById('status-bar-toggle-switch').checked;
      state.globalSettings.showSeconds = document.getElementById('global-show-seconds-switch').checked;
      state.globalSettings.lockScreenEnabled = document.getElementById('lock-screen-toggle').checked;
      state.globalSettings.lockScreenPassword = document.getElementById('lock-screen-password-input').value.trim();
      
      const lockPreview = document.getElementById('lock-wallpaper-preview');
      if (lockPreview.dataset.tempUrl) {
          state.globalSettings.lockScreenWallpaper = lockPreview.dataset.tempUrl;
      }

      await db.globalSettings.put(state.globalSettings);


      applyGlobalWallpaper();
      newWallpaperBase64 = null;
      applyAppIcons();
      applyGlobalCss(state.globalSettings.globalCss);
      applyStatusBarVisibility();
      initLockScreen();
      alert('外观设置已保存并应用！');
      showScreen('home-screen');
    });


    document.getElementById('upload-global-bg-url-btn').addEventListener('click', async () => {

      const url = await showCustomPrompt("网络图片", "请输入背景图片的URL", "", "url");


      if (url && url.trim()) {

        state.globalSettings.globalChatBackground = url.trim();


        renderWallpaperScreen();
      } else if (url !== null) {

        alert("请输入有效的URL。");
      }
    });

    document.getElementById('upload-ephone-bg-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("网络图片 (EPhone)", "请输入EPhone主屏幕的背景图片URL", "", "url");
      if (url && url.trim()) {

        newWallpaperBase64 = url.trim();

        renderWallpaperScreen();
      } else if (url !== null) {
        alert("请输入有效的URL。");
      }
    });


    document.getElementById('upload-cphone-bg-url-btn').addEventListener('click', async () => {
      const url = await showCustomPrompt("网络图片 (CPhone)", "请输入CPhone的背景图片URL", "", "url");
      if (url && url.trim()) {

        state.globalSettings.cphoneWallpaper = url.trim();

        renderWallpaperScreen();
      } else if (url !== null) {
        alert("请输入有效的URL。");
      }
    });



    document.getElementById('remove-ephone-bg-btn').addEventListener('click', () => {

      newWallpaperBase64 = null;
      state.globalSettings.wallpaper = '';

      renderWallpaperScreen();
    });


    document.getElementById('remove-cphone-bg-btn').addEventListener('click', () => {

      state.globalSettings.cphoneWallpaper = '';

      renderWallpaperScreen();
    });



    document.getElementById('css-preset-select').addEventListener('change', handleCssPresetSelectionChange);
    document.getElementById('save-css-preset-btn').addEventListener('click', saveCssPreset);
    document.getElementById('delete-css-preset-btn').addEventListener('click', deleteCssPreset);


    document.getElementById('font-preset-select').addEventListener('change', handleFontPresetSelectionChange);
    document.getElementById('save-font-preset-btn').addEventListener('click', saveFontPreset);
    document.getElementById('delete-font-preset-btn').addEventListener('click', deleteFontPreset);


    document.getElementById('theme-preset-select').addEventListener('change', handleThemePresetSelectionChange);
    document.getElementById('save-theme-preset-btn').addEventListener('click', saveThemePreset);
    document.getElementById('delete-theme-preset-btn').addEventListener('click', deleteThemePreset);




    document.getElementById('manage-sticker-categories-btn').addEventListener('click', openStickerCategoryManager);


    document.getElementById('close-sticker-category-manager-btn').addEventListener('click', () => {
      document.getElementById('sticker-category-manager-modal').classList.remove('visible');
      renderStickerPanel();
    });


    document.getElementById('add-new-sticker-category-btn').addEventListener('click', addNewStickerCategory);


    document.getElementById('existing-sticker-categories-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteStickerCategory(categoryId);
      }
    });


    document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
      if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;

        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;
        switchStickerCategory(finalId);
      }
    });


    document.getElementById('select-all-stickers-checkbox').addEventListener('change', handleSelectAllStickers);

    document.getElementById('export-single-chat-btn').addEventListener('click', exportSingleChat);

    document.getElementById('import-single-chat-btn').addEventListener('click', () => {
      document.getElementById('import-single-chat-input').click();
    });

    document.getElementById('import-single-chat-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importSingleChat(file);
      }
      e.target.value = null;
    });


    document.getElementById('add-char-memo-btn').addEventListener('click', () => openMemoEditor());
    document.getElementById('add-char-diary-btn').addEventListener('click', () => openDiaryEditor());
    document.getElementById('favorite-diary-btn').addEventListener('click', toggleDiaryFavorite);
    document.getElementById('favorite-article-btn').addEventListener('click', toggleBrowserArticleFavorite);
    document.getElementById('favorite-memo-btn').addEventListener('click', toggleMemoFavorite);
    document.getElementById('copy-diary-content-btn').addEventListener('click', () => {
      const content = document.getElementById('char-diary-detail-content').innerText; // Use innerText to get formatted text
      copyTextToClipboard(content, '日记内容已复制！');
    });

    document.getElementById('copy-memo-content-btn').addEventListener('click', () => {
      const content = document.getElementById('char-memo-detail-content').value; // It's a textarea
      copyTextToClipboard(content, '备忘录内容已复制！');
    });

    document.getElementById('copy-article-content-btn').addEventListener('click', () => {
      const content = document.getElementById('char-article-content').innerText;
      copyTextToClipboard(content, '文章内容已复制！');
    });


    document.getElementById('regenerate-char-qq-btn').addEventListener('click', async () => {

      showCustomAlert("正在执行...", "正在生成新的模拟聊天记录，并同时让角色思考如何与你继续对话...");

      try {

        await Promise.all([
          handleGenerateSimulatedQQ(),
          handleContinueRealConversationFromCPhone()
        ]);

        console.log("CPhone QQ模拟记录生成 和 主聊天推进 已同时完成。");

      } catch (error) {
        console.error("在同时执行两个函数时出错:", error);
        await showCustomAlert("操作失败", `在执行组合操作时遇到错误: ${error.message}`);
      }
    });


    document.getElementById('char-chat-list').addEventListener('click', (e) => {
      const item = e.target.closest('.chat-list-item');
      if (item && item.dataset.conversationIndex) {
        const index = parseInt(item.dataset.conversationIndex);
        if (!isNaN(index)) {

          openCharSimulatedConversation(index);
        }
      }
    });



    document.getElementById('back-to-char-qq-list-btn').addEventListener('click', () => {
      switchToCharScreen('char-qq-screen');
    });



    const charConversationMessages = document.getElementById('char-conversation-messages');


    const cphoneScrollHandler = () => {

      if (cphoneActiveConversationType !== 'private_user') {
        return;
      }


      if (charConversationMessages.scrollTop < 1 && !isLoadingMoreCphoneMessages) {
        const totalMessages = state.chats[activeCharacterId]?.history.length || 0;

        if (totalMessages > cphoneRenderedCount) {

          loadMoreMirroredMessages();
        }
      }
    };


    charConversationMessages.addEventListener('scroll', cphoneScrollHandler);



    document.getElementById('char-simulated-send-btn').addEventListener('click', () => {
      alert("这是模拟对话，无法发送消息哦~");
    });



    document.getElementById('regenerate-char-album-btn').addEventListener('click', handleGenerateSimulatedAlbum);


    document.getElementById('char-album-grid').addEventListener('click', (e) => {

      const photoItem = e.target.closest('.char-photo-item');


      if (photoItem && photoItem.dataset.description) {
        const description = photoItem.dataset.description;


        showCustomAlert("照片详情", description.replace(/\n/g, '<br>'));
      }
    });
    document.getElementById('regenerate-char-browser-btn').addEventListener('click', handleGenerateBrowserHistory);

    document.getElementById('regenerate-char-taobao-btn').addEventListener('click', handleGenerateTaobaoHistory);



    document.getElementById('char-product-grid').addEventListener('click', (e) => {
      const item = e.target.closest('.char-product-item');
      if (item && item.dataset.reason) {
        const reason = item.dataset.reason;
        showCustomAlert("TA的想法...", reason.replace(/\n/g, '<br>'));
      }
    });


    window.openCharWallet = openCharWallet;
    document.getElementById('regenerate-char-memo-btn').addEventListener('click', handleGenerateSimulatedMemos);
    document.getElementById('char-memo-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-memo-screen'));

    document.getElementById('regenerate-char-diary-btn').addEventListener('click', handleGenerateSimulatedDiaries);
    document.getElementById('add-char-diary-btn').addEventListener('click', handleWriteNewDiaryEntry);
    document.getElementById('char-diary-detail-back-btn').addEventListener('click', () => switchToCharScreen('char-diary-screen'));
    document.getElementById('regenerate-char-amap-btn').addEventListener('click', handleGenerateAmapHistory);
    document.getElementById('regenerate-char-usage-btn').addEventListener('click', handleGenerateAppUsage);
    document.getElementById('regenerate-char-music-btn').addEventListener('click', handleGenerateSimulatedMusic);
    document.getElementById('close-char-music-player-btn').addEventListener('click', closeCharMusicPlayer);
    document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
    document.getElementById('regenerate-douban-btn').addEventListener('click', handleGenerateDoubanPosts);
    document.getElementById('douban-detail-back-btn').addEventListener('click', () => showScreen('douban-screen'));
    document.getElementById('douban-send-comment-btn').addEventListener('click', handleSendDoubanComment);
    document.getElementById('douban-wait-reply-btn').addEventListener('click', handleDoubanWaitReply);

    document.getElementById('cphone-wallpaper-upload-input').addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        const dataUrl = await new Promise((res) => {
          const reader = new FileReader();
          reader.onload = () => res(reader.result);
          reader.readAsDataURL(file);
        });

        // 1. 立即保存和显示
        state.globalSettings.cphoneWallpaper = dataUrl;
        renderWallpaperScreen(); // This will update the preview
        await showCustomAlert("成功", "CPhone 壁纸已更新！\n\n图片将在后台静默上传到图床... (保存设置后生效)");

        // 2. 启动静默上传
        (async () => {
            await silentlyUpdateDbUrl(
                db.globalSettings,
                'main',
                'cphoneWallpaper',
                dataUrl
            );
        })();
      }
      event.target.value = null; // 清空 input
    });



    document.getElementById('cphone-icon-settings-grid').addEventListener('click', (e) => {
      if (e.target.classList.contains('change-icon-btn')) {
        const item = e.target.closest('.icon-setting-item');
        const iconId = item.dataset.iconId;
        if (iconId) {
          handleIconChange(iconId, 'cphone', item);
        }
      }
    });
    document.getElementById('import-appearance-btn').addEventListener('click', () => {
      document.getElementById('import-appearance-input').click();
    });

    document.getElementById('import-appearance-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importAppearanceSettings(file);
      }
      e.target.value = null;
    });


 
    document.addEventListener('visibilitychange', () => {

      if (document.visibilityState === 'hidden') {

        localStorage.setItem('ephoneLastActiveTimestamp', Date.now());
        console.log("应用已切换到后台，记录当前时间。");
      }
    });

    document.getElementById('export-world-book-btn').addEventListener('click', exportWorldBooks);
    document.getElementById('import-world-book-btn').addEventListener('click', () => {
      document.getElementById('import-world-book-input').click();
    });
    document.getElementById('import-world-book-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        handleWorldBookImport(file);
      }
      e.target.value = null;
    });
    document.getElementById('enable-ai-drawing-switch').addEventListener('change', async (e) => {
      const isEnabled = e.target.checked;
      state.globalSettings.enableAiDrawing = isEnabled;
      await db.globalSettings.put(state.globalSettings);


      const activeScreen = document.querySelector('.screen.active');
      if (activeScreen) {
        switch (activeScreen.id) {
          case 'chat-interface-screen':
            renderChatInterface(state.activeChatId);
            break;
          case 'chat-list-screen':

            if (document.getElementById('qzone-screen').classList.contains('active')) renderQzonePosts();

            if (document.getElementById('favorites-view').classList.contains('active')) renderFavoritesScreen();
            break;
          case 'douban-screen':
            renderDoubanScreen();
            break;
          case 'douban-post-detail-screen':
            openDoubanPostDetail(activeDoubanPostId);
            break;

          case 'character-phone-screen':
            const activeCharScreen = document.querySelector('.char-screen.active');
            if (activeCharScreen) {
              switch (activeCharScreen.id) {
                case 'char-album-screen':
                  renderCharAlbum();
                  break;
                case 'char-taobao-screen':
                  renderCharTaobao();
                  break;
                case 'char-browser-article-screen':
                  const char = state.chats[activeCharacterId];
                  const history = char.simulatedBrowserHistory || [];
                  const lastArticleIndex = history.length > 0 ? history.length - 1 : 0;
                  renderCharArticle(history[lastArticleIndex]);
                  break;
                case 'char-usage-screen':
                  renderCharAppUsage();
                  break;
                case 'char-qq-screen':
                  renderCharSimulatedQQ();
                  break;
                case 'char-qq-conversation-screen':
                  const convoIndex = document.querySelector('#char-chat-list .chat-list-item')?.dataset.conversationIndex || 0;
                  openCharSimulatedConversation(parseInt(convoIndex));
                  break;
              }
            }
            break;
        }
      }
      showCustomAlert('设置已应用', `AI生图功能已${isEnabled ? '开启' : '关闭'}。`);
    });

    document.getElementById('search-history-btn').addEventListener('click', openSearchHistoryScreen);
    document.getElementById('search-history-back-btn').addEventListener('click', () => {
      showScreen('chat-settings-screen');
    });
    document.getElementById('execute-search-btn').addEventListener('click', handleSearchHistory);
    document.getElementById('clear-search-btn').addEventListener('click', clearSearchFilters);




    document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadFrame);
    document.getElementById('batch-import-frames-btn').addEventListener('click', handleBatchUploadFrames);


    document.querySelector('#avatar-frame-modal .modal-body').addEventListener('click', (e) => {

      if (e.target.classList.contains('delete-btn')) {
        const frameId = parseInt(e.target.dataset.id);
        if (!isNaN(frameId)) {
          handleDeleteCustomFrame(frameId);
        }
      }
    });





    setupHomeScreenPagination();


    window.openPresetScreen = openPresetScreen;


    document.getElementById('add-preset-btn').addEventListener('click', async () => {
      const name = await showCustomPrompt('创建新预设', '请输入预设名称');
      if (name && name.trim()) {
        const newPreset = {
          id: 'preset_' + Date.now(),
          name: name.trim(),
          content: []
        };
        await db.presets.add(newPreset);
        await renderPresetScreen();
        openPresetEditor(newPreset.id);
      }
    });

    document.getElementById('manage-preset-categories-btn').addEventListener('click', openPresetCategoryManager);

    document.getElementById('add-preset-entry-btn').addEventListener('click', () => {
      const container = document.getElementById('preset-entries-container');
      if (container.querySelector('p')) {
        container.innerHTML = '';
      }
      const newBlock = createPresetEntryBlock();
      container.appendChild(newBlock);
      newBlock.querySelector('.entry-content-textarea').focus();
    });


    document.getElementById('save-preset-btn').addEventListener('click', async () => {
      if (!editingPresetId) return;
      const preset = await db.presets.get(editingPresetId);
      if (!preset) return;


      const newName = document.getElementById('preset-name-input').value.trim();
      if (!newName) {
        alert('预设名称不能为空！');
        return;
      }
      preset.name = newName;
      preset.categoryId = parseInt(document.getElementById('preset-category-select').value) || null;

      const entriesContainer = document.getElementById('preset-entries-container');
      const entryBlocks = entriesContainer.querySelectorAll('.message-editor-block');
      const newEntries = [];
      entryBlocks.forEach(block => {
        const content = block.querySelector('.entry-content-textarea').value.trim();
        if (content) {
          newEntries.push({
            comment: block.querySelector('.entry-comment-input').value.trim(),
            keys: (block.querySelector('.entry-keys-input').value.trim() || '').split(',').map(k => k.trim()).filter(Boolean),
            content: content,
            enabled: block.querySelector('.entry-enabled-switch').checked
          });
        }
      });
      preset.content = newEntries;


      await db.presets.put(preset);
      editingPresetId = null;


      showScreen('preset-screen');



      await renderPresetScreen();
    });




    document.getElementById('import-preset-btn').addEventListener('click', async () => {
      

     
      try {
        
        await requirePinActivation();

        
        document.getElementById('import-preset-input').click();

      } catch (error) {
    
        console.warn("预设导入被取消:", error.message);
      }
    
    });

    document.getElementById('import-preset-input').addEventListener('change', handlePresetImport);

    document.getElementById('reset-button-order-btn').addEventListener('click', resetButtonOrder);

    document.getElementById('clear-specific-data-btn').addEventListener('click', openDataClearWizard);


    document.getElementById('cancel-clear-wizard-btn-step1').addEventListener('click', () => {
      document.getElementById('data-clear-wizard-modal').classList.remove('visible');
    });
    document.getElementById('go-to-clear-step2-btn').addEventListener('click', handleDataClearNext);


    document.getElementById('back-to-clear-step1-btn').addEventListener('click', handleDataClearBack);
    document.getElementById('cancel-clear-wizard-btn-step2').addEventListener('click', () => {
      document.getElementById('data-clear-wizard-modal').classList.remove('visible');
    });
    document.getElementById('confirm-final-clear-btn').addEventListener('click', handleConfirmDataClear);


    document.getElementById('data-clear-wizard-modal').addEventListener('click', (e) => {
      const item = e.target.closest('.clear-posts-item');
      if (item) {

        e.stopPropagation();
        item.classList.toggle('selected');
      }
    });
    document.getElementById('data-clear-wizard-modal').addEventListener('change', (e) => {

      if (e.target.id === 'select-all-chars-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-char-list .clear-posts-item').forEach(item => {
          item.classList.toggle('selected', isChecked);
        });
      } else if (e.target.id === 'select-all-types-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#data-clear-type-list .clear-posts-item').forEach(item => {
          item.classList.toggle('selected', isChecked);
        });
      }
    });

    document.getElementById('compress-images-btn').addEventListener('click', compressAllLocalImages);

    document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);


    document.getElementById('copy-timestamp-btn').addEventListener('click', copyMessageTimestamp);

    document.getElementById('npc-list-back-btn').addEventListener('click', () => {

      switchToChatListView('messages-view');
    });


    document.getElementById('add-npc-btn').addEventListener('click', () => openNpcEditor(null));


    document.getElementById('save-npc-btn').addEventListener('click', saveNpc);
    document.getElementById('npc-editor-modal').addEventListener('click', (e) => {
      if (e.target.id === 'manage-npc-groups-btn') {
        openNpcGroupManager();
      }
    });
    document.getElementById('close-npc-group-manager-btn').addEventListener('click', () => {
      document.getElementById('npc-group-manager-modal').classList.remove('visible');
      // 重新填充NPC编辑器里的下拉菜单
      if (document.getElementById('npc-editor-modal').classList.contains('visible')) {
        openNpcEditor(editingNpcId);
      }
    });
    document.getElementById('add-new-npc-group-btn').addEventListener('click', addNewNpcGroup);
    document.getElementById('existing-npc-groups-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        deleteNpcGroup(parseInt(e.target.dataset.id));
      }
    });
    document.getElementById('cancel-npc-editor-btn').addEventListener('click', () => {
      document.getElementById('npc-editor-modal').classList.remove('visible');
    });


    document.getElementById('npc-avatar-input').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          document.getElementById('npc-avatar-preview').src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    document.getElementById('chat-lock-overlay').addEventListener('click', (e) => {

      if (e.target.id === 'spectator-reroll-btn') {
        handleSpectatorReroll();
      } else if (e.target.id === 'spectator-edit-btn') {

        openAiResponseEditor();
      }

    });
    addLongPressListener(document.getElementById('music-visual-container'), () => {
      if (musicState.currentIndex > -1) {
        handleChangeAlbumArt(musicState.currentIndex);
      }
    });
    document.getElementById('douban-settings-btn').addEventListener('click', openDoubanSettingsModal);
    document.getElementById('save-douban-settings-btn').addEventListener('click', saveDoubanSettings);
    document.getElementById('cancel-douban-settings-btn').addEventListener('click', () => {
      document.getElementById('douban-settings-modal').classList.remove('visible');
    });

    document.getElementById('time-zone-search-input').addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      const selectEl = document.getElementById('time-zone-select');


      for (const option of selectEl.options) {
        const optionText = option.textContent.toLowerCase();


        if (optionText.includes(searchTerm)) {
          option.style.display = '';
        } else {

          option.style.display = 'none';
        }
      }
    });





    window.openWerewolfLobby = openWerewolfLobby;


    document.getElementById('werewolf-game-btn').addEventListener('click', () => openWerewolfLobby('group'));


    document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
      document.getElementById('werewolf-lobby-modal').classList.remove('visible');
    });
    document.getElementById('start-werewolf-game-btn').addEventListener('click', initializeWerewolfGame);


    document.getElementById('werewolf-role-confirm-btn').addEventListener('click', () => {
      document.getElementById('werewolf-role-modal').classList.remove('visible');
      executeNightPhase();
    });

    document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
      const confirmed = await showCustomConfirm('退出游戏', '确定要退出当前这局狼人杀吗？游戏进度将不会被保存。', {
        confirmButtonClass: 'btn-danger'
      });
      if (confirmed) {
        werewolfGameState.isActive = false;

        showScreen(werewolfGameState.chatId ? 'chat-interface-screen' : 'home-screen');
      }
    });

    document.getElementById('werewolf-game-over-close-btn').addEventListener('click', () => {
      document.getElementById('werewolf-game-over-modal').classList.remove('visible');
      showScreen(werewolfGameState.chatId ? 'chat-list-screen' : 'home-screen');
    });



    document.getElementById('cancel-wolf-kill-btn').addEventListener('click', () => {
      document.getElementById('werewolf-kill-modal').classList.remove('visible');
    });



    document.getElementById('cancel-werewolf-lobby-btn').addEventListener('click', () => {
      document.getElementById('werewolf-lobby-modal').classList.remove('visible');
    });

    document.getElementById('werewolf-retry-btn').addEventListener('click', handleWerewolfRetry);
    document.getElementById('manual-werewolf-summary-btn').addEventListener('click', handleManualWerewolfSummary);
    document.getElementById('check-and-fix-data-btn').addEventListener('click', checkAndFixData);
    const emergencyResetBtn = document.getElementById('emergency-reset-appearance-btn');
    if (emergencyResetBtn) {
        emergencyResetBtn.addEventListener('click', handleEmergencyAppearanceReset);
    }
    const factoryResetBtn = document.getElementById('factory-reset-btn');
    if (factoryResetBtn) {
        factoryResetBtn.addEventListener('click', handleFactoryReset);
    }
    document.getElementById('dynamic-island-music-toggle-switch').addEventListener('change', (e) => {
      const isEnabled = e.target.checked;
      state.globalSettings.alwaysShowMusicIsland = isEnabled; // 更新内存中的状态

   
      const isFrameMode = document.body.classList.contains('frame-mode-active');

     
      if (musicState.isActive && !isFrameMode) {
        const lyricBar = document.getElementById('global-lyrics-bar');
        const phoneScreenForIsland = document.getElementById('phone-screen');

        if (isEnabled) {
      
          lyricBar.classList.remove('visible');
          phoneScreenForIsland.classList.add('dynamic-island-active');
        } else {
      
          phoneScreenForIsland.classList.remove('dynamic-island-active');
          if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
            lyricBar.classList.add('visible');
          }
        }
      }
    });
    document.getElementById('delete-world-books-btn').addEventListener('click', openWorldBookDeletionModal);


    document.getElementById('cancel-delete-world-books-btn').addEventListener('click', () => {
      document.getElementById('delete-world-books-modal').classList.remove('visible');
    });
    document.getElementById('confirm-delete-world-books-btn').addEventListener('click', handleConfirmWorldBookDeletion);

    document.getElementById('delete-world-books-modal').addEventListener('click', (e) => {

      const item = e.target.closest('.clear-posts-item');
      if (item) {
        item.classList.toggle('selected');
      }

      if (e.target.id === 'select-all-world-books-for-clear') {
        const isChecked = e.target.checked;
        document.querySelectorAll('#delete-world-books-list .clear-posts-item').forEach(el => {
          el.classList.toggle('selected', isChecked);
        });
      }
    });


    document.getElementById('sticker-search-input').addEventListener('input', () => {

      renderStickerPanel(false);
    });


    document.getElementById('sticker-category-tabs').addEventListener('click', (e) => {
      if (e.target.classList.contains('sticker-category-tab')) {
        const categoryId = e.target.dataset.categoryId;
        const finalId = (categoryId !== 'all' && categoryId !== 'uncategorized') ? parseInt(categoryId) : categoryId;


        document.getElementById('sticker-search-input').value = '';


        switchStickerCategory(finalId);
      }
    });




    const chatMessagesContainer = document.getElementById('chat-messages');
    chatMessagesContainer.addEventListener('scroll', () => {

      if (chatMessagesContainer.scrollTop < 1 && !isLoadingMoreMessages) {
        const totalMessages = state.chats[state.activeChatId]?.history.length || 0;

        if (totalMessages > currentRenderedCount) {
          loadMoreMessages();
        }
      }
    });


    const thoughtsHistoryList = document.getElementById('thoughts-history-list');
    thoughtsHistoryList.addEventListener('scroll', () => {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = thoughtsHistoryList;

      if (scrollHeight - scrollTop <= clientHeight + 50 && !isLoadingMoreThoughts) {
        const totalItems = state.chats[state.activeChatId]?.thoughtsHistory.length || 0;
        if (totalItems > thoughtsHistoryRenderCount) {
          loadMoreThoughts();
        }
      }
    });


    const qzoneContent = document.querySelector('#qzone-screen .qzone-content');
    qzoneContent.addEventListener('scroll', () => {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = qzoneContent;

      if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMorePosts) {
        if (qzonePostsCache.length > qzonePostsRenderCount) {
          loadMoreQzonePosts();
        }
      }
    });

    
    const localGridEl = document.getElementById('nai-gallery-grid-local');
    const cloudGridEl = document.getElementById('nai-gallery-grid-cloud');

    const naiGridScrollHandler = (e) => {
      
      const targetGrid = e.currentTarget;
      const tabId = targetGrid.id.includes('local') ? 'local' : 'cloud';

      
      if (tabId !== activeNaiGalleryTab) {
        return;
      }
      
      const { scrollTop, scrollHeight, clientHeight } = targetGrid;
      
      
      if (scrollHeight - scrollTop <= clientHeight + 100 && !isLoadingMoreNaiImages[tabId]) {
        if (naiGalleryCache[tabId].length > naiGalleryRenderCount[tabId]) {
          loadMoreNaiGalleryImages(); 
        }
      }
    };

    // 分别为两个新网格绑定事件
    if (localGridEl) {
      localGridEl.addEventListener('scroll', naiGridScrollHandler);
    }
    if (cloudGridEl) {
      cloudGridEl.addEventListener('scroll', naiGridScrollHandler);
    }
    

    document.getElementById('read-together-btn').addEventListener('click', openReadingRoom);
    const restoreBtn = document.getElementById('reading-restore-btn');

    makeDraggable(restoreBtn, restoreBtn);
    document.getElementById('close-reading-btn').addEventListener('click', closeReadingRoom);
    document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);
    document.getElementById('next-page-btn').addEventListener('click', showNextPage);
    document.getElementById('prev-page-btn').addEventListener('click', showPrevPage);
    document.getElementById('book-upload-input').addEventListener('change', handleBookFileUpload);


    document.getElementById('minimize-reading-btn').addEventListener('click', minimizeReadingRoom);
    document.getElementById('reading-restore-btn').addEventListener('click', restoreReadingRoom);


    makeDraggable(document.getElementById('reading-window'), document.querySelector('#reading-window .reading-header'));


    document.getElementById('open-reading-library-btn').addEventListener('click', openBookLibrary);

    document.getElementById('close-reading-library-btn-header').addEventListener('click', () => {
      document.getElementById('reading-library-modal').classList.remove('visible');
    });
    document.getElementById('import-new-book-btn-header').addEventListener('click', importBook);



    document.getElementById('reading-library-list').addEventListener('click', (e) => {
      const target = e.target;
      if (target.classList.contains('group-name')) {
        const bookId = parseInt(target.dataset.bookId);
        loadBookFromLibrary(bookId);
      } else if (target.classList.contains('delete-group-btn')) {
        const bookId = parseInt(target.dataset.bookId);
        deleteBookFromLibrary(bookId);
      }
    });

    document.getElementById('page-indicator').addEventListener('click', handlePageJump);
    document.getElementById('reading-library-search-input').addEventListener('input', (e) => {

      renderBookLibrary(e.target.value);
    });
    const debouncedUpdateReadingContext = debounce(updateReadingContextOnScroll, 300);


    document.getElementById('reading-content').addEventListener('scroll', debouncedUpdateReadingContext);
    document.getElementById('api-temperature-slider').addEventListener('input', (e) => {
      document.getElementById('api-temperature-value').textContent = e.target.value;
    });
    const chatListContainer = document.getElementById('messages-view');
    chatListContainer.addEventListener('scroll', () => {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = chatListContainer;

      if (scrollHeight - scrollTop <= clientHeight + 150 && !isLoadingMoreChats) {
        loadMoreChats();
      }
    });



    document.getElementById('manage-product-categories-btn').addEventListener('click', openProductCategoryManager);
    document.getElementById('close-product-category-manager-btn').addEventListener('click', () => {
      document.getElementById('product-category-manager-modal').classList.remove('visible');


      openProductEditor(editingProductId);
    });
    document.getElementById('add-new-product-category-btn').addEventListener('click', addNewProductCategory);
    document.getElementById('existing-product-categories-list').addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-group-btn')) {
        deleteProductCategory(parseInt(e.target.dataset.id));
      }
    });


    document.getElementById('add-product-variation-btn').addEventListener('click', () => addProductVariationInput());


    document.getElementById('cancel-variation-selection-btn').addEventListener('click', () => {
      document.getElementById('variation-selection-modal').classList.remove('visible');
    });
    document.getElementById('variation-decrease-qty').addEventListener('click', () => {
      const display = document.getElementById('variation-quantity-display');
      let qty = parseInt(display.textContent);
      if (qty > 1) display.textContent = qty - 1;
    });
    document.getElementById('variation-increase-qty').addEventListener('click', () => {
      const display = document.getElementById('variation-quantity-display');
      display.textContent = parseInt(display.textContent) + 1;
    });
    document.getElementById('product-category-tabs').addEventListener('click', (e) => {

      if (e.target.classList.contains('product-category-tab')) {

        const categoryId = e.target.dataset.categoryId === 'all' ? 'all' : parseInt(e.target.dataset.categoryId);


        switchShoppingCategory(categoryId);
      }
    });
    document.getElementById('generate-shopping-items-btn').addEventListener('click', handleGenerateShoppingItems);
    document.getElementById('shopping-settings-btn').addEventListener('click', openShoppingSettingsModal);
    document.getElementById('save-shopping-settings-btn').addEventListener('click', saveShoppingSettings);
    document.getElementById('cancel-shopping-settings-btn').addEventListener('click', () => {
      document.getElementById('shopping-settings-modal').classList.remove('visible');
    });
    document.getElementById('select-all-products-checkbox').addEventListener('change', (e) => {
      const isChecked = e.target.checked;

      const visibleItems = document.querySelectorAll('#product-grid .product-item');

      visibleItems.forEach(item => {
        const productId = parseInt(item.dataset.id);
        item.classList.toggle('selected', isChecked);
        if (isChecked) {
          selectedProducts.add(productId);
        } else {
          selectedProducts.delete(productId);
        }
      });
      document.getElementById('delete-selected-products-btn').textContent = `删除 (${selectedProducts.size})`;
    });


    document.getElementById('delete-selected-products-btn').addEventListener('click', async () => {
      if (selectedProducts.size === 0) {
        alert("请先选择要删除的商品。");
        return;
      }

      const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要永久删除选中的 ${selectedProducts.size} 个商品吗？此操作不可恢复。`, {
          confirmButtonClass: 'btn-danger'
        }
      );

      if (confirmed) {
        await db.shoppingProducts.bulkDelete([...selectedProducts]);


        document.getElementById('manage-products-btn').click();

        await renderShoppingProducts();

        await showCustomAlert("成功", "选中的商品已成功删除。");
      }
    });

    document.getElementById('appearance-preset-select').addEventListener('change', handleAppearancePresetSelectionChange);
    document.getElementById('save-appearance-preset-btn').addEventListener('click', saveAppearancePreset);
    document.getElementById('delete-appearance-preset-btn').addEventListener('click', deleteAppearancePreset);



    document.getElementById('novelai-switch').addEventListener('change', (e) => {
      const detailsDiv = document.getElementById('novelai-details');
      detailsDiv.style.display = e.target.checked ? 'block' : 'none';
    });


    document.getElementById('novelai-key-toggle').addEventListener('click', function() {
      const input = document.getElementById('novelai-api-key');
      if (input.type === 'password') {
        input.type = 'text';
        this.textContent = '😌';
      } else {
        input.type = 'password';
        this.textContent = '🧐';
      }
    });

  
    document.getElementById('novelai-settings-btn').addEventListener('click', () => {
      loadNovelAISettings();
      document.getElementById('novelai-settings-modal').style.display = 'flex';
    });


    document.getElementById('nai-cors-proxy').addEventListener('change', (e) => {
      const customProxyGroup = document.getElementById('nai-custom-proxy-group');
      if (e.target.value === 'custom') {
        customProxyGroup.style.display = 'block';
      } else {
        customProxyGroup.style.display = 'none';
      }
    });

    document.getElementById('close-novelai-settings').addEventListener('click', () => {
      document.getElementById('novelai-settings-modal').style.display = 'none';
    });


    document.getElementById('save-nai-settings-btn').addEventListener('click', () => {
      saveNovelAISettings();
      document.getElementById('novelai-settings-modal').style.display = 'none';
      alert('NovelAI设置已保存！');
    });

    document.getElementById('reset-nai-settings-btn').addEventListener('click', () => {
      if (confirm('确定要恢复默认设置吗？')) {
        resetNovelAISettings();
      }
    });


    document.getElementById('novelai-test-btn').addEventListener('click', () => {
      const apiKey = document.getElementById('novelai-api-key').value.trim();
      if (!apiKey) {
        alert('请先填写NovelAI API Key！');
        return;
      }
      document.getElementById('novelai-test-modal').style.display = 'flex';
      document.getElementById('nai-test-result').style.display = 'none';
      document.getElementById('nai-test-error').style.display = 'none';
    });

 
    document.getElementById('close-novelai-test').addEventListener('click', () => {
      document.getElementById('novelai-test-modal').style.display = 'none';
    });

    document.getElementById('close-nai-test-btn').addEventListener('click', () => {
      document.getElementById('novelai-test-modal').style.display = 'none';
    });

 
    document.getElementById('nai-generate-btn').addEventListener('click', async () => {
      await generateNovelAIImage();
    });



    document.getElementById('nai-download-btn').addEventListener('click', () => {
      const img = document.getElementById('nai-result-image');
      const link = document.createElement('a');
      link.href = img.src;
      link.download = 'novelai-generated-' + Date.now() + '.png';
      link.click();
    });

  
    document.getElementById('character-nai-prompts-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];

      // 加载当前角色的NAI提示词配置
      const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
      };

  
      document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
      document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';

      document.getElementById('character-nai-prompts-modal').style.display = 'flex';
    });

   
    document.getElementById('close-character-nai-prompts').addEventListener('click', () => {
      document.getElementById('character-nai-prompts-modal').style.display = 'none';
    });

    document.getElementById('save-character-nai-prompts-btn').addEventListener('click', async () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];

      if (!chat.settings.naiSettings) {
        chat.settings.naiSettings = {
          promptSource: 'system'
        };
      }

      chat.settings.naiSettings.characterPositivePrompt = document.getElementById('character-nai-positive').value.trim();
      chat.settings.naiSettings.characterNegativePrompt = document.getElementById('character-nai-negative').value.trim();

      console.log('💾 [专属弹窗] 保存角色NAI提示词');
      console.log('   characterPositivePrompt:', chat.settings.naiSettings.characterPositivePrompt);
      console.log('   characterNegativePrompt:', chat.settings.naiSettings.characterNegativePrompt);
      console.log('   promptSource:', chat.settings.naiSettings.promptSource);

     
      await db.chats.put(chat);

      document.getElementById('character-nai-prompts-modal').style.display = 'none';
      alert('角色专属NAI提示词已保存！');
    });

    document.getElementById('reset-character-nai-prompts-btn').addEventListener('click', () => {
      if (confirm('确定要清空当前角色的NAI提示词配置吗？')) {
        document.getElementById('character-nai-positive').value = '';
        document.getElementById('character-nai-negative').value = '';
      }
    });

 
    document.getElementById('group-character-nai-prompts-btn').addEventListener('click', () => {
      if (!state.activeChatId) return;
      const chat = state.chats[state.activeChatId];

      // 加载当前角色的NAI提示词配置
      const naiSettings = chat.settings.naiSettings || {
        promptSource: 'system',
        characterPositivePrompt: '',
        characterNegativePrompt: ''
      };

    
      document.getElementById('character-nai-positive').value = naiSettings.characterPositivePrompt || '';
      document.getElementById('character-nai-negative').value = naiSettings.characterNegativePrompt || '';

      document.getElementById('character-nai-prompts-modal').style.display = 'flex';
    });
 

    document.getElementById('manage-frames-btn').addEventListener('click', toggleFrameManagementMode);
    document.getElementById('select-all-frames-checkbox').addEventListener('change', handleSelectAllFrames);
    document.getElementById('delete-selected-frames-btn').addEventListener('click', executeBatchDeleteFrames);
    document.getElementById('delete-current-category-btn').addEventListener('click', handleDeleteCurrentCategory);
    document.getElementById('char-wallet-back-btn').addEventListener('click', () => {

      switchToCharScreen('char-taobao-screen');
    });
    document.getElementById('sticker-binding-chat-list').addEventListener('click', (e) => {
      const item = e.target.closest('.contact-picker-item');
      if (item) {
        const checkbox = item.querySelector('.sticker-binding-checkbox');
        if (checkbox && e.target !== checkbox) {
          checkbox.checked = !checkbox.checked;
        }
      }
    });
    const stickerTabsContainer = document.getElementById('sticker-category-tabs');
    addLongPressListener(stickerTabsContainer, (e) => {
      const tab = e.target.closest('.sticker-category-tab');
      if (tab) {
        e.preventDefault();
        const categoryIdStr = tab.dataset.categoryId;
        if (categoryIdStr === 'all') {
          showCustomAlert("提示", "“全部”分类无法被绑定。");
          return;
        }
        const categoryId = categoryIdStr === 'uncategorized' ? 'uncategorized' : parseInt(categoryIdStr);
        openStickerCategoryBindingModal(categoryId);
      }
    });

    document.getElementById('open-nai-gallery-btn').addEventListener('click', openNaiGallery);
    document.getElementById('nai-gallery-tabs').addEventListener('click', (e) => {
      const tab = e.target.closest('.nai-gallery-tab');
      if (tab && !tab.classList.contains('active')) {
        switchNaiGalleryTab(tab.dataset.tabId);
      }
    });
    document.getElementById('close-nai-gallery-btn').addEventListener('click', () => {
      document.getElementById('nai-gallery-panel').classList.remove('visible');
    });

    document.getElementById('manage-nai-gallery-btn').addEventListener('click', toggleNaiGalleryManagementMode);

    document.getElementById('nai-gallery-grid-local').addEventListener('click', (e) => {
      handleNaiGalleryGridClick(e);
    });
    document.getElementById('nai-gallery-grid-cloud').addEventListener('click', (e) => {
      handleNaiGalleryGridClick(e);
    });

    document.getElementById('select-all-nai-gallery-checkbox').addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      const activeGridId = `nai-gallery-grid-${activeNaiGalleryTab}`;
      
      
      document.querySelectorAll(`#${activeGridId} .nai-gallery-item`).forEach(item => {
        item.classList.toggle('selected', isChecked);
        const key = item.dataset.key;
        if (isChecked) {
          selectedNaiImages.add(key);
        } else {
          selectedNaiImages.delete(key);
        }
      });
      updateNaiGalleryActionButtons();
    });
    document.getElementById('download-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDownloadNaiImages());
    document.getElementById('upload-selected-nai-gallery-btn').addEventListener('click', () => executeBatchUploadNaiImagesToImgBB());
    document.getElementById('export-selected-nai-gallery-btn').addEventListener('click', () => executeBatchExportNaiImages()); 
    document.getElementById('delete-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDeleteNaiImages());
    document.getElementById('delete-selected-nai-gallery-btn').addEventListener('click', () => executeBatchDeleteNaiImages());
    document.getElementById('chat-expand-btn').addEventListener('click', () => {
      document.body.classList.toggle('chat-actions-expanded');
    });
    document.getElementById('profile-edit-btn').addEventListener('click', openThoughtEditor);
    document.getElementById('open-quick-reply-btn').addEventListener('click', openQuickReplyModal);

    document.getElementById('cancel-quick-reply-btn').addEventListener('click', () => {
      document.getElementById('quick-reply-modal').classList.remove('visible');
    });


    document.getElementById('add-quick-reply-btn').addEventListener('click', addNewQuickReply);

  
    
    document.getElementById('minimize-char-music-btn').addEventListener('click', minimizeCharMusicPlayer);
    
    
    document.getElementById('char-music-restore-btn').addEventListener('click', restoreCharMusicPlayer);
    
  
    makeDraggable(document.getElementById('char-music-restore-btn'), document.getElementById('char-music-restore-btn'));

document.getElementById('imgbb-enable-switch').addEventListener('change', (e) => {
    document.getElementById('imgbb-settings-details').style.display = e.target.checked ? 'block' : 'none';
});

document.getElementById('imgbb-key-toggle').addEventListener('click', function() {
    const input = document.getElementById('imgbb-api-key');
    if (input.type === 'password') {
        input.type = 'text';
        this.textContent = '😌';
    } else {
        input.type = 'password';
        this.textContent = '🧐';
    }
});
document.getElementById('catbox-enable-switch').addEventListener('change', (e) => {
        document.getElementById('catbox-settings-details').style.display = e.target.checked ? 'block' : 'none';
    });

    document.getElementById('catbox-key-toggle').addEventListener('click', function() {
        const input = document.getElementById('catbox-userhash');
        if (input.type === 'password') {
            input.type = 'text';
            this.textContent = '😌';
        } else {
            input.type = 'password';
            this.textContent = '🧐';
        }
    });
const biliSearchBtn = document.getElementById('char-bilibili-search-btn');
    if (biliSearchBtn) {
        biliSearchBtn.addEventListener('click', handleCharBilibiliSearch);
        console.log("B站搜索按钮已绑定"); // 调试日志
    } else {
        console.error("找不到B站搜索按钮 (char-bilibili-search-btn)，请检查HTML ID");
    }
  const regenBiliBtn = document.getElementById('regenerate-char-bilibili-btn');
    if (regenBiliBtn) {
        regenBiliBtn.addEventListener('click', handleGenerateSimulatedBilibili);
    }
    // 2. 绑定回车键搜索
    const biliInput = document.getElementById('char-bilibili-search-input');
    if (biliInput) {
        biliInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleCharBilibiliSearch();
        });
    }
const ghSwitch = document.getElementById('github-enable-switch');
    if (ghSwitch) {
        ghSwitch.addEventListener('change', (e) => {
            document.getElementById('github-settings-details').style.display = e.target.checked ? 'block' : 'none';
        });
    }

    // GitHub 按钮功能绑定
    const ghUploadBtn = document.getElementById('github-upload-btn');
    if (ghUploadBtn) {
        ghUploadBtn.addEventListener('click', () => uploadToGitHub(false));
    }

    const ghDownloadBtn = document.getElementById('github-download-btn');
    if (ghDownloadBtn) {
        ghDownloadBtn.addEventListener('click', restoreFromGitHub);
    }
    const ghTokenToggle = document.getElementById('github-token-toggle');
    if (ghTokenToggle) {
        ghTokenToggle.addEventListener('click', function() {
            const input = document.getElementById('github-token');
            if (input.type === 'password') {
                input.type = 'text';
                this.textContent = '😌'; // 睁眼
            } else {
                input.type = 'password';
                this.textContent = '🧐'; // 闭眼
            }
        });
    }
document.getElementById('toggle-reading-fullscreen-btn').addEventListener('click', toggleReadingFullscreen);   
// 2. 绑定确认和取消按钮事件 (请将此段代码放在 init() 函数中，或者脚本底部的事件监听区域)
document.addEventListener('DOMContentLoaded', () => {
    // ... 其他初始化代码 ...

    // 绑定亲属卡弹窗按钮
    const cancelBtn = document.getElementById('cancel-kinship-creation-btn');
    const confirmBtn = document.getElementById('confirm-kinship-creation-btn');
    const modal = document.getElementById('kinship-creation-modal');

    if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
            modal.classList.remove('visible');
        });
    }

    if (confirmBtn) {
        confirmBtn.addEventListener('click', async () => {
            if (!selectedKinshipCharId) {
                return alert("请先选择一个绑定对象！");
            }

            const limitInput = document.getElementById('kinship-limit-input');
            const limit = parseFloat(limitInput.value);

            if (isNaN(limit) || limit <= 0) {
                return alert("请输入有效的额度！");
            }

            // 调用原有的发送逻辑
            await sendKinshipRequest(selectedKinshipCharId, limit);
            
            // 关闭弹窗
            modal.classList.remove('visible');
            
            // 如果当前不在该聊天，提示跳转
            if (state.activeChatId !== selectedKinshipCharId) {
               // sendKinshipRequest 内部已经处理了跳转或追加消息
            }
        });
    }
});
const kinshipCancelBtn = document.getElementById('cancel-kinship-creation-btn');
    if (kinshipCancelBtn) {
        // 先移除可能存在的旧监听器，防止重复
        const newCancelBtn = kinshipCancelBtn.cloneNode(true);
        kinshipCancelBtn.parentNode.replaceChild(newCancelBtn, kinshipCancelBtn);
        
        newCancelBtn.addEventListener('click', () => {
            document.getElementById('kinship-creation-modal').classList.remove('visible');
        });
    }

    // 绑定确认赠送/申请按钮
    const kinshipConfirmBtn = document.getElementById('confirm-kinship-creation-btn');
    if (kinshipConfirmBtn) {
        const newConfirmBtn = kinshipConfirmBtn.cloneNode(true);
        kinshipConfirmBtn.parentNode.replaceChild(newConfirmBtn, kinshipConfirmBtn);

        newConfirmBtn.addEventListener('click', async () => {
            if (!selectedKinshipCharId) {
                return alert("请先选择一个对象！");
            }

            const limitInput = document.getElementById('kinship-limit-input');
            const limit = parseFloat(limitInput.value);

            if (isNaN(limit) || limit <= 0) {
                return alert("请输入有效的额度（必须大于0）！");
            }

            // --- 新增：获取选择的类型 ---
            const typeRadio = document.querySelector('input[name="kinship-type"]:checked');
            const type = typeRadio ? typeRadio.value : 'grant'; // 默认为赠送

            // 调用发送逻辑，传入 type
            await sendKinshipRequest(selectedKinshipCharId, limit, type);
            
            document.getElementById('kinship-creation-modal').classList.remove('visible');
            
            const actionText = type === 'grant' ? "赠送" : "申请";
            await showCustomAlert(`${actionText}成功`, `亲属卡${actionText}已发送给对方。`);
        });
    }
document.getElementById('char-wallet-content').addEventListener('click', async (e) => {
    if (e.target.classList.contains('unbind-kinship-btn')) {
        e.stopPropagation();
        const chatId = e.target.dataset.chatId;
        
        // 1. 先获取钱包数据，判断是谁给谁开的卡
        const wallet = await db.userWallet.get('main');
        const card = wallet?.kinshipCards?.find(c => c.chatId === chatId);
        
        if (!card) {
            // 卡不存在（可能数据错乱），给个默认提示
            alert("未找到该亲属卡记录");
            return;
        }

        // 2. 根据类型决定文案
        // 如果没有 type 字段（旧数据），默认认为是 'out' (我送TA)
        const isMyGift = (card.type === 'out' || !card.type); 
        
        let title = "";
        let message = "";
        let confirmText = "";

        if (isMyGift) {
            title = "收回亲属卡";
            message = "确定要停止为 TA 买单吗？\n收回后，对方将无法再使用您的额度消费。";
            confirmText = "确认收回";
        } else {
            title = "退还亲属卡";
            message = "确定要解绑这张亲属卡吗？\n解绑后，您将无法再使用 TA 的额度消费。";
            confirmText = "确认退还";
        }
        
        const confirmed = await showCustomConfirm(
            title, 
            message, 
            { confirmButtonClass: 'btn-danger', confirmText: confirmText }
        );

        if (confirmed) {
            try {
                if (wallet && wallet.kinshipCards) {
                    // 过滤掉当前角色的卡
                    wallet.kinshipCards = wallet.kinshipCards.filter(c => c.chatId !== chatId);
                    await db.userWallet.put(wallet);
                    
                    await showCustomAlert("成功", "亲属卡已解绑。");
                    
                    // 刷新界面
                    renderCharWallet();
                    
                    // 3. 发送系统消息通知AI (根据方向不同，通知内容也不同)
                    const chat = state.chats[chatId];
                    if(chat) {
                        let sysContent = "";
                        if (isMyGift) {
                            sysContent = '[系统提示：用户已收回了给你的亲属卡额度，你无法再使用代付功能了。]';
                        } else {
                            sysContent = '[系统提示：用户主动退还/解绑了你赠送的亲属卡，不再使用你的钱了。]';
                        }

                        chat.history.push({
                           role: 'system',
                           content: sysContent,
                           timestamp: Date.now(),
                           isHidden: true
                        });
                        await db.chats.put(chat);
                    }
                }
            } catch (error) {
                console.error(error);
                alert("解绑失败");
            }
        }
    }
});
const alipayScreen = document.getElementById('alipay-screen');
if (alipayScreen) {
    alipayScreen.addEventListener('click', async (e) => {
        // 检查点击的是不是解绑按钮
        if (e.target.classList.contains('alipay-unbind-btn')) {
            e.stopPropagation(); 
            
            const chatId = e.target.dataset.chatId;
            const chat = state.chats[chatId];
            const charName = chat ? chat.name : '该角色';

            // 1. 获取钱包数据判断方向
            const wallet = await db.userWallet.get('main');
            const card = wallet?.kinshipCards?.find(c => c.chatId === chatId);
            
            if (!card) return;

            // 2. 动态生成文案
            const isMyGift = (card.type === 'out' || !card.type);
            
            let title = "";
            let message = "";
            let confirmText = "";

            if (isMyGift) {
                title = "终止赠予";
                message = `确定要停止赠予“${charName}”亲属卡吗？\n解绑后，对方将无法再使用该额度。`;
                confirmText = "确认收回";
            } else {
                title = "解绑亲属卡";
                message = `确定要解绑“${charName}”赠送的亲属卡吗？\n解绑后，您将失去该消费额度。`;
                confirmText = "确认解绑";
            }

            const confirmed = await showCustomConfirm(
                title, 
                message, 
                { confirmButtonClass: 'btn-danger', confirmText: confirmText }
            );

            if (confirmed) {
                try {
                    if (wallet && wallet.kinshipCards) {
                        // 从数组中移除该卡片
                        wallet.kinshipCards = wallet.kinshipCards.filter(c => c.chatId !== chatId);
                        await db.userWallet.put(wallet);
                        
                        await showCustomAlert("成功", "已成功解绑亲属卡。");
                        
                        // 刷新支付宝界面
                        openAlipayScreen();

                        // 3. 通知 AI
                        if (chat) {
                            let sysContent = "";
                            if (isMyGift) {
                                sysContent = '[系统提示：用户已在支付宝端单方面收回了给你的亲属卡授权。]';
                            } else {
                                sysContent = '[系统提示：用户已在支付宝端主动退还/解绑了你赠送的亲属卡。]';
                            }

                            chat.history.push({
                               role: 'system',
                               content: sysContent,
                               timestamp: Date.now(),
                               isHidden: true
                            });
                            await db.chats.put(chat);
                        }
                    }
                } catch (error) {
                    console.error(error);
                    alert("解绑操作失败");
                }
            }
        }
    });
}
document.getElementById('export-appearance-btn').addEventListener('click', exportAppearanceSettings);
// --- To-Do List Events ---
    const todoBtn = document.getElementById('open-todo-list-btn');
    if(todoBtn) todoBtn.addEventListener('click', openTodoList);
    
    document.getElementById('todo-list-back-btn').addEventListener('click', () => showScreen('chat-interface-screen'));
    
    document.getElementById('todo-prev-day-btn').addEventListener('click', () => changeTodoDate(-1));
    document.getElementById('todo-next-day-btn').addEventListener('click', () => changeTodoDate(1));
    
    document.getElementById('add-todo-btn').addEventListener('click', () => openTodoEditor(null));
    
    document.getElementById('cancel-todo-editor-btn').addEventListener('click', () => {
        document.getElementById('todo-editor-modal').classList.remove('visible');
    });
    
    document.getElementById('save-todo-btn').addEventListener('click', saveTodo);
    const todoDateDisplay = document.getElementById('todo-current-date-display');
    if (todoDateDisplay) {
        // 1. 动态创建一个隐藏的 input[type="date"]
        const datePicker = document.createElement('input');
        datePicker.type = 'date';
        // 隐藏它，但保持可交互性
        datePicker.style.cssText = 'position:absolute; visibility:hidden; width:0; height:0; top:0; left:0;';
        todoDateDisplay.parentNode.appendChild(datePicker); // 插入到导航栏里

        // 2. 点击文字 -> 触发选择器
        todoDateDisplay.addEventListener('click', () => {
            // 将当前显示的日期同步给选择器
            datePicker.value = getTodoDateString(currentTodoDate);
            
            // 尝试弹出原生日期面板
            try {
                datePicker.showPicker(); // 现代浏览器 (Chrome 99+, Safari 15+)
            } catch(e) {
                datePicker.click(); // 旧版兼容
            }
        });

        // 3. 监听日期改变
        datePicker.addEventListener('change', (e) => {
            if (e.target.value) {
                // 解析 YYYY-MM-DD (避免直接 new Date() 带来的时区偏差问题)
                const [y, m, d] = e.target.value.split('-').map(Number);
                // 构造本地时间对象
                currentTodoDate = new Date(y, m - 1, d);
                
                // 刷新界面
                updateTodoDateDisplay();
                renderTodoList();
            }
        });
    }
    // 类型选择器点击事件
    const typeOptions = document.querySelectorAll('.todo-type-option');
    typeOptions.forEach(opt => {
        opt.addEventListener('click', () => {
            typeOptions.forEach(o => o.classList.remove('active'));
            opt.classList.add('active');
        });
    });
// --- 在 init() 函数内部的事件绑定区域添加 ---

    // 1. 长期记忆列表滚动监听
    const memoryListContainer = document.getElementById('memory-list-container');
    if (memoryListContainer) {
        memoryListContainer.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = memoryListContainer;
            // 距离底部 50px 时触发加载
            if (scrollHeight - scrollTop <= clientHeight + 50) {
                loadMoreMemories();
            }
        });
    }

    // 2. 待办事项列表滚动监听
    const todoListContainer = document.getElementById('todo-list-container');
    if (todoListContainer) {
        todoListContainer.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = todoListContainer;
            if (scrollHeight - scrollTop <= clientHeight + 50) {
                loadMoreTodos();
            }
        });
    }
// 绑定邮箱底部按钮事件
const deleteSelectedBtn = document.getElementById('mail-delete-selected-btn');
if (deleteSelectedBtn) {
    deleteSelectedBtn.addEventListener('click', executeBatchDeleteEmails);
}

const selectAllBtn = document.getElementById('mail-select-all-btn');
if (selectAllBtn) {
    selectAllBtn.addEventListener('click', handleSelectAllEmails);
}
    document.getElementById('manage-rules-btn').addEventListener('click', toggleRuleManagementMode);
    document.getElementById('import-rules-btn').addEventListener('click', () => {
        document.getElementById('import-rules-input').click();
    });
    document.getElementById('import-rules-input').addEventListener('change', handleRulesImport);

    // 2. 底部操作栏按钮
    document.getElementById('select-all-rules-checkbox').addEventListener('change', handleSelectAllRules);
    document.getElementById('export-selected-rules-btn').addEventListener('click', exportSelectedRules);
    document.getElementById('delete-selected-rules-btn').addEventListener('click', deleteSelectedRules);
// ... 在 init() 函数内 ...
const redditSearchBtn = document.getElementById('char-reddit-search-btn');
if (redditSearchBtn) {
    redditSearchBtn.addEventListener('click', () => {
        const query = document.getElementById('char-reddit-search-input').value.trim();
        handleRedditSearch(query);
    });
}

// 绑定回车搜索
const redditInput = document.getElementById('char-reddit-search-input');
if (redditInput) {
    redditInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
             const query = e.target.value.trim();
             handleRedditSearch(query);
        }
    });
}
const regenRedditBtn = document.getElementById('regenerate-char-reddit-btn');
if (regenRedditBtn) {
    regenRedditBtn.addEventListener('click', handleGenerateSimulatedReddit);
}
document.getElementById('nai-preset-select').addEventListener('change', handleNaiPresetChange);
    document.getElementById('save-nai-preset-btn').addEventListener('click', () => handleSaveNaiPreset(false));
    document.getElementById('update-nai-preset-btn').addEventListener('click', () => handleSaveNaiPreset(true));
    document.getElementById('delete-nai-preset-btn').addEventListener('click', handleDeleteNaiPreset);
    document.getElementById('bind-nai-preset-btn').addEventListener('click', openNaiBindingModal);
    
    document.getElementById('save-nai-binding-btn').addEventListener('click', saveNaiBinding);
    document.getElementById('cancel-nai-binding-btn').addEventListener('click', () => {
        document.getElementById('nai-binding-modal').classList.remove('visible');
    });
document.getElementById('manage-quick-reply-categories-btn').addEventListener('click', openQuickReplyCategoryManager);
    
    // 2. 绑定分类管理器内的按钮
    document.getElementById('add-new-quick-reply-category-btn').addEventListener('click', addNewQuickReplyCategory);
    document.getElementById('close-quick-reply-category-manager-btn').addEventListener('click', () => {
        document.getElementById('quick-reply-category-manager-modal').classList.remove('visible');
        renderQuickReplyList(true); // 关闭时刷新主列表的Tabs
    });
// --- Sticker Batch Move (表情包批量移动) ---
const stickerMoveBtn = document.getElementById('move-selected-stickers-btn');
if (stickerMoveBtn) {
    stickerMoveBtn.addEventListener('click', executeBatchMoveStickers);
}

// --- Quick Reply Management (快捷回复管理) ---
const batchQuickReplyBtn = document.getElementById('batch-quick-reply-btn');
if (batchQuickReplyBtn) {
    batchQuickReplyBtn.addEventListener('click', toggleQuickReplyManagementMode);
}

const selectAllQuickRepliesCb = document.getElementById('select-all-quick-replies-checkbox');
if (selectAllQuickRepliesCb) {
    selectAllQuickRepliesCb.addEventListener('change', handleSelectAllQuickReplies);
}

const moveQuickRepliesBtn = document.getElementById('move-selected-quick-replies-btn');
if (moveQuickRepliesBtn) {
    moveQuickRepliesBtn.addEventListener('click', executeBatchMoveQuickReplies);
}

const deleteQuickRepliesBtn = document.getElementById('delete-selected-quick-replies-btn');
if (deleteQuickRepliesBtn) {
    deleteQuickRepliesBtn.addEventListener('click', executeBatchDeleteQuickReplies);
}


   
    initLockScreen();
    checkForUpdates();
    updateLockedFeatureUI();
    initSystemNotification();
    showScreen('home-screen');
  }

  init();
});
        
        

  // 新增：处理用户拍自己的功能
  async function handleUserPatSelf(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');

    const myNickname = getDisplayNameInGroup(chat, state.qzoneSettings.nickname);

    // 弹出输入框让用户输入拍自己的后缀
    const suffix = await showCustomPrompt(
      `你拍了拍自己`,
      "输入拍一拍后缀",
      "",
      "text"
    );

    if (suffix === null) return;

    // 创建可见的拍一拍消息
    const visibleMessageContent = `${myNickname} 拍了拍自己 ${suffix.trim()}`;
    const visibleMessage = {
      role: 'system',
      type: 'pat_message',
      content: visibleMessageContent,
      timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 创建隐藏的系统提示，让AI知道用户拍了自己
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍自己${suffix.trim()}。你可以对此作出回应或评论。]`;
    const hiddenMessage = {
      role: 'system',
      content: hiddenMessageContent,
      timestamp: Date.now() + 1,
      isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
      appendMessage(visibleMessage, chat);
    }
    await renderChatList();
  }
